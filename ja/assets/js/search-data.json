{
  "0": {
    "id": "0",
    "title": "ShotGrid Toolkit を使用する場合、3ds Max が起動時にクラッシュするのはなぜですか?",
    "content": "ShotGrid Toolkit を使用する場合、3ds Max が起動時にクラッシュするのはなぜですか?ShotGrid Desktop または ShotGrid Web サイトから 3ds Max を起動すると、真っ白なダイアログが表示されて 3ds Max がフリーズするか、または次のメッセージが表示されます。Microsoft Visual C++ Runtime Library (Not Responding)Runtime Error!Program: C: Program Files Autodesk 3ds Max 2016 3dsmax.exeR6034An Application has made an attempt to load the C runtime library incorrectly.Please contact the application's support team for more information.通常、これは、パス内の msvcr90.dll のバージョンと 3ds Max にバンドルされている Python のバージョンの競合が原因です。 解決策最初に、パイプライン設定の config/hooks フォルダに移動し、ファイル before_app_launch.py を作成します。そのファイル内に次のコードを貼り付けます。&quot;&quot;&quot;Before App Launch HookThis hook is executed prior to application launch and is useful if you needto set environment variables or run scripts as part of the app initialization.&quot;&quot;&quot;import osimport tankclass BeforeAppLaunch(tank.get_hook_baseclass()):    &quot;&quot;&quot;    Hook to set up the system prior to app launch.    &quot;&quot;&quot;    def execute(self, **kwargs):        &quot;&quot;&quot;        The execute functon of the hook will be called to start the required application        &quot;&quot;&quot;        env_path = os.environ[&quot;PATH&quot;]        paths = env_path.split(os.path.pathsep)        # Remove folders which have msvcr90.dll from the PATH        paths = [path for path in paths if &quot;msvcr90.dll&quot; not in map(            str.lower, os.listdir(path))        ]        env_path = os.path.pathsep.join(paths)        os.environ[&quot;PATH&quot;] = env_pathここでファイルを保存します。次に、パイプライン設定で config/env/includes/app_launchers.yml を開き、エントリ launch_3dsmax を探します。hook_before_app_launch: default を hook_before_app_launch: '{config}/before_app_launch.py' に置き換える必要があります。これで ShotGrid と ShotGrid Desktop から 3ds Max を正しく起動できるようになりました。まだ問題が解決しない場合は、support@shotgunsoftware.com までご連絡ください。",
    "url": "/a7555f37/",
    "relUrl": "/a7555f37/"
  },
  "1": {
    "id": "1",
    "title": "About the Isolation Feature Set",
    "content": "What is the Isolation Feature SetThe isolation feature set combines our Cloud Hosted Platform with client-managed AWS resources to provide a solution that satisfies the most stringent security and privacy requirements. Clients retain control of their sensitive content without having to host ShotGrid on their infrastructure.Leveraging the isolation feature set has the following advantages over the Standard offering:  Media Isolation by hosting of assets and attachments in a client-owned S3 Bucket  Web Traffic Isolation from the public internet  Media Traffic Isolation from the public internet  Media Replication allowing you to replicate media in one additional AWS Region  Access to fully managed ShotGrid Cloud Services  Automatic and continuous version upgrades  Ephemeral compute + in-memory segration between clientsIn a nutshell, this means that with the isolation features, your ShotGrid site and the data related to it cannot be reached by anyone outside of your studio network.The isolation feature set is a solution that requires less upkeep, as well as less IT/System Administrator knowledge and skills, than hosting ShotGrid on-premise. The list of advantages compared to on-premise includes, but is not limited to:  No ShotGrid specific knowledge required  No manual ShotGrid updates required  Very low level of maintenance required for the AWS componentsMedia isolation featureMedia Isolation allows your studio to keep the ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid can be store in your studio private S3 bucket. Access to the media is provided to the ShotGrid service only, using AWS AssumeRole keyless Security Token Service. Your studio remains in control of the assets and the access to the assets, access that you can revoke at will.Traffic isolation featuresMedia and Web traffic isolation features can be enabled to prevent your traffic from being routed on the public internet, limiting it to the AWS backbone and your studio network. The traffic between ShotGrid Services and your studio stays in closed network, never going outside AWS or your Studio network.With the Media Traffic Isolation feature activated, the media will only leave your studio infrastructure once to get transcoded.Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.EligibilityThe Isolation feature set is available for all Super Awesome clients. See Getting Started for more details about how to active the different features. The activation of the isolation feature set is not instantaneous, and requires manual setup involving your AWS account.What the Isolation Feature Set is notThe isolation feature set is not a completely isolated solution. Both the compute services and the database services are shared amongst clients, and managed by ShotGrid. From a hardware standpoint, the isolation features does not guarantee complete physical isolation. However, ShotGrid services are guaranteeing isolation at the memory level. Processes are never reused to answer requests from different clients during their lifetime. Client metadata is stored in different databases. Client media is individually stored on S3.High Level ArchitectureThe ShotGrid cloud service  can be decoupled at a high level in 3 parts:Compute Stack: The part of the ShotGrid Service that handles client requests and serves data to the client.Data Stack: Metadata storage (databases).Media Storage: Where the client’s attachments, media, and assets are stored. ShotGrid uses AWS S3 to store client content.Please read Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk ShotGrid for more details about the architecture.Ephemeral compute and memory isolationEven if clients share the same infrastructure, ShotGrid guarantees a complete memory isolation, both in transit and at rest, of client data. This makes ShotGrid less prone to data leaking due to architecture flaws or software vulnerabilities exploiting memory, like buffer overflow.Ephemeral transcodingEverytime media is uploaded to ShotGrid, the transcoding service is invoked to create a web friendly versions of your assets. That process happens only once, after the initial upload. The media is directly uploaded from the client to S3, from where it is fetched by the ShotGrid Transcoding Service. Each transcoding job is handled by a single container, which is killed after that unique job. The only place the media temporarily lives is in the container memory. The ShotGrid Transcoding service doesn’t store permanently a copy of your media.",
    "url": "/84dfd5cc/",
    "relUrl": "/84dfd5cc/"
  },
  "2": {
    "id": "2",
    "title": "管理",
    "content": "管理Toolkit セットアップの管理および設定に基づくクイック アンサーのコレクションです。ShotGrid Desktop:  ShotGrid Desktop を使用して Toolkit プロジェクトを再セットアップするにはどうすればいいですか?  Windows で ShotGrid Desktop をサイレント インストールするにはどうすればいいですか?  Linux で ShotGrid Desktop のデスクトップ/ランチャー アイコンをセットアップするにはどうすればいいですか?  ShotGrid Desktop のブラウザ統合を無効にするにはどうすればいいですか?設定の管理:  複数のストレージ ルートを使用するように設定を変更するにはどうすればいいですか?  パイプライン設定を新しい場所に移動するにはどうすればいいですか?  プロジェクト ディレクトリを新しいローカル ストレージのルートに移動するにはどうすればいいですか?  パイプライン設定のコアの場所を更新するにはどうすればいいですか?  プロジェクト間でアセットを共有するにはどうすればいいですか?  アプリまたはエンジンをアンインストールするにはどうすればいいですか?キャッシュベースの質問:  パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?  キャッシュの場所",
    "url": "/ba09d04c/",
    "relUrl": "/ba09d04c/"
  },
  "3": {
    "id": "3",
    "title": "Administration",
    "content": "Administration",
    "url": "/a944bb05/",
    "relUrl": "/a944bb05/"
  },
  "4": {
    "id": "4",
    "title": "設定のセットアップ",
    "content": "設定の基本操作このガイドを読み終えると、プロジェクト情報を設定に追加するための基本的な知識を習得し、その設定をプロジェクトに関連付けて、パイプライン設定をカスタマイズするための準備を行えるようになります。このガイドについてこのガイドでは、ShotGrid Desktop の[Advanced Project Setup]ウィザードを使用して、デジタル コンテンツ作成パイプラインの設定を作成する方法について説明します。短時間で設定ツールを習得し、ウィザードの使用方法を学習して、さらに知識を広げることできます。ウィザードを使用することにより、プロジェクトのパイプライン設定を作成でき、パイプラインの各ステップに対応するように編集、拡張する準備が整います。設定により、プロダクション パイプラインをサポートするために必要なユーザ インタフェース、ShotGrid アプリ、およびさまざまなツールの特性がコントロールされます。ウィザードを使用することは、設定を拡張するための 1 つの方法にすぎません。ウィザードによってパイプラインの各ステップに具体的な設定が追加されるだけでなく、ソフトウェア アプリケーションとの統合も追加されます。このガイドでは、プロジェクトの設定のベースとして Toolkit の既定の設定を使用します。このガイドでは、次のユーザを対象としています。  [Advanced Project Setup]ウィザードを使用したことがないユーザ  ShotGrid の使用方法に関する基本知識を持っているユーザ  ShotGrid Toolkit を新たに使用するユーザこのドキュメントの使い方このガイドを使用してカスタマイズ可能なプロジェクトの設定を作成するには、以下が必要になります。  アクティブな ShotGrid サイト。こちらから ShotGrid に登録し、30 日間の無償体験版を取得して試してみることができます。  ShotGrid Desktop。Desktop がインストールされていない場合は、こちらのリンクに従ってインストールを開始できます。  プロジェクト ファイルおよびパイプライン設定を保存できるファイルシステムへのアクセス権。ファイルシステム上に Shotgun というフォルダを作成し、その中に projects と configs という 2 つのフォルダを作成します。[Advanced Project Setup]ウィザードについてShotGrid Desktop の[Advanced Project Setup]ウィザードは、既定の設定に基づいてパイプライン設定を生成します。既定の設定により、パイプライン プロセスをサポートするカスタマイズ可能な設定、アプリ、UI 要素を備えた、構築のための強固な基盤が提供されます。ユーザはプロジェクトのパイプラインに関するニーズに合わせて、このウィザードで作成される設定を編集したり、拡張したりできます。既定の設定は、次のとおりです。  ディスク上のファイルの配置場所を決定する、ファイルシステムの基本的なスキーマおよびテンプレート  ユーザのソフトウェア アプリケーション内から ShotGrid およびパイプラインの機能を直接操作できる、サポート対象のすべてのソフトウェア統合カスタマイズするには、想像力、賢さ、プログラミング上の知識の他に、ShotGrid コミュニティ内の他のユーザが作成した作品から借用する能力が必要です。設定を作成する設定はプロジェクトごとに必要です。ShotGrid Desktop を介してプロジェクトに初めてアクセスするときに、基本設定がダウンロードされて、設定されます。この基本設定により、ユーザがシステムにインストールしているサポート対象のコンテンツ作成ソフトウェアが自動的に検出され、その設定がプロジェクトに関連付けられます。サポート対象ソフトウェア アプリケーション内の統合は、パイプライン設定内の設定値によって管理されます。Panel アプリには ShotGrid のプロジェクト情報が表示されるため、アーティストは作業セッションから移動しなくてもノートに返信し、バージョンを確認することができます。Publisher アプリを使用すると、アーティストはチーム内の他のメンバーに自分の作品を公開することができます。また、Loader アプリを使用すると、アーティストはチームメイトがパブリッシュしたファイルをロードすることができます。基本設定には、ファイルシステムの管理に関する設定や、ディスク上のファイルおよびフォルダの命名方法を指定するためのテンプレートの開発は含まれていません。また、既定の設定を行ったときに追加された多数のアプリも含まれていません。基本設定は、設定ファイルを手動で編集しなくても Toolkit で実行できるシンプルな設定です。ウィザードを使用すると、基本設定が既定の設定に置き換わります。また、作業中のユーザをサポートするアプリおよびソフトウェアが幅広く統合されます。基本設定を編集することもできますが、プロジェクトを設定してカスタマイズするには、高度な設定を行うことが必要になります。基本設定と既定の設定の違い            機能      基本設定      既定の設定                  ダウンロード      プロジェクトにアクセスしたときに自動的にダウンロードされる      [Advanced Project Setup]ウィザードで作成される              アクセシビリティ      システムの場所に格納される      手動で編集可能なファイル形式              更新      自動的に更新      手動で更新              ファイルシステムのサポート      ファイルシステム スキーマはサポートされない      フォルダ構造とファイルの命名基準をサポートするためのツールが付属              ソフトウェア統合      3ds Max、Houdini、Maya、Nuke、Photoshop、Flame      基本設定に加えて、Hiero、Motionbulder、Mari              Toolkit アプリ      ShotGrid Panel、Publisher、Loader      基本設定に加えて、Workfiles、Snapshot、Scene Breakdown、Nuke 書き込みノード、Houdini Mantra ノードなど      このガイドでは、ShotGrid Desktop のウィザードを使用し、既定の設定に基づいてプロジェクトのパイプライン設定を生成します。この設定を生成すると、独自のプロダクション パイプラインをサポートするために必要なカスタマイズを実行できるようになります。実習を開始既定の設定の作成準備を行う手順 1: ShotGrid で「the_other_side」という新しいプロジェクトを作成します。手順 2: ShotGrid Desktop アプリを起動し、ユーザ名およびパスワードを使用して ShotGrid サイトからログインします。手順 3: サムネイル イメージを選択して、ウィザードを実行するプロジェクトにナビゲートします。                    ヒント: Desktop を開いているときに新しいプロジェクトを作成した場合、新しいプロジェクトを表示するには、プロジェクト ウィンドウを更新しなければならないことがあります。デスクトップの右下にあるプロファイルのアバターを選択して、[Refresh Projects]を選択します。    既定の設定にアクセスするプロジェクトにアクセスし、基本設定をダウンロードして設定しました。また、Publish アプリおよびサポート対象のソフトウェア パッケージが検出されて、ShotGrid Desktop の[Apps]ペインに自動的に追加されました。手順 4: プロジェクトがロードされたら、画面の右下にあるプロファイルのアバターを選択します。ポップアップメニューで、[Advanced project setup…]を選択して、ウィザードを開始します。ダイアログ ボックスが開き、[ShotGrid Default]が選択された状態で 4 つのオプションが表示されます。この時点で、プロジェクトのパイプライン設定のベースを既存のプロジェクトの設定にするのか、GIT リポジトリの設定にするのか、それともディスクのパスにするのかを選択できます。この演習では[ShotGrid Default]を選択します。このオプションを使用すると、ShotGrid の既定の設定に基づいてプロジェクトのパイプライン設定が作成されます。手順 5: [Continue]を選択します。ダイアログ ボックスが開き、[Default]が選択された状態で 2 つのオプションが表示されます。この時点で、[Legacy Default]設定オプションを選択することができます。この設定は、まだ以前のバージョンの ShotGrid を使用しているスタジオのために、以前のバージョンの ShotGrid の設定を継承しています。この演習では[Default]を使用します。手順 6: [Continue]を選択します。プロジェクト ファイルの保存場所を定義するダイアログ ボックスが開き、Storage: という単語の横にドロップダウン メニューが表示されます。手順 7: このプロジェクトのプロジェクト データの保存場所を識別します。ダイアログ ボックスの上部にあるドロップダウンで[+ New]を選択し、フィールドに「projects」と入力します。ShotGrid Toolkit では、Linux、Mac、Windows の 3 つのオペレーティング システムをサポートしています。手順 8: プロジェクト データを保存するのに利用するオペレーティング システムの横にあるフィールドを選択します。フォルダ アイコンを選択し、この演習の前にファイルシステム上に作成したプロジェクト フォルダにナビゲートします。この設定の場合、ShotGrid からアクセスできるのは、プロダクション データを保存するために識別されたフォルダに限定されます。この演習の準備中に、ShotGrid のルート ディレクトリ内に projects/ ディレクトリを追加しました。projects/ ディレクトリには、プロジェクトに関連するローカルな情報が格納されます。手順 9: [Save]を選択して、プロジェクト データの保存先としてプロジェクト フォルダを識別します。オペレーティング システムのパスが自動的に更新されて、プロジェクト データの保存場所が識別されます。手順 10: [Continue]を選択します。プロジェクト フォルダに名前を付けるダイアログ ボックスが表示され、プロジェクトの名前がテキスト フィールドに入力されます。この名前はプロジェクトの情報から自動的に入力され、パスは自動的に更新されます。Toolkit は、2 つのいずれかの設定で機能します。パイプライン設定が ShotGrid にアップロードされ、ユーザごとにローカルにキャッシュされる分散設定(Distributed Setup)と、ディスク上の共有場所に保管された単一の設定にユーザがアクセスする中央設定(Centralized Setup)です。この演習では分散設定を使用します。分散設定の詳細については、こちらを参照してください。最後の手順では、該当するフォルダ、ファイル、およびプロジェクトに固有の設定を作成するために必要なデータを生成します。手順 11: 該当するオペレーティング システムの[Browse…]を選択し、この演習の準備中に作成した設定フォルダ configs にナビゲートして、プロジェクト名として「the_other_side」と入力します。プロジェクト設定が保存されるフォルダが作成されます。[Run Setup]を選択して、セットアップが完了するまで待ちます。手順 12: [Done]を選択します。プロジェクト ウィンドウに入力するアイコンが表示されます。ヒント: アプリをメニュー バーに固定すると、ShotGrid Desktop にすばやくアクセスできるようになります。アバターを選択して、[Pin to Menu]を選択します。これでプロジェクトの設定は完了です。指定した場所にプロジェクトの Toolkit パイプライン設定が保存され、カスタマイズを開始できるようになりました。configs フォルダを調べると、いくつかのフォルダとファイルが配置されています。内容を調べてみましょう。ここからの作業は、設定で実行できるすべての操作について楽しみながら学習することができます。次に、これから調べる高度なトピックをいくつか示します。高度なトピックShotGrid Toolkit では、さまざまな方法で設定の編集、クローン作成、またはやり直しを行うことができます。既存の設定を拡張することにより、作業時間を短縮し、ネットワーク内の他のユーザが作成したすべての便利なツールにアクセスできます。広大な ShotGrid のコミュニティを利用して、必要な設定を取得することができます。ShotGrid のコミュニティは共有コミュニティです。そのため、他のユーザに対して親切に対応し、感謝を示し、あなたのジョブに役立つ設定を作成してくれたユーザに賞賛の念を示すことが大切です。そして「お返し」をすることを忘れてはいけません。それこそが ShotGrid の仲間をサポートし、このコミュニティへの参加が特別なことであることを示す理由なのです。次に、設定による楽しみ方の例をいくつかを示します。コマンド ラインを使用して既定の設定を作成するいずれかのプロジェクト設定内で tank コマンドを使用すると、端末から管理コマンドを実行できます。各プロジェクトには専用の tank コマンドがあります。tank setup_project コマンドの機能は、[Advanced Setup Wizard]の機能と似ていて、既存のプロジェクトの設定や既定の設定に基づいて、プロジェクトで使用される編集可能な設定をディスク上に作成することができます。 の実行方法については、tank setup_projectこちらを、 コマンドの詳細については、tankこちらを参照してください。プロダクション中に設定を編集する現在プロダクションで使用している設定を変更する必要があっても、アーティストが使用している間は編集したくない場合があります。ShotGrid には、コマンドをいくつか実行するだけで既存の設定をコピーできる機能があります。この機能を使用すると、プロダクション環境に送信する前に変更内容について安全にテストすることができます。このプロセスを行うと、プロダクションの設定が新しい設定に置き換えられ、古い設定が自動的にバックアップされます。設定のコピーを操作する必要があるのは、次の理由からです。  設定を更新する  実行する前にいくつかの変更をテストする  一部のアプリをアップグレードまたは追加する  テスト後に開発を行って、展開する設定のクローン作成方法、および設定管理に関するその他の基本情報については、「設定のステージングとロールアウト」を参照してください。パイプライン設定のクラウドへの分散このガイドでは、中央設定の作成方法について説明します。中央設定とは、ネットワーク上の共有場所に配置されていて、すべてのユーザがアクセスできるパイプライン設定の単一コピーのことです。従業員が複数の場所およびネットワークに分散している場合は、パイプライン設定の単一コピーを共有できないことがあります。Toolkit は分散設定オプションを提供することによってこのシナリオを可能にします。すなわち、パイプライン設定を ShotGrid にアップロードして、ユーザがプロジェクトにアクセスするたびに設定がダウンロードされ、ローカルにキャッシュされます。分散設定の詳細については、Core API 開発者向けドキュメントを参照してください。複数のルート フォルダを操作する理想的なのは、特定のタスクに合わせて施設を最適化することです。複数のルート フォルダを使用すると、1 台のサーバで日常業務を行い、もう 1 台のサーバでインタラクティブな処理を行うようビデオの再生を最適化することができます。Toolkit では複数のストレージのルートを操作し、上記のようなワークフローを容易に実行することができます。単一ルート設定からマルチルート設定への変換方法を確認してください。これで、プロジェクトのパイプライン設定が作成されたので、編集してみましょう。詳細については、次のガイドの「パイプライン設定の編集」にアクセスしてください。",
    "url": "/5d83a936/",
    "relUrl": "/5d83a936/"
  },
  "5": {
    "id": "5",
    "title": "Apps and Engines Configuration Reference",
    "content": "Apps and Engines Configuration ReferenceThis document contains an overview of all the different options that you can include when creating configurations for Apps, Engines and Frameworks in the ShotGrid Pipeline Toolkit. It can be useful when doing advanced configuration of Apps, and it is important when you are doing development and need to add parameters to your App Configuration Manifest.This document describes functionality only available if you have taken control over a Toolkit configuration. For more info, see ShotGrid Integrations Admin Guide.IntroductionThis document contains specifications for the various file formats that Sgtk uses for its configuration and settings. Please note that this is a reference document which outlines all the various options and parameters available. For best practices on how to manage your configuration, please see the following document:Configuration Management best practices.ShotGrid Pipeline Toolkit EnvironmentsThree major components exists in Toolkit:  An engine provides a translation layer or an adapter between a host application (such as Maya or Nuke) and Sgtk Apps. Apps typically use python and PySide, and it is the responsibility of the engine to present the host application in a standardized fashion and for example add pyside on top of the host application if this doesn’t exist already.  An app provides a piece of business logic, it is essentially a tool that does something. Apps can be hand crafted to work in a specific host application, or they can be designed to run in more than one host application.  A framework is a library which can be used by engines, apps or other frameworks. A framework makes it possible to more easily manage code or behaviour which is shared between multiple apps.An environment file contains the configuration settings for a collection of engines, apps and frameworks. Such a collection is called an Environment. Sgtk launches different environments for different files or different people. You can for example have an environment for Shot production and environment for Rigging. Each environment is a single yaml file.Environment files are located at /&amp;lt;sgtk_root&amp;gt;/software/shotgun/&amp;lt;project_name&amp;gt;/config/envThe yaml file has the following basic format:    engines:        tk-maya:            location            engine settings                apps:                tk-maya-publish:                    location                    app settings                    tk-maya-revolver:                    location                    app settings            tk-nuke:            location            engine settings                apps:                tk-nuke-setframerange:                    location                    app settings                    tk-nuke-nukepub:                    location                    app settings        frameworks:        tk-framework-tools:            location            framework settingsEach app and engine can be configured via settings. These settings correspond with the list of settings that the app/engine exposes in its manifest file called info.yml. As of v0.18.x of Sgtk Core, settings only need to be specified if they differ from the default values specified in the manifest file. In addition to the manifest file, the configurable settings can typically be found on the app/engine page within the Toolkit App Store.In addition to the various settings that can be defined for each item, each app, engine and framework also needs to define where its code is located. This is done using a special location parameter.Code LocationsEach app, engine or framework defined in the environment file has got a location parameter which defines which version of the app to run and where to download it from. Most of the time this is handled automatically by the tank updates and tank install commands. However, if you are doing hand editing of configurations, a variety of options are available for you to help deploy and structure Toolkit:Toolkit currently supports app installation and management using the following location descriptors:  An app_store descriptor represents an item in the Toolkit App Store  A ShotGrid descriptor represents an item stored in ShotGrid  A git descriptor represents a tag in a git repository  A git_branch descriptor represents a commit in a git branch  A path descriptor represents a location on disk  A dev descriptor represents a developer sandbox  A manual descriptor that is used for custom deployment and rolloutFor documentation on how to use the different descriptors, please see the Toolkit reference documentation.Disabling Apps and EnginesSometimes it can be useful to temporarily disable an app or an engine. The recommended way of doing this is to to add a disabled: true parameter to the location dictionary that specifies where the app or engine should be loaded from. This syntax is supported by all the different location types. It may look like this for example:location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;disabled&quot;: true}Alternatively, if you want an app to only run on certain platforms, you can specify this using the special deny_platforms setting:location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;deny_platforms&quot;: [windows, linux]}Possible values for the  deny_platforms  parameter are windows, linux, and mac.Settings and parametersEach app, engine or framework explicitly defines a number of settings which you can override in the configuration file. These settings are strongly typed into strings, integers, lists, etc. For details, see the Toolkit reference documentation.",
    "url": "/6d10dedf/",
    "relUrl": "/6d10dedf/"
  },
  "6": {
    "id": "6",
    "title": "as_template_fields() でコンテキスト内に存在する値が見つからない",
    "content": "as_template_fields() でコンテキスト内に存在する値が見つからないas_template_fields() メソッドはパス キャッシュを使用するため、テンプレートのキーに対応するフォルダがまだ作成されていない場合、フィールドは返されません。これにはいくつかの原因があります。  テンプレート定義とスキーマを同期させる必要があります。このテンプレート定義またはパイプライン設定のスキーマの両方ではなく、いずれかを修正した場合は、予想フィールドが返されません。  フォルダはこの特定のコンテキスト用に作成されていません。まだ作成されていない場合は、パス キャッシュで一致するレコードがないため、予想フィールドが返されません。",
    "url": "/8d9d2658/",
    "relUrl": "/8d9d2658/"
  },
  "7": {
    "id": "7",
    "title": "AWS Knowledge",
    "content": "AWS KnowledgeBelow you can find links to additional reading material from AWS, including documentation on technologies leveraged by the Isolation feature set, as well as compliance information:  [AWS Media Blog] Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Shotgun  [AWS Media Blog] Designing for Studio-Grade Security  [Compliance] MPAA &amp;amp; Studio Security  [AWS Direct Connect] Overview          [AWS Direct Connect] User Guide        [AWS S3] Overview          [AWS S3] User Guide        [AWS EC2] Overview          [AWS EC2] User Guide        [AWS VPC] Overview          [AWS VPC] User Guide        [AWS PrivateLink] Overview",
    "url": "/5528234a/",
    "relUrl": "/5528234a/"
  },
  "8": {
    "id": "8",
    "title": "Webhooks Batch Deliveries",
    "content": "Batch DeliveryEnabling Batch DeliveryYou can choose to configure your webhook so that it will make requests with a batched payload format by selecting the “Deliver in Batched Format” option.If enabled, at the time each request is formed, it will batch up to 50 pending deliveries into its payload.This can help with managing the processing of large bursts of deliveries as a result of many SG events being generated in a short amount of time. Under typical system operation, multiple deliveries per payload will occur when subscribed events are generated more frequently than once in a 2-second period.Responding to deliveriesIf enabling batched deliveries, we recommend that your receiving service is designed to guarantee a response much faster than 1 second per event. Otherwise, you will be at increased risk for timeouts and webhook failure when batches are large.                    Note: For a receiving service that takes on order of 1 second to respond to a single event, the response time is the main performance factor, not delivery overhead. There will not be any significant benefit in batching.    Non-batched-deliveries Webhooks  timeout allowance is 6 seconds per delivery. i.e. a webhook endpoint must respond to each request within 6 seconds.Batched-deliveries Webhooks  timeout allowance is the maximum of: 6 seconds, or, 1 second per event in the batch.  throttling limits still apply: 1 minute of webhook endpoint response time per minute per ShotGrid site, across all webhooks.Comparison of Webhook Delivery FormatsNon-batched-deliveries Webhook Message Body (always 1 delivery):{  &quot;data&quot;:{    &quot;id&quot;:&quot;119.110.0&quot;,    &quot;event_log_entry_id&quot;:479004,    &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,    &quot;operation&quot;:&quot;update&quot;,    &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},    &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1419},    &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:127},    &quot;meta&quot;:{      &quot;type&quot;:&quot;attribute_change&quot;,      &quot;attribute_name&quot;:&quot;code&quot;,      &quot;entity_type&quot;:&quot;Asset&quot;,      &quot;entity_id&quot;:1419,      &quot;field_data_type&quot;:&quot;text&quot;,      &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,      &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;    },    &quot;created_at&quot;:&quot;2021-02-22 17:40:23.202136&quot;,    &quot;attribute_name&quot;:&quot;code&quot;,    &quot;session_uuid&quot;:null,  },  &quot;timestamp&quot;:&quot;2021-02-22T17:40:27Z&quot;}Batched-Deliveries Webhook Message Body (may contain 1 to 50 deliveries)When batching is enabled, a deliveries key is always present, even if there is only 1 event in the batch. Its value is an array of individual event delivery data, where the information provided for each delivery is identical to un-batched mode.{  &quot;timestamp&quot;:&quot;2021-02-22T18:04:40.140Z&quot;,  &quot;data&quot;:{    &quot;deliveries&quot;:[      {        &quot;id&quot;:&quot;170.141.0&quot;,        &quot;event_log_entry_id&quot;:480850,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;code&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,          &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.198641&quot;,        &quot;attribute_name&quot;:&quot;code&quot;,        &quot;session_uuid&quot;:null,      },      {        &quot;id&quot;:&quot;170.141.1&quot;,        &quot;event_log_entry_id&quot;:480851,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;description&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:null,          &quot;new_value&quot;:&quot;Some other *description*&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.212032&quot;,        &quot;attribute_name&quot;:&quot;description&quot;,        &quot;session_uuid&quot;:null,      },    ]  }}",
    "url": "/e7890fc8/",
    "relUrl": "/e7890fc8/"
  },
  "9": {
    "id": "9",
    "title": "Beyond Your First Project",
    "content": "Beyond your first projectHere, we explain where to go once you have got your first project up and running using the ShotGrid Desktop. It covers useful common questions and topics and lists useful documentation resources.Welcome to ToolkitWelcome to Toolkit! If you are reading this, it probably means that you have managed to successfully install your first ShotGrid Pipeline Toolkit Project using the ShotGrid Desktop.At this stage, we are hoping you are up and running and have something looking like the screenshot above, a project page with several application launchers. At this stage, try opening Maya, Nuke or any of the other Applications. You should find a ShotGrid menu with further functionality for managing files and assets.So where do you go from here? Toolkit offers a lot of flexibility in terms of its configuration and how it works. This document tries to cover some of the next steps that we recommend that you carry out once you are up and running with your first project using the ShotGrid Desktop.Basic ConfigurationThis section contains a collection of tweaks and useful things to configure. If you have just set up your very first Toolkit project, there are most likely a number of little tweaks and adjustments you need to do to get everything up and running properly. This section tries to explain these various steps. Please note that some of these things involve editing configuration files and going “under the hood” at the moment. If you have any questions about anything, please visit our support site for help.Setting up Application PathsOnce you have set up your first project and click one of the launch buttons to launch Maya, Motionbuilder or Nuke, it is possible that you see an error message looking something like this:In the toolkit project configuration, we store paths to the various executables that you can launch. If you are seeing the above message, it probably means that those paths are not matching your studio setup. You may also find that the wrong version of the application is being launched; for example, our default configuration may have a path to maya 2015 but your studio is running maya 2014. In this case, you also need to change the paths.In our default configurations, these paths are all stored in a single file called  paths.yml. In order to change a path, locate your project configuration on disk and then navigate into the config folder until you find the  paths.yml file:Open this file and make the necessary changes to the paths. Once you have saved the file, you need to leave the project inside of ShotGrid desktop and then click back into it. (but no need to restart the entire application).Further ReadingFor more information about applications, check out the following topics:  The Toolkit Application Launcher  Passing Commandline ArgumentsShotGrid IntegrationToolkit integrates with ShotGrid and extends the traditional interface by adding special toolkit action menu items to various parts of the UI:This offers a way to launch Toolkit applications or custom tools that operate on data directly from ShotGrid. You can learn more about integrating with your ShotGrid site in  the Browser Integration section of the Admin Guide.Adding Publishes to the ShotGrid UIOnce you have toolkit installed, it usually makes sense to make some minor adjustments to the ShotGrid UI layouts. The ShotGrid Pipeline Toolkit creates  Publish Entities when you publish a file, so it is handy to add a  Publishes Tab to key Assets such as Shot and Asset. To do this, make sure that you are logged in as an admin user. Start by navigating to an Asset or Shot and enter into  Design Mode:Now click the little menu triangle on one of the tabs, and select the  Add New Tab action. This will bring up a Dialog UI. Call the tab  Publishes and make sure that it is associated with  Published File Entities:Now click  Save to save your changes. You are all set!Note: ShotGrid will choose a couple of default fields to pull in when you create a new tab. You may want to add a couple of extra fields for publishes. This is done by clicking the little plus button in the top-right hand corner of the spreadsheet you can see under your new publishes tab. We recommend that you add the following fields:  Description - Holds a description of the changes in this publish  Created By - The user who created the publish  Date Created - When the publish was madeIf you make changes to your layouts, don’t forget to save the page afterwards!Multiple Operating SystemsIn some cases, you may be seeing a message popping up, informing that you  Python cannot be found with a link to this section of the documentation.Toolkit executes its scripts and functionality using a language called  Python. The ShotGrid Desktop comes with a complete Python installation built in, so normally you never need to worry about this. When you set up a new Toolkit project using the ShotGrid Desktop, the project will be set up by default to use the Python that comes bundled with the ShotGrid Desktop. However, sometimes you may explicitly have to tell Toolkit which Python you want it to use. This can happen in if you for example:  Use an older version of the ShotGrid Desktop which doesn’t set up all Python defaults automatically.  If you have installed the ShotGrid Desktop in a non-standard location on disk.  If you a running a manual or more complex Toolkit project setup.The path to Python is stored in configuration files which you can manually edit:In order to find the right file, first navigate to your project configuration. In there, find the tree files starting with  interpreter_. These contain the paths to the python interpreter for Linux, Windows and Mac (“Darwin”). These files contain the location of Python for each of the three operating systems. You now need to go in and manually add the python locations for any operating system you wish you use.If the files are blank, this indicates that you are using an older version of the ShotGrid Desktop. If this is the case, simply try to update the blank files with the default Python paths. They are as follows:  Macosx (Darwin):  /Applications/Shotgun.app/Contents/Frameworks/Python/bin/python  Windows:  C: Program Files Shotgun Python python.exe  Linux:  /opt/Shotgun/Python/bin/pythonIf you rather have installed the ShotGrid Desktop in a non-standard location or intend to use a custom python location, please ensure that the paths in the files point to a valid Python installation. It needs to be v2.6 or above (but not Python 3!). If you want to execute UI based applications and tools, please make sure that the Python you specify has either PyQt or PySide installed and is linked up to a QT v4.6 or higher.Please also note that in order to run Toolkit on multiple operating systems, you need to specify the paths to all your desired platforms when you are running the project setup wizard. If you haven’t done this, and want to add an additional operating system to a storage path or configuration location, please visit our support site for help.Next StepsHopefully at this point you now have the default ShotGrid setup working for a ShotGrid project (or test project). Applications are launching, Context menu actions and publishes are showing up in ShotGrid and things are working on all your desired operating system platforms.This next section is all about what to do next – the process of starting to take that default configuration and adjust it to work more like the rest of your studio pipeline. Toolkit is flexible and highly configurable, and we have lots of documentation. But before you get started, to see it all in action, we recommend spending a couple of minutes checking out our various walkthrough videos. These show the ShotGrid Pipeline Toolkit in action, how it works inside applications such as Maya and Nuke. It also goes through basic concepts such as publishing, version control, loading etc.ShotGrid Toolkit Video CollectionThe anatomy of a Toolkit ProjectWhen you create a new Toolkit project, you end up with a couple of key locations.  The ShotGrid Desktop and its configuration is installed on your local machine. (If you want, it is possible to relocate both the application and the configuration to a shared storage).  The data area where the Toolkit project will store textures, files, renders etc. This is normally on a shared storage, because you want to share this data with other users, however there are exceptions to this rule; user work areas can be stored on local (user only) storage, and integrations such as our perforce integration uses an external system to help distribute content.  The toolkit configuration is a fully self contained bundle, including code, apps, core API etc. This is normally stored on a shared storage so that the configuration is easily accessible by all users.Your Project configuration on disk contains a couple of different items.In the following sections we’ll walk through the various parts of the project configuration folder.Command line accessAs well as using the ShotGrid Desktop, you can also access Toolkit via a terminal or shell. Each project that you create on disk comes with a special  tank command which gives you command line based access to a lot of functionality, including starting up an API session and launching applications.If you navigate to your project configuration, you can see a  tank and a  tank.bat command in the root of the configuration. Running these commands without any options will give you a list of all the commands that are supported in your current configuration, including the following useful commands:  tank shell - Start an interactive python shell with tk api access  tank core - Check if there are any core API updates available for this project  tank updates - Check if any of the apps or engines in this configuration has got any updates availableFor more details on what you can do with the  tank command, please see the in-depth technical documentation:How to Administer ToolkitKey Configuration FilesThe  config folder contains a couple of key configuration files.Toolkit comes with a folder creation system which tries to automatically create folders on disk to make sure that when you start up an application, all the necessary structure on disk exists and has been prepared on beforehand! The configuration for this can be found in the  schema folder indicated above.Hand in hand with this goes the Toolkit  template system which makes it easy to define the various paths to files that you can configure; your publishes, work files, renders etc. This is stored in the  templates.yml file above.Together, these two parts of the project configuration makes it possible to adjust the various Apps that toolkit use to write out data to locations on disk which make sense are are understood by your existing pipeline.Read more about this in our advanced documentation:  Folder Configuration  Filesystem TemplatesA toolkit configuration is essentially made up of a collection of configured  apps and engines. This configuration is located in the  env folder. If the file system configuration files discussed above define  where resources should be located on disk, the environment configuration with its apps and engines define  what the pipeline is supposed to do.Core API platformEach project configuration uses a collection of Apps and Engines. The configuration for these apps and engines are stored in the  env folder inside the configuration. Toolkit will then automatically download and manage the various versions of the code needed to run these apps and engines. The code is placed inside the  installfolder.The configuration, apps and engines are all running on top of the Toolkit Core platform. For new projects, this is also stored inside the  install folder. Essentially, a project configuration is fully self contained - all the necessary pieces required to run toolkit are in a single place. This also means that each project is independent and updating one project will not break another.Tech Notes: Using a shared Toolkit Core (Click to expand)Further readingWe also have a more technical document that goes through the high level concepts in the ShotGrid Pipeline Toolkit and explains ‘bigger picture’ things. Once you have a good grasp of what Toolkit does out of the box, we recommend that you move on to this document to get a deeper undestanding of how Toolkit could be adjusted to suit your particular studio needs.An introduction to the high level concepts in the ShotGrid ToolkitThe Toolkit CommunityA part of Toolkit is its community of pipeline engineers and TDs! We are on a mission to create a vibrant, code sharing community where we all can help evolve Toolkit together to become a powerful and flexible pipeline environment.If you have any questions, or want to read through existing posts and conversations, please visit our  public forums section.",
    "url": "/c3b662a6/",
    "relUrl": "/c3b662a6/"
  },
  "10": {
    "id": "10",
    "title": "Linux で ShotGrid Desktop/ブラウザ統合の起動に失敗する",
    "content": "Linux で ShotGrid Desktop/ブラウザ統合の起動に失敗するLinux で ShotGrid Desktop を初めて実行すると、次のいずれかのエラー メッセージが表示される場合があります。この場合、特定のエラーに合わせて次の手順を実行して問題が解決されるかどうかを確認します。問題が解決しない場合は、support@shotgunsoftware.com までお気軽にお問い合わせください。目次  OPENSSL_1.0.1_EC または HTTPSConnection に関連する問題  libffi.so.5 に関連する問題  証明書検証の失敗に関連する問題  互換性のない Qt バージョンOPENSSL_1.0.1_EC または HTTPSConnection に関連する問題エラーimporting '/opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so': /opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so: symbol ECDSA_OpenSSL, version OPENSSL_1.0.1_EC not defined in file libcrypto.so.10 with link time referenceAttributeError: 'module' object has no attribute 'HTTPSConnection'解決策OpenSSL をインストールする必要があります。このためには、管理者として次のコマンドを実行します。$ yum install openssllibffi.so.5 に関連する問題エラーBrowser Integration failed to start. It will not be available if you continue.libffi.so.5: cannot open shared object file: No such file or directory解決策libffi をインストールする必要があります。このためには、管理者として次のコマンドを実行します。yum install libffilibffi をインストールしても問題が継続する場合は、次の symlink を作成して ShotGrid Desktop を再起動してください。sudo ln -s /usr/lib64/libffi.so.6.0.1 /usr/lib64/libffi.so.5上記の手順で成功したユーザもいますが、 問題が解決しなかったユーザもいます。最新バージョンの ShotGrid Desktop には、現在調査している Web ソケット サーバとの依存関係がいくつか追加されています。証明書検証の失敗に関連する問題考えられるエラーBrowser Integration failed to start. It will not be available if you continue.Error: There was a problem validating if the certificate was installed.certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.解決策コンピュータに Google Chrome をインストールしている場合は、Google Chrome を起動してから ShotGrid Desktop を再起動します。問題が解決しない場合は、support@shotgunsoftware.com までお問い合わせください。Chrome がインストールされていない場合は、端末を開いて、次のコマンドを実行します。ls -al $HOME/.pki/nssdbここで何か見つかった場合は、サポートまでご連絡ください。チケットに次のログ ファイルの内容を添付してください。~/.shotgun/logs/tk-desktop.log何も見つからなかった場合は、次のコードを入力します。$ mkdir --parents ~/.pki/nssdb$ certutil -N -d &quot;sql:$HOME/.pki/nssdb&quot;パスワードは入力しないでください。これで、ShotGrid Desktop が正しく起動されるようになります。互換性のない Qt バージョン考えられるエラー互換性のない Qt ライブラリ(バージョン 0x40805)とこのライブラリ(バージョン 0x40807)を混在させることができない解決策多くの場合、互換のない Qt ライブラリをロードするオーバーライドが実行されると発生します。このエラーが発生しないようにするには、次のコマンドを使用して環境を修正します。unset QT_PLUGIN_PATH",
    "url": "/9207f027/",
    "relUrl": "/9207f027/"
  },
  "11": {
    "id": "11",
    "title": "ローカル ファイル リンクを使用できず、Chrome から Toolkit アプリケーションを起動できない",
    "content": "ローカル ファイル リンクを使用できず、Chrome から Toolkit アプリケーションを起動できない概要ShotGrid のアクション メニューで Toolkit アプリケーションのリストが表示されなかったり、ShotGrid Desktop が動作していてもローカル ファイル リンクを使用するときにエラーが発生したりする場合があります。 これは Chrome での ShotGrid Desktop のブラウザ統合のトラブルシューティングに関するガイドです。皆さんの役に立つことを願っています。Firefox のための個別のガイドがあります。  問題を診断する  証明書問題をすばやく修正する方法  すべてのプラットフォームの ERR_CERT_COMMON_NAME_INVALID または ERR_SSL_SERVER_CERT_BAD_FORMAT を修正する  Windows で ERR_CERT_AUTHORITY_INVALID を修正する問題を診断するShotGrid Desktop は動作していますか?もちろん、そうだと思います。 既に確認済みだと思いますが、 念のためお尋ねしました。:)ShotGrid Desktop の起動後に Chrome を再起動しましたか?ShotGrid Desktop が証明書を登録する前に Chrome を起動した場合(ShotGrid Desktop を初めて起動した場合にのみ発生し、その後は問題になりません)、Chrome は期限切れの証明書のコピーを使用し、ShotGrid Desktop への接続を拒否します。すべてのタブを閉じても Chrome は終了する必要がないため、アドレス バーに chrome://restart と入力して[Enter]キーを押します。これにより、Chrome に関連するすべてのプロセスを終了し、Chrome を再起動させます。ファイアウォール ソフトウェアを使用していますか?ファイアウォール ソフトウェアが localhost またはポート 9000 との接続を妨げていないことを確認します。Chrome が証明書を拒否していますか?Chrome が証明書を受け入れていることを確認するには、https://localhost:9000 を参照します。これは、ローカル ファイル リンクを使用して Toolkit アプリケーションを起動するために ShotGrid Web サイトがアクセスを試みるアドレスです。通常、次のメッセージが表示されます。または、次のいずれかのメッセージが表示された場合は、証明書の登録プロセスに問題があったことを示しています。 証明書問題をすばやく修正する方法この問題を回避する最も簡単な方法は、ADVANCED と Proceed to localhost (unsafe) をクリックすることです。 これにより、Chrome は証明書を承認していることを把握でき、ShotGrid Web サイトが ShotGrid Desktop と通信できるようになります。                    注: このため、Web ブラウザと ShotGrid Desktop 間の接続のみが有効になります。信頼設定は 2 つのアプリケーション間のトラフィック フローを許可しますが、インターネット上の他のサーバの信頼性を暗示しているわけではありません。 残念なことに、問題を抱えたすべてのコンピュータにこのプロセスを繰り返し適用する必要があります。問題が解決されない場合、またはすべてのユーザに展開するには複雑すぎる場合は、次の手順を試すことをお勧めします。                        注: この手順は ERR_SSL_SERVER_CERT_BAD_FORMAT エラーには適用されません。以下の説明のとおりに証明書を再生成する必要があります。    すべてのプラットフォームの NET::ERR_CERT_COMMON_NAME_INVALID と ERR_SSL_SERVER_CERT_BAD_FORMAT を修正するChrome は自己署名証明書のセキュリティを定期的に更新しますが、ブラウザ統合がこの更新で壊れることがあります。 残念ながら、このような問題を解決するには証明書の certificate_path を再生成するしかありません。証明書を再生成するには、ShotGrid Desktop のユーザ メニューの [詳細設定]（Advanced）セクションにある Regenerate Certificates オプションを選択します。(このオプションが表示されない場合は、ロック解除のために tk-desktop エンジンを更新してください。)証明書の再生成を確定すると、証明書を初めて生成したときのように一連のダイアログが表示されます。Windows と macOS で、Windows Certificate Store または macOS キーチェーンの更新を求めるプロンプトが 2 回表示されます。1 回目は古い証明書の削除のときで、2 回目は新しい証明書の登録のときです。Linux では、確認なしで登録されます。 登録されると、ShotGrid Desktop が再起動されます。ShotGrid Desktop の準備が完了したら、Chrome が完全にシャットダウンしてその証明書キャッシュがクリアされるように、アドレス バーに chrome://restart と入力して Chrome を再起動することをお勧めします。コンピュータがインターネットに接続されておらず、更新をダウンロードできない場合は、support@shotgunsoftware.com までお問い合わせください。Windows で NET::ERR_CERT_AUTHORITY_INVALID を修正する特定の状況において、Windows で証明書の読み込みが成功した場合でも、証明書を必要とするアプリケーションがその証明書を使用できないことがあります。これは Windows の証明書ダイアログにアクセスすると確認できます。アクセスするには、[Windows]キーを押してから インターネット オプション と入力します。[インターネットのプロパティ]（Internet Properties）ダイアログで[コンテンツ]（Content）タブに切り替え、[証明書]（Certificates） ボタンをクリックします。最後に、[信頼されたルート証明機関]（Trusted Root Certification Authorities） をクリックし、localhost を探します。エントリが見つからない場合は、Windows ドメインまたはローカル コンピュータのグループ ポリシーに問題がある可能性があります。問題がある場合は、サポート チームに連絡することをお勧めします。ここで、組織の Windows コンピュータを管理するユーザに連絡し、自己署名証明書を信頼しないように Windows に指示しているグループ ポリシーがないかどうかを確認してもらうことをお勧めします。グループ ポリシーの問題を調査するコンピュータがドメイン上にある場合、管理者はこの StackExchange の投稿で説明されている手順を試してみてください。コンピュータがドメイン上にない場合は、管理者によってコンピュータがまだロックされている可能性があります。次の手順には Windows の管理者アカウントが必要です。[Windows]キーを押して、mmc と入力して[Enter]キーを押します。これにより、Microsoft 管理コンソールが起動します。このアプリケーションで、[ファイル]（File）メニューをクリックし、[スナップインの追加と削除]（Add/Remove Snap-In）を選択します。これにより、[スナップインの追加と削除]（Add/Remove Snap-In）ダイアログが表示されます。左側で、Group Policy Object Editor を探して選択し、[追加 &amp;gt;]（Add &amp;gt;）をクリックします。新しいダイアログが表示されたら、[終了]（Finish）をクリックして閉じます。最後に、[スナップインの追加と削除]（Add/Remove Snap-In）ダイアログで、[OK] をクリックします。最後に、メイン ダイアログの左側から [ローカル コンピュータ ポリシー/コンピューターの構成/Windows 設定/セキュリティ設定/公開キーのポリシー]（Local Computer Policy/Computer Configuration/Windows Settings/Security Settings/Public Key Policies）に移動します。選択したら、中央のペインで [証明書パス検証の設定]（Certificate Path Validation Settings） をダブルクリックします。次のダイアログ ボックスで、[これらのポリシーの設定を定義する]（Define these policy settings） の選択が解除されていることを確認します。選択されている場合は、[ユーザーが信頼するルート証明機関 (CA) が証明書の検証に使用されることを許可する(推奨)]（Allow user trusted root CAs to be used to validate certificates (recommended)） が選択されていることを確認します。完了後、OK をクリックすると、設定が保存されます。ここで、Chrome のすべてのウィンドウを閉じて、Chrome を再起動する必要があります。上述のとおりに chrome://restart を使用することをお勧めします。この操作は変更を有効にするために必要です。証明書リストを参照すると、localhost 証明書が表示されます。この変更後にブラウザ統合を使用して問題が発生した場合、または元の設定が正しい場合は、サポート チームまでご連絡ください。他の OS でのトラブルシューティング他の OS での ShotGrid Desktop 統合に問題がある場合は、この記事を更新してサポートできるように、サポート チームまでご連絡ください。",
    "url": "/95518180/",
    "relUrl": "/95518180/"
  },
  "12": {
    "id": "12",
    "title": "ローカル ファイル リンクを使用できず、Firefox から Toolkit アプリケーションを起動できない",
    "content": "ローカル ファイル リンクを使用できず、Firefox から Toolkit アプリケーションを起動できない概要ShotGrid のアクション メニューで Toolkit アプリケーションのリストが表示されなかったり、ShotGrid Desktop が動作していてもローカル ファイル リンクを使用するときにエラーが発生したりする場合があります。これは Firefox での ShotGrid Desktop のブラウザ統合のトラブルシューティングに関するガイドです。皆さんの役に立つことを願っています。Chrome のための個別のガイドがあります。問題を診断するShotGrid Desktop は動作していますか?もちろん、そうだと思います。 既に確認済みだと思いますが、 念のためお尋ねしました。 ファイアウォール ソフトウェアを使用していますか?ファイアウォール ソフトウェアが localhost またはポート 9000 との接続を妨げていないことを確認します。Firefox が証明書を拒否していますか?Firefox が証明書を受け入れていることを確認するには、https://localhost:9000 を参照します。これは、ローカル ファイル リンクを使用して Toolkit アプリケーションを起動するために ShotGrid Web サイトがアクセスを試みるアドレスです。通常、次のメッセージが表示されます。次のいずれかのメッセージが表示された場合は、証明書の登録プロセスに問題があったことを示しています。「安全な接続ではありません」というエラーを解決する方法証明書を受け入れられるように例外を Firefox ブラウザに追加する必要があります。 https://localhost:9000 にアクセスしたばかりの場合は、[詳細]（Advanced）をクリックし、[例外を追加]（Add Exception）ボタンをクリックして例外を追加するのが最も簡単な方法です。ダイアログが表示されます。**[証明書を取得]（Get Certificate）、**[セキュリティ例外を承認]（Confirm Security Exception）の順にクリックします。 証明書を信頼できないというメッセージは無視します。証明書は認証局ではなく ShotGrid Desktop によって生成されているため、問題ありません。これで ShotGrid サイトからローカル ファイル リンクにアクセスし、Toolkit アプリケーションを起動できるようになるはずです。 例外を追加しても問題が解決しない場合は、support@shotgunsoftware.com までご連絡ください。「安全な接続ができませんでした」というエラーを解決する方法[メニューを開きます]（Open Menu）ボタンをクリックして、[オプション]（Preferences）を選択します。次に、左側で[詳細]（Advanced）を選択し、[証明書]（Certificates）、[証明書を表示]（View Certificates）の順に選択します。[サーバー証明書]（Servers）セクションで項目をクリックし、localhost と入力するか、または単に localhost:9000 という名前のエントリが表示されるまでスクロールします。このエントリを削除します。次に、[認証局証明書]（Authorities）タブに移動して localhost と再び入力します。もう一度、localhost エントリを持つ Autodesk セクションが表示されるまでスクロールします。localhost エントリを削除します。これが完了したら、[OK] をクリックして Firefox を再起動します。 Firefox の再起動が完了したら、https://localhost:9000 にアクセスします。次のメッセージが表示されます。ここで、例外を追加するために上記の手順を実行する必要があります。この画面が表示されない場合は、support@shotgunsoftware.com までご連絡ください。",
    "url": "/d4936105/",
    "relUrl": "/d4936105/"
  },
  "13": {
    "id": "13",
    "title": "ShotGrid in the Cloud",
    "content": "ShotGrid in the CloudWhat is ShotGrid in the Cloud?ShotGrid Cloud is our default offering, hosted on AWS and built on top of Autodesk’s Cloud technology platform. ShotGrid Cloud is the latest generation of our hosted service and is completely cloud based.Further ReadingAdministration documentation can be found here.",
    "url": "/af35baf6/",
    "relUrl": "/af35baf6/"
  },
  "14": {
    "id": "14",
    "title": "Community Shared Integrations",
    "content": "Community Shared IntegrationsHere are projects that people in the Toolkit community have been gracious enough to share. They aren’t written by us at ShotGrid and we can’t vouch for them, but we’ll definitely answer any questions we can about them. If you have a project you want added to the list, please visit our support site for help.Engines            Integration      Engine      Information                        tk-katana      Project URL: https://github.com/robblau/tk-katana  Project Contributor:  Lightchaser Animation  Project Maintainer:   Project Description: A ShotGrid Engine for Foundry’s Katana                    tk-unreal      Project URL: https://docs.unrealengine.com/en-US/Engine/Content/UsingUnrealEnginewithAutodeskShotgun/index.html  Project Contributor:  Epic Games  Project Maintainer:  Project Description: A ShotGrid Engine for  Unreal Engine                    tk-substancepainter      Project URL:  https://github.com/diegogarciahuerta/tk-substancepainter  Project Contributor:  Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for Adobe’s Substance Painter                    tk-substancedesigner      Project URL:  https://github.com/diegogarciahuerta/tk-substancedesigner    Project Contributor:  Factor64    Project Maintainer: Diego Garcia Huerta    Project Description: A ShotGrid Engine for Adobe’s Substance Designer    More info:  ShotGrid Community Forums                    tk-modo      Project URL: https://github.com/tremolo/tk-modo    Project Contributor: Lutz Pälike and  Walking The Dog    Project Maintainer:    Project Description: A ShotGrid Engine for Foundry’s Modo                    tk-clarisse      Project URL:  https://github.com/diegogarciahuerta/tk-clarisse  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Clarisse iFX, a fully interactive CG toolset for set-dressing, look development, lighting and rendering.                    tk-natron      Project URL:  https://github.com/diegogarciahuerta/tk-natron  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Natron, a free and open-source node-based software application.                    tk-harmony      Project URL:  https://github.com/diegogarciahuerta/tk-harmony  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Toon Boom Harmony, industry leading production animation software.                    tk-cinema      Project URL:  https://github.com/mikedatsik/tk-cinema  Project Contributor: Mykhailo Datsyk  Project Maintainer: Mykhailo Datsyk  Project Description: A ShotGrid Engine for  Maxon Cinema 4D, a designer-friendly toolset for modeling, animation, and rendering.  More Information:  ShotGrid Community Forums                    tk-krita      Project URL:  https://github.com/diegogarciahuerta/tk-krita  Project Contributor: Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Krita, a free and open-source raster graphics editor designed primarily for digital painting and 2D animation.  More Information: ShotGrid Community Forums                    tk-blender      Project URL:  https://github.com/diegogarciahuerta/tk-blender  Project Contributor: Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Blender, a free and open-source 3D computer graphics software toolset used for creating animated films, visual effects, art, 3D printed models, motion graphics, interactive 3D applications, virtual reality and computer games.  More Information: ShotGrid Community Forums      Apps            Integration      Engine      Information                        tk-maya-playblast      Project URL:  https://github.com/basestudio/tk-maya-playblast    Project Contributor: BASE Studio    Project Maintainer:    Project Description: App to publish playblasts from Maya. See https://goo.gl/5oJTv0                    tk-multi-renderfarm      Project URL: https://github.com/baitstudio/tk-multi-renderfarm    Project Contributor: Bait Studio    Project Maintainer:    Project Description: App to submit work to the farm. See https://goo.gl/ew6mkD                    tk-shotgun-publishrenders      Project URL: https://github.com/janimation/tk-shotgun-publishrenders    Project Contributor:    Project Maintainer:  Dave Sisk    Project Description: This app searches the directory structure of a project to find existing published files or file sequences, then registers them in ShotGrid as published files if the published file objects don’t already exist.                    nuke-getShotgunData      Project URL: https://github.com/RicardoMusch/nuke-getShotgunData    Project Contributor:  Ricardo Musch    Project Maintainer: Ricardo Musch    Project Description: Getting ShotGrid data into nuke text nodes can be a bit of a pain. This node can be used to pipe that info into slates, burn-ins, or anywhere else.                    sb-shotgun-schema-introspection      Project URL: https://github.com/scottb08/sb-shotgun-schema-introspection    Project Contributor:  Scott Ballard    Project Maintainer: Scott Ballard    Project Description: This is a simple Toolkit app that allows ShotGrid and Toolkit developers to quickly navigate and inspect the ShotGrid entities, fields and the underlying schema.                    foto-multi-namingconvention      Project URL: https://github.com/scottb08/foto-multi-namingconvention    Project Contributor:  Griffith Observatory    Project Maintainer: Scott Ballard    Project Description: This is a simple Toolkit app that allows ShotGrid and Toolkit developers to quickly navigate and inspect the ShotGrid entities, fields and the underlying schema.                    tk-cpenv      Project URL: https://github.com/cpenv/tk-cpenv    Project Contributor:  Dan Bradham    Project Maintainer: Dan Bradham    Project Description: This app adds support for  cpenv, a tool that uses modules to manage software plugins, project dependencies and environment variables.    More Information: ShotGrid Community Forums                    rtm-tk-hiero-shotgunDropper      Project URL: https://github.com/RicardoMusch/rtm-tk-hiero-shotgunDropper  Project Contributor:  Ricardo Musch  Project Maintainer: Ricardo Musch  Project Description: This app allows you to drop Versions and playlists from ShotGrid into Hiero.  More Information: ShotGrid Community Forums      ",
    "url": "/58a557ee/",
    "relUrl": "/58a557ee/"
  },
  "15": {
    "id": "15",
    "title": "Configuration Staging and Rollout",
    "content": "Configuration Staging and RolloutThis document explains best practices for how to safely roll out changes to your production pipeline. It explains how you can create a staging sandbox, which is a copy of your production configuration, update this sandbox and do testing and then finally push your changes to the production config.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For the default setup, please see  ShotGrid Integrations Admin Guide.IntroductionThis document outlines how to manage your Toolkit configuration. Toolkit contains several utilities and tools that lets you safely manage your configuration and test upgrades and changes in a safe and sandboxed environment before rolling them out to the entire production.In this document, we’ll describe how to:  Safely upgrade the Toolkit Core API.  Upgrading your Apps and Engines.  Various ways to manage your config across multiple projects.  Go through Toolkit’s  Clone  and  Push  functionality that allows you to safely test upgrades and changes without disrupting production.  How to work with  git  source control and Toolkit.Basics of configuration managementEach Toolkit Project has one or more configurations associated with it. The configuration contains all the settings that the project needs, including file system locations (templates), engines apps, etc. In Toolkit, each project is independently configurable. This means that different projects can live side-by-side safely, and upgrading one project will not affect another.If you are working with a large number of projects, this may become cumbersome and we offer several ways to make this process easy, safe and streamlined.In ShotGrid, each project has a number of  Pipeline Configurations. When a project is first set up with Toolkit, a Pipeline Configuration called  primary  is created. The pipeline configuration entity in ShotGrid points at a location on disk where the Toolkit configuration can be found.During the course of a project, you often need to make changes to the configuration. This can be tweaks to the configuration, or perhaps you need to add additional apps or engines. We also release new app versions frequently and we recommend that you use the latest versions if possible.While it is possible to upgrade your  primary  project configuration straight away, this can be risky; since this configuration is used by everybody on the project, introducing a problem will affect everyone. A better approach is to create an isolated version of the configuration that a select group of people have access to. In this safe environment, upgrades, configuration changes and development can happen without impacting the rest of the production. Once the changes have been tested, they can be safely and confidently pushed to the primary configuration.This process is called  cloning  and means that you make a personal copy of the primary configuration that only you (and other people you invite) have access to the clone. In here you can make changes safely and once you are happy you can push these changes back to the primary configuration.Cloning your ConfigurationOnce you have set up Toolkit and configured a project, the setup will look something like this:There is a  studio  install which holds the Core API for all projects. This  studio  location also contains a  tank command and a Toolkit Python API you can use to access any of your Toolkit-enabled ShotGrid projects.In addition to this, there is a configuration folder for each project. This folder contains all the settings for that project. It also contains a  tank  command (and a Python API) which specifically operates on this configuration. When you are using this tank command or API code, you can strictly only operate on this configuration.When a new project is set up, a  Primary  configuration is created. This is the configuration that Toolkit will use by default for the project. In addition to the primary configuration, you can create additional configurations for a project. These can exist in parallel and are useful if you for example want to privately test some modifications, upgrade some apps or do development without impacting the entire team. Additional configurations are created by a process called  cloning, a process where a configuration is copied to a new location.Once you have cloned your configuration, your setup may look something like this:In addition to the studio level  tank  command and your primary project configuration  tank  command, you now have a new pipeline configuration which has its own  tank  command. If you run this  tank  command, you will operate exclusively on the configuration located in the staging sandbox. So if you want to test out some new things in Maya, you can simply navigate to your cloned sandbox, run  ./tank Shot xyz launch_maya  and the ShotGrid menu which appears in Maya will reflect the configuration inside of your staging sandbox rather than your Primary configuration.Note that the studio level  tank  command always uses the Primary config, so the only way to access a cloned configuration is by navigating to its location and using the  tank  command that is located in that folder. In ShotGrid, you can assign a specific set of users to a pipeline configuration entry, and any users that are associated with a configuration will now see menu entries appear in addition to those coming from the Primary config:Creating a Cloned ConfigurationIn order to create a staging sandbox where you can safely test your upgrades, navigate to the pipeline configurations for your project in ShotGrid and right click on the Primary configuration. An option to clone your configuration will appear:Once you click it, you’ll be presented with a dialog where you specify the path on disk where you want this new configuration to be located. If you are running a multi OS setup, make sure to put in paths for all relevant platforms.When you press ok, Toolkit will copy the configuration across and set up the clone. It will also associate your ShotGrid user with this configuration, so as soon as you have created your clone, you will see new menu items appearing inside ShotGrid.Pushing changes from your staging sandbox to PrimaryOnce you have applied the relevant updates and run any testing that you deem is necessary, you can push back your changes into the production configuration by executing the  tank push_configuration  command. This will transfer all the changes you have made in your staging sandbox to your Primary configuration.Please note that your current configuration is moved to a backup location when you run the push_configuration command. If you accidentally push or if there is a problem with the push, you can roll back simply by taking the content in the backup folder and copying into the config folder.By default, this command will copy a collection of files into the  config  folder in the target pipeline configuration. If you are using unix and would like a more atomic update, you can add a  --symlink  flag to the  push_configuration  command. This will turn the  config  folder in the target pipeline configuration into a symbolic link which makes it easier to upgrade without running the risk of having configuration mismatches in currently running sessions.Refreshing an old cloned configurationIf you have a old dev or staging sandbox set up, but it is out of date and you need to sync its contents with the latest production configuration, you do this by running the  push_configuration  command for the primary configuration:tank push_configurationWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.comStarting Toolkit for your current directory '/tmp'- Using configuration 'Primary' and Core v0.14.52- Setting the Context to Empty Context.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary') to another pipeline configuration in the project.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [324] Staging Sandbox (/my/staging/sandbox)Please type in the id of the configuration to push to (ENTER to exit): 324Hold on, pushing config...Checking if there are any apps that need downloading...Push Complete!Your old configuration has been backed up into the following folder:/my/staging/sandbox/config.bak.20140108_093218Note how we are pushing from the primary project config to the staging sandbox. We do this by running the  primary  configuration’s tank command. If you have multiple sandboxes set up, it is also possible to push data between those.Deleting a cloned configurationIf you want to delete a cloned configuration, simply delete the entry in ShotGrid and remove the folder from disk.Getting latest apps and enginesInside your staging sandbox (or in any other config), you can run the  tank updates  command in order to check if there are any app updates available. This command has got rudimentary filters that you can use if you only want to check certain areas of your configuration:----------------------------------------------------------------------Command: Updates----------------------------------------------------------------------This command will go through your current configuration and check if there areany updates available. If there are updates, you will be asked if you want toperform an upgrade. If settings has been added to the new version that you areinstalling, you may be prompted to specified values for these.Running this command with no parameters will check all environments, enginesand app. This may take a long time. You can also run the updater on a subsetof your installed apps and engines.General syntax:&amp;gt; tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:Check everything:&amp;gt; tank updatesCheck the Shot environment:&amp;gt; tank updates ShotCheck all maya apps in all environments:&amp;gt; tank updates ALL tk-mayaCheck all maya apps in the Shot environment:&amp;gt; tank updates Shot tk-mayaMake sure the loader app is up to date everywhere:&amp;gt; tank updates ALL ALL tk-multi-loaderMake sure the loader app is up to date in maya:&amp;gt; tank updates ALL tk-maya tk-multi-loaderUpgrading the Toolkit Core APIThis section explains how you can use a clone staging sandbox configuration to safely upgrade the Toolkit Core API. If you haven’t got a staging sandbox prepared yet, just follow the instructions in the previous section!If your staging sandbox was cloned from a pipeline configuration using a  shared studio Core API, you’ll want to update your sandbox to use it’s own unique Core API code. This is called “localizing” the core and can be done by navigating to your staging sandbox and running  tank localize. This command will copy the Core API from the studio install, into your sandbox, making it possible to run and test a different version of the Core API later on.The default behavior in Toolkit is to localize the core by default. If you haven’t explicitly created a shared studio core previously, it’s safe to assume your core is localized already.cd /my/staging/sandbox./tank localizeWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.comStarting Toolkit for your current directory '/my/staging/sandbox'- Using configuration 'Staging Sandbox' and Core v0.14.52- Setting the Context to Empty Context.- Running command localize...----------------------------------------------------------------------Command: Localize----------------------------------------------------------------------This will copy the Core API in /mnt/software/shotgun/studio into the Pipelineconfiguration /my/staging/sandbox.Do you want to proceed [yn]yLocalizing Core: /mnt/software/shotgun/studio/install/core -&amp;gt; /my/staging/sandbox/install/coreCopying Core Configuration Files...Localizing Apps: /mnt/software/shotgun/studio/install/apps -&amp;gt; /my/staging/sandbox/install/appsLocalizing Engines: /mnt/software/shotgun/studio/install/engines -&amp;gt; /my/staging/sandbox/install/enginesLocalizing Frameworks: /mnt/software/shotgun/studio/install/frameworks -&amp;gt; /my/staging/sandbox/install/frameworksThe Core API was successfully localized.Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.Now we are no longer sharing the Core API with the studio location but are running our own, independent version. We can now go ahead and perform a standard Core API upgrade, again using our local tank command:cd /my/staging/sandbox./tank coreToolkit will check if there is a new version available and offer you to download and install it.Once you have updated the Core API, make sure to test the installation. Launch some apps, either using the tank command in the sandbox or using the special menu entries in ShotGrid. Do a basic run-through of your pipeline and perform the tests you deem necessary.Finally, once you are happy, it is time to go ahead and update the studio version of the Core API. Note that in the typical Toolkit setup, the Core API is shared between all projects, so by running the tank core command from your studio location  tank  command, you are updating the Core API for all projects.Managing the Project LifecycleEach Toolkit project contains an independent configuration which holds all the settings for that project. If you are managing a lot of projects, this means that you need to manage a lot of configurations. For this reason, Toolkit contains a number of different tools and ways to handle configurations, both for individual projects and for the studio lifecycle and configuration evolution. This section outlines some of those best practices and shows practical steps for how to set up your config.Depending on the needs of your studio, different levels of complexity may be relevant. Toolkit offers three different approaches and we’ll explain each one of them in detail:  The most straightforward approach is to copy the config from the previous project when you set up a new project. This is good if you are a small studio and don’t have a large number of projects.  If you have a higher project turnover and if you run more than one project in parallel, the next level of integration that we recommend involves git version control. Toolkit has native support for git and once you are up and running with a git-based workflow you have a single configuration for your studio and are tracking all the changes you are making to that configuration over time. Each project can safely pull in configuration changes as and when they need to.  If you are running a large-scale facility, it may be worth considering a setup where a single configuration is directly connected to all the currently-active projects in the studio. A single change to this configuration will have an immediate impact on all the projects.In the following sections we’ll describe the different approaches in detail.Inheriting the config from your previous projectThis is the simplest approach to configuration management. For the very first time you set up a project with Toolkit, you download our default configuration. You then set up that first project to match your pipeline settings, filesystem locations, etc. When the project is running, you run commands such as tank updates to update the app versions you are running.When your second project comes around, you don’t want to start with the default config again - instead, during the project setup phase, pick the config from your first project as the starter for your new project. This means that all the changes, tweaks and improvements you did for the first project will be taken advantage of in the second project as well. For the third project, use the second project’s config etc.This is a very simple way to gradually evolve the configuration over time. Changes and improvements will flow from project to project in an ad hoc fashion. The first time you run the setup_project command, just hit enter when the setup process prompts for the configuration to use. This will download and install the default configuration.For your second project, you will be presented with a list of paths to configurations for previous projects. Choose one of these paths and enter that when the setup process prompts for a config. This will copy that configuration to the new project:Welcome to the ShotGrid Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.com- Running command setup_project...----------------------------------------------------------------------Command: Setup project----------------------------------------------------------------------Welcome to the ShotGrid Pipeline Toolkit Project Setup!Connecting to ShotGrid...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   My very first project: '/mnt/software/shotgun/first_project/config'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe ShotGrid Pipeline Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can enter the pathto this config and it will be used for the new project.You can also enter an url pointing to a git repository. Toolkit will thenclone this repository and base the config on its content.[tk-config-default]: /mnt/software/shotgun/first_project/configA studio configuration in git source controlLimitations with the first approach include the fact that the projects are not connected to each other. If you have 10 projects and you all need to update them because a critical bug fix has been released, you would have to manually go through each project and run the  tank updates  command.One way to resolve this is to create a master configuration and store it in git source control. Whenever you create a new project, simply type in the path to this git repository in the setup project dialog and Toolkit will clone it for you. Now all the projects are connected to the same “studio master” config. If you have made some good changes to a project configuration, you can commit them and push them to the studio master. Other projects can then easily pull these down. You also retain a history of all your changes via git.What is Git?The basic idea is that you set up a git repository which holds the git configuration. Whenever you run tank setup_project, you specify the git url to this repository (for example  username@someserver.com:/studio_config.git) and the setup process will clone the repository so that the new project becomes a repository connected to the main studio repository. Once they are connected you can push and pull changes, and work in branches for finer granularity.Setting up your studio config repositoryBefore you do anything else, you need to create a studio config repository. This section shows how to take an existing toolkit configuration and creating a git repository from that.First, you need to go to your git server and create a repository. This process may be different depending on your setup. If you are using something like GitHub, you would start a web browser and navigate to github.com. If you have access to the server you may do something like  git init --bare. In our example, we assume that the git repository you create is called  username@someserver.com:/studio_config.git.Now move the  config  folder of the project you want to use to seed your repo with into a  config.bak  location:cd /project_configs/studio_configmv config config.bakClone your initialized git repository into the  config  location of your project that you want to base the studio config on. Once you have run the clone command, you will have an empty  config folder  which is also a git repository:cd /project_configs/studio_configgit clone username@someserver.com:/studio_config.git configCopy all the files from your config.bak location back into the config folder. Once done, you can delete the empty config.bak folder. Your config files are now inside the git repository and we need to add them, commit them and push them to the server. But before doing that, we need to do some house keeping to handle some Toolkit system files correctly. In the  config  folder, create a  .gitignore  file and add the following lines to it:install_location.ymlpipeline_configuration.ymlNow git will ignore those two system files. We can go ahead and add the rest of the files in the configuration, commit them and push them to the studio repository.git add --allgit commit -am &quot;initial commit of our studio config!&quot;git pushCreating a new project from gitWhen you create a new project, simply specify a valid git url when the setup process prompts you to enter the path to the configuration to use. Following our example above, we would enter username@someserver.com:/studio_config.git. As part of the project setup process, Toolkit will clone this repository into the config folder of your new project configuration. This means that you can later on go into this config folder and run git commands. Note that any cloned pipeline configurations will also clone the git repository and will work seamlessly.Making changes to a projectWhenever you have made changes to your primary config, you can simply go to your config folder and then run git diff, git commit and git push. This would push your changes to the studio configuration that you cloned your project config from.Updating a project to have the latest versionAlternatively, if you have updated your studio level config with some changes and you want to pull those down to your project, just go to your config folder and run a git pull.  Important: Note that once you have done this, make sure you run a tank cache_apps to ensure that all the app versions that your changed config requires are present in the system!Advanced git usage: BranchesThe default behavior in Toolkit is a simple clone operation when a new project is created. The project will be using the git master branch. For a more advanced setup, if you for example want to keep certain configuration changes for a project private and don’t share them with other projects, you can set up a git branch after the project has been created. You then commit to this branch. The changes you want to push to the studio configuration can be merged with the local master branch for the project and then pushed.Advanced git usage: Batch deploymentSince Toolkit keeps a list of all the different configurations for a ShotGrid site via its pipeline configuration entity, it is possible to iterate over this list and execute a git pull command for each of the items, effectively running a batch update on all projects. This functionality is not currently part of Toolkit out of the box, but can be scripted using Python and the ShotGrid Python API.A global configuration using includesThe git based approach above handles independent project configurations which are connected via git: Updates are not automatically reflected across projects but will have to be pulled and pushed.For a fully centralized configuration, where the configuration truly resides in one place and where a single change immediately reflects a group of projects, you will need to make use of the  @include  functionality in the Toolkit configuration. This makes it possible to create references so that each project configuration points at a central location where the actual configuration is being kept.The  @include  syntax allows you to chain together multiple files. For example, if you have a file  /tmp/stuff.yml, which contains the following content:# paths to mayamaya_windows: 'C: Program  Files Autodesk Maya2012 bin maya.exe'maya_mac: '/Applications/Autodesk/maya2012/Maya.app'maya_linux: 'maya'# a configured toolkit appfile_manager:  allow_task_creation: true  file_extensions: []  hook_copy_file: default  hook_filter_publishes: default  hook_filter_work_files: default  hook_scene_operation: default  launch_at_startup: false  launch_change_work_area_at_startup: false  location: {name: tk-multi-workfiles, type: app_store, version: v0.4.8}  saveas_default_name: scene  saveas_prefer_version_up: false  sg_entity_type_filters: {}  sg_entity_types: [Shot, Asset]  task_extra_display_fields: []  template_publish: null  template_publish_area: null  template_work: null  template_work_area: nullAs you can see above, you can create include definitions at several different levels - in the case above, we have an app definition and three strings values. These can then be referenced from an environment file:includes: ['/tmp/stuff.yml']engines:  tk-maya:    # First all our app definitions    apps:         # normally, we would have the entire set of configuration parameters at this point.        # because we are using an include, we can reference an entire sub-section of configuration        # using the @ keyword:         tk-multi-workfiles: '@file_manager'        # alternatively, for simple values, we can use them as parameter values for apps:         tk-maya-launcher:          mac_path: '@maya_mac'          linux_path: '@maya_linux'          windows_path: '@maya_windows'          location: {name: tk-multi-launchapp, type: app_store, version: v0.2.19}    # and after the apps section follows specific configuration options for the engine    location: {name: tk-maya, type: app_store, version: v0.4.1}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    template_project: null    use_sgtk_as_menu_name: falseFurthermore, you can read in several include files, one after the other. If the same include definition exists in two different files, the most recently read file will take precedence. We could extend our example environment above:includes:     # first include a global config file which contains all the studio level app definitions    - '/studio/configurations/studio_apps.yml'    # now we can include an include containing overrides, for example based on project type.    # if the global config contains an entry named file_manager and the vfx_apps.yml contains    # the same, the vfx_apps definition will be used.    - '/studio/configurations/vfx_apps.yml'engines:  tk-maya:        apps:         tk-multi-workfiles: '@file_manager'    location: {name: tk-maya, type: app_store, version: v0.4.1}    use_sgtk_as_menu_name: falseWith the approach just shown, it is possible to have a set of studio defaults which can be overridden by project type defaults which in turn can be overridden by specific project settings. You can either do it on the app level, as shown in the example above, or an engine level, as shown in the next section.Best practices when setting up a global configThere are several ways to set up a global configuration. Our recommended best practices approach for setting this up breaks the configuration down on a per engine basis. Each environment file is completely empty and references engines (and apps) defined in separate files. This makes it easy to tweak and reconfigure things - one engine at a time.Each of these include files are in a standard form, named after the engine. For example, if you have a Maya engine, an include file would contain just the engine and its apps. Its top level entry would simply be named  maya:maya:    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.13}      tk-multi-loader2:        action_mappings:          Maya Scene: [reference, import]          Photoshop Image: [texture_node]          Rendered Image: [texture_node]        actions_hook: '{self}/tk-maya_actions.py'        entities:        - caption: Assets          entity_type: Asset          filters:          - [project, is, '{context.project}']          hierarchy: [sg_asset_type, code]        filter_publishes_hook: '{self}/filter_publishes.py'        location: {name: tk-multi-loader2, type: app_store, version: v1.0.6}        menu_name: Load        publish_filters: []        title_name: Loader      [... additional app entries here ...]    debug_logging: true    location: {name: tk-maya, type: app_store, version: v0.3.10}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: ShotGrid Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    use_sgtk_as_menu_name: false# each include file has a framworks section containing all the frameworks needed for# all apps in the fileframeworks:  tk-framework-shotgunutils_v1.x.x:    location: {name: tk-framework-shotgunutils, type: app_store, version: v1.0.8}In your studio, you most likely don’t have a single maya setup, but may have a number of different ones for different departments and types of things. We recommend that you set up a maya include file for each of these ones, organized in a file hierarchy. Each of these files has a top level  maya  entry just like the file above.Now each project will contain a number of environments. Each of these environment files will be a list of engine includes, linking that specific environment to a collection of engine and app setups. You can set up one (or several) default project configurations for your studio, all containing includes like this, thereby ensuring that the actual app and engine payload is completely contained within the include files and therefore global. If you make a change to your global include files, all projects will be affected. With this setup, your environment files will then be on the following form:includes:         - '/studio/configurations/maya/asset.yml'    - '/studio/configurations/nuke/asset.yml'    - '/studio/configurations/houdini/generic.yml'engines:  tk-maya: '@maya'  tk-nuke: '@nuke'  tk-houdini: '@houdini'# we don't need any frameworks here because there are no apps or engines definedframeworks: nullIf you wanted to break out of the above setup and start defining some project specific entries, you would simply replace  @maya  with a series of app and engine definitions in the environment file itself.Managing a global configurationManaging a global configuration is more involved than managing a normal one. Because you have effectively combined a number of projects into a single file structure, running the  tank updates  command from any project and choosing to update an app version will affect all other projects, so proceed with some caution here.Furthermore, the standard clone workflow won’t work out of the box, since what you are cloning is the project configuration, which now only contains includes.For safe testing and maintenance, we recommend storing the global configuration in source control (e.g.  git) and do updates in a separate test area with a special test project. Once the quality control passes, commit the changes and pull them down into the actual global configuration.",
    "url": "/60762324/",
    "relUrl": "/60762324/"
  },
  "16": {
    "id": "16",
    "title": "Connecting Your Studio With Your AWS VPC",
    "content": "Connecting Your Studio With Your AWS VPCYou can connect your studio networks with AWS using one of many options, described in detail in this Amazon Virtual Private Cloud Connectivity Options whitepaper.Some of the common options our clients have used include:VPN ConnectionUsing a VPN appliance - AWS-managed or client-managed - your studio can establish a secure connection between your data center (or offices) to your AWS private VPC.AWS Direct ConnectAWS Direct Connect creates a dedicated link between your studio and your AWS VPC. This will help segregate your studio’s network traffic to your private AWS VPC from general internet traffic.",
    "url": "/de0ef1a3/",
    "relUrl": "/de0ef1a3/"
  },
  "17": {
    "id": "17",
    "title": "タスク/ステップがファイル名の一部としては存在しているのにコンテキストで見つからないのはなぜですか?",
    "content": "タスク/ステップがファイル名の一部としては存在しているのにコンテキストで見つからないのはなぜですか?Toolkit でフォルダを作成すると、エンティティに対するパスが登録され、検索が実行できるようになります。これは、パスを指定することによって正しいコンテキストを決定できることを意味します。Toolkit はスキーマから生成されたフォルダに対してのみレジストリを作成するので、templates.yml ファイルでのみ定義されているファイル名やフォルダを考慮しません。スキーマに Task フォルダがない場合、Toolkit がファイルのタスクを知る必要があっても、パスだけではタスクを解決できない状況になる可能性があります。例次の既定のスキーマ構造を取ります。Asset および Step フォルダはフォルダ作成プロセス中に登録されます。次のようなテンプレートを使用してファイル パスを生成した場合:assets/{sg_asset_type}/{Asset}/{Step}/work/maya/{task_name}_{name}.v{version}.{maya_extension}`生成されたパスからコンテキストを見つけようとすると、タスクの名前がファイル パスにあるにもかかわらず、確立できるのは Asset と Step のみで、Taskを確立することはできません。解決策ほとんどのワークフローでは、スキーマに Step フォルダがあり、Task フォルダがないことは問題ありません。通常は、Workfiles アプリを使用して、実行するタスクを選択してからファイルを選択し、シーン ファイルを開きます。UI で選択したタスクは、開いたファイルのパスからコンテキストを把握しようとするのではなく、コンテキストを駆動するために使用されます。ただし、次のような場合は、パスからコンテキストを取得できることが重要になります。  当社の自動コンテキスト切り替え機能を使用する場合。この機能を使用すると、Toolkit はユーザーが(Workfiles アプリを介さずに)ソフトウェアのネイティブの開くダイアログでファイルを開いたことを検出し、それに応じて現在のコンテキストを切り替えることができます。  特定のファイルのコンテキストを知る必要があるスタンドアロン プ​​ロセスで API を使用する場合。このような場合の解決策は、スキーマに Task フォルダを導入するか、自動コンテキスト切り替え機能を使用しないことです。API スクリプトの場合は、プロセスに必要なコンテキスト情報が既に存在し、この検索を実行する必要がないことを確認します。",
    "url": "/a10dadb2/",
    "relUrl": "/a10dadb2/"
  },
  "18": {
    "id": "18",
    "title": "貢献ガイド",
    "content": "貢献ガイド当社では、開発状況を可能な限り公開するための取り組みとして、開発者向けドキュメントを クリエイティブ コモンズ ライセンス の公開リポジトリに作成することを決定しました。このドキュメントをより良いものにするための提案がある場合は、ぜひリポジトリの改善についてのプル リクエストをお送りください。プル リクエストを受け入れるためには、以下のいずれかのコントリビューター契約書に署名していただく必要があります。  個人のコントリビューター契約書  会社のコントリビューター契約書上記のいずれかの契約書を提出していただくと、README の手順に従って変更を提出することができます。",
    "url": "/92b042bd/",
    "relUrl": "/92b042bd/"
  },
  "19": {
    "id": "19",
    "title": "複数のストレージ ルートを使用するように設定を変更するにはどうすればいいですか?",
    "content": "複数のストレージ ルートを使用するように設定を変更するにはどうすればいいですか?既定の設定では、単一のローカル ストレージのルートが使用されます(つまり、すべてのプロジェクト ファイルは /sgtk/projects のような単一のルート ポイントに保存されます)。プロジェクト ファイルの一部を保存する新しいストレージ ルートを追加することができます。これは、ディスク スペースが不足した場合やストレージ メディアを高速化する場合に一般的な方法です。「secondary」という名前の別のルートを追加する場合があるとします。必要な手順は次のとおりです。ShotGrid でローカル ストレージを追加する  ShotGrid で、[管理者]（Admin）&amp;gt; [サイト基本設定]（Site Preferences）ページに移動します  [ファイル管理]（File Management）セクションを開きます  [[+] ローカル ファイル ストレージを追加]（[+] Add Local File Storage）をクリックします  名前(「secondary」)と関連するすべてのプラットフォーム上のストレージ ルートへのパスを入力します。特定のプラットフォームを使用していない場合は、空白のままにすることができます。  ページの上部または下部にある[ページを保存]（Save Page）ボタンをクリックします新しいルートをパイプライン設定に追加するToolkit は、config/core/roots.yml ファイルのパイプライン設定で使用されるローカル ストレージに関する情報をキャッシュします。ShotGrid で作成したばかりの新しい secondary ストレージ ルートを追加するには、このファイルを次のように編集します。primary: {    linux_path: /mnt/hgfs/sgtk/projects,    mac_path: /sgtk/projects,    windows_path: 'z: sgtk projects'}secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'}                    注: tk-core v0.18.141 までは、roots.yml で定義されているルートの名前は SG で定義されているローカル ストレージの名前と一致する必要はありません。roots.yml 定義に shotgun_storage_id: &amp;lt;id&amp;gt; キー/値ペアを含めることで、接続を明示的に定義できます。例:secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'    shotgun_storage_id: 123}現在、ストレージ ID を照会するには、API 呼び出しを使用する必要があります。    新しいローカル ストレージ ルートを使用するようにスキーマを修正する新しいストレージ ルートを定義し、Toolkit にそのルートを指定しました。ディレクトリ構造内での使用方法を決める必要があります。ここで、アセットのすべての作業は secondary ストレージに、ショットのすべての作業は primary ストレージに保存されると仮定します。config/core/schema でスキーマを次のようにセットアップできます。config/core/schema/project.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;primary&quot;config/core/schema/secondary.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;secondary&quot;フィルタ内のルートを参照するすべての YAML ファイルも修正する必要があります。たとえば、セカンダリ フォルダの下のどこかに asset.yml がある場合は、セカンダリ フォルダの値と照らし合わせてプロジェクトを除外するようにフィルタを更新する必要があります。filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$secondary&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }使用するルートを指定するようにテンプレート パスを更新する最後に、使用するストレージ ルートを指定するように config/core/templates.yml ファイルで定義されたパスを更新1し、必要に応じて他のパスを更新します。テンプレート パスはスキーマと非常に密な関係にあるので、一致させる必要があります。スキーマで定義されたパスと正しく一致しない定義済みテンプレート パスを使用すると、エラーが発生します。たとえば、secondary ストレージのすべてのアセット作業を使用するため、テンプレート パス maya_asset_work を更新するには、次のように修正します。maya_asset_work:    definition: '@asset_root/work/maya/{name}.v{version}.ma'    root_name: 'secondary'config/core/templates.yml ファイル内の各テンプレート パスをこれと同じように修正します。各ストレージ(「primary」または「secondary」)で正しい root_name を指定します。                    注: 既定のストレージルートを使用するテンプレートには root_name を指定する必要はありません。既定のルートは、roots.yml ファイルで default: true を指定することによって示されます。roots.yml で既定値が明示的に定義されていない場合は、ルート primary が既定値と見なされます。    1 新しい値が設定されると、以前の値を使用して作成された古いファイルに Toolkit からアクセスできなくなるため、パスの更新が最適な方法ではない場合があります(テンプレート パスの変更後は Toolkit で古い作業ファイルは表示されません)。これが問題になる場合は、新しい場所を設定した新しいテンプレート(houdini_shot_publish_v2 など)を作成し、この新しいバージョンを使用するようにアプリをアップグレードすることができます。すべてのアプリがこのようなフォールバックの考え方に対応しているわけではありませんが、古いファイルを認識できるアプリもあります。アプリは ShotGrid 内のパブリッシュと常にリンクされているため、これはパブリッシュに影響しません。",
    "url": "/9ea9dd4e/",
    "relUrl": "/9ea9dd4e/"
  },
  "20": {
    "id": "20",
    "title": "API を使用してパブリッシュを作成するにはどうすればいいですか?",
    "content": "API を使用してパブリッシュを作成するにはどうすればいいですか?オートデスクの sgtk API には、ShotGrid で PublishedFiles エンティティを登録するための便利なメソッドが用意されています。また、独自の API が付属している Publish アプリもあります。Publish API は最終的にコア sgtk API メソッドを使用して PublishedFile を登録しますが、カスマイズ可能な、コレクション、検証、およびパブリッシュに関するフレームワークも用意されています。Publish API ドキュメントだけでなく、パイプライン チュートリアルにも、独自のパブリッシュ プラグインを記述する例が記載されています。register_publish() API メソッドを使用する未処理の ShotGrid API 呼び出しを使用して ShotGrid でパブリッシュ レコードを作成することは可能ですが、Toolkit の便利なメソッドを使用することをお勧めします。パブリッシュを作成する Toolkit アプリはすべて、sgtk.util.register_publish()と呼ばれる API ユーティリティ メソッドを使用しています。基本的に、このメソッドは ShotGrid で新しい PublishedFile エンティティを作成し、ツールキットの概念を使用してその作業を容易にするよう試行します。 以下の行に従ってコードを実行する必要があります。# Get access to the Toolkit APIimport sgtk# this is the file we want to publish.file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/foreground.v034.nk&quot;# alternatively, for file sequences, we can just use# a standard sequence token# file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/renders/v034/foreground.%04d.exr&quot;# The name for the publish should be the filename# without any version number or extensionname = &quot;foreground&quot;# initialize an API object. If you have used the Toolkit folder creation# to create the folders where the published file resides, you can use this path# to construct the API object. Alternatively you can create it from any ShotGrid# entity using the sgtk_from_entity() method.tk = sgtk.sgtk_from_path(file_to_publish)# use the file to extract the context. The context denotes the current work area in Toolkit# and will control which entity and task the publish will be linked up to. If you have used the Toolkit# folder creation to create the folders where the published file resides, you can use this path# to construct the context.ctx = tk.context_from_path(file_to_publish)# alternatively, if the file you are trying to publish is not in a location that is# recognized by toolkit, you could create a context directly from a ShotGrid entity instead:ctx = tk.context_from_entity(&quot;Shot&quot;, 123)ctx = tk.context_from_entity(&quot;Task&quot;, 123)# Finally, run the publish command.# the third parameter (file.nk) is typically the file name, without a version number.# this makes grouping inside of ShotGrid easy. The last parameter is the version number.sgtk.util.register_publish(  tk,  ctx,  file_to_publish,  name,  published_file_type=&quot;Nuke Script&quot;,  version_number=34)上記の基本的なコードに加えて、入力可能なオプションがいくつかあります。パラメータの完全なリストとその機能については、Core API のドキュメントを参照してください。                    ヒント: Toolkit アプリ内からコードを実行している場合は、self.sgtk を介して sgtk インスタンスを、self.context を使用してコンテキストを取得することができます。コードがアプリに含まれていないにもかかわらず、Toolkit 統合が組み込まれているソフトウェア内で実行される場合は、次のコードを使用して現在のコンテキストおよび sgtk インスタンスにアクセスすることができます。import sgtkcurrentEngine = sgtk.platform.current_engine()tk = currentEngine.sgtkctx = currentEngine.context    ",
    "url": "/ed4bcc20/",
    "relUrl": "/ed4bcc20/"
  },
  "21": {
    "id": "21",
    "title": "Linux で ShotGrid Desktop のデスクトップ/ランチャー アイコンをセットアップするにはどうすればいいですか?",
    "content": "Linux で ShotGrid Desktop のデスクトップ/ランチャー アイコンをセットアップするにはどうすればいいですか?現在の ShotGrid Desktop インストーラはショートカットと起動のエントリを自動的に作成しないため、インストール後に手動で作業する必要があります。手順は簡単ですが、使用する Linux の種類によって手順が異なる場合があります。ShotGrid Desktop インストーラを実行すると、ShotGrid Desktop の実行可能なファイルは /opt/Shotgun folder 内に格納されます。実行可能ファイルの名前は ShotGrid です。インストーラはアイコンを配置しません。ShotGrid Desktop エンジンの github リポジトリからダウンロードしてください。アイコンをダウンロードして、実行可能ファイルのパス(/opt/Shotgun/Shotgun)を指定したら、必要なデスクトップまたはメニューのランチャーを手動で作成してください。この操作のプロセスは Linux のバージョンによって異なりますが、通常、Desktop を右クリックして適切なメニュー オプションを選べば、デスクトップ ランチャーを作成できます。",
    "url": "/d82ab5ce/",
    "relUrl": "/d82ab5ce/"
  },
  "22": {
    "id": "22",
    "title": "開発",
    "content": "開発Toolkit を使用した開発に基づくクイック アンサーのコレクションです。  ソフトウェアを起動する前に環境変数を設定するにはどうすればいいですか?  as_template_fields() でコンテキスト内に存在する値が見つからない  Maya で Toolkit アプリを起動するシェルフ ボタンを追加するにはどうすればいいですか?  ShotGrid のイベント デーモンを使用してさまざまな Toolkit コア モジュールをロードするにはどうすればいいですか?  API を使用して Toolkit の設定をプログラムによって更新するにはどうすればいいですか?  API を使用してパブリッシュを作成するにはどうすればいいですか?",
    "url": "/16654f1f/",
    "relUrl": "/16654f1f/"
  },
  "23": {
    "id": "23",
    "title": "Development",
    "content": "DevelopmentWhat is Toolkit?Toolkit is the platform that underpins our pipeline integrations. For example, If you are using the ShotGrid Panel app in Maya or launching the Publish app from ShotGrid Create, you are using tools built upon the Toolkit platform.How can I develop with Toolkit?There are a number of different ways in which you can develop with Toolkit.  Writing custom code, in what we call hooks, to expand the existing app, engine, or framework behavior.  Writing your own apps, engines or frameworks.  Or writing your own standalone scripts that make use of the API.To do any of these things it’s important to understand how to work with the Toolkit API.ShotGrid as a whole has three main API’s  ShotGrid Python API  ShotGrid REST API  ShotGrid Toolkit APIThe Toolkit API is a Python API, designed to be used alongside the ShotGrid Python API or REST API, and is not a replacement for them.Although the Toolkit API does have some wrapper methods, in general whenever you need to access data from your ShotGrid site you will use the ShotGrid Python or REST APIs instead.The Toolkit API instead focuses on the integrations and management of file paths.Some Toolkit apps and frameworks also have their own APIs.These articles will guide you through how you can develop with Toolkit.",
    "url": "/a1cfe87c/",
    "relUrl": "/a1cfe87c/"
  },
  "24": {
    "id": "24",
    "title": "Direct Connect",
    "content": "Direct ConnectAWS Direct Connect is a service from AWS that allows you to establish a dedicated connection from your on-premise data center (or offices) to AWS. Direct Connect will allow you to create a dedicated link between your network and one of the AWS Direct Connect locations.Leveraging AWS Direct Connect ensure that you will benefit from the best experience possible when using the isolation feature set, optimizing reliability and performance for all your access points across the globe.",
    "url": "/0de47d40/",
    "relUrl": "/0de47d40/"
  },
  "25": {
    "id": "25",
    "title": "ShotGrid AWS Direct Connect Onboarding",
    "content": "ShotGrid AWS Direct Connect OnboardingIntroductionAWS Direct Connect (DX) is used to establish private connectivity between AWS and an on-prem facility. DX provides a private, high bandwidth network connection between your network and AWS Virtual Private Cloud (VPC) and bypasses the public internet. AWS has established 100 Direct Connect locations globally and leverages the AWS Partner Network to extend the footprint.Review of Shogun Configuration in AWSCustomer Types  Customer already has AWS Direct Connect dedicated connection  Customer has equipment and network presence in an AWS Direct Connect location  Customer does not have equipment or presence in an AWS Direct Connect locationSetup Options  Request a dedicated Direct Connect connection through AWS Console          Provision the required connectivity yourself      Work with Direct Connect Partner to help establish a dedicated connection to AWS equipment        Request a hosted Direct Connect connection through AWS Direct Connect PartnerCriteria to Determine Setup PathIf you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console (Option 1a):  Do you already have equipment and presence in an AWS Direct Connect location?  Do you know the process for requesting a cross-connect within the Direct Connect location facility?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console and select a Partner to assist (Option 1b):  Are you planning to use AWS Direct Connect to connect to other AWS resources outside of ShotGrid?  Do you have the time and resources to complete the setup?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then you should work with an AWS Direct Connect Partner to request a hosted Direct Connect connection (Option 2):  Are you already working with an AWS Direct Connect Partner?  Do you want a Partner to facilitate the setup?  Are you looking for a port less than 1Gbps or a hosted connection?Disclaimer:  All options are valid and the criteria are just a guide to help simplify the selection process. You can still pick any option based on more specific criteria.Setup DirectionsRequest through AWS Console - Option 1 (a and b)  Create a Connection in the AWS Console  Download the LOA-CFA. The LOA is the authorization to connect to AWS and is required to establish the cross-network connection.  (Option 1a only) Request cross-connects at AWS Direct Connect locations. Find contact information here.  (Option 1b only) Reach out to an AWS Partner and share the LOA with them.  Once the dedicated connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).Request through AWS Direct Connect Partner - Option 2  Reach out to an AWS Partner. The criteria for choosing an AWS Partner are:          AWS Region      Providers      If you are already working with an AWS Direct Connect Partner        If hosted connection, accept a hosted connection. More information can be found here.  Once the hosted connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).FAQHow long should it take to set up AWS Direct Connect?Short Answer - It depends. A lot of factors go into the time it takes to set up AWS Direct Connect. The timeline can vary from a few days to a few months. Some of the factors include current infrastructure, location of equipment, providers, partners, and more. If you are looking to expedite the process, consider using an AWS Direct Connect Partner who is geographically nearby.Further questions about AWS Direct Connect?AWS Direct Connect FAQsVPNA site-to-site VPN can be used as an alternative to AWS Direct Connect. Learn more about AWS VPN here.AWS Documentation &amp;amp; Resources  What is AWS Direct Connect?  Direct Connect User Guide  re:Invent 2018 - 400 level Deep Dive on Direct Connect  AWS Direct Connect Locations  AWS Direct Connect Partners",
    "url": "/8233001e/",
    "relUrl": "/8233001e/"
  },
  "26": {
    "id": "26",
    "title": "ShotGrid Desktop のブラウザ統合を無効にするにはどうすればいいですか?",
    "content": "ShotGrid Desktop のブラウザ統合を無効にするにはどうすればいいですか?ブラウザの統合を無効にするには、次の簡単な 2 つの手順を実行します。      次のテキスト ファイルを作成または開く     Windows: %APPDATA% ShotGrid preferences toolkit.ini Macosx: ~/Library/Preferences/ShotGrid/toolkit.ini Linux: ~/.ShotGrid/preferences/toolkit.ini            次のセクションを追加する     [BrowserIntegration] enabled=0      ブラウザ統合の設定方法に関する詳細については、『管理者ガイド』を参照してください。別の方法Toolkit のパイプライン設定を引き継いだ場合は、代わりに tk-ShotGrid エンジンを環境から削除し、アクションがロードされないようにすることができます。",
    "url": "/1bb3f6ad/",
    "relUrl": "/1bb3f6ad/"
  },
  "27": {
    "id": "27",
    "title": "ファイルシステムの設定",
    "content": "動的ファイルシステムの設定このガイドでは、Toolkit パイプライン構成を変更してプロダクションのフォルダ構造とファイル命名をカスタマイズする方法について学びます。このガイドについてパイプラインを管理する上で最も難しいことの 1 つは、作成される無数のファイルをトラックすることです。Toolkit のパイプラインはファイルシステム管理を自動化します。すなわち、ShotGrid のデータおよび設定されたフォルダ構造に基づいてフォルダを作成し、標準の命名規則に従って正しい場所に自動的にファイルを書き込みます。そのためアーティストはコンテンツ作成に集中できます。パイプライン設定には、既定のフォルダのセットとファイル命名規則がありますが、プロダクションではそれらをカスタマイズすることがよくあります。このガイドは、それらのカスタマイズに必要な知識を提供します。既定の設定では、アセットは asset_type/asset/pipeline_step のようなフォルダ構造で管理されます。このガイドでは、「Set」と呼ばれるカスタム エンティティを使用して、各アセットが使用されるプロダクション セット別にアセットを整理します。最初に ShotGrid でカスタム エンティティを設定し、それを使用して特定のセット用に作成されたアセットを管理します。その結果、フォルダ構造は set/asset_type/asset/pipeline_step のようになります。セットによってアセットを整理することの背景にある考え方を、例を挙げて説明してみましょう。たとえば、いくつかのシーンがガレージで発生し、別のシーンがダイニング ルームで発生するプロジェクトがあるとします。このセットアップでは、「wrench」、「oilcan」、「workbench」などのアセットのファイルは「garage」フォルダに整理され、「plate」、「winebottle」、または「tablecloth」は「dining_room」フォルダに整理されます。この例では、ダイニング ルームに肉汁たっぷりの「filet」アセットが適切に配置されていることを確認します。さらに、プロジェクトのファイル命名テンプレートも編集し、アセットの Maya ワーク ファイルにセットがそれぞれの名前で含まれるようにします。動的に生成されるファイル名により、ダイニング ルームのファイルを他のセットで使用されるファイルと区別できるようになります。このガイドの次の 3 つの手順  ShotGrid で、「Set」とよばれるカスタム エンティティを作成します。これは、アーティストが作成しているダイニング ルームの要素と関連付けるために使用します。  フォルダのスキーマを編集します。これによって、Toolkit はフォルダ構造内の現在のセットに基づいて動的に名前が付けられたフォルダを含めることができます。  アセット ワーク ファイルの命名に使用されるテンプレートを編集します。これによって、Toolkit はファイル名に関連付けられたセットの名前を含めることができます。前提条件このガイドを使用するには、以下が必要です。  アクティブな ShotGrid サイト。 少なくとも 1 つのアセットが作成されたプロジェクトが必要です。アセットにはモデル タスクが必要です。  ShotGrid サイトを使用してアセットを管理する方法の基本的な理解。  システムにインストールされたShotGrid Desktop。  指定したプロジェクトのクローン作成されたパイプライン設定。この設定がない場合は、「設定の基本操作」ガイドを参照し、その演習で作成した設定のクローンを作成します。  YAML の基本的な知識。  パイプライン設定を保存するファイルシステムに最適になるように設定された読み取りおよび書き込み権限。  Toolkit がプロダクション ファイル システムに対して読み取りおよび書き込みを行えるように適切に設定された読み取りおよび書き込み権限。  Maya の有効なサブスクリプション。Maya の 30 日間無償体験版を入手してください。                    注: このガイドは tk-config-default2 パイプライン設定をベースにしています。 設定が変更されている場合は、YAML 設定のファイル、フォルダ、およびブロックの場所がここに記載されている内容と異なる可能性があります。    ファイル スキーマとテンプレートについてToolkit パイプライン設定のスキーマとテンプレートを使用すると、ShotGrid データを利用してディスク上のプロダクション ファイルを管理できます。既定の設定のスキーマには、Shot、Sequence、Asset、Asset Type などのエンティティが含まれています。その他の Level、Episode、Season などのエンティティ、または今回使用する Set などのカスタム エンティティを追加できます。Toolkit プラットフォームではスキーマを使用してフォルダ構造を動的に構築できます。これは、実際のプロダクション ファイルシステムを構築するときのテンプレートとして使用されるプロダクション フォルダ構造のミニチュア バージョンです。スキーマはフォルダの動的作成のための明示的なガイドで、YAML ファイルを使用して動的に作成されるフォルダのルールを定義します。既定の設定には、アセットとショットの両方のパイプラインのフォルダ作成をサポートする事前設定されたスキーマが含まれています。作成している新しい Set エンティティのサポートを追加するために、アセット フォルダ構造の作成をサポートするスキーマの部分 /assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt; を変更します。テンプレートを使用すると、ShotGrid データとスキーマ構造の情報を使用して作成したファイルに動的に名前を付けて保存することができます。既定の設定には、パイプラインのニーズに合わせて編集できる一連のスタータ テンプレートが用意されています。                    注: Shotgun 統合の基本セットアップにはファイルシステム管理は含まれていません。プロジェクトのファイルシステム管理を設定するには、プロジェクトに高度な設定が必要です。最初のガイドの『設定の基本操作』で、高度なセットアップ プロセスについて説明しています。    実習を開始スキーマとテンプレートをカスタマイズすることで、ダイニング ルームのセットの作成時に生成されるファイルを動的に管理できます。それらのファイルとはすなわち、食器一式、蒸し上がったフィレ ミニヨン、Penfolds Grange Hermitage 1951 のワイン、ポテト グラタン、レモン ガーリック風味のアスパラガスなどです。ダイニング ルームのセットで使用されるアセットは「Dining Room」という Set エンティティに関連付けられ、より簡単に管理できるようになります。Set は 既定の設定に標準装備されたエンティティ タイプではないため、カスタム エンティティを有効にし、それに「Set」という名前を付けてからスキーマおよびテンプレートを拡張して使用する必要があります。カスタム エンティティを有効にする手順 1: ブラウザで ShotGrid サイトを開きます。アバターをクリックして、[管理者]（ADMIN）&amp;gt; [サイト基本設定]（Site Preferences）の順にクリックします。結果のページで[エンティティ]（Entities）セクションを展開します。ShotGrid で利用可能なエンティティのタイプのリストが表示されます。下図のリストの一番上には、現在の ShotGrid サイト用に構成されているいくつかのエンティティ タイプが示されています。これらのエンティティ タイプの下には、設定も有効化もされていないいくつかのカスタム エンティティがあります。カスタム エンティティ タイプをどれか選択して設定し、有効にします。手順 2: 矢印を選択してグレー表示の無効なカスタム エンティティの設定を開きます。[はい、カスタム エンティティを使用します…]（Yes, use Custom Entity…）の横のラジオ ボタンをオンにし、[表示名]（Display name）を Set に変更し、ウィンドウの上部にスクロールして[変更を保存]（Save Changes）を選択します。これによって、カスタム エンティティが ShotGrid でアクティブになり、表示名が Set になります。エンティティのシステム名は CustomEntity01 のままなので、基本的にここではカスタム エンティティの別名を作成していることになります。この例では、CustomEntity01 を使用していますが、別のカスタム エンティティを使用することもできます。                    注: 選択したカスタム エンティティのシステム名はメモしておきます。    アセットをセットに関連付けるデータ フィールドを追加します。アセット エンティティにデータ フィールドを追加すると、アセットを新しいエンティティにリンクできます。アーティストがダイニング ルーム用に作成したアセットは、Dining Room セット エンティティに関連付けられます。手順 3: ページ上部の[プロジェクト]（Projects）ドロップダウンを選択して、この実習に使用するプロジェクトを開きます。手順 4: プロジェクト メニュー バーで[アセット]（Assets）を選択し、[アセット]（Assets）ページに移動します。[アセット]（Assets）メニューで、[フィールド]（Fields）&amp;gt; [アセット フィールドの管理…]（Manage Asset Fields…）を選択します。このアクションはアセット フィールド管理者を表示します。[+ 新しいフィールドを追加]（+ Add a new field）を選択します。新しいフィールドのパラメータを選択します。[新しいフィールド名]（New Field Name）に「Set」と入力します。[一般]（GENERAL）メニューのフィールド タイプ（Field Type）で、エンティティ（Entity）を選択し、[タイプを制限]（Restrict the type）までスクロールダウンして、Set を選択します。[次へ]（Next）を選択します。このガイドでは、[現在のプロジェクトのみ]（Only the current project）に適用し、[フィールドを作成]（Create Field）を選択します。ShotGrid は新しいフィールドを設定します。変更が適用されたら、[完了]（Done）を選択します。[ダイニング ルーム]（Dining Room）の Set エンティティを作成する手順 5: アセットの新しい Set フィールドを選択して、「Dining Room」と入力します。すると、「一致するものが見つかりません。「Dining Room」を作成」というメッセージが表示されます。[「Dining Room」を作成]を選択します。[セットを作成]（Create Set）を選択します。アセットの Set フィールドに Dining Room と追加したことにより、Dining Room セット エンティティとの関連付けが生成されます。手順 6: filet アセットのモデル タスクを自分自身に割り当てて、テスト目的で簡単に見つけられるようにします。スキーマを設定するこれで、Set カスタム エンティティが有効になり、「Dining Room」と呼ばれる Set エンティティが作成され、Asset エンティティがダイニング ルームのセットにリンクされました。ShotGrid サイトにすべての要素が配置されたので、フォルダ構造の変更を開始できます。アーティストがタスクでの作業を開始すると、Toolkit は関連付けられた ShotGrid データを使用してファイルシステムに作成するフォルダを決定します。パイプライン設定のスキーマに基づいて、新しいフォルダが作成され、自動的に名前が付けられます。次に、アーティストがプロダクション パイプラインを実行する際に Toolkit が動的に生成するフォルダ構造を定義します。これは、スキーマを編集することで実行されます。                    注: アクティブなプロダクションの設定に影響を与えないように、クローン作成された設定でテストすることをお勧めします。クローン作成プロセスでは設定のコピーが作成され、安全な環境で編集してからライブ設定に変更をプッシュすることができます。設定のクローン作成の詳細については、『設定のステージングとロールアウト』ドキュメントを参照してください。    手順 7: パイプライン設定に移動します。スキーマ フォルダ &amp;lt;pipeline_configuration_root&amp;gt;/config/core/schema にドリル ダウンして、project フォルダを開きます。現在のスキーマは、次のようになります。&amp;lt;project&amp;gt;/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;このフォルダ構造の動的作成をサポートします。the_other_side/assets/prop/filet/model代わりに次のような構造にします。the_other_side/assets/Dining-Room/Prop/filet/modelこれを実現するには、スキーマを次のように設定します。&amp;lt;project&amp;gt;/assets/&amp;lt;CustomEntity01&amp;gt;/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;Set エンティティは CustomEntity01 として表されます。ShotGrid で CustomEntity01 に Set という表示名を付けましたが、この構成では常にそのシステム名 CustomEntity01 でこれを参照します。スキーマが YAML ファイルを使用する方法スキーマには静的フォルダと動的フォルダを含めることができます。スキーマに「assets」という名前の静的フォルダがある場合、それはプロダクション ファイルシステム内の「assets」という名前の単一のフォルダに対応します。一方、スキーマには「asset」という名前の動的フォルダがあり、これはプロジェクト内の各アセットに対する単一のフォルダを表します。すべての動的フォルダには、その隣に、フォルダと同じ名前の YAML ファイル(たとえば asset/ および asset.yml)があり、スキーマ フォルダに基づいてプロダクション フォルダを生成するためのルールが定義されています。Set エンティティの新しいフォルダと YAML ファイルを作成します。スキーマには、ShotGrid が追跡するさまざまなエンティティに関連するフォルダを含む project フォルダがあります。ShotGrid が Set 内のアイテムをトラックできるようにするために、新しいアセット エンティティ CustomEntity01 を追加します。これらのアイテムはアセットなので、アセットの下のフォルダと YAML ファイルを編集します。繰り返しますが、目標は asset_type/asset/step フォルダ構造から set/asset_type/asset/step に移動することです。そこで、スキーマ内のセットを表すフォルダを、対応する YAML ファイルと共に追加します。カスタム エンティティにはシステム名を使用する必要があるので、CustomEntity01/ フォルダと CustomEntity01.yml を作成します。手順 8: スキーマの project/assets フォルダ内に CustomEntity01 フォルダを追加します。手順 9: 以下の内容で、CustomEntity01 フォルダの隣に CustomEntity01.yml という名前のファイルを作成します。type: &quot;shotgun_entity&quot;name: &quot;code&quot;entity_type: &quot;CustomEntity01&quot;filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }YAML ファイルは、CustomEntity01 フォルダに付ける名前を Toolkit に指示します。この場合は、タイプ ShotGrid_entity のフォルダを作成しています。これは、ShotGrid クエリに対応していることを意味します。entity_type フィールドは ShotGrid の CustomEntity01 エンティティをクエリするように指示し、name フィールドはエンティティのどのフィールドをクエリするのかを指示します。この場合は CustomEntity01 から code フィールドを取得します。filters フィールドは、この動的フォルダを作成する必要があるケースを制限します。手順 10: asset_type/ と asset_type.yml を CustomEntity01 フォルダに移動します。フォルダ構造を Dining-Room/Prop/filet のようにしたいので、asset_type フォルダは階層内の CustomEntity01 フォルダよりも*下に *にする必要があります。asset_type/ と asset_type.yml を CustomEntity01 フォルダに移動します。asset.yml ファイルを編集します。filters フィールドは、特定の時点でどのエンティティにフォルダを作成するかを制限します。現在の状態では、asset.yml のフィルタ フィールドは次のようになります。filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }アセットのフォルダを作成するときは、正しいプロジェクト フォルダと正しいasset_type フォルダが選択されていることを確認する必要があります。セットのフォルダを追加したので、3 番目のフィルタを追加します。追加しないと、次のようなフォルダとなり、これはもちろん正しくありません。assets/Dining-Room/Prop/spoonassets/Garage/Prop/spoonassets/Classroom/Prop/spoonこれを防ぐために、3 番目のフィルタを追加します。これにより、アセットのフォルダは正しいセットのフォルダにのみ作成されるようになります。手順 11: asset.yml の filters フィールドを次のように変更します。filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }    - { &quot;path&quot;: &quot;sg_set&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$CustomEntity04&quot; ] }フォルダ作成のテストこれで、アセットを Set カスタム エンティティで整理するためにスキーマが正しく修正されました。それでは、テストしてみましょう。フォルダは、Toolkit パイプライン ワークフローのいくつかの時点で作成されます。  アプリケーション ランチャー： ユーザがタスクの DCC を起動するたびに、Toolkit はそのタスクのディレクトリを作成します(まだ作成されていない場合)。Toolkit ではまず最初に DCC の起動を行う傾向があるので、通常はこの方法でディレクトリが作成されます。これは、ShotGrid の右クリック メニュー、または ShotGrid Desktop あるいは Create アプリで実行できます。  ShotGrid メニュー: タスク用のフォルダを作成する最も直接的な方法は、ShotGrid で右クリックして[フォルダを作成]（Create Folders）メニュー項目を選択することです。  Toolkit API: Toolkit API を介して直接ディレクトリ作成ロジックを起動できます。この方法によって、Toolkit をカスタム ランチャーにプラグインしたり、ShotGrid で作成される Shot のディレクトリを自動的に作成するためのワークフローのイベント トリガとして使用することができます。  tank コマンド: ShotGrid のメニュー項目と同様、tank folders 端末コマンドからもタスク用のフォルダを作成できます。tank コマンドでテストします。手順 12: filet アセットで tank folders を実行します。端末から以下を実行します。&amp;gt; cd &amp;lt;pipeline_configuration_root_folder&amp;gt;&amp;gt;  ./tank Asset Filet folders出力の要約:----------------------------------------------------------------------Command: Folders----------------------------------------------------------------------Creating folders, stand by...The following items were processed: - /Users/michelle/Documents/Shotgun/projects/the_other_side. . . - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/ - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/publish. . .In total, 23 folders were processed.最終的な構造が期待した構造と一致し、Toolkit が非常にスマートになり、「Dining」と「Room」の間にダッシュが追加されています。/the_other_side/assets/Dining-Room/Prop/Filet/modelファイルを読み書きするための Toolkit テンプレートフォルダ構造を設定したので、次のステップでテンプレートを編集します。プロダクション ファイルに適切な名前を付け、作成後に正しいフォルダに配置します。Toolkit アプリがテンプレートを使用する方法まず、ShotGrid でアセットをセットに関連付ける方法を作成しました。すなわち CustomEntity01 がセットを表すようにして、Asset エンティティにアセットとセットの間のリンクを表すリンク フィールドを追加しました。アセットとセット間の関係を確立したら、その関連付けを使用するようにフォルダ スキーマを設定し、すべてのアセットのフォルダをその関連付けられたセットのフォルダ内に配置します。次に、ファイルに動的に名前を付ける方法を作成し、Toolkitアプリ でファイルを自動的に管理できるようにします。アーティストがプロジェクト内のタスクを実行し始めると、必要なフォルダ構造が生成されます。その後、Workfiles アプリの[File Save]アクションを開始すると、ファイルに自動的に名前が付けられます。Toolkit の Workfiles アプリを通じてアクセスされるテンプレートは、そのファイルに名前を付けるために使用されます。Nuke Write ノードや Houdini Mantra ノードなどのレンダリング アプリは、パブリッシュ ファイル用のパブリッシャー アプリと同様に、テンプレートを使用してレンダリングされたファイルに名前を付けて保存します。Workfiles の[File Open]アクションを使用してファイルにアクセスすると、テンプレートを使用してロードする適切なファイルが検索されます。Publisher、Loader、および Nuke Studio Export の各アプリも、テンプレートを使用してファイルを検索および管理します。アーティストはファイル名や場所を気にする必要はありません。Toolkit がテンプレートおよび実行されているタスクに基づいてそれらをすべて管理します。テンプレートは設定ファイル /&amp;lt;pipeline_configuration_root&amp;gt;/config/core/templates.yml によって管理されます。最後の 2 つのガイドでは、作業環境に固有の設定を管理および作成しました。スキーマとテンプレートの設定は config/core フォルダに格納されており、環境に固有のものではありません。すべてのテンプレートは単一のファイルに格納されますが、それらはさまざまな環境設定ファイルのアプリ設定で、このファイルから参照されます。たとえば、template_work は、ワークファイルに使用する templates.yml のテンプレートを指定する Workfiles アプリの設定です。ワークファイルが構成されている環境およびエンジンに応じて、この設定を使用して maya_shot_work テンプレートまたは templates.yml の houdini_asset_work テンプレートを参照することができます。手順 13: パイプライン設定で config/core/templates.yml を開きます。このファイルは 3 つのセクションに分かれています。  キー: トークンのセット({version}、{Asset} など)。テンプレートを構築するために使用されます。テンプレートが使用されると、実際の値に置き換えられます。各キーには、必須の名前とタイプ、およびオプションのパラメータがあります。  パス: キーを使用してディスク上のフォルダおよびファイルへのパスを表す名前付き文字列。paths セクションのテンプレートは検証済みで、実際にディスク上に存在する必要があります。  文字列: パス セクションと似ていますが、これらは任意のテキストのテンプレートです。パス セクションの項目は検証済みで、ディスク上の実際のパスと対応している必要がありますが、Toolkit ワークフローで参照するテキスト データを格納するために文字列を使用できます。Set エンティティのテンプレート キーを追加する最初に行うことは、エンティティのシステム名を使用して、Set エンティティの新しいキーを定義することです。手順 14: 適切なインデントを使用し、templates.yml の keys セクションに次の行を追加します。       CustomEntity01:           type: strテンプレートを修正するToolkit がファイルを読み書きする場所はテンプレートが定義するので、ここで定義するパスがスキーマで定義されているフォルダ構造と一致することが重要です。最終的に、プロダクション ファイルは現在作成しているファイルシステムに配置されます。そこで、スキーマに定義した新しいフォルダ構造に合わせて、アセット関連のテンプレートをすべて変更します。次に、Maya のアセット ステップで作業ファイルのテンプレートを変更し、ファイル名にそのセットも含めるようにします。既定の設定では、該当のテンプレートは maya_asset_work で、ここから開始します。                    注: Maya でアセットベースのワークファイルに maya_asset_work というテンプレートを使用するのは、既定の設定の規約です。これが正しいテンプレートであることを確認するには、asset_step 環境で、tk-maya エンジンの tk-multi-workfiles2 の template_work 設定の値を確認します(Github にあります)[(https://github.com/shotgunsoftware/tk-config-default2/blob/v1.2.4/env/includes/settings/tk-multi-workfiles2.yml#L217)]。    手順 15: templates.yml を開いて、maya_asset_work を検索します。   maya_asset_work:        definition: '@asset_root/work/maya/{name}.v{version}.{maya_extension}'maya_asset_work の definition 値は @asset_root で始まります。@ 記号は、@asset_root の値が他の場所で定義されていることを意味します。                    注: 先頭の @ 記号は、templates.yml に含めることを意味しません。これは、環境設定ファイルで実行されます。    統合ごと、アプリごと、環境ごとに異なる設定を使用できるので、templates.yml 内のさまざまな場所でパスの最初の部分が使用される可能性があります。構成は、単一の変数を使用して共通のパス ルートを格納し、テンプレート内でその変数を参照できるように設定されます。共通ルートを参照できる場合は、パス生成設定の各インスタンスを変更する必要はありません。既定の設定には、@shot_root、@sequence_root、および @asset_root の 3 つの共通ルート変数があります。@asset_root を変更します。この変更はすべてのアセット関連のテンプレートに影響します。ファイルシステム スキーマのパスと一致するようにテンプレートを編集します。手順 16: templates.yml の paths セクションの上部にある asset_root を検索します。既定の設定では、次のようになります。asset_root: assets/{sg_asset_type}/{Asset}/{Step}スキーマの変更に一致するように asset_root パスに CustomEntity01 を追加します。asset_root: assets/{CustomEntity01}/{sg_asset_type}/{Asset}/{Step}ファイル名にセットを追加するスキーマの変更を反映するようにファイルのフォルダ構造を変更したため、ファイルの読み込み/書き出しは適切な場所で行われます。では、Maya のアセット ワークファイル テンプレートのファイル名を変更して、そのセットも含めるようにします。maya_asset_work テンプレート定義をもう一度見つけます。現在の状態では、ファイル名は以下です。{name}.v{version}.{maya_extension}{name} テンプレート キーは、Workfiles アプリの[File Save]アクションでのユーザ入力を表す特別なキーです。ユーザの入力は含まれず、現在のセットとアセットだけで構成されるようにテンプレートを変更します。手順 17: maya_asset_workテンプレート定義を次のように変更します。    maya_asset_work:        definition: '@asset_root/work/maya/{CustomEntity01}_{Asset}.v{version}.{maya_extension}'このアクションにより、ファイル名に Dining-Room エンティティの適切な名前を使用できます。結果は次のようになります。Dining-Room_Filet.v1.mbtemplates.yml が変更され、プロダクション フォルダ構造に新しいセット フォルダが反映され、Maya のアセット タスクのワークファイルにセットの名前が含まれるようになりました。変更をテストしましょう。テストの実行手順 18: ShotGrid Desktop から Maya を起動します。Maya で、[ShotGrid] &amp;gt; [File Open]（ファイルを開く）に移動し、表示されるダイアログで、ShotGrid で Set を指定したアセットのタスクを選択します。[+ 新しいファイル]（+New File）を選択します。単純な 3D オブジェクトを作成するか、[ShotGrid] &amp;gt; [Save File]（ファイルを保存）を使用してファイルを保存することができます。成功しました!テンプレートの新しい設定を使用して、[File Save]ダイアログボックスに**プレビュー：Dining-Room_scene.v001.ma **が表示されていることに注意してください。Work Area: Workfiles がファイルを保存するパスとして …/ShotGrid/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/work/maya を表示します。高度なトピック例を拡張するこの例では 1 つのテンプレートを変更しましたが、ファイルシステムの設定については他にもさまざまな操作を実行できます。現実の例では、すべてのアセット関連のファイルを同じファイル命名規則に従うように変更します。他のエンティティ(Season、Episode、Level など)に基づいて変更を加えたり、ユーザ フォルダを作成したり、正規表現で操作した ShotGrid のデータに基づいてフォルダに名前を付けたりすることができます。Toolkit のすべてのフォルダおよびスキーマ オプションについては、『ファイル システム設定リファレンス』を参照してください。パス キャッシュフォルダ作成時に、ディスク上のフォルダと ShotGrid エンティティの間にマッピングが作成されます。これらのマッピングは ShotGrid の FilesystemLocation エンティティとして保存され、ユーザのマシンの SQLite データベースにキャッシュされます。パス キャッシュの仕組みと、その使用方法の詳細については、このドキュメントを参照してください。その他のリソース  『ファイル システム設定リファレンス』  Toolkit 設定紹介のウェビナー ビデオ",
    "url": "/56b441c6/",
    "relUrl": "/56b441c6/"
  },
  "28": {
    "id": "28",
    "title": "設定を編集する",
    "content": "パイプライン設定を編集するこのガイドを読み終えると、以下に関する基本的な知識を習得できます。  特定の Toolkit アプリの構成設定を見つける  設定を編集する  構成設定によって拡張できるその他の機能を調べるこのガイドについてこのガイドでは、プロジェクト パイプラインの要求に応じて、既存のパイプライン設定内の設定を編集する方法について説明します。最初のガイドの『設定の基本操作』では、パイプライン設定を編集するための準備方法について説明しました。プロジェクトに対して編集可能な設定を作成する方法を理解していない場合は、「設定の基本操作」を参照してから、先へ進んでください。ShotGrid Toolkit では、既定の設定を拡張することにより、パイプラインのワークフロー内のタスクをカスタマイズできます。カスタマイズの例としては、ユーザが Toolkit の機能を操作する方法を変更するために、いくつかのソフトウェア パッケージに含まれている Toolkit アプリのボタンを有効または無効に切り替えるだけという簡単なものがあります。Toolkit には独自の設定を行う機能があるため、カスタム ワークフローの作成、反復タスクや日常的なタスクの自動化、フックの変更、および Toolkit プラットフォーム上に構築されたカスタム ツールの追加といった作業を、スマートに、かつ短時間で行うことができます。ただし、Toolkit にアクセスするには ShotGrid ソフトウェアの統合が必要であり、衣服を洗うなどの日常的なタスク向けのリリースはまだ実現していません。このガイドの演習では、ShotGrid ソフトウェア統合内のアクションをコントロールする構成設定の見つけ方、設定の配置場所、および設定の編集方法について説明します。具体的には、[+New Task]ボタンの動作を管理する Workfiles アプリの設定を編集することにより、アーティストが Maya 内のプロジェクトで作業しているときに新しいタスクを作成できないようにします。このドキュメントの使い方このガイドを使用してパイプライン設定を編集するには、以下が必要です。  アクティブな ShotGrid サイト。  1 つ以上のアセットを含むプロジェクト。最初のガイドで作成した the_other_side プロジェクトにアセットを追加できます。プロジェクトのアセットを作成する方法については、「設定の基本操作」ガイドを確認してください。  指定したプロジェクトのパイプライン設定。この設定がない場合は、「設定の基本操作」ガイドを参照し、その演習で作成した設定を使用します。  パイプライン設定を保存するファイルシステムに最適になるように設定された読み取りおよび書き込み権限。  システムにインストールされた ShotGrid Desktop。  Maya の有効なサブスクリプション。Maya の 30 日間無償体験版はこちらから取得してください。                    注: このガイドは tk-config-default2 パイプライン設定をベースにしています。 設定が変更されている場合は、YAML 設定のファイル、フォルダ、およびブロックの場所がここに記載されている内容と異なる可能性があります。    Workfiles アプリについてWorkfiles アプリは、ShotGrid ソフトウェア統合のファイル管理を行い、作業ファイルの参照、オープン、および保存機能へのアクセスをコントロールします。[+New Task]ボタンをクリックすると Workfiles アプリのアクションが実行され、ShotGrid に移動しなくてもタスクを追加することができます。設定は環境単位のファイルに分割されています。これにより、ユーザはパイプライン内のステージごとに機能を管理して、ユーザがファイルを作成、命名、保存する、タスクを実行する、または特定の機能を実行するタイミングをコントロールすることができます。これは Workfiles アプリのすべての機能に関係し、任意のアプリまたはエンジンの設定を変更する場合にも適用されます。詳細については、このドキュメントの末尾にある「高度なトピック」を参照してください。設定ファイルの概要作業しているプロジェクトのパイプライン設定が保存されている場所を見つけるには、ShotGrid のパイプライン設定リストを使用します。保存場所がわかっている場合は、手順 5 に進みます。パイプライン設定を見つける手順 1: この演習で使用するプロジェクトを管理している ShotGrid サイトを開きます。手順 2: ShotGrid サイトの [プロジェクト]（Projects）ページでプロジェクトを選択して、ShotGrid サイトのプロジェクトにアクセスします。手順 3: 右上にあるアバターを選択して、[管理者]（ADMIN）メニューを表示し、下にスクロールして[既定のレイアウト]（Default Layouts）&amp;gt; [パイプラインの設定]（Pipeline Configuration）&amp;gt; [パイプライン設定リスト]（Pipeline Configuration List）を選択します。手順 4: [パイプライン設定リスト]（Pipeline Configuration List）が表示されたら、列見出しの右端にある[+]記号を選択して、列をもう 1 つ追加します。ドロップダウン リストで、オペレーティング システムに該当するパスを選択します。新しいフィールドにパスが表示されます。手順 5: 端末またはファイル マネージャで、プロジェクトのパイプライン設定が保存されているフォルダを参照して、開きます。Toolkit 設定のルート フォルダには、cache、config、および install の 3 つのサブフォルダがあります。config フォルダおよびその中のネストされたフォルダを開くと、サブフォルダとファイルがいくつか表示されます。env フォルダには、アーティストの作業環境をサポートする統合の設定が保存されています。これらの環境を利用することにより、パイプラインのステージごとに設定をカスタマイズすることができます。既定の設定には事前に定義された環境セットが用意されていますが、使用しているパイプラインで詳細な環境セットが必要な場合は、これらを変更できます。手順 6: env フォルダを開きます。Toolkit は YAML ファイルを使用して機能を設定します。YAML が設定の言語として選択された理由は、Toolkit 内のファイルを、読み取りやすく、軽量で、カスタマイズが容易になる方法でフォーマットすることが可能だからです。YAML の詳細については、こちら を参照してください。設定は、識別子、エンジン、アプリ、およびフレームワークを提供する、ネストされた YAML ファイルで構成されています。これは、影響を与えるアクションを制御するための特定のコード バンドルに導くための、ある種のロードマップです。設定ファイルを編集するShotGrid Toolkit を使用すると、さまざまなソフトウェア パッケージ内に統合されたアプリを変更できます。Workfiles アプリの機能の例としては、[+New Task] ボタンがあります。ユーザはこのボタンをクリックして、[File Open]ダイアログ ボックスに新しいタスクを追加できます。既定では、この機能はプロジェクトのすべてのフェーズで、すべてのユーザに対して有効になっています。ただし、スタジオでこの機能を制限したい場合があります。たとえば、特定の命名規則がある場合や、タスクの作成をプロジェクトのプロダクション管理チームに限定する場合などです。この場合は、アーティストが Maya で作業するパイプライン内のすべてのポイントで、[+New Task]ボタンを無効にします。Maya のプロジェクトに対して[+New Task]ボタンを無効にする手順 7: ShotGrid Desktop を開きます。手順 8: 設定を編集するプロジェクトを選択します。手順 9: ShotGrid Desktop から Maya を起動します。ShotGrid メニューが完全にロードされるまで待ちます。インターネット接続速度が遅い場合は、この間に設定を行いましょう。つまり、適度な量のクリームを入れて一杯の完璧なエスプレッソを作るようなものです。Maya および ShotGrid が完全にロードされると、[File Open]ダイアログ ボックスが自動的に開きます。ShotGrid Desktop から Maya を起動すると、Maya は project 環境になり、Toolkit ワークフローの設定はファイル config/env/project.yml によって制御されます。既定の設定で識別される環境は、project、sequence、shot、shot_step、asset、asset_step です。手順 10: [File Open]ダイアログ ボックスの左側のペインで[Assets]タブを選択します。検索結果に表示されたフォルダ内のいずれかのアセットを選択します。[+New Task]ボタンが有効になります。[+New Task]ボタンをコントロールする設定を特定するToolkit のパイプライン設定は、パイプラインに対するユーザのニーズに合わせて環境をカスタマイズする場合に使用します。パイプライン設定では、プロジェクトのパイプラインに対するニーズに合わせて、既定の ShotGrid の統合の設定を必要なだけオーバーライドできます。この構造により、設定は軽量化され、ShotGrid の主要コード内の既定値と異なる設定のみを追加することができます。この演習では、Workfiles アプリの[+New Task]ボタンをオフにしますが、その前にこのボタンをコントロールする構成設定を特定する必要があります。手順 11: [Project (プロジェクト名)]の横にある[File Open]ウィンドウの上部にある [&amp;gt;] を選択します。この参照ボックスには、[File Open]ウィンドウの機能をコントロールする構成設定の詳細が表示されます。Toolkit の一部のアプリには、アプリに使用される設定と、既定の設定を表示する参照ボックスがあります。[Location:]に注目してください。識別子は tk-multi-workfiles2 です。これは、Workfiles アプリを作成するコードのバンドルの識別子です。パイプライン設定を検索する場合、この名前でアプリの設定の配置場所を識別します。ShotGrid の統合で使用可能な機能に関するすべての構成設定、アプリ、エンジンがリストされた「アプリとエンジンの概要」ページがあります。[Configuration:]見出しの下で、この特定の環境の設定を探します。                    注: my_tasks_filters の設定の後に、launch_at_startup の設定があります。この設定に注意することは重要です。この設定がプロジェクト環境内の[File Open]設定の既定の設定になります。この設定は、Shotgun Desktop から Maya を起動したときに、[File Open]ダイアログが自動的に開くことを示します。    [Setting allow_task_creation]まで下にスクロールします。この設定の既定値は[True]です。この値の場合、ユーザは Maya プロジェクト環境内から新しいタスクを作成できます。設定を検索する際に、考慮すべき点がいくつかあります。  実行しているソフトウェア アプリケーション。  作業を行っているファイル、および作業している環境。これはアプリの参照ボックスに表示されています。  特定の設定の名前。これはアプリの参照ボックス、または「アプリとエンジンの概要」ページに表示されています。  拡張する YAML ファイル。設定の配置場所を示す識別子およびロードマップの詳細は、YAML ファイルに記述されています。  YAML ファイル内の拡張する特定のブロック。これはロードマップで識別されています。  YAML ファイル内で使用されている識別子および記号、  および現在のプロジェクトの設定の保存場所(これが最も重要)。設定は、パイプライン設定内の複数の場所で利用できます。配置場所を判別するには、設定を反映させるソフトウェア統合、および変更を反映させるパイプライン プロセス内の場所を考慮します。allow_task_creation の値の設定場所を特定する手順 12: メインの Maya ウィンドウを前面に表示します。手順 13: Maya ウィンドウの右上にある[ShotGrid] メニュー項目を特定します。ヒント: メニューが表示されない場合は、一部のメニュー項目が非表示になっていることを示す[»]が表示されています。[»]を選択して ShotGrid メニューを表示するか、Maya ウィンドウの幅を広げます。手順 14: メニューの右上にある[ShotGrid] &amp;gt; プロジェクト the_other_side &amp;gt; [Work Area Info…]を選択します。[Work Area Info]ダイアログ ボックスには、現在の作業領域の内容と詳細が表示されます。この情報には、ユーザが作業している環境、および設定が配置されてい環境設定ファイルのパスが含まれています。手順 15: [Your Current Work Area]ダイアログ ボックスの下部にある[Environment]タブを選択します。最初の項目は、使用されているエンジンを識別します。このエンジンは、特定のソフトウェア アプリケーションに ShotGrid ツールを統合する機能を制御します。このエンジンには、各ソフトウェア統合に固有のロジックが保持されています。ウィンドウに表示される 2 番目の項目は、現在のプロジェクト環境の配置場所のパスを示します。最後の 2 つのフォルダは config/env/ と、その後の project.yml です。project.yml ファイルは、現在の環境の設定の保存場所を案内するロードマップの起点となります。手順 16: お気に入りのテキスト エディタで project.yml を開きます。description: Apps and Engines when launching with a project only context.################################################################################includes:- ./includes/frameworks.yml- ./includes/settings/tk-3dsmaxplus.yml- ./includes/settings/tk-desktop.yml- ./includes/settings/tk-flame.yml- ./includes/settings/tk-houdini.yml- ./includes/settings/tk-mari.yml- ./includes/settings/tk-maya.yml- ./includes/settings/tk-motionbuilder.yml- ./includes/settings/tk-nuke.yml- ./includes/settings/tk-photoshopcc.yml- ./includes/settings/tk-shell.yml- ./includes/settings/tk-shotgun.yml################################################################################# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;################################################################################# reference all of the common frameworksframeworks: &quot;@frameworks&quot;project.yml 内の説明の下に、includes、engines、および frameworks という 3 つのセクションがあります。includes セクションには、設定内の他の YAML ファイルを参照するファイル ポインタのリストが示されています。既定の設定のアーキテクチャでは、ファイルを常に軽量化するために、ファイルをネストし、ポインタを使用するという方法も採用しています。includes に沿ってファイルを順に移動していくと、探している構成設定にたどり着きます。これはロシアのマトリョーシカ人形と似ています。人形を開くと、その中に次の人形が入っています。このようにして、最終的に適切な構成設定が見つかります。すべてのエンジンが tk-&amp;lt;name of software application&amp;gt; として識別されています。Maya の設定に反映させたいため、求めている識別子は tk-maya になります。project.yml ファイルの includes: セクションの下で、./includes/settings/tk-maya.yml の行を探します。この行は、Maya エンジンの設定をコントロールする設定 tk-maya が、includes フォルダ内の settings フォルダ内でネストされていることを示します。engines: セクションで tk-maya 値を探します。tk-maya: &quot;@settings.tk-maya.project&quot;@ は、値が、インクルードされたファイルから取得されていることを示します。settings および project の参照は、プロジェクトの設定であることを示します。これらは既定の設定内の命名規則であり、ユーザを案内するガイドとして役立ちます。この行全体は、インクルードされたファイル内の settings.tk-maya.project ブロックを探して、Maya エンジン tk-maya の構成設定を探すようユーザに指示しています。ShotGrid Toolkit は YAML ファイル内で単純な用語を使用して、設定の名前や、設定に到達するためのパスを示します。Maya の[File Open]参照ボックスを調べて気づいたように、[+New Task]ボタンの実行方法をコントロールするコード バンドルは tk-multi-workfiles2 で識別されます。Toolkit のバンドルは、YAML ファイル内でこれらの識別子を使用して参照されています。「tk-multi-workfiles2」は、Workfiles アプリのコード バンドルの識別子です。[+New Task]ボタンは、Workfiles アプリの機能です。tk-maya.yml での Workfiles アプリの検索手順 17: ファイル ブラウザ内で、env/includes/settings フォルダを参照して、tk-maya.yml を開きます。手順 18: project.yml からのインクルードの内容に沿って、tk-maya.yml ファイル内で settings.tk-maya.project を検索します。特に行いたいのは、特定のプロジェクトのプロジェクト環境内で[+New Task]ボタンを無効にすることです。プロジェクト環境内で作業しながら、このプロジェクトの設定を操作し、場所の情報を取得しました。# projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;  menu_favourites:  - {app_instance: tk-multi-workfiles2, name: File Open...}  location: &quot;@engines.tk-maya.location&quot;settings.tk-maya.projects の下に、tk-multi-workfiles2 アプリの設定が次のように表示されています。tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;@ 記号は、tk-multi-workfiles2 の値がインクルードされたファイルから取得されていることを示します。tk-maya.yml の上部にある includes セクションに、以下のように表示されています。includes:...- ./tk-multi-workfiles2.yml現在のファイル config/env/includes/settings と同じディレクトリ内にある tk-multi-workfiles2.yml ファイル内で settings.tk-multi-workfiles2.launch_at_startup を検索します。手順 19: tk-multi-workfiles2.yml ファイルを開いて、settings.tk-multi-workfiles2.launch_at_startup を検索します。# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  launch_at_startup: true  entities:Maya 参照ボックスが示すように、allow_task_creation 設定には true の既定値があります。ベスト プラクティスとして、パイプライン設定には既定の設定が反映されていません。これにより、簡易形式が可能になり、既定のコードと異なる設定のみが設定に追加されます。設定が明示的に指定されていない場合は、この設定にアクセスするすべての呼び出しが既定値を受け取ります。Toolkit が設定を読み取って環境を構築するときに、この環境内で実行されているアプリ、エンジン、およびフレームワークはこのプロジェクトのパイプライン構成設定を使用し、設定の内容に基づいてすべての既定の設定をオーバーライドします。手順 20: tk-multi-workfiles2.yml の settings.tk-multi-workfiles2.launch_at_startup: の下に allow_task_creation を追加して、その値を false に設定します。# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  allow_task_creation: false  launch_at_startup: true  entities:注: Toolkit の既定の構成設定は、特定の設定を見つけやすいようにアルファベット順に編成されています。この規則に従うことにより、設定の内容が増えた場合でも作業を簡単に行うことができます。手順 21: ファイルを保存します。設定を再ロードする手順 22: Maya の[File Open]ダイアログ ボックスで参照ボックスを開き、[Reload Engines and Apps]を選択します。これにより、構成設定が再ロードされます。変更を表示する手順 23: [File Open]ダイアログ ボックスに移動して、アセットを選択します。[+New Task]ボタンが表示されないことに注目してください。これで、Workfiles アプリの構成設定を変更して、プロジェクト環境内のボタンの動作を変更できました。この設定はプロジェクト環境内で変更しただけなので、別の環境で作業を開始した場合は、[+New Task]ボタンの設定は引き続き有効になります。実際のプロダクションでも同様の変更を行うには、ここで行った変更をすべての環境に反映する必要があります。**環境を変更する手順 24: アセットの検索結果の下にあるフォルダを開いて、作業するアセットを選択します。手順 25: [+New File]を選択します。[+New File]を選択することにより、新しいアセットの作業が始まり、asset_step環境が Maya にロードされます。アーティストがアセット タスクを選択して、新しいファイルを作成するか、既存のファイルを開くと、asset_step 環境が自動的にロードされて、パイプラインのこのステージ用に設定されたツールおよび機能が表示されます。作業している環境を見つける手順 26: Maya メニューの右上で[ShotGrid]を選択します。[Art, Asset]は、ユーザが作業中であること、およびユーザが作業している環境を示します。手順 27: [Art, Asset] &amp;gt; [Work Area Info…]を選択して、現在の作業領域に含まれているパラメータを表示します。手順 28: 下部にある[Environment]タブを選択します。設定がパイプライン設定内のどこに配置されているのかを判別するために必要な情報が、環境ごとに表示されます。アーティストが新しいタスクを追加できないようにするには、アーティストが作業する環境ごとに[+New Task]ボタンを無効にする必要があります。各環境に上記と同じ手順を使用して、設定を適切に編集します。注: 各環境は独立していて、プロジェクトには専用の設定があります。また、プロジェクトがロードされるときにソフトウェアの統合によってパイプライン設定から読み取られるのは、特定のソフトウェアの設定のみです。これでパイプライン設定の編集と、アプリの設定の変更が完了しました。ここから先は、楽しみながら作業できます。ShotGrid Toolkit 環境で実行できるすべての機能について学習しましょう。次に、これから調べる高度なトピックをいくつか示します。高度なトピックこのガイドでは、単一のエンジン(tk-maya)および単一の環境(project)内のアプリの構成設定に単純な変更を加えました。また、Toolkit が環境別に整理されていることも学習しました。各環境はソフトウェアの実装ごとに一意であり、プロジェクトとタスクによって環境が絞り込まれるため、パイプライン内の定義されたポイントでアーティストが特定の機能を使用できるように設定することが可能です。このガイドで行った単純な変更を一般化して、Toolkit のパイプライン設定を詳細にカスタマイズすることができます。他のエンジンWorkfiles アプリのシステム名は tk-multi-workfiles2 です。名前内の multi は、このアプリがマルチ アプリであることを意味します。マルチ アプリはソフトウェアに依存しています。マルチ アプリの機能および関数は、Maya、Nuke、Houdini、または他の任意のサポート対象アプリのいずれで実行されているかにかかわらず、同じです。すべてのソフトウェア パッケージで Workfiles 内のタスク作成を無効にする場合は、すべてのエンジン(tk-nuke、tk-houdini など)にこのガイドの手順を実行します。他の環境プロジェクト環境でのタスク作成は無効になりましたが、実際のスタジオ環境では、アーティストが作業しているすべての環境でタスク作成を無効にしたい場合があります。そのためには、このガイドの手順に従いますが、project.yml から開始しないで、asset_step.yml、shot_step.yml などから開始します。カスタム環境を作成する既定の設定には、project、sequence、shot、shot_step、asset、および asset_step という、パイプラインに関する一連の定義済みの手順が付属しています。ただし、スタジオによっては、パイプラインのステージごとに異なる構成設定が必要な場合があります(asset_step_rig、asset_step_model、shot_step_anim、shot_step_light など)。Toolkit はカスタム環境をサポートしています。詳しくは、『環境設定リファレンス』の「カスタム環境」セクションを参照してください。ビデオのリソース  Toolkit 設定の概要(SIGGRAPH 2018 Developer Day で収録)  既定の設定の概要ウェビナーアプリの構成設定の変更に関する学習は以上です。次は、Toolkit の構成にアプリを追加してみましょう。",
    "url": "/37f575b8/",
    "relUrl": "/37f575b8/"
  },
  "29": {
    "id": "29",
    "title": "VPC Endpoints",
    "content": "VPC EndpointsComing soon.",
    "url": "/8a9c5baf/",
    "relUrl": "/8a9c5baf/"
  },
  "30": {
    "id": "30",
    "title": "環境設定リファレンス",
    "content": "環境設定リファレンスはじめにToolkit パイプラインの中心にあるのは環境設定です。Toolkit パイプライン設定内の環境構成ファイルでは、さまざまな DCC 内で使用可能な Toolkit アプリを定義し、それぞれの設定をカスタマイズできます。このドキュメントは環境設定ファイルの構造と機能についての完全なリファレンスです。ここでは、プロジェクト内のさまざまなワークフローを設定するための Toolkit の**「環境」の概念、環境設定の構成、ファイル参照、そしてどのようなカスタマイズが行えるかを確認する方法について説明します。                    注: このドキュメントは環境設定ファイルのリファレンスとして使用しますが、『パイプライン設定の編集に関する Toolkit の基本ガイド』には、構成設定を編集するステップバイステップの手順が例として記載されています。    環境についてShotGrid Toolkit プラットフォームは、一般的に使用されるコンテンツ作成ソフトウェアのための完全にカスタマイズ可能な統合セットを提供するため、これを使用してスタジオのパイプラインを構築できます。プロジェクトの構成において、統合されているソフトウェア パッケージはどれか、そのそれぞれで利用可能な Toolkit アプリはどれかを指定し、さらに各アプリのオプションを指定することにより、スタジオのニーズに合わせてアーティストのワークフローを構築できます。しかし、スタジオのパイプラインでは、さまざまなタイプのアーティストが異なるワークフローを使用するのが一般的です。簡単な例として、アセットを扱うアーティストの場合は Mari などのテクスチャ ペイント ソフトウェアを利用可能にし、ショットを扱うアーティストの場合は Nuke などの合成ソフトウェアを利用可能にします。ソフトウェア パッケージの他にも、異なるアーティストに対して、同じ Toolkit アプリで異なる設定を使用することができます。たとえば、ショットのアーティストとアセットのアーティストの両方が Workfiles アプリを使用することがありますが、ショットのアーティストは Shot エンティティ、アセットのアーティストは Asset エンティティに関連付けられているファイルにのみナビゲートできるように制限することができます。プロジェクト内でこれらの個別のワークフローをサポートするために、Toolkit はアプリとエンジンの構成を環境上で分離しています。環境には、一連のソフトウェア パッケージの統合とその設定が含まれています。それらのすべてには、特定の共通するコンテキストがあります。上記の例では、アセットを扱うアーティストはアセットの手順の環境で作業し、ショットを扱うアーティストはショットの手順の環境で作業しています。環境はそれぞれ独立して構成されているため、プロジェクト内で異なるワークフローを使用できます。Toolkit の既定の設定に関するメモToolkit での環境設定の構築には多くの自由が与えられています。このドキュメントは利用可能なすべてのオプションのリファレンスで、実際のパイプラインのニーズに最も適した選択をするのに必要な知識を得ることができます。またこのドキュメントでは、既定の設定と呼ばれる、パイプライン設定の出発点として選択された特別な設定についても説明します。パイプラインをカスタマイズする準備が整ったら、最初の手順はプロジェクト用の編集可能なパイプライン設定を作成することです。これらの選択は単なる規則であり、Toolkit のワークフローにハードコードされているわけではありませんが、既定の設定を例として参照すると、パイプラインのカスタマイズを開始した後に使用できる機能や、独自の設定を構築するためのベスト プラクティスについて学ぶことができます。また、新しい Toolkit ユーザが既定の設定を出発点として参照すれば、Toolkit の規則について知るのにも役立ちます。このドキュメントでは、Toolkit の環境設定の一般的な機能と、既定の設定における特定の選択とを常に区別します。既定の設定の環境構成の詳細については、README ファイルを参照してください。ファイルの場所パイプライン設定内の config/ ディレクトリには、カスタマイズ対象のすべてのファイルとフォルダが含まれています。config/ には、cache、core、および env の 3 つのサブディレクトリがあります。env ディレクトリには環境設定ファイルが保持されるため、このドキュメントでは config/env 内のファイルを参照します。既定の設定では、config/env/ に次のファイルが表示されます。asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.ymlこれらの各ファイルは環境に対応しています。異なるファイルを含めることで、各環境を別々に設定できます。Toolkit が現在の環境を判断する仕組みToolkitは pick_environment というコア フックを使用し、現在のコンテキストに基づいて特定の時点で使用する環境ファイルを決定します。pick_environment フックの戻り値は環境設定ファイルに対応しています。たとえば、pick_environment が shot_step を返した場合、Toolkit は config/env/shot_step.yml を使用して Toolkit 環境を設定します。カスタム環境上記の環境設定ファイルは、既定の設定で提供されます。ただし、スタジオによっては、異なる環境や追加の環境を採用することがあります。たとえば、スタジオによっては、パイプラインのステージごとに異なる構成設定が必要な場合があります(asset_step_rig、asset_step_model、shot_step_anim、shot_step_light など)。 その場合、利用可能な環境を完全にカスタマイズできます。これを行うには、目的の環境設定ファイルを config/env ディレクトリに追加します。次に、pick_environment コア フックをオーバーライドして、新しい環境をいつ使用するかを定義するロジックを追加します。基本構造Toolkit の設定ファイルは YAML で記述されます。バンドル(アプリ、エンジン、またはフレームワーク)の一般的な設定の構成は次のとおりです。bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: valueこの構成を説明するために、非常に単純な例を示します。単一のエンジンがあり、その中に単一のアプリケーションが定義されている環境です。以下は、この設定の project.yml の内容です。engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4エンジン ブロックすべての環境設定ファイルは engines ブロックで始まります。ここに、その環境用に定義されているすべてのエンジンがネストされています。この例では、単一のエンジン tk-maya のみが定義されています。apps と location の 2 つの設定がリストされています。location はすべてのバンドルに必要な特別な設定です。apps 設定はエンジンに定義されたすべてのアプリのリストで、それぞれ独自の設定があります。この場合、エンジンに対して定義されるアプリは 1 つのみです(tk-multi-workfiles2)。ロケーション ディスクリプタすべての Toolkit バンドルには location 設定があり、これをバンドルの**「ディスクリプタ」と呼びます。ディスクリプタは、特定のバンドルの入手元、およびそのタイプに応じて直接アクセスするかローカルにキャッシュするかを Toolkit に指示します。Toolkit バンドルを入手できる場所の例としては、ShotGrid App Store、GIT リポジトリ、ディスク上のパス、または ShotGrid サイトにアップロードされた zip ファイルなどがあります。これらには、それぞれ対応するディスクリプタ タイプがあり、そのタイプに固有の設定があります。以下に、上記の例の tk-maya エンジンのディスクリプタをもう一度示します。    location:        type: app_store        name: tk-maya        version: v0.9.4これはタイプ app_store のディスクリプタで、指定されたバンドルを ShotGrid App Store から入手するよう Toolkit に指示します。タイプ app_store のディスクリプタの設定は name と version です。対照的に、スタジオでカスタム バンドルをアクティブに開発している場合、たとえば特定のワークフロー用の Toolkit アプリを作成している場合は、ディスク上のパスから直接入手することができます。この場合、以下に示すようにタイプ dev のディスクリプタを使用します。    location:        type: dev        path: /path/to/appdev ディスクリプタは app_store ディスクリプタとは設定が異なります。他の設定を使用することもできますが、ディスク上のアプリの場所を参照する path 設定を使用して簡単にセットアップすることができます。利用可能なすべてのディスクリプタ タイプとその設定に関する詳細は、Toolkit Core API ドキュメントの「ディスクリプタ」セクションを参照してください。アプリ ブロックアプリは Toolkit のユーザ ツールであり、各アプリは他のアプリから独立して実行できます。パイプラインのニーズに基づいてどのアプリを使用するかを選択できます。エンジン ブロック内の apps 設定は、特定のエンジンで使用できるアプリを定義します。以下に、上記の例の apps 設定をもう一度示します。engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8単一のアプリ、tk-multi-workfiles2 アプリが定義されていることがわかります。現在のところ、単一の設定、すなわちディスクリプタのみが定義されています。project 環境の tk-maya エンジンで他のアプリを利用できるようにするには、ここで追加します。ここでは、エンジンに Panel、tk-multi-shotgunpanel、および About アプリ、tk-multi-about を追加します。例の project.yml ファイルは次のようになります。engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4ここでは、いくつかの重要な注意事項があります。  既定の設定ではバンドルがアルファベット順にリストされ、この例ではその規則に従います。  ファイルが長くなり始めていますが、構成設定はまだ追加していません。  他のエンジンや他の環境でこれらと同じアプリを使用していることが想像できます。たとえば、Panel、About アプリ、Workfiles アプリの 3 つのすべてのアプリが、異なるエンジン(Houdini、Nuke、Photoshop など)および異なる環境(asset_step や shot_step)で実行されている可能性があります。設定内の異なる場所で共通のアプリ設定を定義することは、変更が必要なときに、それぞれの場所で変更が必要になることを意味します。最後の 2 つの問題を軽減するために、Toolkit 設定はインクルードをサポートします。インクルード「インクルード」を使用すると、あるファイルのセクションを構成内の別のファイルで参照できます。インクルードを使用すると、構成設定を一箇所で設定し、複数の環境で使用できます。インクルードは次の 2 つの部分で構成されます。  includes リスト: キーが includes で、インクルードするすべてのファイルのリストを値に持つ YAML 辞書。  構成設定内のリファレンス。@ 記号で始まり、インクルード ファイルから参照するセクションの名前をポイントする名前が付けられています。上記の例を具体化するために、すべてのエンジンのロケーション ディスクリプタを保持する単一のファイルを作成しているとします。そのファイルを includes サブフォルダに置き、engine_locations.yml という名前を付けます。engine_locations.yml の内容は以下のようになります。config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...このファイルはすべてのエンジンの場所に対する単一のソースとして機能し、すべての環境設定から参照することができます。このインクルード ファイルを使用した場合、この例は次のようになります。config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationここでは、tk-maya エンジンの location 設定の値が、インクルードされる YAML ファイルのキーを参照していることがわかります。                    注: この例では、既定の設定の規則に従い、すべてのエンジンの場所を config/env/includes/engine_locations.yml ファイルに含めています。    アプリの場所を示すために、2 番目のインクルード ファイルを追加することができます。実際には、これは既定の設定によって行われます。例を拡張してみましょう。config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationインクルードされた engine_locations.yml ファイルから tk-maya エンジンのディスクリプタを取得し、インクルードされた app_locations.yml ファイルから tk-maya エンジン用に定義された各アプリのディスクリプタを取得します。                    注: 既定の設定では、この例では示されていない 2 番目のネスト レベルを使用しています。単なるディスクリプタ以上の設定を持つすべてのアプリまたはエンジンは、includes/settings に設定ファイルがあります(例: includes/settings/tk-maya.yml、includes/settings/tk-multi-workfiles2.yml)。エンジン設定ファイルには、アプリ設定ファイルからのアプリ設定が含まれ、環境設定ファイルにはエンジン設定ファイルからの設定が含まれています。既定の設定の構造の詳細については、README ファイルを参照してください。構成設定の変更に関する詳細な手順については、『構成設定の編集に関する Toolkit の基本ガイド』を参照してください。    スパース構成すべての Toolkit バンドルには、使用可能な構成設定のセットがあり、それぞれの設定に既定値があります。Toolkit は**「スパース構成」を許可します: 構成設定が環境設定ファイル(またはそこに含まれるファイル)で明示的に指定されていない場合、バンドルの既定値が使用されます。この例では、location 以外にアプリの設定を指定していません。したがって、設定の現在の状態では、3 つのアプリはすべての設定に既定値を使用します。それでは、どの構成設定が利用可能であるかを知るにはどうすれば良いでしょうか。                    注: Toolkit の構成がスパース構成であることは必須ではありませんが、既定の設定はスパース構成です。    利用可能な構成設定を検出するスパース構成では、単に設定ファイルを見ただけでは、どの構成設定がアプリに使用できるかをすぐに判断することはできません。アプリで利用可能な構成設定を確認する場合、2 つの選択肢があります。  アプリのドキュメント: 各アプリには独自のドキュメント ページがあり、それぞれのページに「設定オプション」セクションがあります。このセクションでは、アプリで使用可能なすべての構成設定が、それぞれの説明と既定値と共に一覧表示されています。たとえば、Workfiles ドキュメント ページを参照することができます。アプリとエンジンのページには、すべてのアプリとエンジンのドキュメント ページが一覧表示されています。  マニフェスト: すべての Toolkit バンドルは、そのルート ディレクトリに info.yml というファイルを含んでいます。このファイルをバンドルの**「マニフェスト」と呼び、バンドルで利用可能なすべての設定を、それぞれの説明と既定値と共に定義します。マニフェストは、バンドルの独自のキャッシュ(パイプライン設定内の install/app_store/tk-multi-workfiles2/v0.11.8/info.yml など)、または Github (ここでは Workfiles の場合の例を示します)にあります。構成設定を修正する既定値の設定を変更するには、パイプライン設定の適切な環境で、適切なブロックに構成を追加し、その値を設定します。例に戻って、プロジェクト環境で Maya が起動されると tk-multi-workfiles2 が自動的に起動するように設定してみましょう。アプリのマニフェストを見ると、アプリの起動時に Workfiles UI を起動するかどうかを制御する launch_at_startup 設定があり、その既定値が False であることがわかります。そこで、launch_at_startup オプションを追加して True に設定します。project.yml ファイルは次のようになります。config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationtk-multi-workfiles2 の設定がインクルード ファイルからのものである場合は、そのファイルでこの変更を行います。その他の参考情報  Toolkit の基本ガイド: パイプライン設定を編集する  Toolkit の基本ガイド: アプリを追加する  アニメーション パイプラインのチュートリアル  ディスクリプタのリファレンス ドキュメント  ウェビナー: Toolkit の管理  ファイル システム設定リファレンス  既定の設定の環境構成に関する README",
    "url": "/487a9f2c/",
    "relUrl": "/487a9f2c/"
  },
  "31": {
    "id": "31",
    "title": "API",
    "content": "APIregisterCallbacksA global level function in all plugins that is used to tell the framework about event processing entry points in the plugin.registerCallbacks(reg)  reg: The Registrar you will interact with to tell the framework which functions to call.RegistrarThe Registrar is the object used to tell the framework how to interact with a plugin. It is passed to the registerCallbacks function.AttributesloggerSee getLogger.MethodsgetLoggerGet the python Logger object used to log messages from within the plugin.setEmails(*emails)Set the emails that should receive error and critical notices when something bad happens in this plugin or any of its callbacks.To send emails to default addresses as specified in the configuration file (default)reg.setEmails(True)To disable emails (this is not suggested as you won’t get error messages)reg.setEmails(False)To send emails to specific addresses usereg.setEmails('user1@domain.com')orreg.setEmails('user1@domain.com', 'user2@domain.com')registerCallback(sgScriptName, sgScriptKey, callback, matchEvents=None, args=None, stopOnError=True)Register a callback into the engine for this plugin.  sgScriptName: The name of the script taken from the ShotGrid  scripts page.  sgScriptKey: The application key for the script taken from a ShotGrid  script page.  callback: A function or an object with a __call__ method. See exampleCallback.  matchEvents: A filter of events you want to have passed to your callback.  args: Any object you want the framework to pass back into your callback.  stopOnError: Boolean, should an exception in this callback halt processing of events by all callbacks in this plugin. Default is True.The sgScriptName is used to identify the plugin to ShotGrid. Any name can be shared across any number of callbacks or be unique for a single callback.The sgScriptKey is used to identify the plugin to ShotGrid and should be the appropriate key for the specified sgScriptName.The specified callback object will be invoked when an event that matches your filter needs processing. Although any callable should be able to run, using a class here is not suggested. Use of a function or an instance with a __call__ method is more appropriate.The matchEvent argument is a filter that allows you to specify which events the callback being registered is interrested in. If matchEvents is not specified or None is specified, all events will be passed to the callback. Otherwise each key in the matchEvents filter is an event type while each value is a list of possible attribute names.matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],}You can have multiple event types or attribute namesmatchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],    'Shotgun_Version_Change': ['description', 'sg_status_list']}You can filter on any event type that has a given attribute namematchEvents = {    '*': ['sg_status_list'],}You can also filter on any attribute name for a given event typematchEvents = {    'Shotgun_Version_Change': ['*']}Although the following is valid and functionally equivalent to specifying nothing, it’s just really uselessmatchEvents = {    '*': ['*']}When matching against non field specific event types such as “_New” or “_Retirement”, you don’t provide a list, instead you pass None as the value.matchEvents = {    'Shotgun_Version_New': None}The args argument will not be used by the event framework itself but will simply be passed back to your callback without any modification.                    Note: The point of the args argument is for you to be able to process time consuming stuff in the registerCallbacks function and have it passed back to you at event processing time.    Another use of the args argument could be to pass in a common mutable, a dict for example, to multiple callbacks to have them share data.The stopOnError argument tells the system if an exception in this callback can cause event processing to stop for all callbacks in the plugin. By default this is True but can be switched to False. You will still get mail notifications of errors should there be any but processing of events will not stop. Being a per callback setting you can have some critical callbacks for whom this is True but others for whom this is False.CallbackAny plugin entry point registered by Registrar.registerCallback is generally a global level function that looks like this:exampleCallback(sg, logger, event, args)  sg: A ShotGrid connection instance.  logger: A Python logging.Logger object preconfigured for you.  event: A ShotGrid event to process.  args: The args argument specified at callback registration time.                    Note: Implementing a callback as a __call__ method on an object instance is possible but left as an exercise for the user.    ",
    "url": "/b04a53ae/",
    "relUrl": "/b04a53ae/"
  },
  "32": {
    "id": "32",
    "title": "Configuration",
    "content": "ConfigurationThe following guide will help you configure ShotGridEvents for your studio.Most of the configuration for ShotGridEvents is controlled by the shotgunEventDaemon.conf file. In this file, you’ll find several settings you can modify to match your needs. Most of them have defaults that will work fine for most studios, however, there are some settings that must be configured (specifically, your ShotGrid server URL, script name, and application key so the ShotGridEventDaemon can connect to your ShotGrid server).                    Note: For Windows: Windows users will need to change all the paths in the configuration file for Windows equivalents. We suggest keeping all paths, including logging, under one single location for the sake of simplicity. This documentation tends to refer to C: shotgun shotgunEvents when mentioning Windows paths.    Edit shotgunEventDaemon.confOnce you have installed ShotGridEvents, the next step is to open the shotgunEventDaemon.conf file in a text editor and modify the settings to match your studio’s needs. The defaults will be fine for most studios, however, there are some settings that have no defaults that will need to be provided by you before you can run the daemon.The items you must provide are:  your ShotGrid server URL  the Script name and Application key for connecting to ShotGrid  the full path to your plugins for the ShotGridEventDaemon to runOptionally, you can also specify an SMTP server and email-specific settings in order to setup email notification for errors. While this is optional, if you choose to set this up, you must provide all of the configuration values in the email section.There is also a section for an optional timing log which can help with troubleshooting if you ever encounter performance issues with your daemon. Enabling timing logging will populate its own separate log file with the timing information.ShotGrid SettingsUnderneath the [ShotGrid] section, replace the default tokens with the correct values for server, name, and key. These should be the same values you’d provide to a standard API script connecting to ShotGrid.Exampleserver: https://awesome.shotgunstudio.comname: ShotGridEventDaemonkey: e37d855e4824216573472846e0cb3e49c7f6f7b1Plugin SettingsYou will need to tell the ShotGridEventDaemon where to look for plugins to run. Under the [plugins] section replace the default token with the correct  value for paths.You can specify multiple locations (which may be useful if you have multiple departments or repositories using the daemon). The value here must be a full path to a readable existing directory.Examplepaths: /usr/local/shotgun/ShotGridEvents/pluginsWhen you’re first getting started, a good plugin to test with is the logArgs.py plugin located in the /usr/local/shotgun/ShotGridEvents/src/examplePlugins directory. Copy that into the plugins folder you specified and we’ll use that for testing things.Location of shotgunEventDaemon.confBy default, the daemon will look for the shotgunEventDaemon.conf file in the same directory that ShotGridEventDaemon.py is in, and in the /etc directory. If you need to put the conf file in another directory, it’s recommended you create a symlink to it from the current directory.                    Note: If for some reason the above won’t work for you, the search paths for the config file are located in the _getConfigPath() function at the bottom of the shotgunEventDaemon.py script                        Note: For Windows The /etc doesn’t exist on Windows so the configuration file should be put in the same directory as the Python files.    Testing the DaemonDaemons can be difficult to test since they run in the background. There isn’t always an obvious way to see what they’re doing. Lucky for us, the ShotGridEventDaemon has an option to run it as a foreground process. Now that we have done the minimum required setup, let’s go ahead and test the daemon and see how things go.                    Note: The default values used here may require root access (for example, to write to the/var/log directory). The examples provided use are run using sudo to accommodate this.    $ sudo ./ShotGridEventDaemon.py foregroundINFO:engine:Using ShotGrid version 3.0.8INFO:engine:Loading plugin at /usr/local/shotgun/ShotGridEvents/src/examplePlugins/logArgs.pyINFO:engine:Last event id (248429) from the ShotGrid database.You should see the lines above when you start the script (some of the details may differ obviously). If you get any errors, the script will terminate since we opted to run it in the foreground we’ll see that happen. Some common errors are displayed below if you get stuck.The logArgs.py plugin simply takes the event that occurred in ShotGrid and passes it to the logger. Not very exciting but it’s a simple way to ensure that the script is running and the plugin is working. If you’re at a busy studio, you may have already noticed a rapid stream of messages flowing by. If not, login to your ShotGrid server in your web browser and change some values or create something. You should see log statements printed out to your terminal window corresponding to the type of event you generated with your changes.                    Note: There are variables in the logArgs.py file that need to be filled in with appropriate values. ‘$DEMO_SCRIPT_NAMES$’ and ‘$DEMO_API_KEY$’ must be edited to contain the same values that were used in the shotgunEventDaemon.conf file in order for the logging to function correctly.    If you don’t see anything logged to the log file, check your log-related settings in ShotGridEventDaemon.conf to ensure that the logging value is set to log INFO level messageslogging: 20and the logArgs plugin is also configured to show INFO level messages. There is a line at the end of the registerCallbacks() method that should readreg.logger.setLevel(logging.INFO)Assuming all looks good, to stop the ShotGridEventDaemon process, simply type &amp;lt;ctrl&amp;gt;-c in the terminal and you should see the script terminate.Running the daemonAssuming all went well with your testing, we can now run the daemon as intended, in the background.$ sudo ./ShotGridEventDaemon.py startYou should see no output and control should have been returned to you in the terminal. We can make sure that things are running well in two ways. The first would be to check the running processes and see if this is one of them.$ ps -aux | grep shotgunEventDaemonkp              4029   0.0  0.0  2435492    192 s001  R+    9:37AM   0:00.00 grep shotgunEventDaemonroot            4020   0.0  0.1  2443824   4876   ??  S     9:36AM   0:00.02 /usr/bin/python ./ShotGridEventDaemon.py startWe can see by the second line returned that the daemon is running. The first line is matching the command we just ran. So we know it’s running, but to ensure that it’s working and the plugins are doing what they’re supposed to, we can look at the log files and see if there’s any output there.$ sudo tail -f /var/log/shotgunEventDaemon/shotgunEventDaemon2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.Go back to your web browser and make some changes to an entity. Then head back to the terminal and look for output. You should see something like the following2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.2011-09-09 09:45:31,228 - plugin.logArgs.logArgs - INFO - {'attribute_name': 'sg_status_list', 'event_type': 'Shotgun_Shot_Change', 'entity': {'type': 'Shot', 'name': 'bunny_010_0010', 'id': 860}, 'project': {'type': 'Project', 'name': 'Big Buck Bunny', 'id': 65}, 'meta': {'entity_id': 860, 'attribute_name': 'sg_status_list', 'entity_type': 'Shot', 'old_value': 'omt', 'new_value': 'ip', 'type': 'attribute_change'}, 'user': {'type': 'HumanUser', 'name': 'Kevin Porterfield', 'id': 35}, 'session_uuid': '450e4da2-dafa-11e0-9ba7-0023dffffeab', 'type': 'EventLogEntry', 'id': 276560}The exact details of your output will differ, but what you should see is that the plugin has done what it is supposed to do, that is, log the event to the logfile. Again, if you don’t see anything logged to the log file, check your log-related settings in ShotGridEventDaemon.conf to ensure that the loggingvalue is set to log INFO level messages and your logArgs plugin is also configured to show INFO level messages.A Note About LoggingIt should be noted that log rotation is a feature of the ShotGrid daemon. Logs are rotated at midnight every night and ten daily files are kept per plugin.Common ErrorsThe following are a few of the common errors that you can run into and how to resolve them. If you get really stuck, please visit our support site for help.Invalid path: $PLUGIN_PATHS$You need to specify the path to your plugins in the shotgunEventDaemon.conf file.Permission denied: ‘/var/log/shotgunEventDaemon’The daemon couldn’t open the log file for writing.You may need to run the daemon with sudo or as a user that has permissions to write to the log file specified by the logPath and logFile settings in shotgunEventDaemon.conf. (the default location is /var/log/shotgunEventDaemon which is usually owned by root.ImportError: No module named shotgun_api3The ShotGrid API is not installed. Make sure it is either located in the current directory or it is in a directory in your PYTHONPATH.If you have to run as sudo and you think you have the PYTHONPATH setup correctly, remember that sudo resets the environment variables. You can edit the sudoers  file to preserve the PYTHONPATH or run sudo -e(?)List of Configuration File SettingsDaemon SettingsThe following are general daemon operational settings.pidFileThe pidFile is the location where the daemon will store its process id while it is running. If this file is removed while the daemon is running, it will shut down cleanly after the next pass through the event processing loop.The directory must already exist and be writable. You can name the file whatever you like but we strongly recommend you use the default name as it matches with the process that is runningpidFile: /var/log/shotgunEventDaemon.pideventIdFileThe eventIdFile points to the location where the daemon will store the id of the last processed ShotGrid event. This will allow the daemon to pick up where it left off when it was last shutdown, thus it won’t miss any events. If you want to ignore any events since the last daemon shutdown, remove this file before starting up the daemon and the daemon will process only new events created after startup.This file keeps track of the last event id for each plugin and stores this information in pickle format.eventIdFile: /var/log/shotgunEventDaemon.idlogModeThe logging mode can be set to one of two values:  0 = all log messages in the main log file  1 = one main file for the engine, one file per pluginWhen using a value of 1, the log messages generated by the engine itself will be logged to the main log file specified by the logFile config setting. Any messages logged by a plugin will be placed in a file named plugin.&amp;lt;plugin_name&amp;gt;.logMode: 1logPathThe path where to put log files (both for the main engine and plugin log files). The name of the main log file is controlled by the logFilesetting below.logPath: /var/log/shotgunEventDaemon                    Note: The shotgunEventDaemon will have to have write permissions for this directory. In a typical setup, the daemon is set to run automatically when the machine starts up and is given root privileges at that point.    logFileThe name of the main daemon log file. Logging is configured to store up to  10 log files that rotate every night at midnight.logFile: shotgunEventDaemonloggingThe threshold level for log messages sent to the log files. This value is the default for the main dispatching engine and can be overridden on a per plugin basis. This value is simply passed to the Python logging module. The most common values are:  10: Debug  20: Info  30: Warnings  40: Error  50: Criticallogging: 20timing_logEnabling timing logging by setting this value to on will generate a separate log file with timing information which should make troubleshooting performance issues with your daemon simpler.The timing information provided for each callback invocation is as follows:  event_id The id of the event that triggered the callback  created_at The timestamp in ISO format when the event was created in ShotGrid  callback The name of the invoked callback in plugin.callback format  start The timestamp in ISO format of the start of callback processing  end The timestamp in ISO format of the end of callback processing  duration The duration in DD:HH:MM:SS.micro_second format of the callback processing time  error If the callback failed or not. The value can be False or True.  delay The duration in DD:HH:MM:SS.micro_second format of the delay between the event creation and the start of processing by the callback.conn_retry_sleepIf the connection to ShotGrid fails, this is the number of seconds to wait until the connection is re-attempted. This allows for occasional network hiccups, server restarts, application maintenance, etc.conn_retry_sleep = 60max_conn_retriesNumber of times to retry the connection before logging an error level message(which potentially sends an email if email notification is configured below).max_conn_retries = 5fetch_intervalThe number of seconds to wait before requesting new events after each batch of events is done being processed. This setting generally doesn’t need to be adjusted.fetch_interval = 5ShotGrid SettingsThe following are settings related to your ShotGrid instance.serverThe URL for the ShotGrid server to connect to.server: %(SG_ED_SITE_URL)s                    Note: There is no default value here. Set the SG_ED_SITE_URL environment variable to the URL for your ShotGrid server (ie. https://awesome.shotgunstudio.com)    nameThe ShotGrid Script name the ShotGridEventDaemon should connect with.name: %(SG_ED_SCRIPT_NAME)s                    Note: There is no default value here. Set the SG_ED_SCRIPT_NAME environment variable to the Script name for your ShotGrid server (ie. shotgunEventDaemon)    keyThe ShotGrid Application Key for the Script name specified above.key: %(SG_ED_API_KEY)s                    Note: There is no default value here. Set the SG_ED_API_KEY environment variable to the Application Key for your Script name above (ie:0123456789abcdef0123456789abcdef01234567)    use_session_uuidSets the session_uuid from every event in the ShotGrid instance to propagate in any events generated by plugins. This will allow the ShotGrid UI to display updates that occur as a result of a plugin.use_session_uuid: True  ShotGrid server v2.3+ is required for this feature.  ShotGrid API v3.0.5+ is required for this feature.                    Note: The ShotGrid UI will only show updates live for the browser session that spawned the original event. Other browser windows with the same page open will not see updates live.    Plugin SettingspathsA comma-delimited list of complete paths where the framework should look for plugins to load. Do not use relative paths.paths: /usr/local/shotgun/plugins                    Note: There is no default value here. You must set the value to the location(s) of your plugin files (ie:/usr/local/shotgun/shotgunEvents/plugins or C: shotgun shotgunEvents plugins on Windows)    Email SettingsThese are used for error reporting because we figured you wouldn’t constantly be tailing the log and would rather have an active notification system.Any error above level 40 (ERROR) will be reported via email if all of the settings are provided below.All of these values must be provided for there to be email alerts sent out.serverThe server that should be used for SMTP connections. The username and password values can be uncommented to supply credentials for the SMTP connection. If your server does not use authentication, you should comment out the settings for username and passwordserver: smtp.yourdomain.com                    Note: There is no default value here. You must replace the smtp.yourdomain.com token with the address of your SMTP server (ie. smtp.mystudio.com).    usernameIf your SMTP server requires authentication, uncomment this line and make sure you have configured the SG_ED_EMAIL_USERNAME environment variable with the username required to connect to your SMTP server.username: %(SG_ED_EMAIL_USERNAME)spasswordIf your SMTP server requires authentication, uncomment this line and make sure you have configured the SG_ED_EMAIL_PASSWORD environment variable with the password required to connect to your SMTP server.password: %(SG_ED_EMAIL_PASSWORD)sfromThe from address that should be used in emails.from: support@yourdomain.com                    Note: There is no default value here. You must replacesupport@yourdomain.com with a valid value (ie. noreply@mystudio.com).    toA comma-delimited list of email addresses to whom these alerts should be sent.to: you@yourdomain.com                    Note: There is no default value here. You must replace you@yourdomain.com with a valid value (ie. shotgun_admin@mystudio.com).    subjectAn email subject prefix that can be used by mail clients to help sort out alerts sent by the ShotGrid event framework.subject: [SG]",
    "url": "/ed5161c4/",
    "relUrl": "/ed5161c4/"
  },
  "33": {
    "id": "33",
    "title": "Example Plugins",
    "content": "Example PluginsThere is a folder of example plugins in the source code.This page includes a few more simple examples, for anyone looking to get started. You can copy/paste this code and it should run(Note: you’ll have to update the script_name, and script_key values to something specific for your installation)First, here’s a template upon which all SG event code should be written1. Code TemplateCopy / Paste this to get started on new plugins&quot;&quot;&quot;Necessary Documentation of the codeAuthor: YouTemplate Author: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    # This takes the form of:    #    matchEvents = {'Shotgun_Entity_EventType': ['list', 'of', 'field', 'names', 'you', 'need', 'sg_custom_field']}    # the 'id' is always returned, in addition to any fields specifically requested by your callback    matchEvents = {        'Shotgun_Task_Change': ['content']    }    # script_name and script_key are defined by you whenever you create a SG script    # the entry_function_call refers to the function that performs the work of the event plugin    reg.registerCallback('script_name', 'script_key', entry_function_call, matchEvents, None)# This gives you#    shotgun handle = sg#    a logger object... please use this instead of python print, especially if you respect your time and your fellow developers#    an event object... this is the metadata that describes what's happening with the particular event.#        some very good information comes from the event['meta'] object, below is the example event['meta'] data from the subject renamer plugin#              {#                &quot;type&quot;: &quot;attribute_change&quot;,#                &quot;attribute_name&quot;: &quot;subject&quot;,#                &quot;entity_type&quot;: &quot;Note&quot;,#                &quot;entity_id&quot;: 2,#                &quot;field_data_type&quot;: &quot;text&quot;,#                &quot;old_value&quot;: &quot;My Note Subject&quot;,#                &quot;new_value&quot;: &quot;2017-05 May-09 - My Note Subject&quot;#              }def entry_function_call(sg, logger, event, args):    # Now do stuff    pass   2. Note Subject RenamingWorking with New Entity EventsThis is a great one to start with  because it’s simple, but it also deals with a rather tricky aspect of catching Shotgun_Entity_New events…import timefrom pprint import pprintdef registerCallbacks(reg):    matchEvents = {        'Shotgun_Note_New': ['*'],    }    reg.registerCallback('script_name', 'script_key', Function_Name, matchEvents, None)def Function_Name(sg, logger, event, args):    # Waiting here should allow the entity to be fully created             #     and all the necessary attributes to be added to the NOTE entity    time.sleep(1)    current_date = time.strftime(&quot;%Y-%m %b-%d&quot;)    asset_id = event['meta']['entity_id']    asset_type = event['meta']['entity_type']    asset = sg.find_one(asset_type, [['id', 'is', asset_id]], ['subject'])    if asset['subject'] is None:        current_name = current_date + ' - ' + event['project']['name'] + ' - ' + event['user']['name']    else:        current_name = current_date + ' - ' + asset['subject']    # Modify ALL notes except those in 'Software Development'    if event['project'] == None:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})        return    if event['project']['id'] != 116:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})    else:        logger.info('Dates are not prepended for notes in project id 116 - Software Development')        returnNote the sleep call as the very first line of the function body. The reason for this deals with the way that new events are handled.  When a NEW entity is created in SG, it is still rather unformed - meaning that it doesn’t possess all the attributes needed to fully define that entity as you’re used to it. In fact, in this example, I can’t even guarantee that the subject attribute will be on the Note entity when SG emits the Shotgun_Note_New event.  In order to add all of the necessary attributes, SG then publishes a series of Shotgun_Note_Change events wherein SG will add every single attribute to the entity and update the values of those attributes - if required.  This means that a multiplicity of events are created, which means that if you need two different attributes to be present and you didn’t write a sleep aspect to your code, then you’d have to sift through ALL of the Shotgun_Note_Change events and the internal metadata looking for only those that have new attributes added and values set… This is a cumbersome process and will process many Shotgun_Note_Change events looking for - effectively - just one per note at time of creation.  The solution as I’ve found it is to rely on Shotgun_Entity_New and let the script sleep for a short period. At the end of the sleep, SG will have updated all the attributes required for the entity and then you can re-query that same entity for any of the fields you need2. Field Deletion WarningGenerating Notes, Working with Fields as Entities, and Entity Retirement Events&quot;&quot;&quot;Create a Note when a field is deletedAuthor: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    &quot;&quot;&quot;    fn: registerCallbacks    @brief required function. It connects to the event daemon and calls the trashedFieldWarning Function.    It runs every time a field is deleted (retired)    @param[in] reg variable that is required by shotgun event daemon plugins    @return none    &quot;&quot;&quot;    matchEvents = {        'Shotgun_DisplayColumn_Retirement': ['*']    }    reg.registerCallback('script_name', 'script_key',                         trashedFieldWarning, matchEvents, None)def CreateNote(sg, logger, event):    constants = {'note header': ':: FIELD DELETION :: '}    def GetListOfPipelineUsers():        pipeline_users = sg.find('Group', [['code', 'is', 'People_Who_Need_to_Know']], ['code', 'users', 'addressings_to',                                                                         'sg_ticket_type', 'sg_priority'])        return pipeline_users[0]['users']    def CreateToolsNote():        # Note to members of the pipeline group        # Body text = CreateNoteRequestText()        # Date Created = event['event']['created_at']        # Created By = event['user']['id']        # Project = Software Development['id']        # Subject = ':: Field Delete Warning :: ' + event['entity']['name']        note_data = {            'project': {'type': 'Project', 'id': 'ID OF PROJECT WHERE YOU WANT THE NOTE REPORTED TO'},            # ex: 'project': {'type': 'Project', 'id': 2},            'content': CreateNoteRequestText(),            'created_at': event['created_at'],            'created_by': event['user'],            'addressings_to': GetListOfPipelineUsers(),            'subject': constants['note header'] + event['meta']['display_name']        }        sg.create('Note', note_data)    def CreateNoteRequestText():        OUT = ''        # Tool Name = event['entity']['name']        # sg_assigned_to = members of the pipeline group        # Description = linked Ticket decription        # Project = decided in GUI        # sg_sg_request_ticket = event['entity']['id']        # task_template = Software task template        # Software Projects = defined in GUI        OUT = '::FIELD DELETION WARNING:: n'        OUT += ':: A Field was deleted :: n'        OUT += ':: It was called %s :: n'%event['meta']['display_name']        return OUT    logger.info('::WARNING:: A FIELD has been deleted')    CreateToolsNote()def trashedFieldWarning(sg, logger, event, args):    &quot;&quot;&quot;    fn: finalizeTasksFromShot    @brief Function to create and send a warning note, via SG, whenever a field is deleted    event['entity']['id'] yields the id of the current entity that was caught by the plugin as having been changed.    ie. this is the id of the field that was just deleted    @param[in] sg defines the Shotgun handle to access the database    @param[in] logger sets logging messages to the shotgun event daemon    @param[in] event the collection of shots that have changed    @param[in] args useless variable for this particular function    @return none    &quot;&quot;&quot;    if event['meta']['entity_type'] == 'DisplayColumn':        logger.info('This DisplayColumn was deleted %s', event['meta']['display_name'])    if event['event_type'] == 'Shotgun_DisplayColumn_Retirement':        logger.info('The incoming event call is for deleting a field from an entity. Field name: %s', event['meta']['display_name'])    # logger.info(' TEST ')    # logger.info('Deleted Field ID is #%d, and is called: %s', event['entity']['id'], event['entity']['name'])    CreateNote(sg, logger, event)This is a very simple script. There is no special logic in checking for deleted fields. If a field is deleted, then a note is created and sent to a group of people that need to know. In my department, we have the group id set to the ‘programmers’ group, and the project id of the note set to the ‘development’ project.",
    "url": "/34048d1e/",
    "relUrl": "/34048d1e/"
  },
  "34": {
    "id": "34",
    "title": "Installation",
    "content": "InstallationThe following guide will help you setup ShotGridEvents for your studio.System RequirementsThe daemon can run on any machine that has Python installed and has network access to your ShotGrid server. It does not need to run on the ShotGrid server itself. In fact, if you are using the hosted version of ShotGrid, this isn’t an option. However, you may run it on your ShotGrid server if you like. Otherwise, any server will do.  Python v2.6, v2.7 or 3.7  ShotGrid Python API          Use v3.0.37 or higher for Python v2.6 or v2.7 and use v3.1.0 or more for Python 3.7.      In either case, we strongly suggest using the most up to date Python API version and keeping this dependency updated over time.        Network access to your ShotGrid serverInstalling the ShotGrid APIAssuming Python is already installed on your machine, you now need to install the ShotGrid Python API so that the ShotGrid Event Daemon can use it to connect to your ShotGrid server. You can do this in a couple of ways:  place it in the same directory as the ShotGrid Event Daemon  place it in one of the directories specified by the PYTHONPATH environment variable.To test that the ShotGrid API is installed correctly, from your terminal window:$ python -c &quot;import shotgun_api3&quot;You should see no output. If you see something like the output below then you need to make sure your PYTHONPATH is setup correctly or that the ShotGrid API is located in the current directory.$ python -c &quot;import shotgun_api3&quot;Traceback (most recent call last):File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;ImportError: No module named shotgun_api3Installing ShotGridEventsThe location you choose to install ShotGridEvents is really up to you. Again, as long as Python and the ShotGrid API are installed on the machine, and it has network access to your ShotGrid server, it can run from anywhere. However, it makes sense to install it somehwere that is logical to your studio, something like /usr/local/shotgun/shotgunEvents seems logical so we’ll use that as the example from here on out.The source and archives are available on GitHub at https://github.com/shotgunsoftware/shotgunEvents                    Note: For Windows: You could use C: shotgun shotgunEvents if you have a Windows server but for this documentation we will be using the Linux path.    Cloning the sourceThe easiest way to grab the source if you have git installed on the machine is to simply clone the project. This way you can also easily pull in any updates that are committed to ensure you stay up to date with bug fixes and new features.$ cd /usr/local/shotgun$ git clone git://github.com/shotgunsoftware/shotgunEvents.git                    Warning: Always make sure you backup your configuration, plugins, and any modifications you make to shotgunEvents before pulling in updates from GitHub so you don’t lose anything. Or, fork the project yourself so you can maintain your own repository of changes :)    Downloading the archiveIf you don’t have git on your machine or you simply would rather download an archive of the source, you can get things rolling following these steps.  head over to https://github.com/shotgunsoftware/shotgunEvents/archives/master  download the source in the format you want  save it to your machine  extract the files to the /usr/local/shotgun directory  rename the /usr/local/shotgun/shotgunsoftware-shotgunEvents-xxxxxxx directory to /usr/local/shotgun/shotgunEventsExtracting the archive into /usr/local/shotgun.For .tar.gz archives:$ tar -zxvf shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.tar.gz -C /usr/local/shotgunFor .zip archives:$ unzip shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.zip -d /usr/local/shotgunThen you can rename the GitHub-assigned directory name to shotgunEvents:$ mv shotgunsoftware-shotgunEvents-1c0c3eb shotgunEventsNow you should now have something like this:$ ls -l /usr/local/shotgun/shotgunEventstotal 16-rw-r--r--  1 kp  wheel  1127 Sep  1 17:46 LICENSE-rw-r--r--  1 kp  wheel   268 Sep  1 17:46 README.mkddrwxr-xr-x  9 kp  wheel   306 Sep  1 17:46 docsdrwxr-xr-x  6 kp  wheel   204 Sep  1 17:46 srcInstalling RequirementsA requirements.txt file is provided at the root of the repository. You should use this to install the required packages$ pip install -r /path/to/requirements.txtWindows specificsYou will need one of the following on your Windows system:  Python with PyWin32 installed  Active PythonActive Python ships with the PyWin32 module which is required for integrating the ShotGrid Event Daemon with Windows’ Service architecture.You can then install the deamon as a service by running the following command (we are assuming that C: Python27_32 python.exe is the path to your Python executable, adjust accrodingly):&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py installOr remove it with:&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py removeStarting and stopping the service can be achieved through the normal service management tools or via the command line with:&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py start&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py stopIn most cases you will need to be sure you are running each of the commands listed as your system’s administrative user. You can do so by right clicking the cmd application and choosing “Run as Administrator”.                    Note: If you have installed the daemon on Windows in a network location or if you have configured it to read and write logs and other resources from a network location you will need to edit the service’s properties to change the user running the service from the local machine account to a domain account that has access to the network resources.    ",
    "url": "/7c203655/",
    "relUrl": "/7c203655/"
  },
  "35": {
    "id": "35",
    "title": "Plugins",
    "content": "Plugins OverviewA plugin file is any .py file in a plugin path as specified in the config file.There are some example plugins provided in the src/examplePlugins folder in your download of the code. These provide simple examples of how to build your own plugins to look for specific events generated, and act on them, changing other values on your ShotGrid instance.You do not need to restart the daemon each time you make updates to a plugin, the daemon will detect that the plugin has been updated and reload it automatically.If a plugin generates an error, it will not cause the daemon to crash. The plugin will be disabled until it is updated again (hopefully fixed). Any other plugins will continue to run and events will continue to be processed. The daemon will keep track of the last event id that the broken plugin processed successfully. When it is updated (and fixed, hopefully), the daemon will reload it and attempt to process events starting from where that plugin left off. Assuming all is well again, the daemon will catch the plugin up to the current event and then continue to process events with all plugins as normal.A ShotGrid event processing plugin has two main parts: a callback registration function and any number of callbacks.registerCallbacks functionTo be loaded by the framework, your plugin should at least implement the following function:def registerCallbacks(reg):    passThis function will be used to tell the event processing system which functions to call to process events.This function should take one argument which is a Registrar object.The Registrar has one critically important method:Registrar.registerCallback.For each of your functions that should process ShotGrid events, call Registrar.registerCallback once with the appropriate arguments.You can register as many functions as you wish and not all functions in the file need to be registered as event processing callbacks.CallbacksA callback that will be registered with the system must take four arguments:  A ShotGrid connection instance if you need to query ShotGrid for additional information.  A Python Logger object that should be used for reporting. Error and Critical messages will be sent via email to any configured user.  The ShotGrid event to be processed.  The args value passed in at callback registration time. (See Registrar.registerCallback)                    Warning: You can do whatever you want in a plugin but if any exception raises back to the framework, the plugin within which the offending callback lives (and all contained callbacks) will be deactivated until the file on disk is changed (read: fixed).    LoggingUsing the print statement in an event plugin is not recommended. It is prefered you use the standard logging module from the Python standard library. A logger object will be provided to your various functionsdef registerCallbacks(reg):    reg.setEmails('root@domain.com', 'tech@domain.com') # Optional    reg.logger.info('Info')    reg.logger.error('Error') # ERROR and above will be sent via email in default configanddef exampleCallback(sg, logger, event, args):    logger.info('Info message')If the event framework is running as a daemon this will be logged to a file otherwise it will be logged to stdout.Building Robust pluginsThe daemon runs queries against ShotGrid but has built in functionality to retry find() commands should they fail, giving the daemon itself a certain degree of robustness.https://github.com/shotgunsoftware/shotgunEvents/blob/master/src/shotgunEventDaemon.py#L456If a plugin needs network resources (be that ShotGrid or some other resource), it needs to provide its own retry mechanisms / robustness. In the case of ShotGrid access you could riff off what’s in the daemon and make a helper function or class that could provide that functionality to your plugins.The ShotGrid Python API does already do some level of retrying on network issues but should you hit a ShotGrid maintenance window that can run a few minutes, or be unlucky enough to hit a network blip, that might not be enough.https://github.com/shotgunsoftware/python-api/blob/master/shotgun_api3/shotgun.py#L1554Depending on what your plugin does, you can also register it to just keep trucking should it encounter issues while processing events. Look at the stopOnError argument of the registerCallback function:https://github.com/shotgunsoftware/shotgunEvents/wiki/API#wiki-registerCallback                    Note: The plugin won’t stop but any failed attempts won’t be retried.    ",
    "url": "/3d05c112/",
    "relUrl": "/3d05c112/"
  },
  "36": {
    "id": "36",
    "title": "Technical Details",
    "content": "Technical OverviewEvent TypesThe event types your triggers can register to be notified of are generally respect the following form Shotgun_[entity_type]_[New|Change|Retirement|Revival]. Here are a few examples of this pattern:Shotgun_Note_NewShotgun_Shot_NewShotgun_Task_ChangeShotgun_CustomEntity06_ChangeShotgun_Playlist_RetirementShotgun_Playlist_RevivalSome notable departures from this pattern are used for events that aren’t related to entity record activity but rather key points in application behavior.CRS_PlaylistShare_CreateCRS_PlaylistShare_Revoke SG_RV_Session_Validate_SuccessShotgun_Attachment_ViewShotgun_Big_QueryShotgun_NotesApp_Summary_EmailShotgun_User_FailedLoginShotgun_User_LoginShotgun_User_LogoutToolkit_App_StartupToolkit_Desktop_ProjectLaunchToolkit_Desktop_AppLaunchToolkit_Folders_CreateToolkit_Folders_Delete    This list is not exhaustive but is a good place to start. If you wish to know more about the activity and event types on your ShotGrid site, please consult a page of EventLogEntries where you can filter and search through like any other grid page of any other entity type.Event Log Entries for ThumbnailsWhen a new thumbnail is uploaded for an entity, an Event Log entry is created with `Type` == `Shotgun_&amp;lt;Entity_Type&amp;gt;_Change` (e.g. Shotgun_Shot_Change).  The ‘is_transient’ field value is set to true:    { &quot;type&quot;: &quot;attribute_change&quot;,&quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656,  &quot;is_transient&quot;: true }        When the thumbnail becomes available, a new Event Log entry is created with the ‘is_transient’ field value now set to false:    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: false }        If we update the thumbnail again, we get these new Event Log entries:    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;,  &quot;old_value&quot;: 11656, &quot;new_value&quot;: 11657,  &quot;is_transient&quot;: true }{ &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;,  &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;,  &quot;old_value&quot;: null, &quot;new_value&quot;: 11657,  &quot;is_transient&quot;: false }        Notice the ‘old_value’ field is set to null when the attachment’s thumbnail is the placeholder thumbnail.Plugin Processing OrderEach event is always processed in the same predictable order so that if any plugins or callbacks are co-dependant, you can safely organize their processing.The configuration file specifies a paths config that contains one or multiple plugin locations. The earlier the location in the list the sooner the contained plugins will be processed.Each plugin within a plugin path is then processed in ascending alphabetical order.                    Note: Internally the filenames are put in a list and sorted.    Finally, each callback registered by a plugin is called in registration order. First registered, first run.We suggested keeping any functionality that needs to share state somehow in the same plugin as one or multiple callbacks.Sharing stateMany options exist for multiple callbacks that need to share state.  Global variables. Ick. Please don’t do this.  An imported module that holds the state information. Ick, but a bit better than simple globals.  A mutable passed in the args argument when calling Registrar.registerCallback. A state object of your design or something as simple as a dict. Preferred.  Implement callbacks such as __call__ on object instances and provide some shared state object at callback object initialization. Most powerful yet most convoluted method. May be redundant compared to the args argument method above.Event BacklogsThe framework is designed to have every plugin process every single event they are interested in exactly once, without exception. To make sure this happens, the framework stores a backlog of unprocessed events for each plugin and remembers the last event each plugin was provided. Here is a description of situations in which a backlog may occur.Backlogs due to gaps in the event log entry sequenceEach event that occurs in ShotGrid (field update, entity creation, entity retirement, etc.) has a unique ID number for its event log entry. Sometimes there are gaps in the ID number sequence. These gaps can occur for many reasons, one of them being a large database transaction that has not yet been completed.Every time there is a gap in the event log sequence the “missing” event IDs are put into a backlog for later processing. This allows for the event daemon to process the events from a long database transaction once it has finished.Sometimes the gap in the event log sequence will never be filled in, such as with a failed transaction or reverted page setting modifications. In this case, after a 5 minute timeout, the system will stop waiting for the event log entry ID number and will remove it from the backlog. When this happens you will see a “Timeout elapsed on backlog event id #” message. If the first time a gap in the event sequence is seen and it is already deemed to have exceeded the timeout, the message will appear as “Event # never happened - ignoring” and it won’t be put in the backlog in the first place.Backlogs due to plugin errorsDuring normal operation, the framework is always tracking the last event that was processed by each plugin. If you have a plugin that fails for any reason it will stop processing further events. When you fix the plugin, by fixing a bug for example, the framework will start processing events at the last event stored for the fixed plugin. This is done in order to make sure the newly fixed plugin gets to process all events, including those that have occurred in the past between the failure and the fix. If the failure occurred long ago, this may mean a lot of events need to be revisited and it may take a while for the fixed plugin to catch up with the other plugins that were functioning normally.While your fixed plugin plays catch-up, the other plugins will be ignoring these events in order to make sure no single event is processed twice by the same plugins. This leads to the “Event X is too old. Last event processed is (Y)” message. This is a debug message and can be safely ignored.There is no formal way to sidestep this. The framework is designed to make sure every single plugin processes every event once and only once. However, If you are familiar with Python and its pickle data format, you can stop the daemon, open the .id file with a Python interpreter/interactive shell, decode its contents with the pickle modules and edit its contents to remove the stored id thus skipping the accrued backlog. This is unsupported and at your own risk. Please backup the .id file appropriately before you do this.",
    "url": "/af5c969c/",
    "relUrl": "/af5c969c/"
  },
  "37": {
    "id": "37",
    "title": "Writing Event-Driven Triggers",
    "content": "ShotGrid  Event FrameworkThis software was originaly developed by Patrick Boucher with support from Rodeo Fx and Oblique. It is now part of ShotGrid  Software’s open source initiative.This software is provided under the MIT License that can be found in the LICENSE file or at the Open Source Initiative website.OverviewWhen you want to access the ShotGrid  event stream, the preferred way to do so it to monitor the events table, get any new events, process them and repeat.A lot of stuff is required for this process to work successfully, stuff that may not have any direct bearing on the business rules that need to be applied.The role of the framework is to keep any tedious monitoring tasks out of the hands of the business logic implementor.The framework is a daemon process that runs on a server and monitors the ShotGrid event stream. When events are found, the daemon hands the events out to a series of registered plugins. Each plugin can process the event as it wishes.The daemon handles:  Registering plugins from one or more specified paths.  Deactivate any crashing plugins.  Reloading plugins when they change on disk.  Monitoring the ShotGrid  event stream.  Remembering the last processed event id and any backlog.  Starting from the last processed event id on daemon startup.  Catching any connection errors.  Logging information to stdout, file or email as required.  Creating a connection to ShotGrid  that will be used by the callback.  Handing off events to registered callbacks.A plugin handles:  Registering any number of callbacks into the framework.  Processing a single event when one is provided by the framework.Advantages of the framework  Only deal with a single monitoring mechanism for all scripts, not one perscript.  Minimize network and database load (only one monitor that supplies event tomany event processing plugins).",
    "url": "/0d8a11d9/",
    "relUrl": "/0d8a11d9/"
  },
  "38": {
    "id": "38",
    "title": "Features Description",
    "content": "Isolation Feature SetThis section describes in detail each of the Isolation Features.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup section.In This Section  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media Replication",
    "url": "/82f8da29/",
    "relUrl": "/82f8da29/"
  },
  "39": {
    "id": "39",
    "title": "Filesystem Configuration Reference",
    "content": "File System Configuration ReferenceThis document is a complete reference of the file system centric configurations in the ShotGrid Pipeline Toolkit. It outlines how the template system works and which options are available. It also shows all the different parameters you can include in the folder creation configuration.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For details, see  ShotGrid Integrations Admin Guide.IntroductionThis document explains how to configure the part of Toolkit’s configuration related to your file system, including examples. Toolkit handles a lot of files and directories, and you can leverage Toolkit’s configuration as a way of expressing how paths are put together and what they mean. The file system is typically accessed in two different and completely separate ways:      Folder Creation:  After an object has been created in ShotGrid, folders on disk need to be created before work can begin. This can be as simple as having a folder on disk representing the Shot, or can be more complex-for example setting up a user specific work sandbox so that each user that works on the shot will work in a separate area on disk.          Toolkit automates folder creation when you launch an application (for example you launch Maya for shot BECH_0010), Toolkit ensures that folders exist prior to launching Maya. If folders do not exist, they are created on the fly. Folders can also be created using API methods, using the  tank command in the shell  and via the  Create Folders menu in ShotGrid. A special set of configuration files drives this folder creation process and this is outlined in  Part 1  of the document below.            Opening and Saving Work:  While working, files need to be opened from and saved into standardized locations on disk. These file locations typically exist within the folder structure created prior to work beginning.          Once a folder structure has been established, we can use that structure to identify key locations on disk. These locations are called  Templates. For example, you can define a template called  maya_shot_publish  to refer to published Maya files for Shots.  Toolkit apps  will then use this template-a publish app may use it to control where it should be writing its files, while a  Workfiles App  may use the template to understand where to open files from. Inside Toolkit’s environment configuration, you can control which templates each app uses. All the key file locations used by Toolkit are therefore defined in a single template file and are easy to overview.      Part 1 - Folder Creation SyntaxThe folder configuration maps entities in ShotGrid to locations on disk. Rather than using a single configuration file, the configuration is in the form of a “mini file system” which acts as a template for each unit that is configured-this is called the  schema configuration. Folders and files will be copied across from this “mini file system” to their target location when Toolkit’s folder creation executes. It is possible to create dynamic behavior. For example, a folder can represent a Shot in ShotGrid, and you can control the naming of that folder. More specifically, you can pull the name of that folder from several ShotGrid fields and then perform character conversions before the folder is created.The above image shows a schema configuration. When you run the Toolkit folder creation, a connection is established between an entity in ShotGrid and a folder on disk. Toolkit uses this folder schema configuration to generate a series of folders on disk and each of these folders are registered as a  Filesystem Location  entity in ShotGrid. One way to think about this is that ShotGrid data (e.g., Shot and Asset names) and the configuration is “baked” out into actual folders on disk and in ShotGrid. Configurations always start with a folder named “project”. This will always represent the connected project in ShotGrid and will be replaced with the Toolkit name for the project. Below this level are static folders. The folder creator will automatically create the  sequencesfolder, for example.Digging further inside the sequences folder, there is a  sequence  folder and a  sequence.yml  file. Whenever Toolkit detects a YAML file with the same name as a folder, it will read the contents of the YAML file and add the desired dynamic behavior. In this case, the  sequence.yml  file contains the structure underneath the project folder, which consists of three types of items:  Normal folders and files:  these are simply copied across to the target location.  A folder with a YAML file  (having the same name as the folder): this represents dynamic content. For example, there may be a  shot  and  shot.yml  and when folders are created, this  shot  folder is the template used to generate a number of folders-one folder per shot.  A file named name.symlink.yml  which will generate a symbolic link as folders are being processed.  Symbolic links are covered later in this document.The dynamic configuration setup expressed in the YAML files currently supports the following modes:      ShotGrid Query folders:  Dynamic folder names based on a ShotGrid Database Query. For example, this mode can be used to create a folder for every Shot in a project.        ShotGrid List Field folders:  Dynamic folder names based on a ShotGrid List Field. For example, this mode can be used to create a folder for every value in the ShotGrid List field “Asset Type”, found on the Asset Entity in ShotGrid.        Deferred folders:  Only executed when a second folder creation pass is requested via the create folders method of the Toolkit API, usually when an application (such as Maya) is launched. Typically, this method is executed by Toolkit’s various application launchers just prior to starting up an application.        Current User Folders:  A special folder, which represents the current user.  Let’s dive deeper into these modes.ShotGrid Query FoldersFor a dynamic folder which corresponds to a ShotGrid query, use the following syntax in your YAML file:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: shotgun_entity&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: Asset&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: code&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]   Set the value of dynamic content  type  field to be  shotgun_entity.  The  entity_type  field should be set to the ShotGrid entity from which we want to pull data from (e.g., “Asset”, “Shot”, “Sequence”, “CustomEntity02”, etc).      The  name  field is the name that should be given to each folder based on the data in ShotGrid.          You can use a single field, like in the example above (e.g.,  name: code).      You can use multiple fields in brackets (e.g.,  name:  &quot;{asset_type}_{code}&quot;).      If you want to include fields from other linked entities, you can use the standard ShotGrid dot syntax (e.g.,  name: &quot;{sg_sequence.Sequence.code}_{code}&quot;).        The  filters  field is a ShotGrid Query. It follows the  ShotGrid API syntax  relatively closely. It is a list of dictionaries, and each dictionary needs to have the keys  path,  relation, and  values. Valid values for $syntax are any ancestor folder that has a corresponding ShotGrid entity (e.g.,  &quot;$project&quot;  for the Project and  &quot;$sequence&quot;  if you have a sequence.yml higher up the directory hierarchy). For ShotGrid entity links, you can use the $syntax (e.g.,  { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }) to refer to a parent folder in the configuration-this is explained more in depth in the  examples below.Multiple foldersInclude a slash in your name definition in order to create an expression which creates multiple folders at once:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: shotgun_entity&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: Asset&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;{sg_asset_type}/{code}&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] When creating a file system template (see for a Part 2 of this document for details) for this kind of path, the  _last_folder will represent the ShotGrid entity. The example above could for example be expressed with the following templateasset_step_folder: assets/{asset_type}/{Asset}/{Step}{asset_type}  and  {Asset}  are both defined as string template keys and the  {Asset}  token will be used in context calculations when determining the context for a given path.Create With Parent FolderIn ShotGrid, there is nesting within ShotGrid data structures. This nesting can be referred to as a Parent to Child relationship, and vice versa. For instance, Sequences are typically parents to Shots in the file system, and likewise, Shots are typically Children to Sequences.                    Note: This filesystem nesting relationship is independent from the  ShotGrid Hierarchy, and there is no connection between the two. They are configured completely independently.    A shotgun_entity type folder supports an optional flag to control whether the folder creation process tries to recurse down into it when a parent is created, so that the child will also be created. Flags are settings that can only have certain fixed values, in this case “true” or “false”. To add this flag, use this example:&amp;lt;a name=&quot;recurse down from parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# recurse down from parent foldercreate_with_parent: true As mentioned, this setting is optional and set to false by default. If you set it to true, Toolkit create folders for any child entity it finds. To continue with our example, if you want Shots to be created whenever their parent Sequence is created, set  create_with_parent  to  true  for the Shot.                    Note: the default setting is  false, meaning that if you create folders for a Sequence, shot folders will not be created automatically. Also, you will need to add this flag to make it true. There will not be a flag in the shotgun_entity folder specifying false since false is the default behavior.    Optional fieldsTypically, when you define the folder name (e.g.,  {code}_{sg_extra_field}), Toolkit requires all fields to have values in ShotGrid. For example, if the  sg_extra_field  is blank, an error message will be generated. If you have a field that is sometimes populated and sometimes not, you can mark it as optional. This means that Toolkit will include the field if it has a value, and exclude it if the value is blank-without error.You define optional fields using square brackets, like:  {code}[_{sg_extra_field}]. This will generate the following folder names:  If the  code  is BECH_0010 and the  sg_extra_field  is extra, the folder name will be  BECH_0010_extra.  If the  code  is BECH_0010 and the  sg_extra_field  is blank, the folder name will be  BECH_0010.                    Note: optional fields can only be used to define part of the name of a folder in your schema. An entire folder can not be optional.    Regular expression token matchingToolkit supports the extraction of parts of a ShotGrid field name using regular expressions. This makes it possible to create simple expressions where a value in ShotGrid can drive the folder creation. For example, if all assets in ShotGrid are named with a three letter prefix followed by an underscore (e.g  AAT_Boulder7), this can split into two filesystem folder levels, e.g.  AAT/Boulder7:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: shotgun_entity&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: Asset&amp;lt;a name=&quot;Extract parts of the name using regular expressions&quot;&amp;gt;&amp;lt;/a&amp;gt;# Extract parts of the name using regular expressionsname: &quot;{code:^([^_]+)}/{code^[^_]+_(.*)}&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]The syntax is similar to the  subset  tokens in the Template system; Simply add a colon after the ShotGrid field name, then followed by a regular expression. Any groups (e.g. sections surrounded by  ()s) defined in the regular expression will be used to extract values. If there are multiple groups in the regex, these will be concatenated together. For example, the following expression would extract the intials for the user who created an object:  {created_by.HumanUser.code:^([A-Z])[a-z]* ([A-Z])[a-z]*}ExamplesBelow are a collection of examples showing how to use the filters syntax.To  find all shots which belong to the current project and are in progress, use the syntax below. Note that the ShotGrid Shot entity has a link field called project which connects a shot to a project. We want to make sure that we only create folders for the shots that are associated with the current project. Since there is a project level higher up in the configuration file system, we can refer to this via the $syntax and Toolkit will automatically create to this ShotGrid entity link reference. Remember, valid values for $syntax are any ancestor folder that has a corresponding ShotGrid entity (e.g.,  &quot;$project&quot;  for the Project and  &quot;$sequence&quot;  if you have a sequence.yml higher up the directory hierarchy).entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;status&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;ip&quot; ] }If you have a Sequence folder higher up the tree and want to  create folders for all Shots which belong to that Sequence, you can create the following filters:entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] }To  find all assets  use this syntax:entity_type: Assetfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]ShotGrid List Field FoldersShotGrid list field  folders are useful if you want to create one folder for every asset type in ShotGrid, for instance. Asset types are list fields in ShotGrid, and this folder config type makes it possible to define a layer in the file system that reflects those asset type listings.                    Note: once folders have been created on disk, we strongly advise not to change the value (e.g., the asset type) on the associated data.    When you want a dynamic folder which corresponds to all the items in a ShotGrid list field, use the following syntax in your YAML file:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_list_field&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Asset&quot;&amp;lt;a name=&quot;only create for values which are used in this project.&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create for values which are used in this project.&amp;lt;a name=&quot;this is optional and will be set to false if not specified.&quot;&amp;gt;&amp;lt;/a&amp;gt;# this is optional and will be set to false if not specified.skip_unused: false&amp;lt;a name=&quot;by default, list fields are only created if they are needed by a child entity node&quot;&amp;gt;&amp;lt;/a&amp;gt;# by default, list fields are only created if they are needed by a child entity node&amp;lt;a name=&quot;by setting the create_with_parent parameter to true you ensure that list field&quot;&amp;gt;&amp;lt;/a&amp;gt;# by setting the create_with_parent parameter to true you ensure that list field&amp;lt;a name=&quot;nodes are always created&quot;&amp;gt;&amp;lt;/a&amp;gt;# nodes are always createdcreate_with_parent: false&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namefield_name: &quot;{sg_asset_type}_type&quot;  Set value of dynamic content  type  field to be  shotgun_list_field.  The  entity_type  field should be set to the ShotGrid entity from which we want to pull data (for instance, “Asset”, “Sequence”, “Shot”, etc.).      The  field_name  field should be set to the ShotGrid field from which the data is pulled from and must be a  list type field. You can use expressions if you want to add static text alongside the dynamic content.field_name: &quot;{sg_asset_type}_type&quot;  This example expression includes text as well as a template key.    The optional  skip_unused  parameter will prevent the creation of directories for list type field values which are not used (as covered under the  Optional Fields  section above).                    Note: setting this to True may negatively affect folder creation performance. Also, the culling algorithm is currently crude and does not work in scenarios where complex filters have been applied to the associated entity.      The optional  create_with_parent  parameter forces the creation of the list_field node, even if there isn’t a child entity level node that is currently being processed (see  Create With Parent Folder  section above).Pipeline Step FolderThe Pipeline Step folder represents a  Pipeline Step  in ShotGrid. Pipeline Steps are also referred to as Steps.&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_step&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name. This field needs to come from a step entity.&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder name. This field needs to come from a step entity.name: &quot;short_name&quot;You can use name expressions here, just like you can with the  ShotGrid entity described above. The node will look at its parent, grandparent, etc., until a ShotGrid entity folder configuration is found. This entity folder will be associated with the Step and the type of the entity will be used to determine which Steps to create.                    Note: If you want to create a top level folder with Pipeline Steps, just use the ShotGrid entity node and set the associated type to step.    By default, the Step folder will try to create all the relevant Steps for a particular entity automatically. For example, if the folder creation is triggered for a shot which has five Steps (Layout, Animation, FX, Lighting, Compositing), Step folders will automatically be created for those five Steps (Layout, Animation, FX, Lighting, Compositing).You can, however, turn this off by using the following syntax:&amp;lt;a name=&quot;recurse down from parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# recurse down from parent foldercreate_with_parent: falseAdding this setting to the configuration means that no Step folders will be created when a Shot folder is created. Instead, Step folders will be created only when you run the folder creation on a Task. This can be useful if you want to configure user sandboxes and other structures which are created just before work starts.Different file system layouts for different pipeline stepsImagine you want to have one folder structure for Lighting and Comp and one for everything else. If you want to have different file system layouts for different Pipeline Steps, you can achieve this by adding a  filter  clause to your config. This filter allows you to scope which Pipeline Steps will be covered by a particular Step’s configuration. In our example, you can create two configuration files:  step_lightcomp.yml  and  step.yml. In the first one, you would add the following filter:filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ] The above syntax will only be used when Step folders of the type  Light  or  Comp  are being created. For the other file, we want to create a rule for everything else:filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;not_in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ]Now you can define separate sub structures in each of these folders.Advanced: Specifying a parentAs part of the folder creation, Toolkit needs to associate a Pipeline Step with an entity (e.g., “Shot”, “Asset”, etc). Toolkit does this by default by looking up the folder tree and picking the first ShotGrid entity folder it finds. For example, if you have the hierarchy  Sequence &amp;gt; Shot &amp;gt; Step, the Step folder will automatically be associated with the Shot, which is typically what you want.However, if you have a hierarchy with entities below your primary entity, for example  Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Step, Toolkit will, by default, associate the Step with the Department level, which is not desired. In this case, we need to explicitly tell Toolkit where to look. We can do this by adding the following to the Step configuration:associated_entity_type: ShotShotGrid Task FolderThe Task folder represents a  Task  in ShotGrid. By default, the Task folder will not will not be created with its parent. For example, if the folder creation is triggered for a Shot which has a Task node associated, the Task folders will not be created automatically. Instead, Task folders will only be created when the folder creation is executed for the Task (e.g., launching a Task from ShotGrid).&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_task&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name. This field needs to come from a task entity.&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder name. This field needs to come from a task entity.name: &quot;content&quot; You can, however, turn on creation so that Tasks are created with their parent entity by using the following syntax:&amp;lt;a name=&quot;recurse down from parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# recurse down from parent foldercreate_with_parent: trueSimilar to a Step, you can also optionally supply a  filter  parameter if you want to filter which Tasks your folder configuration should operate on.Once again, you can use name expressions, just like you can with the  ShotGrid entity described above, where static text can be used alongside dynamic content so that you can create a name that has both dynamic and static context.name: &quot;task_{content}&quot;The node will look at its parent, grandparent etc., until a ShotGrid entity folder configuration is found. This entity folder will be associated with the task and will be used to determine which task folders to create.Advanced: Specifying a parentAs part of the folder creation, Toolkit needs to associate a Task with an entity (e.g., a Shot, an Asset, etc.). Toolkit does this by default by looking up the folder tree and picking the first ShotGrid entity folder it finds. For example, if you have the hierarchy  Sequence &amp;gt; Shot &amp;gt; Task, the Task folder will automatically be associated with the Shot, which is typically what you want.However, if you have a hierarchy with entities below your primary entity (e.g., below Shot), like  Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Task,  Toolkit would by default associate the Task with the department level, which is not desired. In this case, we need to explicitly tell Toolkit where to look, similarly to how we updated this with Steps in the  previous section. We can do this by adding the following to the Task configuration:associated_entity_type: ShotWorkspaces and Deferred Folder CreationDeferred folder creation means that creation will only be executed when a second folder creation pass is requested via the optional  engine  parameter in the create folders method of the Toolkit API. Typically, this method is executed by Toolkit’s various application launchers just prior to starting up an application. Most folder types support a deferred flag, which is  false  by default. To make deferred folder creation  true, you can add this flag:&amp;lt;a name=&quot;only create this folder when tk.create_filesystem_structure is&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create this folder when tk.create_filesystem_structure is&amp;lt;a name=&quot;called with tk-maya, tk-nuke or any-custom-string.&quot;&amp;gt;&amp;lt;/a&amp;gt;# called with tk-maya, tk-nuke or any-custom-string.defer_creation: [&quot;tk-maya&quot;, &quot;tk-nuke&quot;, &quot;any-custom-string]&amp;lt;a  name=&quot;create this folder when any application launches, but not when normal folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# create this folder when any application launches, but not when normal folder&amp;lt;a name=&quot;creation runs&quot;&amp;gt;&amp;lt;/a&amp;gt;# creation runsdefer_creation: trueThis flag makes it possible to split the folder creation in half-one part that runs in a first “global” pass and a second pass that runs at a later point. Typically, the second pass is associated with the engine launching (although it does not happen automatically since the default is  false) and allows for a user to create folders just before engine startup. This allows for two primary workflows:  Workspaces:  Application specific folder setups. Folders can be created just before an application launches.  A common workflow for this is to have a Pipeline Step that might require Houdini, Maya, and another Engine, depending on what the shot requires and how an Artist chooses to tackle it. The Artist can create maya/, houdini/, and other directories for that Pipeline Step initially, but if the Artist on a given shot only ever works in Maya, empty folders for Houdini and any other Engine are unnecessary. So, if you defer the folder creation to happen at the time of the launch of individual engines, then if an Artist never uses Houdini, the houdini/ folder will not be created for that shot.  User folders:  A user folder is created just before application launch. The user folder config construct (described above) is deferred by default.  This can happen so that instead of basing a user folder on the assigned user in ShotGrid, you can create a folder for the current user whenever they launch an Engine. For instance, if you start working on a shot, and you launch Maya, a username folder will be created for you (based on your username in ShotGrid), and you will not interfere with anyone else’s work.Tip: If you prefer a normal, static folder to be created when an application (like Maya) launches, just create a config YAML file named the same as the folder and add the following:&amp;lt;a name=&quot;type of content&quot;&amp;gt;&amp;lt;/a&amp;gt;# type of contenttype: &quot;static&quot;&amp;lt;a name=&quot;only create this folder for maya&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create this folder for mayadefer_creation: &quot;tk-maya&quot;:::yaml&amp;lt;a name=&quot;type of content&quot;&amp;gt;&amp;lt;/a&amp;gt;# type of contenttype: &quot;static&quot;&amp;lt;a name=&quot;only create this folder when tk.create_filesystem_structure is&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create this folder when tk.create_filesystem_structure is&amp;lt;a name=&quot;called with any-custom-string.&quot;&amp;gt;&amp;lt;/a&amp;gt;# called with any-custom-string.defer_creation: &quot;any-custom-string&quot; Current User FolderThe current user folder is a special construct that lets you set up work areas for different users. A common scenario is if you have multiple artists from a department working on the same shot. User folders can be used so that artists can store their workfiles in their own directories and be able to filter just for their files in the  Workfiles App. In this case, the configuration file needs to include the following options:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;user_workspace&quot;name: &quot;login&quot;  Set value of  type  field to be  user_workspace.  The  name  field is the name that should be given to a user folder. It must consist of a combination of fields fetched from People in ShotGrid (HumanUser  in ShotGrid).  You can use a single field, like in the example above (e.g.,  name: login).  You can use multiple fields in brackets (e.g.,  name: &quot;{firstname}_{lastname}&quot;).  If you want to include fields from other linked entities, you can use the standard ShotGrid dot syntax (e.g.,  name: &quot;{sg_group.Group.code}_{login}&quot;).The current user folder is created as a deferred folder by default, meaning that it will only be executed when a second folder creation pass is requested via the optional  engine  parameter in the create folders method of the Toolkit API.Static foldersStatic folders (and files) are the most simple type. You can drop them into the configuration structure, and they will automatically get copied across when the folder creation process executes.  Here are some examples of static folders  (https://github.com/shotgunsoftware/tk-config-default/tree/master/core/schema/project) in the default configuration (note that static folders do not have a corresponding YAML file).Often, you will not need to go beyond this for static folders; however, Toolkit does support some more advanced functionality for static folders. It is possible to define dynamic conditions to determine if a static folder should get created. For example, you may want to have special static folders that only get created for Pipeline Steps of the Editorial type. In this case, you need to add a YAML configuration file next to the static folder and give it the same name, with the extension “yml”. Then, use the following syntax:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;static&quot;&amp;lt;a name=&quot;pick one of the ShotGrid folders that are above this folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# pick one of the ShotGrid folders that are above this folder&amp;lt;a name=&quot;in the folder hierarchy. In this case it is a parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# in the folder hierarchy. In this case it is a parent folder&amp;lt;a name=&quot;named step that we want to look at when deciding if this&quot;&amp;gt;&amp;lt;/a&amp;gt;# named step that we want to look at when deciding if this&amp;lt;a name=&quot;static folder should be created or not.&quot;&amp;gt;&amp;lt;/a&amp;gt;# static folder should be created or not.constrain_by_entity: &quot;$step&quot;&amp;lt;a name=&quot;we can now define constraints for this step. Constraints are simple&quot;&amp;gt;&amp;lt;/a&amp;gt;# we can now define constraints for this step. Constraints are simple&amp;lt;a name=&quot;ShotGrid queries, following the same syntax as the other ShotGrid filters&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid queries, following the same syntax as the other ShotGrid filters&amp;lt;a name=&quot;shown in previous sections.&quot;&amp;gt;&amp;lt;/a&amp;gt;# shown in previous sections.#&amp;lt;a name=&quot;In our example, if the parent step matches the constraints given&quot;&amp;gt;&amp;lt;/a&amp;gt;# In our example, if the parent step matches the constraints given&amp;lt;a name=&quot;in the filter below, the static folder will be created. If not,&quot;&amp;gt;&amp;lt;/a&amp;gt;# in the filter below, the static folder will be created. If not,&amp;lt;a name=&quot;it (and its children) will be ignored by the folder creation process.&quot;&amp;gt;&amp;lt;/a&amp;gt;# it (and its children) will be ignored by the folder creation process.constraints:    - { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;edit&quot; ] } By default, static folders will automatically get created together with their parent folder. There may be cases where this is not desirable, and in those cases you can add a special flag to indicate that the static folder should not be created together with its parent:&amp;lt;a name=&quot;do not recurse down automatically&quot;&amp;gt;&amp;lt;/a&amp;gt;# do not recurse down automaticallycreate_with_parent: false Symbolic LinksYou can create symbolic links (symlink) as part of the dynamic folder creation. If you want to create a symbolic link with the name  artwork, create a file in your schema configuration named  artwork.symlink.yml. This will be identified by the system as a symbolic link request and will not be copied across, but will instead be processed.The  artwork.symlink.yml  file must, at the very least, contain a  target  key:&amp;lt;a name=&quot;Example of a .symlink.yml file&quot;&amp;gt;&amp;lt;/a&amp;gt;# Example of a .symlink.yml file&amp;lt;a name=&quot;A target parameter is required.&quot;&amp;gt;&amp;lt;/a&amp;gt;# A target parameter is required.target: &quot;../Stuff/$Project/$Shot&quot;&amp;lt;a name=&quot;Additional parameters will be passed to the hook as metadata&quot;&amp;gt;&amp;lt;/a&amp;gt;# Additional parameters will be passed to the hook as metadata&amp;lt;a name=&quot;so you can for example include permission hints or other stuff&quot;&amp;gt;&amp;lt;/a&amp;gt;# so you can for example include permission hints or other stuff&amp;lt;a name=&quot;that you may need for advanced customization&quot;&amp;gt;&amp;lt;/a&amp;gt;# that you may need for advanced customizationadditional_param1: abcadditional_param2: def If the target parameter contains  $EntityType  tokens such as  $Asset,  $Shot, or  $Project, these will attempt to be resolved with the name of the folder representing that entity (Asset, Shot, Project, etc.). Toolkit will look up the filesystem tree for these values and if they are not defined higher up in the tree, an error will be reported.List fields, such as asset type on assets, are expressed with a syntax that includes the entity type, e.g.  $Asset.sg_asset_type. For example:&amp;lt;a name=&quot;Example of a .symlink.yml file&quot;&amp;gt;&amp;lt;/a&amp;gt;# Example of a .symlink.yml file&amp;lt;a name=&quot;A target parameter is required.&quot;&amp;gt;&amp;lt;/a&amp;gt;# A target parameter is required.target: &quot;../renders/$Project/$Asset.sg_asset_type/$Asset&quot;Symlink creation happens (like all input/output, or I/O) inside the folder processing hook. A special  symlinkaction is passed from the system into the hook, and you will get the name of the symlink, the fully resolved target, and all the YAML metadata contained within the definition file along with this request. For our  artworkexample above, we create the folder under the Shot like this: {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  }Ignoring files and foldersFiles that are placed in the schema scaffold will be copied across into the target area as part of the folder creation. This copy process is handled by a core hook, so for example, permissions handling can be customized for a project or studio.                    Note: There are more details on this kind of handling in the  Customizing I/O and Permissions sectionCustomizing I/O and Permissions section under Simple Customization. We have a  process_folder_creation core hook  (https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71) that handles a lot of folder setup. You can add chmod calls into this hook (and/or set permissions as you mkdir), thereby setting permissions for the folders you are creating.    Sometimes it can be useful to exclude certain files and folders from being copied across as part of the folder creation. For example, if you store your folder creation configs in Git or SVN, you will have  .git  and  .svnfolders that you will not want to copy to each Shot or Asset folder. If there are files which you do not want to have copied, a file named  ignore_files  can be placed in the  config/core/schema  folder inside the project configuration. This file should contain glob-style patterns to define files not to copy. Each pattern should be on a separate line:&amp;lt;a name=&quot;This is a good example of a standard ignore_files file&quot;&amp;gt;&amp;lt;/a&amp;gt;# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time.DS_Store           # no mac temp files to be copied across at folder creation time You can also use wildcards. For example, if you need to exclude all files with the TMP extension, just add a *.tmp line to the file.&amp;lt;a name=&quot;This is a good example of a standard ignore_files file&quot;&amp;gt;&amp;lt;/a&amp;gt;# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time*.tmp           # no files with tmp extension to be copied across at folder creation timeCustomizing I/O and PermissionsShot and Asset folders often need to be created with special permissions and parameters. Sometimes this is as simple as setting permission bits during the folder creation, and sometimes it may be as complex as sending a remote request to a special folder creation server that will create the folders with the appropriate credentials, groups, and permissions.It is also common that folders on different levels in the file system tree need to have different permissions; a work area folder is typically writeable for everybody, whereas a shot folder may have much stricter permissions.Toolkit allows for customization of the folder creation via a single hook. This is a core hook and it is named  process_folder_creation.py. As the folder creation API call is traversing the folder configuration and deciding which folders should be created, it builds up a list of items that could be created. These items can be both files and folders. As the final step of the folder creation, this list is passed to a hook to handle the actual folder processing. You can examine the default  process_folder_creation core hook here(https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71).Data passed to the hookThe folder creation hook is executed just once for each folder creation request. All the folder creation data is passed in a list to the hook and the hook typically loops over this and creates the folders according to the parameters passed from the Core API.The data in the list is always a depth first recursion, starting with the top level folders and files and then traversing deeper and deeper. Here is an example of what the data passed to the hook may look like:[ {'action': 'entity_folder',  'entity': {'id': 88, 'name': 'Chasing the Light', 'type': 'Project'},  'metadata': {'root_name': 'primary', 'type': 'project'},  'path': '/mnt/projects/chasing_the_light'}, {'action': 'folder',  'metadata': {'type': 'static'},  'path': '/mnt/projects/chasing_the_light/sequences'}, {'action': 'entity_folder',  'entity': {'id': 32, 'name': 'aa2', 'type': 'Sequence'},  'metadata': {'entity_type': 'Sequence',               'filters': [{'path': 'project',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04c90&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2'}, {'action': 'entity_folder',  'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'}, {'action': 'copy',  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'source_path': '/mnt/software/tank/chasing_the_light/config/core/schema/project/sequences/sequence/shot/sgtk_overrides.yml',  'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/sgtk_overrides.yml'}, {'action': 'create_file',  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'content': 'foo bar',  'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/automatic_content.txt'}, {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  },]The data is a list of dictionaries. Each dictionary has a key called  action. This key denotes the type of I/O item that is requested. If you are implementing the folder creation hook, you need to add support for the following different actions:  entity_folder: A folder on disk which is associated with a ShotGrid entity.  folder: A folder on disk.  copy: A file that needs to be copied from a source location to a target location.  create_file:- A file that needs to be created on disk.  symlink: A symbolic link should be created.Each of the actions have a different set of dictionary keys. For example, the  entity_folder  action has an  entity key  which contains the details of the entity that it is connected to. The  create_file  has a  source_path  and a  target_path  key which inform the hook which file to copy and where.All  actions  also have a key called  metadata. This key represents the YAML configuration data that comes from the associated configuration file in the schema setup. You can see in the example above how the  metadata  key for a ShotGrid folder contains all the filter and naming information that is set up within the schema configuration. For example, here is the metadata for the Shot folder in the example above:{'action': 'entity_folder',  'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} …which corresponds to the  shot.yml  schema configuration file:&amp;lt;a name=&quot;Copyright (c) 2013 ShotGrid Software Inc.&quot;&amp;gt;&amp;lt;/a&amp;gt;# Copyright (c) 2013 ShotGrid Software Inc.#&amp;lt;a name=&quot;CONFIDENTIAL AND PROPRIETARY&quot;&amp;gt;&amp;lt;/a&amp;gt;# CONFIDENTIAL AND PROPRIETARY#&amp;lt;a name=&quot;This work is provided _AS IS_ and subject to the ShotGrid Pipeline Toolkit&quot;&amp;gt;&amp;lt;/a&amp;gt;# This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit&amp;lt;a name=&quot;Source Code License included in this distribution package. See LICENSE.&quot;&amp;gt;&amp;lt;/a&amp;gt;# Source Code License included in this distribution package. See LICENSE.&amp;lt;a name=&quot;By accessing, using, copying or modifying this work you indicate your&quot;&amp;gt;&amp;lt;/a&amp;gt;# By accessing, using, copying or modifying this work you indicate your&amp;lt;a name=&quot;agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights&quot;&amp;gt;&amp;lt;/a&amp;gt;# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights&amp;lt;a name=&quot;not expressly granted therein are reserved by ShotGrid Software Inc.&quot;&amp;gt;&amp;lt;/a&amp;gt;# not expressly granted therein are reserved by ShotGrid Software Inc.&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ] Note that the dynamic token  $sequence  has been resolved into an actual object at runtime.Passing your own folder creation directives to the hookIn addition to the various configuration directives required by Toolkit, you can also define your own configuration items as part of the schema configuration. These are passed into the hook via the  metadata  key described above, and can be used to drive folder creation.For example, if you had the following structure in your schema setup:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of itemsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]&amp;lt;a name=&quot;user settings&quot;&amp;gt;&amp;lt;/a&amp;gt;# user settingsstudio_permissions_level: &quot;admin&quot; …the data passed via the folder creation hook would be:{'action': 'entity_folder',  'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity',               'studio_permissions_level': 'admin'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} Now the special parameter  studio_permissions_level  is passed into the hook and you can use that, for example, to control file permissions. You can also pass arbitrarily complex data structures using this method. A typical usecase for this would be to control permissions at a very detailed level.Adding custom configuration to static foldersTypically, when you create a folder inside the folder schema configuration, and it does not have a corresponding YAML file, Toolkit will assume that it is a static folder and will simply create it.If you would like to associate custom configuration metadata with a static folder, you have to create a YAML configuration file with the  static  type. For example, let’s say you have a static  assets  folder just under the project root and would like to group together assets and add custom configuration metadata. To achieve this, create the following  assets.yml  file:type: staticstudio_permissions_level: &quot;admin&quot;The configuration data passed to the hook will then contain the following:{'action': 'folder', 'metadata': {'studio_permissions_level': 'admin', 'type': 'static'}, 'path': '/mnt/projects/chasing_the_light/assets'},Again, arbitrarily complex data can be passed from the YAML configuration file into the hook in this way.Simple customization of how folders are createdA simple folder creation hook could look something like this:class ProcessFolderCreation(Hook):    def execute(self, items, preview_mode, **kwargs):        &quot;&quot;&quot; The default implementation creates folders recursively using open permissions. This hook should return a list of created items. Items is a list of dictionaries. Each dictionary can be of the following type: Standard Folder --------------- This represents a standard folder in the file system which is not associated with anything in ShotGrid. It contains the following keys: * &quot;action&quot;: &quot;folder&quot; * &quot;metadata&quot;: The configuration yaml data for this item * &quot;path&quot;: path on disk to the item Entity Folder ------------- This represents a folder in the file system which is associated with a ShotGrid entity. It contains the following keys: * &quot;action&quot;: &quot;entity_folder&quot; * &quot;metadata&quot;: The configuration yaml data for this item * &quot;path&quot;: path on disk to the item * &quot;entity&quot;: ShotGrid entity link dict with keys type, id and name. File Copy --------- This represents a file copy operation which should be carried out. It contains the following keys: * &quot;action&quot;: &quot;copy&quot; * &quot;metadata&quot;: The configuration yaml data associated with the directory level on which this object exists. * &quot;source_path&quot;: location of the file that should be copied * &quot;target_path&quot;: target location to where the file should be copied. File Creation ------------- This is similar to the file copy, but instead of a source path, a chunk of data is specified. It contains the following keys: * &quot;action&quot;: &quot;create_file&quot; * &quot;metadata&quot;: The configuration yaml data associated with the directory level on which this object exists. * &quot;content&quot;: file content * &quot;target_path&quot;: target location to where the file should be copied. &quot;&quot;&quot;        # set the umask so that we get true permissions        old_umask = os.umask(0)        folders = []        try:            # loop through our list of items            for i in items:                action = i.get(&quot;action&quot;)                if action == &quot;entity_folder&quot; or action == &quot;folder&quot;:                    # folder creation                    path = i.get(&quot;path&quot;)                    if not os.path.exists(path):                        if not preview_mode:                            # create the folder using open permissions                            os.makedirs(path, 0777)                        folders.append(path)                elif action == &quot;copy&quot;:                    # a file copy                    source_path = i.get(&quot;source_path&quot;)                    target_path = i.get(&quot;target_path&quot;)                    if not os.path.exists(target_path):                        if not preview_mode:                            # do a standard file copy                            shutil.copy(source_path, target_path)                            # set permissions to open                            os.chmod(target_path, 0666)                        folders.append(target_path)                elif action == &quot;create_file&quot;:                    # create a new file based on content                    path = i.get(&quot;path&quot;)                    parent_folder = os.path.dirname(path)                    content = i.get(&quot;content&quot;)                    if not os.path.exists(parent_folder) and not preview_mode:                        os.makedirs(parent_folder, 0777)                    if not os.path.exists(path):                        if not preview_mode:                            # create the file                            fp = open(path, &quot;wb&quot;)                            fp.write(content)                            fp.close()                            # and set permissions to open                            os.chmod(path, 0666)                        folders.append(path)                else:                    raise Exception(&quot;Unknown folder hook action '%s'&quot; % action)        finally:            # reset umask            os.umask(old_umask)        return folders Part 2 - Configuring File System TemplatesThe Toolkit templates file is one of the hubs of the Toolkit configuration. There is always one of these files per project and it resides inside the  config/core  folder inside your pipeline configuration.This file contains definitions for  templates  and their  keys.A  key  is a dynamic field we defined. It can be a name, a version number, a screen resolution, a shot name etc. Keys are configured with types, so we can define that a key should be a string or an int for example. They are also formatted, so we can define that a string should only contain alpha numeric characters, or that all integers should be padded with eight zeroes.A  template  is a dynamic path. An example of a template is  shots/{shot}/publish/{name}.{version}.ma. This template could for represent maya publishes for a shot - the bracketed fields are keys.The templates file is divided into three sections: keys, paths and strings.The Keys SectionKeys define what values are acceptable for fields. In the template config file keys are defined in the form:key_name:   type: key_type   option: option_value   option: option_value Key type is either  str,  int, or  sequence. Str keys are keys whose values are strings, int keys are keys whose values are integers, and sequence keys are keys whose values are sequences of integers.In addition to specifying the type, you can also specify additional options. The following options exist:      default: default_value  - Value used if no value was supplied. This can happen if you are using the Toolkit API and trying to resolve a set of field values into a path for example.        choices: [choice1, choice2, etc]  - An enumeration of possible values for this key.        exclusions: [bad1, bad2, etc]  - An enumeration of forbidden values for this key. If key is of type sequence, frame spec values cannot be invalidated with this setting.        length: 12  - This key needs to be of an exact length.        alias: new_name  - Provides a name which will be used by templates using this key rather than the key_name. For example if you have two concepts of a version number, one is four zero padded because that is how the client wants it, and one is three zero padded because that how it is handled internally - in this case you really want both keys named “version” but this is not really possible since key names need to be unique. In this case you can create an alias. See one of the examples below for more information.        filter_by: alphanumeric  - Only works for keys of type string. If this option is specified, only strings containing alphanumeric values (typically a-z, A-Z and 0-9 for ascii strings but may include other characters if your input data is unicode) will be considered valid values.        filter_by: alpha  - Only works for keys of type string. If this option is specified, only strings containing alpha values (typically a-z, A-Z for ascii strings but may include other characters if your input data is unicode) will be considered valid values.        filter_by: '^[0-9]{4}_[a-z]{3}$'  - Only works for keys of type string. You can define a regular expression as a validation mask. The above example would for example require the key to have four digits, then an underscore and finally three lower case letters.        format_spec: &quot;04&quot;  - For keys of type int and sequence, this setting means that the int or sequence number will be zero or space padded. Specifying “04” like in the example will result in a four digit long zero padded number (e.g. 0003). Specifying “03” would result in three digit long zero padded number (e.g. 042), etc. Specifying “3” would result in three digit long space padded number (e.g. “ 3”). For keys of type timestamp, the format_spec follows the  strftime and strptime convention.        strict_matching: true  - Only works for keys of type type int. This settings means that the field will only match numbers that have been properly formatted. For example, given “003” and strict_matching set to true, we would match “002”, “12345” and “042”, but not “00003” or “2”. If you need the matching to be less strict, set strict_matching to false. The default behavior is to strictly match.        shotgun_entity_type  - When used in conjunction with the  shotgun_field_name  option, will cause contexts to query ShotGrid directly for values. This allows using values from fields not seen in the folder structure to be used in file names.        shotgun_field_name  - Only used in conjunction with  shotgun_entity_type.        abstract  - Denotes that the field is abstract. Abstract fields are used when a pattern is needed to describe a path - for example image sequences (%04d) or stereo (%V). Abstract fields require a default value.        subset  and  subset_format  - Extracts a subset of the given input string and makes that the key value, allowing you to create for example an initials key from a full username or a key that holds the three first letters of every shot name.  For technical details about template keys, see the  API reference.Example - An alphanumeric nameA name that defaults to “comp” and that is alphanumeric:name:    type: str    default: &quot;comp&quot;    filter_by: alphanumericnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{version}.nk Example - Version numberA version number that would match numbers such as 002, 102, 034, 12341version:    type: int    format_spec: &quot;03&quot; A version number that would match numbers such as 002, 102, 034, 12341, but also 0002, 2 and 0102version:    type: int    format_spec: &quot;03&quot;    strict_matching: false Example - A stereo eyeA typical stereo eye setup. The eye field is either L or R, but when used in software, it is often referred to in a generic, abstract fashion as %V. Since %V does not really refer to a file name but rather a collection of files, we set the  abstract  flag. Abstract fields need to have a default value that is pulled in whenever the abstract representation is being requested.eye:    type: str    choices: [&quot;L&quot;, &quot;R&quot;, &quot;%V&quot;]    default: &quot;%V&quot;    abstract: truenuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{eye}_v{version}.{SEQ}.exrExample - Image sequencesImage sequences are abstract by definition and they have a default value set to %0Xd unless otherwise specified. The below sequence spec would identify frame numbers such as 0001, 1234 and 12345.SEQ:    type: sequence    format_spec: &quot;04&quot;nuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{channel}_{eye}_v{version}.{SEQ}.exr Example - Two fields both named version via an aliasTwo definitions of version number that can both be used by code that expects a key which is named “version”. This is useful if you have two Toolkit apps that both need a  version  field but you want these version field to be formatted differently.nuke_version:    type: int    format_spec: &quot;03&quot;    alias: versionmaya_version:    type: int    format_spec: &quot;04&quot;    alias: version&amp;lt;a name=&quot;nuke versions are using numbers on the form 003, 004, 005&quot;&amp;gt;&amp;lt;/a&amp;gt;# nuke versions are using numbers on the form 003, 004, 005&amp;lt;a name=&quot;the nuke publish app requires a field called {version}&quot;&amp;gt;&amp;lt;/a&amp;gt;# the nuke publish app requires a field called {version}&amp;lt;a name=&quot;however {nuke_version} is a valid replacement for {version}&quot;&amp;gt;&amp;lt;/a&amp;gt;# however {nuke_version} is a valid replacement for {version}&amp;lt;a name=&quot;because it has an alias defined&quot;&amp;gt;&amp;lt;/a&amp;gt;# because it has an alias definednuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{nuke_version}.nk&amp;lt;a name=&quot;maya versions are using numbers on the form 0004, 0005, 0006&quot;&amp;gt;&amp;lt;/a&amp;gt;# maya versions are using numbers on the form 0004, 0005, 0006maya_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{maya_version}.ma Example - TimestampA timestamp that defaults to the current local time and is formatted as YYYY-MM-DD-HH-MM-SS.now:    type: timestamp    format_spec: &quot;%Y-%m-%d-%H-%M-%S&quot;    default: now A timestamp that defaults to the current utc time and is formatted as YYYY.MM.DD.year_month_day:    type: timestamp    format_spec: &quot;%Y.%m.%d&quot;    default: utc_now A timestamp that defaults to 9:00:00 and is formatted as HH-MM-SS.nine_am_time:    type: timestamp    format_spec: &quot;%H-%M-%S&quot;    default: &quot;09-00-00&quot; Example - ShotGrid mappingsThis is useful when you would like to to add ShotGrid fields to a file name, for example. Let’s say we would like to include the user name in a file name- we’d use the following definition:current_user_name:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: loginnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{current_user_name}_{name}.v{version}.nkWhen a Toolkit app populates all the context fields (via the  context.as_template_fields()  method, it will populate the higher level fields  Shot,  Sequence  and  Step  automatically. It will also scan through all fields which have  shotgun_entity_type  defined (like our  current_user_name  field above). If the ShotGrid Entity is defined in the context, it will be able to automatically resolve the value. The current user is always tracked in the context, and in the above example, it would also be possible to pull data from fields on Shot, Sequence and Step since these are defined as part of the higher level path and therefore part of the context. However, trying to refer to an Asset entity in a field wouldn’t work in the above example since Toolkit would have no way of knowing which asset in ShotGrid to pull the data from.Example - String field with two valid valuesOften times a studio will have a project that needs to save out ASCII and Binary Maya files. In this scenario, a string value with two valid values looks like:maya_file_extension:    type: str    choices: [&quot;ma&quot;, &quot;mb&quot;]                     Note: the default apps use either  .ma  or  .mb  based on what’s configured in the  templates.yml. So, for example, if you want to change the work files app to save  .mb  instead of  .ma  in a project, you can change these three templates (for Shots):    maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.ma'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.ma'If  you  instead  end  them  with  .mb,  then  the  apps  will  save  out  as  Maya  binary:maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.mb'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.mb'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.mb' Check out  The Paths Section  below for more details.Example - Disallowing a valueA string field for which the value “assets” is not allowed. This is useful if you for example have two a folder which contains folders for all the sequences for a project alongside with a single “assets” folder where all the assets are kept:project |--- sequence1 |--- sequence2 |--- sequence3  --- assets In order for Toolkit to correctly understand that the assets folder is not just another sequence, we can define that “assets” is not a valid value for the sequence template.sequence:    type: str    exclusions: [&quot;assets&quot;] The exclusions field above allows us to define two templates that both correctly resolves:sequence_work_area: {sequence}/{shot}/workasset_work_area: assets/{asset}/work Example - Subsets of stringsThe following example extends a previous example and shows how to prefix filenames with a user’s initials.user_initials:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: login    subset: '([A-Z])[a-z]*  ([A-Z])[a-z]*'    subset_format: '{0}{1}'nuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{user_initials}_{name}.v{version}.nk The Paths SectionThe Paths section specifies where work will be saved. All paths consist of at least a name and a definition, where the definition is a combination of key names in brackets interspersed with non-key values representing a path. For example, a definition for a shot work file might look like:shot_work: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma With Sequence, Shot, Step and version being keys defined in the same template file.                    Note: If a string key’s name matches the entity type of a dynamic schema folder that has an associated ShotGrid entity, then that folder name will be substituted in for the token. For example, if you are using a {Sequence} template key of type ‘string’ like the above snippet, and in your schema, you have a dynamic folder named ‘sequence’, and in its corresponding  sequence.yml  file, it’s defined to be of type  shotgun_entity, and is connected to the ‘Sequence’ entity type in ShotGrid. Toolkit will recognize that your template key corresponds to this dynamic folder’s entity type (in that they are both Sequence). So, Toolkit will take the resulting folder name (i.e., the name of the specific sequence in question), and substitutes that in for the template key.    This form is required if any optional attributes need to be defined. Currently, the only optional attribute is  root_name, which can be used to specify a project root for a path in a project that has multiple roots.  Multiple roots  are used when you’d like to add a new storage root to store some of your project files.root_name: name_of_project_rootFor example, it may look like this:shot_work:  definition: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma  root_name: primary You need to use the above format if you want to use another storage root than the primary one. In this example, using this simple format implies that you are using the primary root for all entries.The Strings SectionStrings are similar to paths in that they must include a name and definition, which can be supplied in the simple form:string_name: string_definitionString definitions are templates consisting of key names and other values which together resolve to a string rather than a file system path. An example might the name used in ShotGrid for a publish:maya_publish_sg_name: &quot;Maya  publish,  {name},  v{version}&quot;With name and version as key names defined in the same file.Using Optional Keys in TemplatesOptional keys in templates are useful for a number of reasons. One common case is when  {SEQ}  is optional for rendered images. In this example, there can be a set of exrs that that are comprised of frame numbers, like  /path/to/render/shot.101.exr  (and 102, 103, etc), while you are also able to use the same template for quicktime movies, like  /path/to/render/shot.qt. Another more common case is when you are rendering stereo images. If you are in a studio where the convention is:  left eye: file.LFT.exr, right eye: file.RGT.exr, stereo image: file.exr?, you can make  {eye}  optional.Optional sections can be defined using square brackets:shot_work: sequences/{Shot}/work/{Shot}.[v{version}.]ma The optional section must contain at least one key. If the path is resolved with no value for the key(s) in an optional section, the path will resolve as if that section did not exist in the definition. The example above can be thought of as two templates baked into a single definition:shot_work: sequences/{Shot}/work/{Shot}.v{version}.mashot_work: sequences/{Shot}/work/{Shot}.ma As you pass in a dictionary of fields, Toolkit will choose the right version of the template depending on the values:&amp;gt;&amp;gt;&amp;gt; template = tk.templates[&quot;shot_work&quot;]&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;, &quot;version&quot;: 12}/project/sequences/ABC_123/work/ABC_123.v12.ma&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;}/project/sequences/ABC_123/work/ABC_123.ma Advanced questions and troubleshootingHow can I add a new entity type to my file structure?Let’s say you have been working on feature animations and shorts on your ShotGrid site, and now you have been awarded episodic work. Let’s walk through how you can incorporate an episodic workflow to Toolkit. The first thing to do is to set up your hierarchy in ShotGrid for episodic work following the instructions  here.                    Note: see the  Create with parent folder section above  to revisit nesting relationships in Toolkit (which is completely independent from the project hierarchy in ShotGrid).    Additional Reference:  How does the Episode entity work?  Customizing an entity’s hierarchyShotGrid fields required for the Episode &amp;gt; Sequence &amp;gt; Shot hierarchyYou can choose to use any Custom Entity for Episode (Site Preferences &amp;gt; Entities), or you can use the official Episode entity that was made available in ShotGrid 7.0.7.0. If you signed up for ShotGrid pre-7.0.7.0 (before 2017), the “TV Show” template uses CustomEntity02 for Episodes. If you decide to use another entity that is not CustomEntity02 or the official Episode entity, no worries! ShotGrid and Toolkit are flexible. Let’s walk through both cases.For the purpose of this exercise, we will use Episode (CustomEntity02) and the official Episode entity as examples of how to incorporate Episodes with the project hierarchy update (you can use either/or). First, the way to properly set up our Project’s  Episode &amp;gt; Sequence &amp;gt; Shot  hierarchy is to ensure the following fields are in ShotGrid:Episodea)  Using the official Episode entity:  the “Episode” entity may be the entity used when creating a TV Show project from the Project Template.ORb)  Using a custom entity:  CustomEntity02  may be the custom entity used when creating a TV Show project from the Project Template.  As noted previously, you can enable another custom entity and use it instead of  CustomEntity02—just make sure to replace all  CustomEntity02’s with the specific one that you have enabled.SequenceA single entity link called Episode (sg_episode) that links to the Episode entity is required.Using the official  Episode  EntityUsing  CustomEntity02ShotA single entity field called Sequence (sg_sequence) that links to the Sequence entity. This should already exist as part of the TV Show Project Template in ShotGrid.Using the official  Episode  EntityUsing  CustomEntity02Toolkit schema definitionLet’s assume a hierarchy as follows (where the folders in  {}s are dynamically named based on their name in ShotGrid):- {project_name} - shots episode.yml - {episode_name} sequence.yml - {sequence_name} shot.yml - {shot_name} ... …EpisodesIn your  config/core/schema/project/shots  folder, create a folder named  episode  with a corresponding  episode.yml  file in the same directory with the following content:Using the official  Episode  Entity&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Episode&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]Using  CustomEntity02&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;CustomEntity02&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] This tells Toolkit to create folders for every Episode in this project.SequenceIn your  config/core/schema/project/shots/episode  folder, create a folder named  sequence  with a corresponding  sequence.yml  file in the same directory with the following content:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Sequence&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_episode&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$episode&quot; ] } ]` This tells Toolkit to create folders for every Sequence that is linked to the Episode above it in the directory tree.ShotsIn your  config/core/schema/project/shots/episode/sequence  folder, create a folder named  shot  with a corresponding  shot.yml  file in the same directory with the following content:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]` This tells Toolkit to create folders for every Shot that is linked to the Sequence above it in the directory tree.After you’ve done this, your schema should reflect the following:Toolkit template definitionsIn order to tell Toolkit that you are using Episodes in your schema, you need to create a new key in the  keys section  at the top to define it:Using the official  Episode  Entitykeys:    ...    Episode:        type: str    ... Then, in your template paths below, update the  shot_root  template, as well as any other template paths that are in the shot hierarchy, to match your episodic hierarchy by inserting  {Episode}  in the proper place to specify the episode in the directory structure:...    paths:        shot_root: shots/{Episode}/{Sequence}/{Shot}/{Step}        … Using  CustomEntity02keys:    ...    CustomEntity02:        type: str    ...Then, in your template paths below, update the  shot_root  template, as well as any other template paths that are in the shot hierarchy, to match your episodic hierarchy by inserting  {CustomEntity02}  in the proper place to specify the episode in the directory structure:...    paths:        shot_root: shots/{CustomEntity02}/{Sequence}/{Shot}/{Step}        … That’s all you need for the basic  Episode &amp;gt; Sequence &amp;gt; Shot  workflow!How can I set up a branch in my structure?This relates to  Different file system layouts for different Pipeline Steps, more specifically, if you are looking to add a branch to your structure. For example, you can have one structure for “Pipeline Step A” and another for all other Pipeline Steps.Let’s say you are adding another kind of  Asset Type  to your Pipeline, and that new Asset Type is a Vehicle. You want to change the file structure for Vehicles so that it has different folders for different Pipeline Steps; for example, “geoprep” and “lookdev”, with additional folders inside each of those Pipeline Step folders. In parallel to this update, the way that you create Assets currently should remain the same. Let’s walk through how to update your pipeline to accommodate this new flow.Step 1: Modify the schemaFirst, modify your schema to reflect the way your folder structure will look with the new Asset Type.  Start by creating a new branch in the schema for this new Asset Type: vehicle.  At the same level as  asset/  and  asset.yml, add an  asset_vehicle/  folder and  asset_vehicle.yml.  These YAML files also have a filter setting in them. Modify the filter in your  asset.yml  so that it applies to all assets  except for  vehicle, and then modify  asset_vehicle.yml  to apply  only to  assets of type vehicle.  Here is an example of what those filters look like.      Now that you have two folders to represent  asset  and  asset_vehicles, add all the folders underneath  asset_vehicle  that you expect to be created for those assets (e.g.,  geoprep,  lookdev, etc.).    If you are saving and publishing files for these assets, you’ll want to create templates, in  core/templates.yml, that describe the file paths for saved and publish files. For example, in addition to  maya_asset_work, you may create a template called  maya_asset_work_vehicle, and its definition will be the templated path where you want to save Maya work files for vehicle assets.Step 2: Create a new environment fileAt this point, you have a directory structure for the new Asset Type, and you have templates that describe where to save and publish files in the new directory structure. Now, you need to tell Toolkit when to use these new templates. To do this, create a new environment file.  Create a copy of  env/asset_step.yml  called  env/asset_vehicle_step.yml. These two files will be identical, except  env/asset_vehicle_step.yml  will use your new templates. Replace any instances of  maya_asset_work  with  maya_asset_work_vehicle. Do the same for any other vehicle templates you’ve created.  Finally, you’ll need to teach Toolkit when to pick your new environment. To do this, modify the  pick_environment  core hook to return  asset_vehicle  or  asset_vehicle_step  when the asset in context is of type  vehicle  . Now, when you are working with an Asset of this new type (vehicle), Toolkit will know to use its environment configuration, and to therefore save and publish files to its alternate file system structure.How can I create a custom Pipeline Step using a custom entity?In ShotGrid 7.0.6.0,  managing Pipeline Steps via the Admin menu  was introduced. With this feature, you can easily add custom fields to Pipeline Steps.  Pro Tip: In most cases, utilizing custom fields on Pipeline Steps helps keep your pipeline more organized than creating a custom entity to manage those Pipeline Steps.However, in more advanced cases, it may be useful to have an alternative Pipeline Step. For instance, you might like to have the flexibility of different naming conventions and structures for production versus pipeline in the area of Pipeline Steps, as well as flexibility in naming and structuring them independently. While typically ShotGrid’s built-in Pipeline Steps are used for scheduling purposes, you may want to use another  Custom Entity  to structure the file system and group individual tasks together in the pipeline. You can accomplish this by creating a custom link field from a Task to a custom entity. This is then used by the system to group tasks together, via the step node.In the folder configuration, add two special options to tell it to use your custom step setup rather than ShotGrid’s built-in Pipeline Step:entity_type: &quot;CustomNonProjectEntity05&quot;task_link_field: &quot;sg_task_type&quot;",
    "url": "/82ff76f7/",
    "relUrl": "/82ff76f7/"
  },
  "40": {
    "id": "40",
    "title": "Python API で発生する SSL: CERTIFICATE_VERIFY_FAILED の問題の解決",
    "content": "Python API で発生する SSL: CERTIFICATE_VERIFY_FAILED の問題の解決Python API は、API にバンドルされ、マシンに格納されている証明書のリストを利用して、ShotGrid で使用されているさまざまな Web サービスに接続します。ただし、新しい認証局がリリースされた場合は、これらが Python API または OS にバンドルされていないことがあります。オートデスクの Python API には、2019 年 2 月 21 日時点の証明書の最新コピーが付属していますが、最新バージョンの API を使用している場合でも、API がこれらの証明書を使用して Amazon S3 にアップロードするのを妨害するバグが存在します。背景情報については、この AWS に関するブログの投稿を参照してください。状況を一時的に修正するには、次の解決策を試してください。                    注: これらは一時的な回避策です。オートデスクでは長期的な解決策を模索しています。    推奨される解決策Windows 証明書ストアに必要な CA 証明書を追加します。Windows 7 ユーザがこの解決策を使用する場合は、最初に PowerShell 3.0 にアップグレードするか、certutil を使用して必要な証明書を追加しなければならない可能性があります。      [スタート]を右クリックしてから、[Windows PowerShell (管理者)]を左クリックして、昇格された PowerShell を起動します。        次のコマンドを PowerShell ウィンドウに貼り付けて、[Return]キーを押して実行します。     $cert_url = &quot;https://www.amazontrust.com/repository/SFSRootCAG2.cer&quot; $cert_file = New-TemporaryFile Invoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullName Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root            サムプリント 925A8F8D2C6D04E0665F596AFF22D863E8256F3F を保持している追加証明書の詳細が表示されたら操作は完了しているので、PowerShell を閉じることができます。  代わりの解決策Python API を使用している場合      Python API v3.0.39 にアップグレードします。        a. ShotGrid_API_CACERTS を /path/to/shotgun_api3/lib/httplib2/cacerts.txt に設定します。    または    b. スクリプトを更新し、Shotgun オブジェクトをインスタンス化するときに ca_certs=/path/to/shotgun_api3/lib/httplib2/cacerts.txt を設定します。  Toolkit を使用している場合      Toolkit の展開方法に応じて、tank core コマンドを使用するか、パイプライン設定の core/core_api.yml ファイルを更新して、最新バージョンの Toolkit API にアップグレードします。        https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem にある証明書の最新リストをダウンロードします。        ShotGrid_API_CACERTS をこのファイルの保存場所に設定します。ただし、接続を作成するときに、Python API のように Toolkit から ca_certsca_certs パラメータを指定することはできません。  Python API または Toolkit を更新できない場合      https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem にある証明書の最新リストをダウンロードします。        SSL_CERT_FILE 環境変数をこのファイルの保存場所に設定します。  ",
    "url": "/c593f0aa/",
    "relUrl": "/c593f0aa/"
  },
  "41": {
    "id": "41",
    "title": "Getting Started",
    "content": "Getting StartedShotGrid Toolkit には、スタジオのパイプラインを作成するための高度にカスタマイズ可能な一連のツールが用意されています。アーティストは、コンテンツ作成ソフトウェアから移動しなくても、ShotGrid から情報にアクセスし、他のユーザと作品を共有できます。これらのガイドは、実践的な演習を通して、独自の Toolkit パイプラインを設定できるように設計されています。ShotGrid Desktop アプリを使用すると、プロジェクト用の編集可能な設定を生成したり、既存のアプリの設定を変更したり、さまざまなアーティストの環境に Toolkit アプリを追加してカスタム パイプラインを設計したりできます。各ガイドは以前のガイドを基に作成されていますが、記載されている手順はどこから読み進めてもかまいません。",
    "url": "/3c5b69aa/",
    "relUrl": "/3c5b69aa/"
  },
  "42": {
    "id": "42",
    "title": "Getting Started",
    "content": "Isolation Feature Set - Getting StartedWant to learn more about the isolation features? See About the Isolation Feature Set for more details about what is in store for you. The Isolation feature set is available only to Super Awesome clients. Before starting, make sure to upgrade your subscription to Super Awesome.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup sectionIn This Section  About the Isolation Feature Set  Client Responsibilities  Onboarding Process  Planning Your Setup",
    "url": "/0f6d8a60/",
    "relUrl": "/0f6d8a60/"
  },
  "43": {
    "id": "43",
    "title": "Houdini ShotGrid 統合が起動しないのはなぜですか。",
    "content": "Houdini ShotGrid 統合が起動しないのはなぜですか。ここでは、ShotGrid の統合で Houdini が起動しない場合に見られる、最も一般的な理由について説明します。この場合、Houdini は ShotGrid Desktop、ShotGrid の Web サイト、または tank コマンドからエラーなしで起動します。 ただし、Houdini が起動すると、ShotGrid メニューまたはシェルフが表示されなくなります。この問題は、HOUDINI_PATH 環境変数がオーバーライドされていて、ShotGrid がその環境変数に基づいて起動スクリプト パスを渡そうとしているために発生することがよくあります。Houdini を ShotGrid から起動すると、起動アプリケーション ロジックは ShotGrid ブートストラップ スクリプト パスを HOUDINI_PATH 環境変数に追加します。 しかし、Houdini に houdini.env ファイルがあると問題が発生することがあります。 このファイルがあると、ユーザーは Houdini がロードされたときに存在する環境変数を設定できますが、ファイルに定義されている値によって現在のセッションの既存の環境変数が上書きされます。これを修正するには、その変数の新しい定義に既存の HOUDINI_PATH 環境変数を含めます。たとえば、houdini.env ファイルに既に次のように記述されている場合:HOUDINI_PATH = /example/of/an/existing/path;&amp;amp;次のように、ファイルに定義されているパスの終端に $HOUDINI_PATH; と追加して保存する必要があります。HOUDINI_PATH = /example/of/an/existing/path;$HOUDINI_PATH;&amp;amp;これにより、Houdini の起動時に ShotGrid の設定値が維持されます。                    注意: Windows では、$HOUDINI_PATH によって問題が発生することがあります。この変数によって ShotGrid の統合へのブートストラップが数回試行され、次のようなエラーが表示されます。Toolkit bootstrap is missing a required variable : TANK_CONTEXTこのエラーが表示される場合は、代わりに %HOUDINI_PATH% を使用してください。    問題が解決しない場合は、サポート チームに問い合わせて問題の診断を依頼してください。",
    "url": "/eecfb05b/",
    "relUrl": "/eecfb05b/"
  },
  "44": {
    "id": "44",
    "title": "概要",
    "content": "",
    "url": "/",
    "relUrl": "/"
  },
  "45": {
    "id": "45",
    "title": "Windows で ShotGrid Desktop をサイレント インストールするにはどうすればいいですか?",
    "content": "Windows で ShotGrid Desktop をサイレント インストールするにはどうすればいいですか?ShotGrid Desktop インストーラをサイレントで実行するには、次の方法で ShotGrid Desktop インストーラを起動します。ShotgunInstaller_Current.exe /Sインストール フォルダも指定する場合は、引数 /D を使用して起動します。ShotgunInstaller_Current.exe /S /D=X: path to install folder.                    注: 引数 /D は最後の引数として指定する必要があります。パスの中にスペースがある場合でも、&quot; は使用しないでください。    ",
    "url": "/3a27b3da/",
    "relUrl": "/3a27b3da/"
  },
  "46": {
    "id": "46",
    "title": "アプリを追加する",
    "content": "アプリを追加するこのガイドを読み終えると、Toolkit の設定管理ツールに関する知識を短時間で得ることができます。次の内容について学習します。  アクティブなパイプライン設定のコピーを安全に作成する  設定にアプリを追加する  特定の環境でこのアプリを使用するために必要な設定を追加する  変更をアクティブな設定にプッシュするこのガイドについてこのガイドでは、既存のパイプライン設定に ShotGrid Toolkit アプリを追加する方法について説明します。設定管理ツールに関する知識を短時間で得ることができます。ここで追加するアプリは、ShotGrid Python コンソール アプリです。Maya には独自の Python コンソールがありますが、Toolkit アプリには Maya コンソールにない機能がいくつか用意されています。このガイドでは、「パイプライン設定を編集する」ガイドで作成したパイプライン設定を利用します。 このガイドをまだ完了していない場合は、既存のパイプライン設定を使用してアプリを追加してください。このドキュメントの使い方このガイドを使用して Toolkit アプリをインストールするには、以下が必要です。  アクティブな ShotGrid サイト。  指定したプロジェクトのパイプライン設定。この設定がない場合は、「設定の基本操作」ガイドの手順を完了し、その演習で作成した設定を使用します。  パイプライン設定の保存先のファイルシステムに最適になるように設定された読み取りおよび書き込み権限。  システムにインストールされた ShotGrid Desktop。  Maya の有効なサブスクリプション。Maya の 30 日間無償体験版はこちらから取得してください。                    注: このガイドは tk-config-default2 パイプライン設定をベースにしています。 設定が変更されている場合は、YAML 設定のファイル、フォルダ、およびブロックの場所がここに記載されている内容と異なる可能性があります。    ShotGrid Toolkit アプリについてToolkit アプリの仕組みパイプライン設定で参照されているアプリは、さまざまな場所から取得できます。既定の設定の標準アプリは、ShotGrid アプリ ストアから取得されています。パイプライン設定内のファイルを使って、ShotGrid 統合からアプリにアクセスする方法を指定します。これはたとえば Toolkit に、「アドレス帳にある Python コンソール アプリのアドレスを調べることはできますか」と尋ねるようなものです。パイプライン設定ファイルは Toolkit に、特定のアプリで利用されているコードのバンドルの検索場所を指示します。Toolkit アプリの「アドレス」は既定の設定の config/env/includes/app_locations.yml ファイルにリストされていて、コードの検索方法を指定します。これらの「アドレス」は記述子といいます。ShotGrid の統合には、アプリのコード バンドルの検索方法だけでなく、アプリの使用環境も指示する必要があります。以下に、アプリのインストール方法と、ShotGrid の統合にアプリの使用場所を指示する方法について、概念を示します。また、設定を拡張し、記述子を検索するよう Toolkit に要求して、アプリの使用場所を ShotGrid に指示する手順についても説明します。このガイドでは、次の手順について詳細に説明します。  追加するアプリの記述子を判別します。  アプリの記述子の追加先となるアクティブなパイプライン設定をコピーします。  アプリの記述子が設定に含まれているかどうかを確認して、含まれていない場合は追加します。  YAML ファイルを正しくフォーマットします(インデントにはタブでなく、スペースを使用します)。  アプリの使用環境を判別します。  これらの環境内で、ShotGrid にアプリの使用を許可する設定を追加します。  新しい設定をテストします。  拡張した設定を有効にします。Python コンソール アプリの場所の記述子を見つける手順 1: 「アプリとエンジンの概要」ページを開いて、Maya の ShotGrid Python コンソールの情報を検索します。タイトルを選択します。こうすると、アドレス帳に必要なすべての情報を含む、アプリの情報が表示されます。[System Name]は主要な識別子です(tk-multi-pythonconsole)。[Latest Version:]も必要です( v1.1.2)。Maya のプロジェクト環境内に Python コンソール アプリが含まれていないことを確認する手順 2: Maya を起動し、ShotGrid メニューを選択して([ShotGrid] &amp;gt; プロジェクト the_other_side)、プロジェクト環境内にある、このプロジェクトで使用可能なアプリのリストを表示します。設定を拡張するプロダクションで使用している設定を編集するには、まずコピーを作成してから、そのコピーを編集します。この方法で編集すると、有効な設定に影響を与えることなく、テストのための安全なスペースを確保してから、設定を有効にすることができます。ステージング サンドボックスを作成すると、現在プロダクションで使用しているパイプライン設定のコピーを使用して再生できます。サンドボックス内で設定のコピーを変更し、変更内容をテストしてから、変更をプロダクションにプッシュして有効にします。パイプライン設定のクローンを作成すると、コピーを作成し、コピーを使用して再生できるサンドボックスを構築してから、新しい設定を有効なプロダクションにプッシュするプロセスが自動化されます。アプリを追加するパイプライン設定のクローンを作成する[パイプラインの設定]（Pipeline Configuration）リストに移動します。手順 3: ShotGrid を開き、右上にある[管理者]（Admin）メニュー（アバター） &amp;gt; [既定のレイアウト]（Default Layouts） &amp;gt; [パイプラインの設定]（Pipeline Configuration） &amp;gt; [パイプライン設定リスト]（Pipeline Configuration List）を選択します。この操作を行うと、ShotGrid サイトのすべてのパイプライン設定の詳細なリストが表示されます。手順 4: [パイプライン設定リスト]（Pipeline Configuration List）が表示されたら、列見出しの右端にある[+]記号を選択して、[プロジェクト]（Projects）列を追加します。プロジェクトの設定の配置場所を確認する手順 5: オペレーティング システムに該当する[パス]（Path）フィールドを追加します。設定ファイルのパスが表示されます。手順 6: [プライマリ]（Primary）行項目の横にある空のスペース内で右クリックして、コンテキスト メニューから[この設定のクローンを作成…]（Clone this Configuration…）を選択します。手順 7: [パイプライン設定リスト]（Pipeline Configuration List）内の設定およびディレクトリ内のファイルに、それぞれ「Primary Clone Config 2」および「the_other_side_clone2」という名前を付けます。[OK]をクリックします。ShotGrid によって設定内のすべてのファイルおよびフォルダがコピーされ、アプリのキャッシュが作成されるまで待ちます。この時間を利用して、エスプレッソの完璧なショットと一緒に、軽く、ふわっとした、口の中でとろけるクロワッサンを作成するアプリを使用しましょう。完了すると、クローンが作成された設定の情報を使用して[パイプライン設定リスト]が更新され、ローカルな config フォルダに新しい設定が追加されます。                    注: [ユーザ制限]（User Restrictions）の下にユーザ名が追加されています。ShotGrid は、この設定を作成したユーザのみが新しい設定にアクセスできるよう、自動的に制限します。この設定を編集し、テストして、最終的に使用するユーザを追加することができます。ただし、ShotGrid の柔軟性を高めて、詳細なコントロールを可能にする方法がもう 1 つあります。    クローン作成された設定にプロジェクトを関連付ける手順 8: ShotGrid Desktop を開いて、クローン作成した設定を作成する対象となったプロジェクトを選択します。右上にある下矢印を選択して、このプロジェクトに関連付けられた設定を表示し、直前に作成した[Primary Clone Config 2]を選択します。これで、ShotGrid Desktop がこのプロジェクトでクローン作成した設定を使用するようになりました。パイプライン設定を編集する手順 9: クローン作成した設定を、ファイルシステム上の、この設定を作成するときに指定したパス内で検索します。config/env/includes/app_locations.yml ファイルを表示します。app_locations.yml ファイルは既定の設定のアドレス帳です。このファイルには、アプリの記述子がリストされています。このファイルはアプリの配置場所を示しているため、ユーザはこのファイルを基にアプリの設定を作成することができます。使用するアプリがアドレス帳で参照されていない場合は、Toolkit に検索場所を指示する必要があります。Toolkit にアプリの検索場所を指示する手順 10: ファイル内で pythonconsole を検索します。プロジェクトで既定の設定を使用した場合は、Python コンソール アプリの記述子がこのファイル内にリストされます。この記述子は、作業開始時に調べた Maya アプリのリスト内にある記述子と一致する必要があります。アプリのバージョンが、Maya アプリのリスト内にあったバージョンと一致することを確認します。apps.tk-multi-pythonconsole.location:	type: app_store	name: tk-multi-pythonconsole	version: v1.1.2                    注: 別の設定を使用している場合は、その記述子をファイルに追加しなければならいことがあります。    すべてのアプリおよびエンジンに記述子があります。記述子の仕組みと type: の設定方法の詳細については、Core API ドキュメントの記述子に関するセクションを参照してください。Toolkit に記述子を使用するよう指示するMaya のプロジェクト環境内で作業している場合は、記述子を使用して Python コンソール アプリを特定し、このアプリを使用するよう Toolkit に指示する必要があります。手順 11: クローン作成した設定内にある config/env/project.yml ファイルを開き、tk-maya エンジンの設定を検索します。# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;@settings を使用する tk-maya: “@settings.tk-maya.project” 行は、設定がインクルードされたファイルに含まれていることを示します。tk-maya は Maya エンジンを識別し、project は環境を識別します。YAML ファイルShotGrid Toolkit パイプライン設定は YAML ファイル内で単純な用語を使用して、アプリやエンジンの場所、およびこれらの設定を識別します。この特定のブロックの各要素は、次のとおりです。  settings は、既定の設定で、設定フォルダの参照として選択された内容を表します。  project は、既定の設定で、プロジェクト環境の参照として選択された内容を表します。  tk-maya は、Maya 用の Toolkit エンジンの識別子です。  @ は、設定値がインクルードされたファイルから取得されたことを示すために使用される Toolkit 用語です。YAML ファイルは ShotGrid の統合の窓口であり、パイプラインの要求を満たす作業環境を簡単に設定できるようにします。設定における Toolkit バンドルの参照方法ShotGrid の統合のコードは、アプリ、エンジン、およびフレームワークのバンドルに整理されています。これらのバンドルは、tk-maya、tk-multi-pythonconsole のような記述子を使用して、Toolkit の YAML ファイル内で参照されています。YAML の各バンドルに対応するブロックには、識別されたバンドルへのアクセス方法や利用方法をコントロールする設定が含まれています。Python コンソールの設定の配置場所既定の設定のこの特定のブロックに含まれている「tk-maya.project」は、プロジェクト環境内の Maya エンジンの識別子です。ここで目標とするのは、Python コンソール アプリのコード バンドルをプロジェクト環境内の Maya エンジンに追加することです。使用された用語を基に判断すると、tk-maya.yml が、プロジェクト環境の設定が配置されている YAML ファイルの名前であることは確実です。tk-maya.yml ファイル内の settings.tk-maya.projectで apps を検索します。手順 13: ファイルを検索するには、includes セクションの engines の上で tk-maya.yml を探します。./includes/settings/tk-maya.yml手順 14: クローン作成した設定内の config/env/includes/settings/tk-maya.yml をテキスト エディタで開き、settings.tk-maya.project を検索します。手順 15: 次の行の下に場所の記述子を追加します。settings.tk-maya.project:  apps:about アプリの tk-multi-about: をガイドとして使用して、場所の記述子を追加し、ファイルを保存します。                    注: YAML ファイルが、タブでなくスペースを使用して正しくフォーマットされていることを確認してください。    # projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-pythonconsole:      location: &quot;@apps.tk-multi-pythonconsole.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;Screening Room、ShotGrid Panel、および Workfiles2 アプリの場所識別子は別のインクルードされたファイルにリストされていて、About アプリとアクセス方法が異なります。これらのアプリには追加設定があるため、情報整理しておくために、これらのアプリはインクルードされた設定フォルダに分割して配置されています。                    注: python コンソール アプリは既に既定の設定に存在しますが、これまでに設定に追加したことがないアプリを追加する場合、またはアプリのバージョンを変更し、中央設定を使用している場合は、追加の手順が必要になります。端末を開いて、クローン作成した設定の保存場所を参照します。クローン作成した設定のルート フォルダから、次のコマンドを実行します。Linux または Mac の場合:./tank cache_appsWindows の場合:tank.bat cache_appsこれにより、設定内のアプリ、エンジン、フレームワークがスキャンされ、それらがすべてダウンロードされたことが確認されます。    Maya で変更内容を表示する手順 16: ShotGrid Desktop を開いて、作業しているプロジェクトを選択し、クローン作成された設定を使用していることを確認します。青いバーが表示され、プロジェクトの名前の下に、作成したクローンの名前が示されます。                    注: プライマリを使用している場合は、青いバーは表示されず、設定の名前は表示されません。    手順 17: Desktop から Maya を起動して、メニュー [ShotGrid] &amp;gt; [プロジェクト]（Project） &amp;gt; […]を選択します。次の場合:  直前に編集した、クローン作成した設定を使用している場合  クローン作成した設定が正しく拡張された場合  拡張したファイルを保存した場合  プロジェクトにクローン作成した設定を関連付けるよう選択した場合  ShotGrid Desktop から Maya を再起動した場合Maya で Python コンソール アプリを使用できるようになります。プロダクションに変更をプッシュするPython コンソール アプリが正しく追加されたことを確認したら、変更を有効にすることができます。手順 18: 端末を開いて、クローン作成した設定の保存場所を参照します。クローン作成した設定のルート フォルダから、次のコマンドを実行します。Linux または Mac の場合:./tank push_configurationWindows の場合:tank.bat push_configurationプロンプトに従って、プロジェクトのプライマリ設定(変更のプッシュ先の設定)の ID を入力します。$ lscache		config		install		tank		tank.bat$ ./tank push_configurationWelcome to the Shotgun Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.comStarting Toolkit for your current path'/Users/michelle/Documents/Shotgun/configs/the_other_side_clone2'- The path is not associated with any Shotgun object.- Falling back on default project settings.- Running as user 'Michelle'- Using configuration 'Primary Clone Config 2' and Core v0.18.159- Setting the Context to Project the_other_side.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary Clone Config 2') to another pipeline configuration in the project.By default, the data will be copied to the target config folder. If pass a--symlink parameter, it will create a symlink instead.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [1] Primary (/Users/michelle/Documents/Shotgun/configs/the_other_side)Please type in the id of the configuration to push to (ENTER to exit):クローン作成した設定のプッシュ先に指定できるパイプライン設定のリストが表示されます。設定を更新しているプロジェクトのプライマリ パイプライン設定の ID を入力します。                    注: このガイドの「手順 3」に示した ShotGrid の[パイプラインの設定]（Pipeline Configuration）ページにも、パイプライン設定の ID が表示されています。プロジェクト ID を検索するには、設定リストに移動して、ID 列を追加します。    ID を入力した後、ShotGrid は以下の処理を行います。  プライマリ設定をバックアップする  クローン作成した設定をコピーする  クローンされた設定のコピーにプロジェクトを関連付けて、クローンをそのまま残す  プライマリ設定の保存場所を表示する  ダウンロードしてキャッシュに入れなければならないアプリがあるかどうかを確認するPlease type in the id of the configuration to push to (ENTER to exit): 1Hold on, pushing config…Your old configuration has been backed up into the following folder:/Users/michelle/Documents/Shotgun/configs/the_other_side/config.bak.20190118_111627Checking if there are any apps that need downloading…Push Complete!プライマリ設定で行った変更を表示する手順 19: ShotGrid Desktop の右上にある矢印をクリックして、[CONFIGURATION]リスト内の[Primary]を選択します。手順 20: Desktop から Maya を起動して、メニュー[ShotGrid] &amp;gt; [プロジェクト]（Project） &amp;gt; […]を参照して、ShotGrid Python コンソールを検索します。Python コンソール アプリが、選択されたプロジェクトのプロジェクト環境に追加されました。2 番目のガイドの「設定を編集する」で、各環境は独立していて、プロジェクトには専用の設定があること、およびプロジェクトをロードするときに、ソフトウェアの統合によってパイプライン設定から設定が収集されることを説明しました。Python コンソールを環境内で使用できるように設定するには、app_locations.yml ファイル内で場所の記述子を参照するようこの環境に指示する必要があります。この場合、Python コンソール アプリを使用可能にするパイプラインの任意のポイントで、「Python コンソール アプリをここで使用する」ように設定する必要があります。高度なトピックShotGrid 開発者のコミュニティToolkit の素晴らしい点の 1 つに、Toolkit アプリを誰でも作成できることがあります。また、アプリの所有権を維持したり、ShotGrid コミュニティ内でアプリを共有して ShotGrid ツールに追加したりできます。非常に便利なアプリを作成したため、ShotGrid コミュニティ ページで共有したい場合は、support@shotgunsoftware.com にメールでお問い合わせください。標準的な Toolkit アプリや、愛情のこもった ShotGrid コミュニティで作成されたアプリについては、ShotGrid-dev Google グループで活発に議論されています。ShotGrid コミュニティの貢献度が高まるにつれて、知識やツールの基盤も拡大しています。設定の拡張方法を調べるプロジェクトで使用する設定を選択するときにおわかりになったように、Python コンソール アプリは ShotGrid Desktop のドロップダウンから使用できます。パイプラインに追加するアプリを使用している環境がある場合は、少し推理を働かせて、このアプリを設定に追加するのに必要な情報を見つけることができます。アプリが使用されている環境内の設定ファイルを調べると、アプリの場所の記述子および設定の追加方法がわかります。Desktop アプリはプロジェクト環境内で開くため、project.yml ファイル内で tk-desktop を検索します。config/env/project.yml を開きます。                    注: engine ブロック内の tk-desktop は、インクルードされた内容を指します。includes:  - ./includes/settings/tk-desktop.ymlengines:  tk-desktop: &quot;@settings.tk-desktop.project&quot;インクルードの内容に従って、config/env/includes/settings/tk-desktop.yml を開き、settings.tk-desktop.project ブロックを検索します。このブロック内に、次の行が含まれています。apps:  tk-multi-pythonconsole:  location: &quot;@apps.tk-multi-pythonconsole.location&quot;これらのブロックに従い、プロジェクトの手順中に Python コンソール アプリが Desktop エンジンに追加されます。インクルードの内容に沿って ../includes/app_locations.yml に進み、apps.tk-multi-pythonconsole.location を検索します。次のようになっています。# pythonconsoleapps.tk-multi-pythonconsole.location:  type: app_store  name: tk-multi-pythonconsole  version: v1.1.2    すべてのアプリ、エンジン、およびフレームワークに、特定のバンドルのアクセス場所を Toolkit に指示するための場所の記述子が設定されています。多くのアプリ記述子が app_locations.yml ファイルに含まれていますが、Python コンソール アプリで確認したように、これらの記述子が必要な場所で参照されていない可能性があります。すべての標準アプリおよびエンジンは、「アプリとエンジンの概要」ページにリストされています。任意のアプリを ShotGrid でサポートされている適切なソフトウェア統合に追加したり、独自のアプリケーションを Toolkit ツールに追加したりできます。サポートされているすべてのソフトウェア アプリケーションは、統合の「アプリとエンジンの概要」ページにもリストされています。探しているアプリが見つからない場合は、自分で作成できます。これを機会に、他の ShotGrid ユーザにこの機能の必要性が広まる可能性があります。また、新しいアプリを共有することで、ShotGrid コミュニティに恩返しができます。次のガイドでは、会社の構成方法に合わせて制作用フォルダの構成をカスタマイズする方法について学習します。",
    "url": "/4d147fb2/",
    "relUrl": "/4d147fb2/"
  },
  "47": {
    "id": "47",
    "title": "ShotGrid Integrations Admin Guide",
    "content": "ShotGrid Integrations Admin GuideIntroductionThis document serves as a guide for administrators of ShotGrid integrations. It’s one of three: user, admin, and developer. Our  User Guide  is intended for artists who will be the end users of ShotGrid integrations in their daily workflow, and our  Developer Guide  is technical documentation for those writing Python code to extend the functionality. This document falls between those two: it’s intended for those who are implementing ShotGrid integrations for a studio, managing software versions, and making storage decisions for published files.Standard Pipeline ConfigurationsAt the heart of any Toolkit setup is the Pipeline Configuration, a set of YAML files that manage everything from installed apps to software versions, and in some cases, even hold the templates for setting up your production directory structure and file names. The Pipeline Configuration is highly customizable, but we offer two starting points.The Basic ConfigOur out-of-the-box integrations are designed to run without the need to set up or modify any configuration files. When you use our out-of-the-box integrations, there’s nothing to administer, but Toolkit uses an implied Pipeline Configuration under the hood, and we call this Pipeline Configuration the Basic Config. The Basic Config makes three Toolkit apps – The Panel, Publisher, and Loader – available in all supported software packages, and looks to your Software Entities in ShotGrid to determine which software packages to display in ShotGrid Desktop. The Basic Config does not include filesystem location support. When you use out-of-the-box integrations on a project, your copy of the Basic Config is auto-updated whenever you launch Desktop, so you’ll always have the latest version of our integrations. You can  subscribe to release notes here, and  see the Basic Config in Github here.The Default ConfigThis is the default starting point for our Advanced project setup. It includes  filesystem location support  and a wider array of Toolkit apps and engines.You can  see the Default Config in Github here. For a detailed description of the Default Config’s structure, see the  config/env/README.md  file in your Pipeline Configuration, or  view it here in Github.If you’re familiar with the old structure of the Default Config, take a look at the  Default Config Update FAQ.                    Note: Looking for the old config structure? With the v1.1 release of Integrations, we reorganized the structure of the Default Config to help maximize efficiency and readability, and to make it match the Basic Config’s structure more closely You can still base projects on the legacy Default Config. Just choose ‘Legacy Default’ when prompted to select a configuration in the Desktop Set Up Project Wizard.    The PublisherThe Publisher is designed to ease the transition between the out-of-the-box workflow and the full pipeline configuration. In the out-of-the-box setup, files are published in place, which avoids the need to define templates or filesystem schema. Once a project has gone through the advanced setup and has a full Pipeline Configuration, the same publish plugins will recognize the introduction of templates to the app settings and begin copying files to their designated publish location prior to publishing. Studios can therefore introduce template-based settings on a per-environment or per-DCC basis as needed for projects with full configurations. The Default Config comes fully configured for template-based workflows and is a good reference to see how templates can be configured for the Publish app. See the  tk-multi-publish2.yml file  in the Default Config in Github for more info.For details on writing plugins for the Publisher, see the  Publisher section of our Developer Guide.Configuring software launchesIt’s simple to rely on ShotGrid’s auto-detection of host applications on your system: just launch ShotGrid Desktop, choose a project, and Desktop will display launchers for all supported software packages that it finds in standard application directories. But we also offer robust tools for more fine-grained management of the software in your studio. You can restrict application visibility to specific projects, groups, or even individual users. You can specify Versions, deactivate a given software package across your site, and group software packages together. All of this is managed through Software entities in ShotGrid.When you create a new ShotGrid site, it will have a set of default Software entities—one for each supported host application. You can modify these and add your own to manage the software that shows up in Desktop exactly how you want it.To see your Software entities in ShotGrid, open the Admin menu by clicking on the profile icon in the upper right corner of the screen, and choose  Software.The Software entity has the following fields:  Software Name:  The display name of the Software in Desktop.  Thumbnail:  Uploaded image file for Desktop icon.  Status:  Controls whether or not the Software is available.  Engine:  The name of the integration for the content creation tool.  Products:  For Software packages that include variants (e.g., Houdini vs. Houdini FX), you can specify a comma separated list here. Valid only in auto-detect mode, not manual mode.  Versions:  Specific versions of the software to display. You can specify a comma separated list here. Valid only in auto-detect mode, not manual mode.  Group:  Entities with the same value for the  Group  field will be grouped under a single icon in Desktop and a single menu in ShotGrid. For example, you could create an FX group that includes Houdini and Nuke.  Group Default: When one member of a group has  Group Default  checked, clicking the icon or menu item for the group will launch this software.  Projects:  A way to restrict software to certain projects.  User Restrictions:  A way to restrict software to certain users or groups.  Linux/Mac/Windows Path:  Use these fields to explicitly specify an OS-specific path to software.  Linux/Mac/Windows Args:  Commandline args to append to the command when launching the Software.We can learn a lot about how these fields work together by demonstrating some ways of using them.Example: Grouping versions of the same application, auto-detectSay you have three versions of Maya on your filesystem: Maya 2016, Maya 2017, and Maya 2018. You want to make all of these available to your artists, but you want them to be grouped under a single icon in Desktop.If these three versions of Maya are installed in the standard location on your filesystem, then this will all happen automatically. When you select a project in Desktop, it will scan the standard applications directory on the local machine, and will find the three versions. Since you already have a Maya software entity in ShotGrid, with no specific versions or paths specified, it will display all versions it finds in Desktop.A few things to note here:  When ShotGrid auto-detects your software, a single Software entity generates the menu items for all versions.  None of the Path fields have values specified. The Software entity is in auto-detect mode, so the App is assumed to be in the standard location.These will show up in Desktop as you see here: one icon for Maya, with a drop-down listing all the available versions. If you click on the icon itself, you’ll launch the latest version of Maya.Example: Grouping versions of the same application, manual modeIt’s perfectly fine to store Maya in a non-standard location in your studio. You’ll just need to create your own Software entities, and specify paths to let ShotGrid know where to find your software. Your setup may look like this:Some notes here:  Unlike in auto-detect mode, here you have a Software entity for each version of a given software package.  In order to group them together, use the  Group  and  Group Default  fields. Software entities that share the same value for  Group  will be grouped in Desktop in a dropdown under a single icon, which uses the  Group  value as its name.  When you click on that icon itself, you’ll launch the software within the group with  Group Defaultchecked.  When you specify a value for  any  of Linux Path, Mac Path, or Windows Path on a Software entity, that entity will shift to Manual mode.  Unlike auto-detect mode, where the software  would  show up in Desktop when a path field is empty, in manual mode, a software package will  only  show up on a given operating system if a path is specified for it and the file exists at the specified path.  In this example, none of the three Maya versions would show up in Desktop on Windows because no  Windows Path  has been specified.Example: Restrict by users or groupsNow, say with that last example that we’re not ready to make Maya 2018 available to all users just yet. But we do want TDs, Devs, and our QA engineer, Tessa Tester, to be able to access it. We can achieve this with the  User Restrictions  field. Here’s an example:We made a couple changes from the last example:  The group default is now Maya 2017. We want that to be the production version, so with that box checked, clicking the icon for Maya will now go to this version.  We’ve added a few values to the  User Restrictions  field: It can take both users and groups, and we’ve added our Dev and TD groups, as well as the user Tessa Tester. Now, only those people will see Maya 2018 in Desktop.Example: Restrict software versions by projectSometimes you want to do more complex version management across projects in your studio. You may have a project in a crunch to deliver, which you want to lock off from new versions of software, while at the same time, its sequel may just be starting up and able to evaluate newer versions. In this case, you may have your Software entities set up like this:A few important things to note:  We’ve removed the  Group  and  Group Default  values here, as only one Maya version will ever show up in Desktop for a given environment.  We’ve set the  Software Name  for all three versions to “Maya”. This way, on every project, users will have an icon with the same name, but it will point to different versions depending on what’s configured here.  We’ve set Maya 2016’s  Status  field to  Disabled. We are no longer using this version in our studio, and this field toggles global visibility across all projects.  We’ve specified values for  Projects  for Maya 2017 and Maya 2018. This  Projects  field acts as a restriction. Maya 2017 will  only  show up in the Chicken Planet project, and Maya 2018 will only show up in Chicken Planet II.  Note that once you’ve specified a value for  Projects  for a Software entity, that Software will only show up in the projects you’ve specified. So, if you have other projects in your studio in addition to the Chicken Planet series, you’ll need to specify software for them explicitly.Example: Add your own SoftwareThere are several reasons you might add a new software entity in addition to those that ShotGrid Desktop has auto-detected on your system:  You want to make an application for which there is no engine available to your users through Desktop.  You have in-house software, or third-party software that we don’t have an integration for, for which you’ve written your own engine.  Your software doesn’t live in a standard location, so you want to point ShotGrid to it manually. (This case was described in the “Grouping versions of the same Application, Manual mode” example above.)In these cases, you can add your own Software entities. You’ll need to have a value for the  Software Namefield. If you’re using an in-house engine for your software, specify the engine name in the  Engine  field. Some studios may want to include apps in Desktop that don’t have ShotGrid integrations, as a convenience for artists. Your artists can launch the app straight from Desktop. You can even use all of the settings above to manage versions and usage restrictions. In this case, leave the  Engine  field empty, but you’ll need to specify a value for at least one of  Mac Path,  Linux Path, and  Windows Path.Configuring published file path resolutionWhen you publish a file, the Publisher creates a PublishedFile entity in ShotGrid, which includes a  File/Link  field called  Path. Later on, a different user may try to load this file into their own work session using the Loader. The Loader uses complex logic to resolve a valid local path to the PublishedFile across operating systems.The way in which the Loader attempts to resolve the publish data into a path depends on whether the the publish is associated with a local file link or a  file://  URL.Resolving local file linksLocal file links are generated automatically at publish time if the path you are publishing matches any local storage defined in the ShotGrid Site Preferences. If the publish is a local file link, its local operating system representation will be used. Read more about local file links  here.If a local storage doesn’t define a path for the operating system you are currently using, you can use an environment variable to specify your local storage root. The name of the environment variable should take the form of  SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;. So, if you wanted to define a path on a Mac for a storage root called “Renders”, you’d create a  SHOTGUN_PATH_MAC_RENDERS  environment variable. Let’s go deeper with that example:  Say your ShotGrid site has a storage root called “Renders”, with the following paths specified:  Linux path:  /studio/renders/  Windows path:  S: renders       Mac path:  &amp;lt;blank&amp;gt;        You are on a Mac.    You want to load a publish with the path  /studio/renders/sq100/sh001/bg/bg.001.exr  into your session.The Loader can parse the path and deduce that  /studio/renders/  is the storage root part of it, but no storage root is defined for Mac. So, it will look for a  SHOTGUN_PATH_MAC_RENDERS  environment variable, and if it finds one, it will replace  /studio/renders  in the path with its value.Note:  If you define a  SHOTGUN_PATH_MAC_RENDERS  environment variable, and the local storage Renders  _does_have Mac path set, the local storage value will be used and a warning will be logged.Note:  If no storage can be resolved for the current operating system, a  PublishPathNotDefinedError  is raised.Resolving file URLsThe Loader also supports the resolution of  file://  URLs. At publish time, if the path you are publishing does not match any of your site’s local storages, the path is saved as a  file://  URL. Contrary to local file links, these paths are not stored in a multi-OS representation, but are just defined for the operating system where they were created.If you are trying to resolve a  file://  URL on a different operating system from the one where where the URL was created, the Loader will attempt to resolve it into a valid path using a series of approaches:  First, it will look for the three environment variables  SHOTGUN_PATH_WINDOWS,  SHOTGUN_PATH_MAC, and  SHOTGUN_PATH_LINUX. If these are defined, the method will attempt to translate the path this way. For example, if you are trying to resolve  file:///prod/proj_x/assets/bush/file.txt  on Windows, you could set up  SHOTGUN_PATH_WINDOWS=P: prod  and  SHOTGUN_PATH_LINUX=/prod  in order to hint the way the path should be resolved.  If you want to use more than one set of environment variables, in order to represent multiple storages, this is possible by extending the above variable name syntax with a suffix:  If you have a storage for renders, you could for example define  SHOTGUN_PATH_LINUX_RENDERS,  SHOTGUN_PATH_MAC_RENDERS, and  SHOTGUN_PATH_WINDOWS_RENDERS  in order to provide a translation mechanism for all  file://  URLs published that refer to data inside your render storage.  Then, if you also have a storage for editorial data, you could define  SHOTGUN_PATH_LINUX_EDITORIAL,  SHOTGUN_PATH_MAC_EDITORIAL, and  SHOTGUN_PATH_WINDOWS_EDITORIAL, in order to provide a translation mechanism for your editorial storage roots.Once you have standardized on these environment variables, you could consider converting them into a ShotGrid local storage. Once they are defined in the ShotGrid preferences, they will be automatically picked up and no environment variables will be needed.  In addition to the above, all local storages defined in the ShotGrid preferences will be handled the same way.  If a local storage has been defined, but an operating system is missing, this can be supplied via an environment variable. For example, if there is a local storage named  Renders  that is defined on Linux and Windows, you can extend to support mac by creating an environment variable named  SHOTGUN_PATH_MAC_RENDERS. The general syntax for this is  SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;.  If no root matches, the file path will be returned as is.Here’s an example:Say you’ve published the file  /projects/some/file.txt  on Linux, and a ShotGrid publish with the URL  file:///projects/some/file.txt  was generated. In your studio, the Linux path  /projects  equates to  Q: projects  on Windows, and hence you expect the full path to be translated to  Q: projects some file.txt.All of the following setups would handle this:  A general environment-based override:  SHOTGUN_PATH_LINUX=/projects  SHOTGUN_PATH_WINDOWS=Q: projects      SHOTGUN_PATH_MAC=/projects        A ShotGrid local storage called “Projects”, set up with:    Linux Path:  /projects  Windows Path:  Q: projects      Mac Path:  /projects        A ShotGrid local storage called “Projects”, augmented with an environment variable:    Linux Path:  /projects  Windows Path:`  Mac Path:/projects`  SHOTGUN_PATH_WINDOWS_PROJECTS=Q: projectsNote:  If you have a local storage  Renders  defined in ShotGrid with  Linux path  set, and also a  SHOTGUN_PATH_LINUX_RENDERS  environment variable defined, the storage will take precedence, the environment variable will be ignored, and a warning will be logged. Generally speaking, local storage definitions always take precedence over environment variables.Advanced configurationFor information on the underlying method that performs the resolution of PublishedFile paths, take a look at our  developer reference docs.If you are using Advanced Project Setup, you can add support beyond local file links and  file://  URLs by customizing the  resolve_publish  core hook. Possible customizations include:  Publishes with associated uploaded files could be automatically downloaded into an appropriate cache location by the core hook and the path would be be returned.  Custom URL schemes (such as  perforce://) could be resolved into local paths.Browser IntegrationBrowser integration for ShotGrid Toolkit refers to access to Toolkit apps and launchers by way of right-click context menus in the ShotGrid web application. These menus, an example of which is shown above, contain actions configured for various entity types. In the case where you have multiple pipeline configurations for a project, the actions are organized by pipeline configuration. Browser integration allows you to launch content creation software like Maya or Nuke that is aware of your ShotGrid context, right from the browser.A Brief History of Browser IntegrationOver the years, ShotGrid Toolkit’s browser integration has taken several forms. As technologies and security requirements have progressed, so has the approach to implementing browser integration.Java Applet (deprecated)The first implementation consisted of a Java applet that provided access to the local desktop from the ShotGrid web application. As Java applets became recognized as an exploitable security risk, they fell out of favor, necessitating its deprecation.Browser Plugin (deprecated)Replacing the deprecated Java applet was a browser plugin making use of NPAPI to access the local desktop from the ShotGrid web application. As NPAPI also became known as a security risk, the major web browsers began blocking its use. This necessitated deprecating the browser plugin.Websockets v1 via ShotGrid Desktop (legacy)Hosting a websocket server within the ShotGrid Desktop app was, and still is, the approach to communicating with the local desktop from the ShotGrid web application. The first implementation of this websocket server’s RPC API made use of the same underlying technology developed for the Java applet and browser plugin before it. When the server received a request from ShotGrid, the tank command from the associated project’s pipeline configuration was used to get the list of commands to show in the action menu.Websockets v2 via ShotGrid DesktopThe second iteration of the websocket server’s RPC API changes the underlying mechanism used to get, cache, and execute Toolkit actions. This implementation addresses a number of performance issues related to the earlier browser integration implementations, improves the visual organization of the action menus, and adds support for  out-of-the-box ShotGrid Integrations, which work without explicitly configuring Toolkit. This is the current implementation of browser integration.ConfigurationTo control what actions are presented to the user for each entity type, you modify YAML environment files in your project’s pipeline configuration. There are a few things to understand and consider when first attempting customization.Which engine configuration?The Toolkit engine that manages Toolkit actions within the ShotGrid web app is  tk-shotgun, so it’s this engine’s configuration that controls what shows up in the action menus.In the above example from  tk-config-basic, there are two apps configured that will result in a number of engine commands turned into menu actions. Toolkit apps will register commands that are to be included in the action menu, including launcher commands for each software package found on the local system that correspond to the list of  Software entities  in the ShotGrid site. The result is the list of menu actions shown here:The browser integration code found installations of Houdini, Maya, Nuke, and Photoshop on the user’s system, which resulted in menu actions for launching each of those integrations. Note that in a given environment configuration file, the  engine  for a Software entity needs to be present in order for that Software’s launcher to show up for entities of that environment. So, in this example, the  tk-houdini,  tk-maya,  tk-nuke, and  tk-photoshopcc  engines must all be present in the file from which this snippet was taken. If you wanted to remove, for example, Maya from the list of launchers on this entity, you could just remove the  tk-maya  engine block from the environment config file.In addition to these launchers, the Publish app’s “Publish…” command is included in the menu.Which YML file?You can take one of two paths: making use of the primary environment configuration (config/env/*.yml), as controlled by the config’s  pick_environment.py core hook, or the legacy approach employed by  tk-config-default, which uses  config/env/shotgun_&amp;lt;entity_type&amp;gt;.yml  files.In the case where the standard environment files are used, browser integration uses the  pick_environmentcore hook to determine which environment configuration file to use for a given entity’s action menu. In the simplest case, the environment corresponds to the entity type. For example, if you right-click on a Shot, the resulting action menu will be configured by the  tk-shotgun  block in  config/env/shot.yml. You can customize the  pick_environment  hook to use more complex logic. Should there be no  tk-shotgun  engine configured in the standard environment file, a fallback occurs if a  shotgun_&amp;lt;entity_type&amp;gt;.yml  file exists. This allows browser integration to work with legacy configurations that make use of the entity-specific environment files.Tip: Removing Software from the Browser Launchers with tk-config-default2Updating the configuration for launching software from the ShotGrid browser varies from tk-config-default to tk-config-default2.With tk-config-default2, updates should be applied to config/env/includes/settings/tk-shotgun.yml, whereas in tk-config-default, they were done in config/env/shotgun_task.yml.As an example, let’s remove Mari from the list of options when launching from an Asset through the browser.First, navigate to  config/env/asset.yml  and notice how the  tk-shotgun  engine engine block is pointing to  @settings.tk-shotgun.asset. The  @  symbol signifies that the value for the configuration is coming from an included file. This means you’ll need to go to your  env/includes/settings/tk-shotgun.yml  to make the update.While in your  env/includes/settings/tk-shotgun.yml, notice how each block is per Entity. So, for instance, Asset first:&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;To remove Mari from the list of options on an Asset in the browser, remove the Mari line (tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;):&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;Then, follow the same instructions for each entity (like Shot) from which you’d like to remove the ability to launch a particular software in the ShotGrid browser. Note that once you save the file, you may need to wait a minute and hard-refresh the browser for it to take effect.CachingBrowser integration has a robust caching mechanism, which allows menu actions to be shown to the user as quickly as possible. This is necessary because the process of bootstrapping Toolkit and getting a list of engine commands can be time consuming.When is the cache invalidated?The websocket server’s RPC API looks at two things to determine whether the cached data is still valid: YAML file modification times, and the contents of the site’s Software entities. If one of the environment YAML files in a given config has been modified since the cache data was written, the requisite data is recached and fresh data returned to the ShotGrid web application. Similarly, if any field on any Software entity in ShotGrid has been modified since the data was cached, Toolkit is bootstrapped and new data is cached.Where is the cache file on disk?The cache file location is dependent upon the operating system.`OS X: ~/Library/Caches/Shotgun/&amp;lt;site_name&amp;gt;/site.basic.desktop/tk-desktopWindows: %APPDATA% Shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopLinux: ~/.shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopHook MethodsA  browser_integration.py  hook is included in  tk-framework-desktopserver, which provides the following hook methods:  get_cache_key: This method determines the cache entry’s key for the given configuration URI, project entity, and entity type. The default implementation combines the configuration URI and entity type.  get_site_state_data: This method can be used to include additional queried data from ShotGrid into the hash that’s used to test the validity of cached data. By default, the state of all Software entities that exist on the site are used, but if additional data should be included in the hash, that can be implemented in this hook method.  process_commands: This method provides a place to customize or alter the commands that are to be returned to the ShotGrid web application. The data structure provided to the method is a list of dictionaries, with each dictionary representing a single menu action. Data can be altered, filtered out, or added into the list as is necessary and will be reflected in the menu requesting Toolkit actions immediately.LogsLogs for browser integration can be found in Toolkit’s  standard log location. The relevant log files are  tk-desktop.log  and  tk-shotgun.log. In addition, if you are using Google Chrome, some relevant log output is sometimes available in the developer console within the browser.TroubleshootingThe complex nature of communicating from a web application with the local desktop means that there are possible points of failure along the way. Below are a few such situations and some suggestions of first steps to take when you encounter them.“Open or install ShotGrid Desktop…” shown in the action menuThis likely means one of three things:      ShotGrid Desktop is not currently running on the local machine. It seems obvious, but it is definitely worth double checking.        Chrome or the Python websocket server has refused the connection, resulting in the ShotGrid web application being unable to communicate with ShotGrid Desktop. This situation is most likely related to the self-signed certificates that allow the connection to proceed when requested. Regenerating these certificates from scratch often resolves the issue, and can be triggered from ShotGrid Desktop, as shown below.    ShotGrid Desktop’s websocket server failed to start on launch. This situation is likely limited to situations where a bad release of the websocket server has gone out to the public, which should be exceedingly rare. In this situation, logging will be present in  tk-desktop.log  explaining the error, which can be  sent to ShotGrid’s support team.No actions are shown in the action menuThis is indicative of a configuration problem if actions were expected for this entity type. Some possible issues:      The  tk-shotgun  engine is configured in the correct environment YAML file, but there are no apps present in that configuration. In this case, it’s likely that the intention was for no actions to be present for this entity type.        The  tk-shotgun  engine is configured in the correct environment YML file, and apps are present, but actions still do not appear in the menu. This is likely due to apps failing to initialize. In this case, there will be information in  tk-shotgun.log and tk-desktop.log  describing the problems.        The environment that corresponds to this entity type does not contain configuration for  tk-shotgun. The end result here is the same as #1 on this list. In this case, you can look at the pipeline configuration’s  pick_environment  hook to determine which environment is being loaded for this entity type, and the configuration of  tk-shotgun  can be verified there.        There is an empty list of menu actions cached on disk. To force the cache to be regenerated, there are a few options:          Update the modification time of a YAML file in your project’s configuration. This will trigger a recache of menu actions when they are next requested by ShotGrid. Worth noting is that this will trigger a recache for  all  users working in the project.      Update the value of a field in any of the Software entities on your ShotGrid site. The behavior here is the same as the above option concerning YAML file modification time, but will invalidate cached data for all users in  all  projects on your ShotGrid site. Software entities are non-project entities, which means they’re shared across all projects. If data in any of the Software entities is altered, all projects are impacted.      The cache file can be deleted on the host suffering from the problem. It is typically safe to remove the cache, and since it is stored locally on each host, it will only cause data to be recached from scratch on that one system. The cache is stored in the following SQLite file within your ShotGrid cache location:  &amp;lt;site-name&amp;gt;/site.basic.desktop/tk-desktop/shotgun_engine_commands_v1.sqlite      “Toolkit: Retrieving actions…” is never replaced with menu actionsThere are a few possibilities for this one:      The websocket server has not yet finished caching actions. If this is the first time actions are being retrieved after a significant update to the project’s config, the process can take some time to complete. Wait longer, and observe the contents of  tk-desktop.log  to see if processing is still occurring.        The websocket server has failed to respond and never will. This situation should be rare, but if it becomes obvious that there is no additional processing occurring as a result of the request for actions, as seen in  tk-desktop.log,  contact ShotGrid support, providing relevant log data.        The user is working in more than one ShotGrid site. With ShotGrid Desktop authenticated against a single site, requesting menu actions from a second ShotGrid site results in the user being queried about restarting ShotGrid Desktop and logging into the new site. If that request is ignored, the second site will never receive a list of menu actions.  Toolkit Configuration FileIf your studio is using a proxy server, if you want to pre-populate the initial login screen with some values, or if you want to tweak how the browser-based application launcher integrates with ShotGrid Desktop, there is a special configuration file called  toolkit.ini. ShotGrid Desktop does not require this file in order to run; it’s only needed if you need to configure its behavior. Toolkit looks for the file in multiple locations, in the following order:  An environment variable named  SGTK_PREFERENCES_LOCATION  that points to a file path.  Inside the ShotGrid Toolkit preferences folder: (Note that this file does not exist by default in these locations; you must create it.)          Windows:  %APPDATA% Shotgun Preferences toolkit.ini      macOS:  ~/Library/Preferences/Shotgun/toolkit.ini      Linux:  ~/.shotgun/preferences/toolkit.ini      The  SGTK_PREFERENCES_LOCATION  environment variable option allows you to store your configuration file somewhere else on your computer or on your network. Please note that  toolkit.ini  is the current standard file name. If you were using  config.ini, check below in the  “Legacy Locations”  section.You can see a documented example of a configuration file  here.Please note that this example file is called  config.ini  but it can be just renamed to  toolkit.iniPlease also note that you can use environment variables as well as hard coded values in this file, so that you could, for example, pick up the default user name to suggest to a user via the USERNAME variable that exists on Windows.Legacy Locations (DEPRECATED)Although  toolkit.ini  is the current standard file name, we previously used a  config.ini  file for same purpose. The contents of  toolkit.ini  and  config.ini  are the same. The  config.ini  will be searched for using the following deprecated locations:  An environment variable named  SGTK_DESKTOP_CONFIG_LOCATION  that points to a file.  In the following paths:          Windows:  %APPDATA% Shotgun desktop config config.ini      macOS:  ~/Library/Caches/Shotgun/desktop/config/config.ini      Linux:  ~/shotgun/desktop/config/config.ini      Proxy ConfigurationIf your studio is accessing the internet through a proxy, you’ll need to tell Toolkit to use this proxy when it accesses the Internet. Do so by specifying your proxy as the value of the  http_proxy  setting:http_proxy: &amp;lt;proxy_server_address&amp;gt;Running ShotGrid Desktop with a locally hosted siteIf your ShotGrid site URL does not end with  shotgunstudio.com or shotgrid.autodesk.com, it means that you are running a local ShotGrid site. In this case, it is possible that your site has not yet been fully prepared for ShotGrid integrations and the ShotGrid team may need to go in and do some small adjustments before you can get going! In this case,  please submit a ticket  and we’ll help sort you out.Connecting to the app store with a locally hosted siteIf you are using a local ShotGrid site with access to the Internet through a proxy, you might want to set an HTTP proxy for accessing the app store, but not the local ShotGrid website. To do this, simply add the following line to  toolkit.ini:app_store_http_proxy: &amp;lt;proxy_server_address&amp;gt;where  &amp;lt;proxy_server_address&amp;gt;  is a string that follows the convention documented  in our developer docs.If you need to override this setting on a per-project basis, you can do so in  config/core/shotgun.yml  in your project’s Pipeline Configuration.Offline Usage ScenariosIn general use, ShotGrid Desktop automatically checks for updates for the Desktop app itself, the tk-desktop engine, and the basic configuration at launch time. However, there are cases where you might want to run integrations while offline or on machines that are completely disconnected from the Internet. The following section describes how to address each of these scenarios.ShotGrid CreateThe approaches to resolving offline usage scenarios outlined in this document also apply to the integration features provided by  ShotGrid Create. The various environment variables used to tailor the behavior of ShotGrid Toolkit, such as  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS, apply when using ShotGrid Create in the same ways as ShotGrid Desktop.Running integrations while offlineScenario: I want to run ShotGrid integrations, but I am not connected to the Internet. We have a local ShotGrid install.Solution  If you can temporarily connect to the internet, just download ShotGrid Desktop. It comes prepackaged with a set of  integrations, and pre-bundled with all the apps and engines needed for the ShotGrid integrations for all supported DCCs. When you start it up, it will automatically try to look for upgrades, but if it cannot connect to the ShotGrid App Store, it will simply run the most recent version that exists locally.Good to know  Some Toolkit operations (such as registering a Publish) require access to your ShotGrid site. So, this solution only works for locally hosted sites.  Updates are downloaded to your local machine.  If you switch between being connected and disconnected, Desktop, as well as in-app integrations like those inside Maya and Nuke, will download upgrades at startup whenever they are connected.Managing updates via manual downloadScenario: Our artist workstations are disconnected from the internet, so we cannot use the auto-updates in Desktop. We still want to get updates, but we have to download them via a single online machine and manually transfer them to artists or into a centralized location.Solution  Run ShotGrid Desktop on a workstation connected to the internet. When it starts up, the latest upgrades are automatically downloaded at launch time.  Option 1: Shared Desktop bundle  Copy the  bundle cache  to a shared location where all machines can access it.  Set the  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS  environment variable on offline machines to point to this location.  When Desktop starts up on offline machines, they will pick up the latest upgrades that are available in the bundle cache.  Option 2: Local deployment  Distribute the updated bundle cache to the correct bundle cache location on each local machine.Good to know  With Option 1, the Toolkit code will be loaded from the location defined in  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS. If this location is on a shared storage, make sure that it is performant enough to load many small files.  For Windows setups, this is often not the case. Here we would instead recommend Option 2.Locking off updatesWhile Desktop’s auto-updates are handy for making sure you always have the latest, sometimes you’ll want to freeze a project, or even your whole site, locking it to a specific version and preventing any updates.Freezing updates for a single projectScenario: My project is about to wrap and I would like to freeze it so that no ShotGrid integration updates are automatically downloaded.Solution  Determine the version you want to lock your project to.  You can find the integration releases here.  In ShotGrid, create a Pipeline Configuration entity for the project you want to lock down, with the following fields populated (In this example, we are locking down the config to use v1.0.36 of the integrations):  Name:  Primary  Project: The project you want to lock down  Plugin ids:  basic.*      Descriptor:  sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36    Anyone starting ShotGrid Desktop on the project will now always use v1.0.36. Any new users starting to work on the project will also get v1.0.36.Good to know  Updates are downloaded to your local machine.  The next time a user launches Desktop while connected to the Internet,  v1.0.36  of the basic config, and all of its related code, will be downloaded to their machine.  basic.*  means that all plugins in the basic configuration will pick up this override. If, for example, you wanted to freeze the Nuke and Maya integrations only, you could specify  basic.maya, basic.nuke.  To test, you can create a duplicate of this Pipeline Configuration entity, and add your username to the  User Restrictions  field. This will restrict the entity such that it’s only available to you and won’t impact other users. You can then launch Maya or some other software from this duplicate configuration and confirm that it’s running the expected integrations versions.Known issues  The Flame integration is namespaced  basic.flame, and so is implied to be part of  basic.*. However, the Flame integration isn’t actually included in the basic config. So, if you are using Flame for a project and implement this override, the Flame integration will stop working.  The solution would be to create an additional Pipeline Configuration override specifically for flame:  Name:  Primary  Project: The project you want to lock down (or None for all projects)  Plugin ids:  basic.flame  Descriptor:  sgtk:descriptor:app_store?name=tk-config-flamepluginFreezing updates for your siteScenario: I don’t want any updates. I want full control over what is being downloaded and used in all projects in my studio.Solution  Follow the steps in the above example, but leave the  Project  field blank. With no override in the  Project  field, this Pipeline Configuration entity will apply to all projects, including the “site” project, i.e., the site configuration that is used by Desktop outside of any project.Good to know  This is the workflow to use if you want to “lock down the site config”. This would lock down everything, and you can then proceed with the advanced project setup via the Desktop menu.  If you lock down your entire site to use, for example,  v1.2.3, you can still lock down an individual project to use another config.Known issues  Flame would be affected by this. See the ‘Known Issues’ section of the above scenario for a solution.Freezing updates for all but one projectScenario: I’d like to lock down all projects in our site, except for our test project, which we still want to allow to auto-update.Solution  Freeze updates for your site as described in the above section.  Configure the exception project’s Pipeline Configuration entity to have the following field values:  Name:  Primary  Project: The project you want  not  to lock down  Plugin ids:  basic.*  Descriptor:  sgtk:descriptor:app_store?name=tk-config-basicGood to know  Note that you’ve omitted the version number from the Descriptor field for the project. This will mean that the project is tracking the latest release of the basic config.Safely Upgrading a locked off site  Scenario: We’re locked down to v1.0.0, and we’d like to upgrade to v2.0.0, but first I want to test out the new version before deploying it to the studio.*Solution  Duplicate the Pipeline Configuration entity in ShotGrid by right-clicking on it and selecting “Duplicate Selected”.  Name the cloned config “update test”, and assign yourself to the User Restrictions field.  You will now begin to use this Pipeline Configuration.  Change the descriptor to point to the version you wish to test.  You can invite any users you want to partake in testing by adding them to the User Restrictions field.  Once you are happy with testing, simply update the main Pipeline Configuration to use that version.  Once users restart Desktop or DCCs, the update will be picked up.Taking over a Pipeline ConfigurationWithout setting up any configurations, you get a basic set of ShotGrid integrations out-of-the-box, and this document covers the kinds of administration you can do with these out-of-the-box integrations. This basic setup is built on top of ShotGrid’s Toolkit platform, which supports much richer customization. Within Desktop, the Toolkit Project Setup Wizard will lead you through the process of creating a full, customizable Pipeline Configuration for your project.Each section below explains in detail each of the steps of the Wizard with examples and suggestions of sensible default values in case you are not sure how to set things up.Launching the setup wizard from DesktopOnce you have navigated to a project there will be an “Advanced Project Setup…” menu item in the user menu in the bottom right hand of Desktop. Click on this menu item to launch the Toolkit Setup Wizard.Select a configuration typeWhen you start configuring a new project, the first thing to decide is  which configuration template to use. A configuration template is essentially the complete project configuration with all settings, file system templates, apps and logic needed to run the project.  If this is your very first project, head over to the ShotGrid defaults to get you started.  If you already have configured projects and configurations for previous projects, you can easily reuse these by basing your new project on an existing project  For advanced workflows, you can use external configurations or configs stored in git repositories.Default configuration templatesThis is the place to go if you want to start from scratch. The default configuration contain all the latest apps and engines set up with a default file structure and file naming convention.Once you have installed the default configuration, you can manually tweak the configuration files and customize it to fit the specific needs of your pipeline. Once you have got a project up and running, you can base your next project on this configuration.The Default ConfigurationThis is the default Toolkit VFX configuration and usually a great starting point when you start setting things up. It comes with 3dsmax, Flame, Houdini, Nuke, Mari, Maya, Motionbuilder, and Photoshop set up and contains a simple, straight forward folder setup on disk.The configuration contains a number of different pieces:  A file system setup  A set of templates to identify key locations on disk  A set of preconfigured engines and apps which are chained together into a workflow.File System OverviewThe standard config handles Assets and Shots in ShotGrid. It breaks things down per Pipeline Step. A pipeline step is similar to a department. Each pipeline step contains work and publish areas for the various supported applications. The Shot structure looks like this:Applications and workflowsThe config contains the following components:  Maya, Mari, Nuke, 3dsmax, Flame, Houdini, Photoshop, and Motionbuilder support  ShotGrid Application Launchers  Publishing, Snapshotting, and Version Control  A Nuke custom Write Node  ShotGrid integration  A number of other tools and utilitiesIn addition to the apps above, you can easily install additional apps and engines once the config has been installed.Basing your new project on an existing projectThis is a quick and convenient way to get up and running with a new project with all the defaults and settings that you had in a previous project. Toolkit will simply copy across the configuration from your old setup to the new project. This is a simple and pragmatic way to evolve your configuration - each new project is based on an older project.For more ways and documentation on how to evolve and maintain your pipeline configuration, see here:Managing your project configurationUsing a configuration template from gitUse this option if you want to keep your project’s configuration connected to source control. Specify a url to a remote git or github repository and the setup process will clone it for you. Note that this is not just github, but works with any git repository. Just make sure that the path to the repository ends with  .git, and Toolkit will try to process it as a git setup. Because your project configuration is a git repository, you can commit and push any changes you make to your master repository and beyond that to other projects. Using a github based configuration makes it easy to keep multiple Toolkit projects in sync. You can read more about it here:Managing your project configurationPlease note that if you are running on Windows, you need to have git installed on your machine and accessible in your  PATH. On Linux and Mac OS X, it is usually installed by default.Browsing for a configuration templateUse this option if you have a configuration on disk, either as a folder or zipped up as a zip file. This can be useful if someone has emailed a configuration to you or if you keep a master config on disk which you are basing all your projects on. This is usually an expert option and we recommend either using a config from another project or one of our app store default configs.Setting up a storageEach Toolkit project writes all its files and data to one or more shared storage locations on disk. For example, a configuration may require one storage where it keeps textures, one where it keeps renders and one where it stores scene files. Normally, these storages are controlled from within the ShotGrid Site Preferences, under the  File Management  tab.The Toolkit Setup wizard will ask you to map each storage root required by the configuration to a local storage in ShotGrid.The required root is listed on the left with its description (as defined in the configuration’s  roots.yml  file). On the right, a list of existing ShotGrid local storages is listed. You must select a storage for each required root and enter a path for the current OS if one does not already exist in ShotGrid.You can also add paths for other operating systems that have not been defined. Existing paths are locked to ensure you don’t accidentally affect other projects that may be relying on that storage path. The mapping page in the wizard will ensure that you’ve mapped each required root and that each mapping is valid.You can create a new local storage in the wizard as well by selecting the  +New  item at the end of the storage selection list. You will be prompted for a local storage name and path for the current OS.Once the project is being set up, Toolkit will create a folder for each new project in each of the storage locations. For example, if your primary storage location is  /mnt/projects, a project called  The Edwardian Cry  would end up in  /mnt/projects/the_edwardian_cry. And if the config is using more than just the primary storage, each of the storages would end up with an  the_edwardian_cry  folder.Your primary storage location is typically something like  /mnt/projects  or    studio projects  and is typically a location where you are already storing project data, grouped by projects. It is almost always on a shared network storage.Choosing a project folder nameNow it is time to choose a disk name for your project. This folder will be created in all the different storages which are needed by the configuration. You can see a quick preview in the UI - for most configurations this will only preview the primary storage, but if you are using a multi root config, additional storages will show up too. Toolkit will suggest a default project name based on the name in ShotGrid. Feel free to adjust it in order to create what is right for your setup.Selecting a configuration locationLastly, please decide where to put your configuration files on disk. Toolkit will suggest a location based on previous projects, so that they all end up in the same place on disk.The configuration normally resides on a shared storage or disk, so that it can be accessed by all users in the studio who needs it. If you are planning on using more than one operating system for this project, make sure to enter all the necessary paths. All paths should represent the same location on disk. Often, the path can be the same on Mac OS X and Linux but will be different on Windows.If this is your first project, you typically want to identify a shared area on disk where you store all your future pipeline configurations. This is typically a location where you store software or software settings shared across the studio. This could be something like  /mnt/software/shotgun. It may vary depending on your studio network and file naming conventions.When you set up your first configuration, set it up with paths for all the platforms you use in your studio. This will make it easier later on to create an environment which is accessible from all machines. As a hypothetical example, if your project name is  Golden Circle  you may type in the following three paths:linux:   /mnt/software/shotgun/golden_circlemacosx:  /servers/production/software/shotgun/golden_circlewindows:   prod software shotgun golden_circleWhat can I do once I have a configuration?Once you are up and running with your first configuration, please navigate to our ‘next steps’ documentation to learn more about how to configure and adjust Toolkit to better suite your studio needs:Beyond your first projectYou can also learn more in our  Advanced Project Setup documentation.Advanced functionalitySilent installsIf you are on a Windows network, you can use the argument “/S” to force the .exe ShotGrid Desktop installer to do a silent install. Then you can push a copy of the shortcut to the executable to the startup folder.",
    "url": "/8085533c/",
    "relUrl": "/8085533c/"
  },
  "48": {
    "id": "48",
    "title": "統合",
    "content": "RV の統合ShotGrid Integration、Screening Room for RV、ShotGrid Review など、機能セットに違いがあるいくつかの ShotGrid 統合に加え、RV には Nuke および Maya 向けの統合ツールが付属しています。以下の最初の 2 つのドキュメントでは、Nuke と Maya の統合のインストールとワークフローについて説明し、最後の 2 つのドキュメントではさまざまな ShotGrid の統合について説明します。どちらを使用するかについてはこれらのドキュメントを参照してください。",
    "url": "/268002fe/",
    "relUrl": "/268002fe/"
  },
  "49": {
    "id": "49",
    "title": "Knowledge",
    "content": "Generic KnowledgeIn This Section  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/540597cc/",
    "relUrl": "/540597cc/"
  },
  "50": {
    "id": "50",
    "title": "Learn",
    "content": "ShotGrid Isolation - LearnThis section will host a learning curriculum for ShotGrid Isolation features n the near future.",
    "url": "/da5a2d10/",
    "relUrl": "/da5a2d10/"
  },
  "51": {
    "id": "51",
    "title": "Maya で Toolkit アプリを起動するシェルフ ボタンを追加するにはどうすればいいですか?",
    "content": "Maya で Toolkit アプリを起動するシェルフ ボタンを追加するにはどうすればいいですか?Maya で Toolkit アプリを起動するシェルフ ボタンを Maya に追加するのは非常に簡単です。次に、Loader アプリを起動するカスタム シェルフ ボタンの追加方法の例を示します。                    注: これは、Toolkit が現在の Maya セッションで有効であることが前提です。このコード例では Toolkit をブートストラップしません。    Maya でスクリプト エディタを開き、次の Python コードを貼り付けます。 import maya.cmds as cmds# Define the name of the app command we want to run.# If your not sure on the actual name you can print the current_engine.commands to get a full list, see below.tk_app = &quot;Publish...&quot;try:    import sgtk    # get the current engine (e.g. tk-maya)    current_engine = sgtk.platform.current_engine()    if not current_engine:        cmds.error(&quot;ShotGrid integration is not available!&quot;)    # find the current instance of the app.    # You can print current_engine.commands to list all available commands.    command = current_engine.commands.get(tk_app)    if not app:        cmds.error(&quot;The Toolkit app '%s' is not available!&quot; % tk_app)    # now we have the command we need to call the registered callback    command['callback']()except Exception, e:    msg = &quot;Unable to launch Toolkit app '%s': %s&quot; % (tk_app, e)    cmds.confirmDialog(title=&quot;Toolkit Error&quot;, icon=&quot;critical&quot;, message=msg)    cmds.error(msg)このコードを選択して、カスタム シェルフにドラッグします。カスタム シェルフ ボタンの使用方法に関する詳細については、Maya ドキュメントを参照してください。上部の tk_app と call_func の各変数を修正して、Maya で有効な Toolkit アプリを起動するには、このコード サンプルを使用できる必要があります。",
    "url": "/dba779a5/",
    "relUrl": "/dba779a5/"
  },
  "52": {
    "id": "52",
    "title": "Media Isolation",
    "content": "Media IsolationMedia Isolation allows your studio to retain ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid is stored in your studio’s private S3 Bucket. Access to the media is provided to the ShotGrid services only, using AWS AssumeRole keyless Security Token Service.Client-Owned S3 BucketStoring media and attachments in an S3 bucket that you own means that you remain the legal owner of these artifacts, allowing you to comply with your company’s security and legal policies. Your studio retains control of asset storage and access, access that you can revoke at will.More about AccessWhen using ShotGrid to upload and download media it is transferred directly to / from AWS S3 without transiting through Autodesk infrastructure. ShotGrid will only access media in two situations:  The ShotGrid Transcoding service will get read/write access once, soon after upload, when transcoding the media. See Ephemeral Transcoding for details.  When the ShotGrid service generates S3 Links to your sources and transcoded media.This is rendered possible by leveraging AWS AssumeRole keyless Security Token Service. When setting up Media Isolation, an AWS Role allowing ShotGrid to access your media for the action listed above is created, and the ShotGrid service is allowed to assume that role.ShotGrid Support staff do not have access to your S3 Bucket under any circumstances.CostsWhen activating Media Isolation the following costs, previously covered by Autodesk, become the responsibility of the client:  S3 Costs. All the S3 storage costs will be assumed by the customer. See Media Isolation for more details about how to reduce costs.  S3 Bandwidth. Bandwidth out of the S3 bucket will be assumed by the customer.What Media Isolation is not providingActivating Media Isolation doesn’t guarantee that the access to your ShotGrid site or media takes place within a closed network.",
    "url": "/a3c0e676/",
    "relUrl": "/a3c0e676/"
  },
  "53": {
    "id": "53",
    "title": "Media Replication",
    "content": "Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.Pre-requisitesMedia Isolation is required in order to elect Media Replication.Configuration by usersWhen using Media Replication, each user can customize which region data is read from. A user can either specify the region to use, or use automatic mode. In automatic mode ShotGrid selects the replica determined by the user’s IP address using IP ranges specified in the Isolation Preferences.How it worksShotGrid can be configured to read from up to two different buckets. Using the AWS S3 Replication feature, you can configure replication between buckets in different regions, and then consume media from the region closest to your users. It is important to underline that media is always uploaded to the main bucket.Following AWS service level agreement, S3 guarantees the replication of 99.99% of the object within 15 minutes.Replication DelayA small amount of time, typically under 15 minutes, is required before replication happens. The replication time depends on the size of the object to replicate. In order to alleviate that replication delay, ShotGrid will, for a small period of time, generate links from to object in the source bucket instead of the replica. The duration of this transitional state in configurable in the Isolation Preferences.CostsActivating the Media Replication feature can increase your AWS costs considerabibly. Before activating, be aware that:  Your S3 cost linked to ShotGrid usage will more or less double, because the media is now stored in two regions.  You will be charged for the transfer cost between the source and the destination region. See AWS S3 CRR and the destination region for more details.Next StepsSee Media Replication Setup for setup instructions.",
    "url": "/0221297e/",
    "relUrl": "/0221297e/"
  },
  "54": {
    "id": "54",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic Isolation using AWS PrivateLink for Amazon S3                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS regionYou will need to deploy a VPC with the required VPC endpoint. We provide a private VPC CloudFormation templates as starting points. This template create the necessary VPC, subnets and VPC endpoint.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc-s3-privatelink.yml  Click Next  Set a stack name. Eg. ShotGrid-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used.    Simply add an com.amazonaws.us-west-2.s3 Interface VPC Endpoint to your existing VPC. Make sure the associated security group allow traffic from your site network.Add the VPC to your S3 bucket policyIn order for the S3 VPC endpoint to communicate with your S3 bucket your bucket policy must allow access from the S3 endpoint’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 VPC endpointUse the endpoint URL to list objects in your bucket using AWS CLI. In the following example, replace the VPC endpoint ID vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com and bucket name my-bucket with appropriate information.    aws s3 --endpoint-url https://bucket.vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com ls s3://my-bucket/Configure your test site to use your S3 VPC endpoint  Navigate to the Site Preferences menu within ShotGrid and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Web Traffic Isolation to activate the Web Traffic Isolation feature.See Media Replication to activate the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/2ab85e3e/",
    "relUrl": "/2ab85e3e/"
  },
  "55": {
    "id": "55",
    "title": "Media Traffic Isolation - S3 Proxy",
    "content": "                    Deprecated: The preferred way is to use S3 Private Link instead of a S3 proxy, see Media Traffic Isolation    Media Traffic Isolation using an S3 proxy (DEPRECATED)                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS region                    Disclaimer: Before starting, decide whether your S3 proxy will be privately accessible within your VPC or publicly accessible via the Internet and choose the relevant templates in the following instructions.    You will need to deploy a VPC with the required VPC endpoints. We provide both private VPC and public VPC CloudFormation templates as starting points. These template create the necessary VPCs, subnets and VPC endpoints.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private VPC (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc.yml      Public VPC:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-public-vpc.yml        Click Next  Set a stack name. Eg. shotgun-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used when configuring Media Isolation.    Set up S3 proxyYou will need to deploy an S3 proxy in your VPC to forward traffic to the S3 VPC endpoint. We provide both private and public S3 proxy CloudFormation templates as starting points for this purpose. These will create the necessary Elastic Container Service (ECS) cluster and other resources to run the S3 proxy on AWS Fargate behind an AWS Application Load Balancer (ALB).Make the Docker image available from a private AWS ECR repository  Create a new Elastic Container Registry (ECR) repository  Name the repository s3-proxy  Upload the s3-proxy Docker image to the newly created ECR repository          Install Docker on your workstation      Follow the docker login instructions shown by clicking the View push commands button      Run the following commands, substituting the ECR endpoint in the example for yours:        docker pull quay.io/shotgun/s3-proxy:1.0.6docker tag quay.io/shotgun/s3-proxy:1.0.6 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6docker push 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6                    Create S3 proxy CloudFormation stackCreate a new stack in AWS Console using either the private or public CloudFormation template.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private S3 proxy (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy.yml      Public S3 proxy:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy-public.yml        Click Next  Set a stack name up to 32 characters in length. Eg. shotgun-s3-proxy  Set the parameters that do not have default values with those used when creating the ECR repository, VPC and S3 bucket previously  Click Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  Click NextConfigure HTTPSShotGrid requires that the S3 proxy be accessed via HTTPS, therefore the AWS ALB handling requests for your newly created S3 proxy stack must be configured to accept HTTPS requests.  Create a DNS entry pointing to your S3 proxy, depending upon whether public or private          Private S3 proxy (default):                  Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and make a note of the DNS name          Add a DNS CNAME record pointing to the DNS name of the ALBEg. s3-proxy.mystudio.com. 300 IN CNAME s3proxy-12R1MXX0MFFAV-2025360147.us-east-1.elb.amazonaws.com.                    Public S3 proxy:                  Go to the AWS Global Accelerator dashboard and make a note of the DNS name associated with your S3 proxy’s accelerator          Add a DNS CNAME record pointing to the DNS name of the Global AcceleratorEg. s3-proxy.mystudio.com. 300 IN CNAME a48a2a8de7cfd28d3.awsglobalaccelerator.com.                      Obtain an SSL certificate for your chosen URL, we recommend using AWS Certificate Manager (ACM) for this  Configure HTTPS for the S3 proxy by adding a new HTTPS listener to the AWS ALB          Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and click on the Listeners tab      Click Add listener      Select HTTPS from the Protocol dropdown menu      Click Add action -&amp;gt; Forward to…      Select your S3 proxy’s target group from the Target group dropdown menu      Select the Security policy you’d like to use. Eg. TLS-1-2-Ext-2018-06 (See AWS documentation for more information)      Select the SSL certificate you’d like to use from ACM or import a new certificate      Click Save      Add S3 proxy VPC to S3 bucket policyIn order for the S3 proxy to communicate with your S3 bucket your bucket policy must allow access from the S3 proxy’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 proxyTry to access your S3 proxy using the ping route. Eg. https://s3-proxy.mystudio.com/pingConfigure your test site to use the S3 proxy  Navigate to the Site Preferences menu within ShotGrid and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Web Traffic Isolation to activate the Web Traffic Isolation feature.See Media Replication to activate the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/85124db5/",
    "relUrl": "/85124db5/"
  },
  "56": {
    "id": "56",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic IsolationCommunication between your client systems and S3 bucket targets a number of AWS network endpoints and data traverses the open Internet by default. Media Traffic Isolation allows you to limit the number of network endpoints used to transfer data to and from your S3 bucket and optionally restrict access to your AWS VPC or a defined set of public address scopes.ConfigurationAn S3 Proxy component is deployed within your VPC; which is then used as the endpoint for all S3 communication. It can also be made publicly available using AWS Global Accelerator.How it worksShotGrid can be configured to use an S3 Proxy address to communicate with your S3 bucket. Deploying the S3 Proxy component within your VPC makes it possible to isolate traffic from the public Internet completely, or to allow more tightly controlled access from the Internet to your media.Secure communicationYou are responsible for supplying and renewing SSL certificates for the S3 Proxy component.CostsActivating the Media Traffic Isolation feature will increase your AWS costs. Before activating, be aware that:  There are costs associated with running the S3 Proxy component. See AWS Fargate Pricing for more details.  If you choose to make your S3 Proxy publicly accessible, there are also additional costs associated with AWS Global Accelerator. See AWS Global Accelerator Pricing for more details.Next StepsSee Media Traffic Isolation for setup instructions.",
    "url": "/58919eae/",
    "relUrl": "/58919eae/"
  },
  "57": {
    "id": "57",
    "title": "SG Desktop から Nuke や Maya などを起動したが ShotGrid のメニューにエントリが表示されない",
    "content": "SG Desktop から Nuke や Maya などを起動したが ShotGrid のメニューにエントリが表示されないShotGrid メニューに表示されるアクションはコンテキストに応じて設定されます。つまり、利用可能なアクションのリストは、現在のコンテキストによって異なる可能性があります。コンテキストが間違っているためにアプリが表示されない可能性があります。例ShotGrid Desktop からアプリケーションを起動すると、既定ではプロジェクト環境が表示されます。この環境は、config/env/project.yml に格納されたパイプライン設定内の設定ファイルによって管理されます。ユーザーの作業のほとんどはこの環境では行わないため、多くのアプリでは操作用に設定されていません。既定の Maya プロジェクト アクション:ShotGrid Workfiles アプリを使用すると、作業するアセット、ショット、またはタスクを選択できます。これにより、新しい適切な環境をロードし、多くのアプリで ShotGrid メニューのメニュー項目を有効にできます。既定の Maya アセット タスク アクション:環境が正しいにもかかわらずアクションが表示されない場合は、関連するログを調べ、エラーがないかどうかを確認します。完全な出力を取得するには、デバッグ ログを有効にしなければならない可能性があります。",
    "url": "/901110e2/",
    "relUrl": "/901110e2/"
  },
  "58": {
    "id": "58",
    "title": "Migration",
    "content": "MigrationOnce everything is configured and properly tested with the migration test site, it’s now time to migrate your production site to use the isolation features.Test migrationAsk the ShotGrid team to start the migration process in support ticket/slack.  ShotGrid will clone your production site database to your migration test site.  You will do a first sync of the media from ShotGrid’s S3 bucket to your bucket. ShotGrid will provide the exact instructions.  You can now test your site to be sure your existing media is available.Final migrationThe second test is to definitly migrate your site to use your own S3 bucket.  You will do a second sync of the media from ShotGrid’s S3 bucket to your bucket.  ShotGrid will reconfigure your hosted site with media isolation. Some media will be missing until the final media sync is completed.  You will do a final media sync.",
    "url": "/09699c82/",
    "relUrl": "/09699c82/"
  },
  "59": {
    "id": "59",
    "title": "パイプライン設定を新しい場所に移動するにはどうすればいいですか?",
    "content": "パイプライン設定を新しい場所に移動するにはどうすればいいですか?                    注: このドキュメントのコンテンツは一元管理設定のセットアップにのみ適用されます。分散設定は個々のクライアント マシンにローカルにキャッシュされ、Toolkit によって自動的に管理されます。    パイプライン設定を新しい場所に簡単に移動するには、tank move_configuration コマンドを使用します。これにより、ファイルを移動したり、ShotGrid を更新したり、新しい場所を指すように設定ファイルを更新したりします。 またこのコマンドは、1 つのオペレーティング システムで場所を移動するだけの場合や、以前は特定のオペレーティング システムを使用していなかったがこれから追加する場合などにも役立ちます。Toolkit は、移動する項目、追加する項目、またはそれ以外の項目を検出し、適用前に確認できるように実行内容が表示されます。  タンク move_configuration コマンドを使用  パイプライン設定を手動で移動する                    注意: ローカライズされたコアを持つ設定を移動していて、このパイプライン設定に埋め込まれた Toolkit コアを使用する他のプロジェクトがある場合(つまり、他の設定がこれを共有コアとして使用している場合)は、このパイプライン設定の新しい場所を指すようにこのプロジェクトの設定ファイルを手動で更新する必要があります。このファイルは次の場所に格納されています。  /path/to/pipeline_configuration/install/core/core_Darwin.cfg  /path/to/pipeline_configuration/install/core/core_Linux.cfg  /path/to/pipeline_configuration/install/core/core_Windows.cfg    タンク move_configuration コマンドを使用:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://toolkit.shotgunsoftware.com    Starting Toolkit for your current path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Syntax: move_configuration linux_path windows_path mac_path    This will move the location of the given pipeline configuration.    You can also use this command to add a new platform to the pipeline    configuration.    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    You typically need to quote your paths, like this:    &amp;gt; tank move_configuration &quot;/linux_root/my_config&quot; &quot;p: configs my_config&quot;    &quot;/mac_root/my_config&quot;    If you want to leave a platform blank, just just empty quotes. For example, if    you want a configuration which only works on windows, do like this:    &amp;gt; tank move_configuration &quot;&quot; &quot;p: configs my_config&quot; &quot;&quot;例:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration &quot;/mnt/hgfs/sgtk/software/shotgun/scarlet_new&quot; &quot;z: sgtk software shotgun scarlet_new&quot; &quot;/sgtk/software/shotgun/scarlet_new&quot;    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://toolkit.shotgunsoftware.com    Starting toolkit for path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    New Paths    --------------------------------------------------------------    New Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet_new'    New Windows Path: 'z: sgtk software shotgun scarlet_new'    New Mac Path:     '/sgtk/software/shotgun/scarlet_new'    The configuration will be moved to reflect the specified path changes.    Note for advanced users: If your configuration is localized and you have other    projects which are linked to the core API embedded in this configuration,    these links must be manually updated after the move operation.    Are you sure you want to move your configuration? [Yes/No] yes    Copying '/sgtk/software/shotgun/scarlet' -&amp;gt; '/sgtk/software/shotgun/scarlet_new'    Copying /sgtk/software/shotgun/scarlet/cache...    Copying /sgtk/software/shotgun/scarlet/config...    Copying /sgtk/software/shotgun/scarlet/config/core...    Copying /sgtk/software/shotgun/scarlet/config/core/hooks...    Copying /sgtk/software/shotgun/scarlet/config/core/schema...    Copying /sgtk/software/shotgun/scarlet/config/env...    Copying /sgtk/software/shotgun/scarlet/config/env/includes...    Copying /sgtk/software/shotgun/scarlet/config/hooks...    Copying /sgtk/software/shotgun/scarlet/config/icons...    Copying /sgtk/software/shotgun/scarlet/install...    Copying /sgtk/software/shotgun/scarlet/install/apps...    Copying /sgtk/software/shotgun/scarlet/install/apps/app_store...    Copying /sgtk/software/shotgun/scarlet/install/core...    Copying /sgtk/software/shotgun/scarlet/install/core/python...    Copying /sgtk/software/shotgun/scarlet/install/core.backup...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143244...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143940...    Copying /sgtk/software/shotgun/scarlet/install/engines...    Copying /sgtk/software/shotgun/scarlet/install/engines/app_store...    Copying /sgtk/software/shotgun/scarlet/install/frameworks...    Copying /sgtk/software/shotgun/scarlet/install/frameworks/app_store...    Updating cached locations in /sgtk/software/shotgun/scarlet_new/config/core/install_location.yml...    Updating ShotGrid Configuration Record...    Deleting original configuration files...    All done! Your configuration has been successfully moved.パイプライン設定を手動で移動する                    重要: パイプライン設定をまだ移動していない場合は、上記の組み込み tank コマンドを使用して自動的に移動することを強くお勧めします。    既に手動で移動を開始したが正しく動作しない場合は、新しい場所に移動されたパイプライン設定で Toolkit が引き続き動作するようにするために、変更が必要な内容を以下に示します。      パイプライン設定を新しい場所に移動します。     $ mv /sgtk/software/shotgun/scarlet /mnt/newserver/sgtk/software/shotgun/scarlet_new            Toolkit でパイプライン設定が格納されている場所を見つけられるように install_location.yml を編集します。     $ vi /mnt/newserver/sgtk/software/shotgun/scarlet_new/config/core/install_location.yml        適用可能なプラットフォームすべてで、パイプライン設定の新しい場所を示すようにこのファイル内のパスを更新します。プラットフォームを使用していない場合は、空の文字列 '' を入力します。     # ShotGrid Pipeline Toolkit configuration file # This file was automatically created by setup_project # This file reflects the paths in the primary pipeline # configuration defined for this project. Windows: 'Y: sgtk software shotgun scarlet_new' Darwin: '/mnt/newserver/sgtk/software/shotgun/scarlet_new' Linux: '' # End of file.            ShotGrid でこのプロジェクトに対応する PipelineConfiguration エンティティを特定し、上記の変更と一致するように、[Mac のパス]（Mac Path）、[Windows のパス]（Windows Path）、[Linux のパス]（Linux Path）の各フィールドの値を修正します。  これでパイプライン設定が新しい場所から予想どおりに機能するようになりました。                    注: SG Desktop を使用している場合、プロジェクトから移動して、この新しい場所のパイプライン設定をリロードするためにプロジェクト アイコンを再びクリックする必要があります。    ",
    "url": "/18e34e3c/",
    "relUrl": "/18e34e3c/"
  },
  "60": {
    "id": "60",
    "title": "プロジェクト ディレクトリを新しいローカル ストレージのルートに移動するにはどうすればいいですか?",
    "content": "プロジェクト ディレクトリを新しいローカル ストレージのルートに移動するにはどうすればいいですか?                    注意: プロジェクトの途中でプロジェクトの場所を移動すると、ShotGrid Toolkit の範囲を超えて問題が発生する可能性があります。安易に実行しないように注意してください。    必要に応じて、プロジェクト ファイル(シーン ファイルやレンダリングなど)を 新しいルート ストレージ場所に移動することがあります(たとえば /mnt/smalldrive から /mnt/bigdrive/foo へ)。このためには、単一ルート設定またはマルチルート設定を使用します。たとえば、「asset_storage」という名前のストレージを移動するとします。  古い場所から新しい場所にプロジェクト ファイルをコピー(または移動)します。  ShotGrid で、[管理者]（Admin） &amp;gt; [サイト基本設定]（Site Preferences）ページに移動して、[ファイル管理]（File Management）セクションを開きます。  各プラットフォームでプロジェクト ファイルの新しいストレージへのパスを設定して、「primary」と言う名前のローカル ファイル ストレージを更新します。特定のプラットフォームを使用していない場合は、空白のままにします。  ページの上部または下部にある[変更を保存]（Save Changes）ボタンをクリックします。  ShotGrid で保存したばかりの新しいパスの値と一致するようにプロジェクト設定の config/core/roots.yml ファイルを更新します。Toolkit はパブリッシュ パスをストレージ ルートの相対パスとして保存します。そのため、古いストレージ ルートを使用すると、パスはその前提に基づいて展開されていました。[asset_storage]/assets/Character/betty =&amp;gt; /mnt/smalldrive/assets/Character/betty新しいストレージ ルートの定義を使用すると、パスは次のように展開されます。[asset-storage]/assets/Character/betty =&amp;gt; /mnt/bigdrive/foo/assets/Character/bettyこれで、ShotGrid や Toolkit 内の他のパブリッシュ情報の更新を心配する必要はありません。                    警告: 上記の手順では、既存のストレージ ルートのパスを変更していると想定しています。既存のストレージを破棄するか、新規のストレージを作成する場合は、すべてのフォルダを再登録して PublishedFiles エンティティを再公開する必要があります。    参考情報シーン ファイルで古いパスを指定している場合は、自分でパスを更新するか、パスが適切に解決されるようにシンボリック リンクを作成する必要があります。バージョンこの変更の影響を受ける[ムービーのパス]（Path to Movie）フィールドまたは[フレームのパス]（Path to Frames）フィールドに情報を持つバージョン エンティティを ShotGrid で使用する場合、これらのフィールドも新しい場所をポイントするように更新する必要があります。これらのフィールドは、メディアへの絶対パスを含む文字列フィールドであるためです。",
    "url": "/9aaa493a/",
    "relUrl": "/9aaa493a/"
  },
  "61": {
    "id": "61",
    "title": "環境変数 NUKE_PATH を設定すると Nuke 統合の起動に失敗するのはなぜですか?",
    "content": "環境変数 NUKE_PATH を設定すると Nuke 統合の起動に失敗するのはなぜですか?当社の統合では Nuke の起動時に NUKE_PATH 環境変数が設定され、Nuke の起動プロセス中にブートストラップ スクリプトが実行されます。before_launch_app.py フックを実行する前に NUKE_PATH を明示的に定義するのは tk-multi-launchapp です。起動プロセス中に os.environ['NUKE_PATH'] = &quot;/my/custom/path&quot; などを使用してこの環境変数を設定している場合、ShotGrid の統合は開始されません。これは、起動スクリプトのパスを環境変数から削除したためです。この機能を tank.util で使用すると、Toolkit ブートストラップへのパスを維持しながら、パスが環境変数 NUKE_PATH またはその先頭に追加されます。tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)または、prepend_path_to_env_var() を使用してパスを先頭に追加できます。",
    "url": "/fc2af72c/",
    "relUrl": "/fc2af72c/"
  },
  "62": {
    "id": "62",
    "title": "Disabling auto updates and offline usage",
    "content": "Disabling auto updates and offline usageAuto updatesWhat parts auto update?By default ShotGrid Desktop will automatically check for updates, and install them to the local machine if it finds any.It checks for updates on two components:  tk-framework-desktopstartup - A frame work which aids the launch of ShotGrid Desktop.  tk-config-basic - The default site config.The configuration acts as a manifest for the versions of the apps, engines, frameworks, and core version that should be used by ShotGrid Desktop.By updating the config, you are potentially updating any of these components as well.Any updates that are found are downloaded and stored in the user’s local cache, rather than modifying the original ShotGrid Desktop installed files.ShotGrid Create as an application has it’s own update mechanism separate from ShotGrid Desktop which is not covered here.However the integration features provided in ShotGrid Create work in a similar way, and will also auto update tk-config-basic into the same user cache.What doesn’t auto update?If you have taken over a site configuration, then it won’t check for newer tk-config-basic updates but more on that further down.Also any projects that aren’t using the default site configuration (I.e. a project where the Toolkit advanced setup wizard has been run on it.), will not have their configuration auto updated.What if I can’t or don’t want to auto update?There are scenarios where you might want to run integrations in an environment where there is no connection to the internet or just have control when updates roll out.                    Note: If possible we recommend that you continue to allow auto updates to avoid missing out on new features and bug fixes.    The following sections describes how to address each of these scenarios.  Offline Usage Scenarios  Disabling auto updatesRunning the integrations offline.Initial SetupIf your studio has restricted internet access or no internet access then you will need to ensure that you have all the required parts cached locally.You will still need one machine that can connect to the internet in order to download ShotGrid Create or ShotGrid Desktop.ShotGrid Create and ShotGrid Desktop come prepackaged with all the dependencies required to run the basic integrations.When you start either of them up, it will automatically try to look for updates, but if it cannot connect to the ShotGrid App Store, it will simply run the most recent version that exists locally.It is recommended that you follow the “Managing updates” steps bellow after installing ShotGrid Desktop, as the components bundled with the installer may not be the latest.                    Note: Depending on your network setup, it can sometimes get stuck looking for updates online even though it won’t be able to access them. In this situation you can set the environment variable shotgun_DISABLE_APPSTORE_ACCESS to &quot;1&quot; to stop it from trying.                        Note: You will still need to be able to connect to your ShotGrid site. When we say offline we are talking about not being able to connect to our app store to download updates.    Managing updatesTo update the tk-framework-desktopstartup component, you will need to download the latest version, and set the environment variableSGTK_DESKTOP_STARTUP_LOCATION to point to its location on disk.For the tk-config-basic component it’s a bit more tricky, due to all its dependencies.  Run ShotGrid Desktop on a workstation connected to the internet. When it starts up, the latest upgrades will be automatically downloaded.(Ensure SHOTGUN_DISABLE_APPSTORE_ACCESS is not set on this machine.)  Copy the bundle cache to a shared location where all machines can access it.  Set the SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS environment variable on offline machines to point to this location.  When Desktop starts up on offline machines, they will pick up the latest upgrades that are available in the bundle cache.                    Warning: Depending on your network setup, it can sometimes get stuck looking for updates online even though it won’t be able to access them. In this situation you can set the environment variable SHOTGUN_DISABLE_APPSTORE_ACCESS to &quot;1&quot; to stop it from trying.    CREATE does come with it’s own bundled config, however it doesn’t seem to have the engines, or atleast doesn’t share them when launching Maya for example.Disabling auto updatesDisabling updates for a single project  Determine the version you want to lock your project to. You can find the integration releases here.  In ShotGrid, create a Pipeline Configuration entity for the project you want to lock down, with the following fields populated (In this example, we are locking down the config to use v1.0.36 of the integrations):          Name: Primary      Project: The project you want to lock down      Plugin ids: basic.*      Descriptor: sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36          Anyone starting ShotGrid Desktop on the project will now always use v1.0.36. Any new users starting to work on the project will also get v1.0.36.Good to know  The next time a user launches Desktop while connected to the Internet, v1.0.36 of the basic config, and all of its related code, will be downloaded to their machine.  basic.* means that all plugins in the basic configuration will pick up this override. If, for example, you wanted to freeze the Nuke and Maya integrations only, you could specify basic.maya, basic.nuke.  To test, you can create a duplicate of this Pipeline Configuration entity, and add your username to the User Restrictions field. This will restrict the entity such that it’s only available to you and won’t impact other users. You can then launch Maya or some other software from this duplicate configuration and confirm that it’s running the expected integrations versions.Known issues  The Flame integration is namespaced basic.flame, and so is implied to be part of basic.*. However, the Flame integration isn’t actually included in the basic config. So, if you are using Flame for a project and implement this override, the Flame integration will stop working.The solution would be to create an additional Pipeline Configuration override specifically for flame:          Name: Primary      Project: The project you want to lock down (or None for all projects)      Plugin ids: basic.flame      Descriptor: sgtk:descriptor:app_store?name=tk-config-flameplugin      Disabling updates for all projectsTo disable updates for all your projects, you can follow the steps in the above example, but leave the Project field blank.With no override in the Project field, this Pipeline Configuration entity will apply to all projects, including the “site” project, i.e., the site configuration that is used by Desktop outside of any project.Good to knowIf you lock down your entire site to use, for example, v1.2.3, you can still lock down an individual project to use another config (see “Disabling updates for all but one project” bellow).Known issuesFlame would be affected by this. See the ‘Known Issues’ section of the above scenario for a solution.Disabling updates for all but one projectIf you have disabled updates on all projects as mentioned in the example above, but would like to enable updates on a specific projectYou can  Disabling updates for your site as described in the above section.  Configure the exception project’s Pipeline Configuration entity to have the following field values:          Name: Primary      Project: The project you want not to lock down      Plugin ids: basic.*      Descriptor: sgtk:descriptor:app_store?name=tk-config-basic        Good to knowNote that you’ve omitted the version number from the Descriptor field for the project. This will mean that the project is tracking the latest release of the basic config.UpgradingScenario: We’re locked down to v1.0.0, and we’d like to upgrade to v2.0.0, but first I want to test out the new version before deploying it to the studio.*SolutionDuplicate the Pipeline Configuration entity in ShotGrid by right-clicking on it and selecting “Duplicate Selected”.Name the cloned config “update test”, and assign yourself to the User Restrictions field.You will now begin to use this Pipeline Configuration.Change the descriptor to point to the version you wish to test.You can invite any users you want to partake in testing by adding them to the User Restrictions field.Once you are happy with testing, simply update the main Pipeline Configuration to use that version.Once users restart Desktop or DCCs, the update will be picked up.",
    "url": "/c186b05d/",
    "relUrl": "/c186b05d/"
  },
  "63": {
    "id": "63",
    "title": "Onboarding Process",
    "content": "Onboarding ProcessLeveraging the isolation features requires adopters to become AWS users. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering.Autodesk and Amazon will provide dedicated resources during the onboarding process to help you on this journey.To start the on-boarding process for any of the Isolation features, please open a ShotGrid Support ticket, before proceeding with your setupOnboarding Process OverviewDuring the onboarding process, you’ll have direct access to Autodesk and AWS Leaders who will support you during the implementation.Tech Briefing:  Overview meeting of all of our offerings, where we underline the advantages and disadvantages of each.Tech Deep Dive:  OPTIONAL. Deeper technical dive into isolation features. This meeting can be combined with the Tech Briefing.Kickoff Meeting:	AWS and ShotGrid Leaders review the setup process with the you.Setup / Test / Validation:	Iterative installation process where you connect your AWS resources to ShotGrid, and activate the isolation features.Training: OPTIONAL. Help sessions, if needed, as you ramp up on the AWS/ShotGrid technologies required to securely set-up the isolation features for your site.Onboarding ResourcesShotGrid Community: The ShotGrid Isolation Community forum can be used to ask questions that can be answered by either ShotGrid Experts or other isolation features users. This should be your first stop when asking general questions about isolation features, during setup and beyond.Private Slack Channel: During the onboarding, you will be given access to a dedicated Autodesk Slack Channel. Your ShotGrid and AWS Leaders will be available for quick feedback, answers, and ad-hoc meetings to help you progress as fast as possible with your ShotGrid Isolation setup. This channel will be available only for the onboarding period.ShotGrid Support: A ShotGrid Support ticket will be used to track your onboarding at a higher level. Once your ShotGrid Isolation setup is complete, follow-up support tickets can be opened with the support team as needed.Next StepsOnce the onboarding process is started, you can start thinking about your setup",
    "url": "/f66c5afa/",
    "relUrl": "/f66c5afa/"
  },
  "64": {
    "id": "64",
    "title": "Other Integrations",
    "content": "Other IntegrationsWith ShotGrid’s API, you can integrate with a number of third party packages. However, there are a few with which ShotGrid integrates right out-of-the-box.CinesyncCinesync allows you to have simultaneous synced playback between multiple locations. ShotGrid’s integration allows you to create a Playlist of Versions, play it in Cinesync, and send your Notes made during the session right back into ShotGrid.For more information, please see http://www.cinesync.com/manual/latest.DeadlineThe ShotGrid+Deadline integration allows you to automatically submit rendered Versions to ShotGrid complete with thumbnail, links to frames, and other metadata.For more information, please see http://www.thinkboxsoftware.com/deadline-5-shotgunevent.RushMuch like the Deadline integration, the ShotGrid+Rush integration allows you to automatically submit rendered Versions to ShotGrid complete with thumbnail, links to frames, and other metadata.For more information, please see http://seriss.com/rush-current/index.html.Subversion (SVN)ShotGrid a light but flexible integration, which we use internally, that allows us to track revisions and link them to tickets and releases in ShotGrid. We also provide links to Trac to integrate with an external web SVN repository viewer. This is all done by adding a post-commit hook to SVN, a ShotGrid API script that takes some ENV variables from the commit and then creates a Revision entity in ShotGrid with various fields filled in. It can be modified to match your studio’s needs and can be used for a local or hosted installation since it’s just using the API. For more information, please see https://subversion.apache.org/docs.",
    "url": "/f0ee6c48/",
    "relUrl": "/f0ee6c48/"
  },
  "65": {
    "id": "65",
    "title": "パフォーマンスのトラブルシューティング",
    "content": "パフォーマンスのトラブルシューティングToolkit の使用速度が低下することがあります。速度が低下する理由はさまざまです。サーバ速度やインターネット接続などのクライアント側インフラストラクチャの問題、Toolkit や ShotGrid が高いパフォーマンスで実行されるように設定されていない設定ベースの問題、さらに最適化を行う余地があるコード上の問題などがあります。次に、チェック項目のクイック リストを示します。これらのチェック項目については、以下で詳細に説明します。  アプリ、エンジン、フレームワーク、コア、ShotGrid Desktop が最新であることを確認します。  一般的な用途のときにデバッグ ログが無効になっていることを確認します。  必要なフォルダのみを作成し、フォルダ数を制限して、実際に必要な場合に限りフォルダが作成されるようにします。スキーマにフォルダを追加しすぎると、速度が低下します。  サーバにユーザ キャッシュを保存する、速度が低下することがあります。ユーザの ShotGrid キャッシュをリダイレクトするには、ローカル ドライブ上の場所を指定するように  ShotGrid_HOME環境変数を設定します。  アーティストが必要としていないコンテンツを除外するように、作業ファイルおよびローダー アプリを設定します。ステータスを基準とするフィルタを実行して、エンティティ リストを短くし、アーティストの現在のタスクに関連するエントリが表示されるようにします。  カスタム フックの有無を調べて、追加のオーバーヘッドがないか確認します。次に、適切な方法と、速度が低下する一般的なシナリオを示します。このリストは、まだすべてを網羅するものではありません。新しいパターンが見つかったときに、適宜追加されます。このガイドを参照しても、現在発生している問題の根本的な原因が見つからない場合は、サポート チケットをお送りください。担当チームがサポートいたします。目次:  一般的なお勧めの方法          キャッシュの場所      最新の状態を保つ      一元管理設定と分散設定      デバッグ        ソフトウェアの起動速度が遅い          診断      問題が発生するタイミング(起動前または起動後)      ログを調べる      ソフトウェアの起動速度が低下する一般的な原因        [File Open]、[File Save]、Loader アプリのいずれかで速度が低下する場合  フォルダ作成速度が低下する          I/O 使用量を制御する      フォルダを登録する      一般的なお勧めの方法キャッシュの場所ShotGrid Toolkit はデータをユーザのホーム ディレクトリにキャッシュします。このキャッシュには、さまざまな SQLite データベース、およびキャッシュされたアプリと設定を含めることができます。通常、ユーザのホーム ディレクトリはマシンのローカル ハード ドライブに保存されますが、スタジオでは、ネットワーク上のストレージにこれらをリダイレクトすることが一般的に行われています。この方法の場合、パフォーマンスが低下することがあります。特に大きな影響を受けるのが、ブラウザの統合やフォルダの作成/検索に使用される SQLite データベースです。ユーザ ディレクトリがサーバ上の場所に保存されている場合は、 ShotGrid_HOME環境変数を使用して、ShotGrid Toolkit のキャッシュのパスを再設定することをお勧めします。ShotGrid_HOME 環境変数は、データおよびその他の項目の高速検索に使用されるバンドル キャッシュ、サムネイル、SQLite データベースなど、Toolkit がさまざまなデータをキャッシュする場所を設定する際に使用されます。デバッグShotGrid Toolkit でデバッグ ログを有効にして、さまざまなプロセスから詳細な出力を取得することができます。このようにすると、問題を診断するときに非常に便利です。ただし、デバッグ設定は、通常の日常的な用途のときは有効にならないように設計されています。ログの出力量が増えると、パフォーマンスが大幅に低下することがあります。パフォーマンスの問題が発生した場合、特に、特定のマシンやユーザに限定された問題が発生する場合は、最初にデバッグ ログが有効になっていないことを確認してください。最新の状態を保つパフォーマンスの問題が発生した場合は、コア、アプリ、エンジン、およびフレームワークが最新状態になっていることを確認します。新しいリリースで修正プログラムや最適化が既に提供されていることがあります。一元管理設定と分散設定Toolkit の詳細設定は、一元管理設定と分散設定の 2 つの方法で行うことができます。主な違いは、一元管理設定は通常、スタジオのネットワーク ストレージに配置されていて、すべてのユーザがアクセスできることです。一方、分散設定は一般にクラウド内に保存されていて、ユーザ単位でローカルにキャッシュされます。この 2 つの方法の違いはパフォーマンス以外にもありますが、パフォーマンスに関しては長所と短所の両面があります。次の表に、純粋にパフォーマンスの観点から見た長所と短所を示します。                   利点      欠点                  一元管理設定      - 初期設定プロセスが完了すると、必要なすべてのものが既にダウンロードされていて、すべてのユーザが使用できる状態になっています。      - 一元管理設定は通常、ネットワーク ストレージに保存されるため、Toolkit の一般的な用途のときにパフォーマンスが低下することがあります。                     - 将来の更新は、一元管理された場所に 1 回ダウンロードするだけで済みます。      - Toolkit の設定には多数の小さなファイルが含まれています。多数の小さなファイルにメタデータ操作を行うと、処理速度が大幅に低下し、サーバの負荷が増大することがあります。また、Toolkit を使用する読み取り操作と、サーバの一般的な用途における読み取り操作の負荷が増大すると、設定をすばやく読み取ることができなくなって、Toolkit のパフォーマンスが低下することがあります。              分散設定      - キャッシュされたアプリ、エンジン、フレームワーク、およびコアは、他のローカルにキャッシュされた設定と共有できるような方法で保存されます。つまり、複数のプロジェクトを今後ロードするときに、これらが同じ依存関係を共有していれば、キャッシュ速度が上がる可能性があります。      - 分散設定はユーザ単位でローカルにキャッシュする必要があります。この操作を行うには、通常、設定、および必要なすべてのアプリ、エンジン、フレームワーク、コアをダウンロードします。                     - これらはローカル ハード ドライブ上のユーザ キャッシュに保存されるため、通常はサーバ速度よりもパフォーマンスが向上します。つまり、最初のキャッシュ以降のパフォーマンスは一元管理設定よりも高くなります。      - このプロセスはシーンの背後でシームレスに行われますが、これらをダウンロードする初期コストがかかります。                            - 新しいバージョンの依存関係を指定するように設定を更新するたびに、設定と新しい依存関係の両方をキャッシュする必要があります。      手短に言えば、ストレージは低速だが妥当な速度のインターネット接続を使用している場合は、分散設定が最適な設定になる可能性がありますが、サーバ ストレージのパフォーマンスが高く、インターネットのパフォーマンスが低い場合は、一元管理設定が適している可能性があります。                    注: 分散設定に興味はあっても、マシンごとに依存関係をダウンロードすることについて懸念を抱いている場合は、バンドル キャッシュのみを一元管理して、すべてのユーザで共有することができます。    分散設定を使用している場合、ユーザはキャッシュ内にまだ保存されていないデータのみダウンロードする必要があります。ユーザがデータをダウンロードすると、他のユーザもそのデータを利用できるようになります。このようにするには、共有場所を指定するように各マシンの  ShotGrid_BUNDLE_CACHE_PATH環境変数を設定します。ソフトウェアの起動速度が遅いMaya、Nuke、Houdini などのソフトウェアを起動するときに、ShotGrid を使用しない場合に比べて起動時間が長くなることがあります。ShotGrid を使用しない場合に比べて起動時間が長くなるのは通常のことですが、これらの時間が許容できないレベルまで増大することがあります(ソフトウェアによって異なりますが、通常は起動時間が 1 分未満であると予測しています)。ソフトウェアの起動には多くのプロセスが関係しているため、この問題を診断するのは面倒なことがあります。診断最初に行う必要があるのは、この問題が発生する場合の条件を特定することです。  ShotGrid を使用しないで起動したときに低速になりますか? - 明らかなことかもしれませんが、ShotGrid を使用して起動した場合のみ問題が発生することを確認することが重要です。  起動方法に関係なく低速ですか? つまり、SG Desktop から起動した場合と、ブラウザ統合を使用して SG サイトから起動した場合で違いはありますか? - ShotGrid サイトから起動したときに低速になり、SG Desktop から起動したときに低速にならない場合は、ブラウザ統合に問題があるか、ディスク上にフォルダを作成するときに問題が発生している可能性があります。プロジェクト以外のコンテキストから起動した場合は、ディスク上に作成されるフォルダ数が増える可能性があるため、時間がかかることがあります。また、ソフトウェアが起動されるたびに、必要なフォルダの有無を確認することも重要です。  すべてのプロジェクトで発生しますか? - 問題が発生しないプロジェクトがある場合は、設定方法に固有の問題である可能性があります。  1 日の特定の時点で発生しますか? - 1 日の特定の時点で発生する場合は、1 日の特定の時間帯にサーバ使用量が増大しているなど、インフラストラクチャに対する要求が増加している可能性があります。  使用しているすべてのマシン/OS で発生しますか? - 特定のマシンの速度が低下する場合、問題の原因は Toolkit の外部にある可能性があります。ただし、最初の手順として、このマシンに Toolkit のキャッシュを作成することをお勧めします。ソフトウェアおよび Python パッケージごとに異なるバージョンの OS が付属していて、特定のバンドルでパフォーマンスの問題が発生することがあります。特に、Windows で Samba (SMB)共有を使用している場合に、パフォーマンスの問題が発生するケースが見られます。このような問題の修正プログラムはありませんが、これを使用する場合にこの問題を認識することが大事です。この問題が特定の OS、Python パッケージ、またはソフトウェア バージョンに限定されていると判断される場合は、サポート チームに問い合わせてさらに調査するよう依頼してください。  すべてのユーザで発生しますか? - 上記と同様に、同じマシンを使用している別のユーザでは、この問題が発生しないことがあります。この場合は、まずユーザのローカル ShotGrid キャッシュをクリアします。また、通常のプロダクションでの用途に対してデバッグ ログが有効になっていないことを確認してください。パフォーマンスが低下しなくなります。  起動速度の低下は特定のアプリ/ソフトウェアに特有のものですか、それともすべてのアプリ/ソフトウェアで起動速度が異常に低下しますか? - 特定のソフトウェアの起動速度が低下する場合は、設定に問題がある可能性があります。起動の前後に実行されるようにカスタム フックが設定されていて、パフォーマンス低下の原因となっている可能性があるかどうかを確認することをお勧めします。起動時に使用される一般的なフックは before_app_launch.py、app_launch.py、およびコア フックの engine_init.py です。ときどき、新しいバージョンのソフトウェアがリリースされ、Toolkit の統合の起動速度が突然大幅に低下することもあります。このような場合は、サポートに問い合わせて、この問題が認識されているかどうか、および既知の修正プログラムがあるかどうかを確認する必要があります。使用しているソフトウェア(パッチ/サービス パックが適用可能な場合は、これらを含む)のバージョン番号、および実行している Toolkit エンジンとコアのバージョンをお知らせください。問題が発生するタイミング(起動前または起動後)上記の手順を行っても原因を絞り込むことができなかった場合は、次に、起動プロセスのどの段階で速度が低下するのかを確認します。Toolkit を介してソフトウェアを起動している場合は、一般に起動プロセスを 2 段階のプロセスにまとめることができます。最初の手順では、いくつかの初期操作を実行します。たとえば、ソフトウェアの起動に必要な情報を収集したり、コンテキストからフォルダを自動的に作成し、その後でソフトウェアを実際に起動したりします。次に、起動プロセスの 2 番目の手順が行われ、ソフトウェアの起動後に Toolkit の統合が起動されます。通常は、ログを調べなくても、プロセスの最初の手順と 2 番目の手順のどちらでパフォーマンスの問題が発生しているのかを確認できます。  そのためには、ソフトウェアのスプラッシュ画面を観察して、この画面の起動時間が長いかを確認します。スプラッシュ画面の起動時間が長い場合は、問題が最初の手順で発生している可能性があります。  また、ソフトウェアの起動時間が比較的短いにもかかわらず、初期化が終了して ShotGrid メニューが表示された後に速度が低下することがあります。この場合は、2 番目の手順で問題が発生しています。この情報を把握しておくと、この次の作業でログを確認する際に役立ちます。ログを調べる起動の最初の手順または 2 番目の手順のどちらで問題が発生しているのかを確認したら、調査対象のログを特定することができます。ログはエンジンごとに分かれているため、問題が起動前の段階で発生している可能性がある場合は、SG Desktop から起動しているのか、それとも SG サイトから起動しているのかに応じて、tk-desktop.log または tk-ShotGrid.log を調べる必要があります。次に、デバッグ ログを有効にする必要があります。                    注: デバッグ ログが既に有効になっている場合は、上記のとおり、これが動作低下の原因になっていることがあるため、デバッグ ログを有効にしないでテストしてください。    デバッグ ログを有効にしたら、既存のログをクリアして、起動プロセスを再現する必要があります。ログ内のタイムスタンプを使用して、時間が急に変化している行を確認します。たとえば、フォルダの作成中に、時間が 5 秒間突然変化している行がいくつかあります。2019-05-01 11:27:56,835 [82801 DEBUG sgtk.core.path_cache] Path cache syncing not necessary - local folders already up to date!2019-05-01 11:28:01,847 [82801 INFO sgtk.env.asset.tk-shotgun.tk-shotgun-folders] 1 Asset processed - Processed 66 folders on disk.時間が急に変化している場所を特定したら、そのログの行を調べると、その段階で何が起こっていたのかを把握することができます。たとえば、フォルダの作成中や、ShotGrid 接続の取得中に問題が発生していることがあります。ただし、ログを参照するのは面倒な作業であり、内容に意味があるとは限らないため、サポートに問い合わせて、この作業のサポートを依頼することができます。ソフトウェアの起動速度が低下する一般的な原因            インターネットの速度低下      Toolkit のほぼあらゆる使用状況において ShotGrid サイトに接続して通信する必要がありますが、インターネットの速度が低下すると、この動作が影響を受けます。この場合は通常、ソフトウェアの起動だけでなく、他の状況においても、速度に関する問題が発生します。ただし、接続速度が低下するのではなく、接続が不安定になる場合は、起動時にパフォーマンスの問題が生じる可能性があります(大量の ShotGrid 通信がプロセスを通して行われるためです)。              サーバ アクセス速度の低下      この問題は確実に起動時間に影響します。一元管理設定を使用している(設定が中央サーバに保存されている)場合は、設定ファイルを読み取るときに大量の I/O が発生することがあります。特に、ソフトウェアを起動すると、起動時の状況に応じてフォルダが作成されます。つまり、フォルダが作成されているかどうかが確認され、作成されていなければ作成されます。              フォルダの作成      上記のように、フォルダ作成が速度低下の一般的な原因になることがあります。詳細については、以下のフォルダ作成時のパフォーマンスに関するトラブルシューティングを参照してください。      [File Open]、[File Save]、Loader アプリのいずれかで速度が低下する場合最初に、問題となっているアプリの速度が低下する状況を絞り込んで、特定します。  アプリを起動するときに速度が低下しますか、それともタブ間で移動するときに低下しますか?          アプリは現在、極端に多くの情報を表示するように設定されている可能性があります。[マイ タスク]（My Tasks）タブやその他のタブは、リスト内の不要なエンティティ除外するように設定できます。たとえば、[保留中]（On Hold） (hld)や[最終]（Final） (fin)などの特定のステータスを持つタスクを除外できます。このようにすると、パフォーマンスが向上するだけでなく、アーティストは自分が必要としている情報のみを表示することができます。Loader アプリと Workfiles アプリの両方を除外できます。Workfiles のドキュメントには現在、フィルタに関する特定のセクションが用意されていませんが、階層設定の一環としてフィルタを適用することができます。      File Open アプリの階層を、この階層が展開されるまでサブ項目のロードを遅らせるように設定することもできます。これが既定の設定になっていますが、古い設定を使用している場合は、この設定を使用するように移行することができます。      デバッグ ログが有効になっていないことを確認します。デバッグ ログが有効になっていると、追加の I/O が大量に発生するため、速度が低下することがあります。これらのアプリには、大量のデバッグ出力が含まれています。        ファイルを開く、保存する、または新規作成するときに速度が低下しますか?          シーンの操作やアクションのフックを引き継いで処理したかどうか、およびこれらの関数の前後に速度低下の原因となるカスタム動作が行われているかどうかを確認します。      ファイルを作成するときや、保存するときに、Workfiles はこのコンテキストに必要なすべてのフォルダが作成されていることを確認します。パフォーマンスの問題が発生する一般的な原因は、フォルダの作成です。      フォルダ作成速度が低下するフォルダの作成は多くの要素で構成されていて、問題が発生したときに処理速度が低下する原因となることがあります。フォルダの作成では、次の処理が行われます。  ローカル パス キャッシュを同期する  設定のスキーマを読み取る  状況に応じて作成する必要があるパスのリストを生成する  ローカルに保存されたパス レジストリと比較してパスを確認する  SG サイトとローカルな場所の両方に新しいパスが登録されていない場合は、登録を試みる  フォルダの登録の有無に関係なく、このフォルダがディスク上に実際にあるかどうかを確認し、存在しない場合は作成するつまり、フォルダを作成すると、ディスクの I/O 使用量が大幅に増えるとともに、ローカル データベースへの書き込みと SG サイトとの通信が必要になります。I/O 使用量を制御する多数の小規模な読み取り/書き込み操作を処理するときに、ストレージの速度や効率が低下することがあるため、インフラストラクチャの効率化に役立つ手順を行うと、フォルダ作成の処理時間を短縮できます。ただし、できるだけ負荷を軽減するために Toolkit 設定側で試行できる手順があります。最初に行うのは、この状況、および作業中の環境にとって重要なフォルダのみが作成されるように制限することです。たとえば、Maya でタスクやショットを操作している場合は、特定のショットおよびソフトウェアのフォルダのみを確認して、作成することが理想的です。基本的に、作品を保存およびパブリッシュするのに最低限必要なフォルダを作成するようにします。親フォルダを使用して作成するスキーマ フォルダに適用できる  create_with_parent設定があります。これを true に設定すると、フォルダが親フォルダであるときにそのフォルダが作成されるようになります。この設定を true に設定するときは、多数のフォルダが確認および作成されるという状況にならないように注意してください。例シーケンス/ショットのフォルダ階層がある場合に、親のシーケンスを使用して作成するようにショット フォルダを設定すると、シーケンス フォルダを作成するときはいつでも関連するすべてのショットが確認され、これらのフォルダが作成されるようになります。状況によってはこの方法が便利なことがありますが、多数のフォルダの確認と作成が一度に行われることがあります。このシナリオで、タスクまたはショットの作業ファイル内に新しいファイルを作成すると、ショットの親となるシーケンス フォルダが作成され、作業中のショットだけでなく、この子となるすべてのショット フォルダが作成されます                    注: ステップ スキーマ フォルダの設定は、既定で true になっています。    作成の遅延 defer_creation設定により、特定のエンジンが実行されている場合に限ってフォルダが作成されるように制限することで、フォルダの作成時期を調整することができます。カスタム名を使用し、sgtk API を使用してこの名前のフォルダが作成されるようにすることもできます。例場合によっては、一連のフォルダの作成時期をパブリッシュ段階に限定する必要があります。この場合は、カスタム名を maya_publish という遅延キーワードに設定し、その後で API を使用してこのキーワードをエンジン名として持つフォルダを作成することができます。スキーマ内のフォルダは次のようになります。# the type of dynamic contenttype: &quot;static&quot;# defer creation and only create this folder when Photoshop startsdefer_creation: &quot;publish&quot;その後、次のようなスクリプトを使用してフォルダを作成します。sgtk.create_filesystem_structure(entity[&quot;type&quot;], entity[&quot;id&quot;], engine=&quot;publish&quot;)拡張された例フォルダを遅延することにした場合、プロジェクトのルートに動的でないフォルダが複数あれば、通常はこれらを 1 回のみ作成する必要があります。たとえば、「editorial」および「reference」フォルダが既定の設定のスキーマのルートに配置されている場合は、通常、プロジェクトの開始時にこれらのフォルダを 1 回だけ作成しなければならないことがありますが、既定では、フォルダ作成を行うたびにこれらのフォルダの有無が確認されます。この動作を制限するには、これらのフォルダの yml ファイルを作成して遅延キーワードを設定し、フォルダの作成が特定のエンジンで実行された場合、またはキーワードが渡された場合のみ、これらのフォルダが作成されるようにします。遅延キーワードを tk-shell に設定して、tank folders のような tank コマンドを使用してフォルダ作成を実行することができます。これは、これらのフォルダ作成が tank コマンドを介して実行された場合に限り実行されることを意味します。tank コマンドは、プロジェクトを初めて設定するときに Toolkit 管理者が実行することができます。また、上の例のようなカスタム キーワードを使用してフォルダ作成を実行する、小規模なスクリプトを記述することもできますフォルダを登録するフォルダ作成プロセス中にフォルダが登録されるため、後でコンテキストを調べる際に登録されたパスを使用することができます。上記のように、この処理中に、レジストリが保存されている一元的な場所である ShotGrid サイトと通信する必要があります。ただし、ツールによる高速検索を有効にするために、これらのレジストリもローカルにキャッシュされます。SQLite データベースローカルなパス キャッシュは SQLite データベースを使用してデータを保存します。ネットワーク上のストレージにデータベースが保存されている場合は、データベースに対する読み取りおよび書き込みのパフォーマンスが大幅に低下することがあります。初期同期プロジェクトに多数のフォルダが登録されている場合は(進行中のプロジェクトに新しいユーザが参加する場合など)、状況に応じて、ローカル キャッシュをゼロから生成しなければならないことがあります。この処理には非常に長い時間がかかることがあるため、このようなプロジェクトにはこの処理が 1 回だけ行われるように効率化されました。以降の同期では、ローカル キャッシュとサイトのレジストリの間の差分のみが取得されます。ユーザがプロジェクトを操作する頻度が少なく、セッションの合間に多数のフォルダが作成されている場合は、すべてのデータをキャッシュする間の待ち時間が非常に長くなることがあります。この場合にユーザが使用してきた方法の 1 つは、ローカル キャッシュの最新と見なされるバージョンをユーザのマシンに転送することでした。                    注意: この方法は、プロジェクトに極めて多数のフォルダが作成されている場合に限って必要となります。    この更新プロセスは、コア フック cache_location.py を使用して自動的に実行できます。このフックを使用してキャッシュの場所を設定できますが、場所を変更しなくても、このフックを使用して path_cache.db ファイルの特定のバージョンを一元管理された場所からユーザの既定の場所にコピーして、負担のかかる完全同期を不要にすることができます。一元的に保存されたパス キャッシュを定期的に更新するには、他のユーザのキャッシュから手動でコピーすることができますが、通常はスクリプトを使用して定期的に転送します。                    警告: cache_location.py フックを使用するとキャッシュの場所を設定できますが、すべてのユーザに単一の場所を指定する設定は避けてください。1 つまたは複数のプロセッサがデータベースを同時に編集しようとすると、データベースがロックされることがあります。    ",
    "url": "/396dd133/",
    "relUrl": "/396dd133/"
  },
  "66": {
    "id": "66",
    "title": "Pipeline Integrations",
    "content": "Pipeline IntegrationsHere you’ll find guides, tutorials, videos and other content to help you get started as a toolkit developer.",
    "url": "/e058fbea/",
    "relUrl": "/e058fbea/"
  },
  "67": {
    "id": "67",
    "title": "Pipeline Integrations",
    "content": "Pipeline IntegrationsHere you’ll find reference documentation for components of the Toolkit platform",
    "url": "/162eaa4b/",
    "relUrl": "/162eaa4b/"
  },
  "68": {
    "id": "68",
    "title": "パイプラインのチュートリアル",
    "content": "パイプラインのチュートリアルこのチュートリアルは、アニメーションや視覚効果用のシンプルで一般的なパイプラインの作成について説明します。このチュートリアルに従うと、外観加工を介してモデリングのアセットをプロダクション シーンに転送するのに必要なすべての処理を提供するパイプラインを作成できます。このパイプラインの対象となるワークフローの大部分は、ShotGrid に組み込まれた統合機能を使用して、設定なしですぐに作業することができます。パイプラインの中の、スタジオがカスタム ソリューションを作成する頻度が高い部分については、このチュートリアルで、Toolkit プラットフォームを使用してアーティスト ワークフローをカスタマイズするプロセスを紹介します。次に、このチュートリアルで作成されるパイプラインの概要を示します。    パイプラインの概要パイプラインの概要分かりやすくするため、使用するデジタル コンテンツ作成(DCC)ソフトウェアは最小構成で Maya と Nuke に限定しています。また、パイプラインの工程で渡されるデータは、Maya ASCII ファイル、Alembic キャッシュ、およびレンダリング イメージ シーケンスに限定されます。                    注: このチュートリアルで使用される単純なパイプラインはプロダクションのテストを受けていません。ShotGrid ベースのパイプラインの作成例としてのみ使用してください。    前提条件      作業用の ShotGrid プロジェクト - このチュートリアルでは、ShotGrid を使用してプロダクション データのトラッキングや管理を行った経験があることが前提となります。        ShotGrid 統合の概要 - ShotGrid には統合機能が付属していて、手動設定が不要な、単純なプロダクション ワークフローがいくつか用意されています。このチュートリアルで説明されている手動設定やカスタマイズについて調べる前に、これらのワークフローの機能や範囲について理解する必要があります。ShotGrid 統合の詳細については、こちらを参照してください。        Maya と Nuke の経験 - このチュートリアルは、Maya および Nuke を使用して単純なパイプラインを作成することを目的としています。ShotGrid の統合機能をカスタマイズするには、これらのパッケージの基本について理解する必要があります。        Python の操作に関する知識 - このチュートリアルでは、Python で記述された「フック」を使用して、ShotGrid 統合の機能を変更する必要があります。        YAML に対する知識 - 作成しているパイプラインの設定のほとんどは、YAML ファイルを変更して処理されます。  その他のリソース      ShotGrid サポート サイト        ShotGrid 統合                  ユーザ ガイド                    管理者ガイド                    開発者ガイド            プロジェクトの作成とセットアップこのチュートリアルでは、ShotGrid で新しいプロジェクトを作成して、プロダクション開始の準備に合わせて設定する必要があります。ここで、すべての必要な ShotGrid エンティティが所定の場所にあり、正しくリンクされていることを確認します。このチュートリアルの場合、アセット、シーケンス、ショット、およびタスクの各エンティティが必要で、既定で新しいプロジェクトで使用できる必要があります。作成する項目は次のとおりです。      2 つのアセット:                  ティーポット キャラクタ                    テーブル プロップ                  シーケンス 1 つ        作成したシーケンスにリンクしたショット 1 つ        パイプラインの手順ごとのタスク  次に、ShotGrid で設定したプロジェクト エンティティのスクリーンショットを示します。    ティーポットとテーブル アセット    シーケンスにリンクされたショット    タスクソフトウェア ランチャー次に、Maya および Nuke を ShotGrid Desktop 内で起動できることを確認する必要があります。Desktop で、これらの各パッケージのアイコンをクリックして起動できることを確認します。各パッケージの適切なバージョンが起動していることを確認します。Desktop にアプリケーションが表示されない場合、または予期したバージョンが起動しない場合は、ソフトウェア エンティティを使用して ShotGrid で起動を手動で設定しなければならない可能性があります。    ShotGrid で定義された規定のソフトウェア エンティティソフトウェア エンティティは、プロダクションで使用する DCC パッケージを操作する場合に使用されます。既定では、標準のインストール場所でこれらのパッケージが検索され、Desktop を使用して起動できるようになります。複数のバージョンがインストールされている場合、または標準以外の場所にインストールされている場合は、ShotGrid の対応するソフトウェア エンティティのエントリを更新して、アーティストの起動環境を整理しなければならない可能性があります。ソフトウェア エンティティおよび適切な設定方法の詳細については、「統合管理者ガイド」を参照してください。DCC が予期した方法で起動した場合は、次のセクションに進んでください。環境設定環境設定(設定)は、プロジェクトに関するアーティスト ワークフローを定義します。このワークフローでは、アーティストが起動している DCC に含める ShotGrid 統合、プロジェクトのフォルダ構造の定義方法、およびアーティストがデータを共有するときに作成されるファイルやフォルダの命名規則を指定します。既定では、すべての新しいプロジェクトは基本的な ShotGrid 統合を使用するように設定されています。この統合は、多数の既製のソフトウェア パッケージを使用してアーティスト間でファイルを共有するための基本的なワークフローを提供します。 次のセクションでは、プロジェクトのパイプライン環境設定(設定)を引き継いで、スタジオに合わせてカスタマイズする方法の概要を示します。プロジェクトの設定を引き継ぐShotGrid Desktop (以下、「Desktop」)を使用して、プロジェクトの設定を引き継ぎます。Desktop 内で右マウス ボタンをクリックするか、または右下のユーザ アイコンをクリックして、ポップアップ メニューを表示します。[Advanced project setup…] オプションを選択し、ウィザードに従ってプロジェクトの設定をローカルにインストールします。次の図に、必要な手順を示します。『統合管理者ガイド』の「パイプラインの設定を引き継ぐ」に示されている手順に従うこともできます。    Desktop のポップアップ メニューで[Advanced project setup…]を選択する    [ShotGrid Default]（ShotGrid の既定値）設定タイプを選択する    [Default configuration]（既定の設定）を選択する初めて ShotGrid プロジェクトをセットアップする場合は、プロジェクト データのストレージ場所を定義するためのプロンプトも表示されます。それ以外の場合は、既存の格納場所を選択することができます。    新しいストレージを作成します。    新しいストレージに名前を付けます。このストレージはプロジェクト固有のものではなく、サイト全体で使用されることに注意してください。    使用するオペレーティング システム上でこのストレージにアクセスするパスを設定します。[サイト基本設定]（Site Preferences）の[ファイル管理]（File Management）セクションで、ShotGrid サイトのストレージを表示および編集できます。これらの設定について詳しくは、こちらを参照してください。格納場所が選択されたので、その場所にある新しいプロジェクトのディレクトリ名を選択します。    プロジェクト ファイルを配置するフォルダの名前を入力する。このチュートリアルでは中央設定を使用します。[分散設定]（Distributed Setup）オプションは、さまざまなメリットを提供する代替オプションを提供します。これは、高速共有ストレージのないスタジオで役に立つ場合があります。各種設定の長所と短所について詳しくは、「ツールキット管理」のプレゼンテーションを参照してください。サイト全体にわたるストレージとは異なり、設定はプロジェクトごとに異なるため、ここで選択するディレクトリが直接設定の保存に使用されます。    現在のオペレーティング システムに対して選択した設定パスをメモする。上記の画面で選択したフォルダに設定がインストールされます。このチュートリアルを通して、このフォルダに含まれている設定の内容を調べて、変更します。上記の画面で[Run Setup]をクリックすると、Desktop は設定に必要なすべてのコンポーネントのダウンロードおよびインストールを開始します。このインストール処理には数分かかる場合があります。完了したら、プロジェクト全体の設定のローカル コピーが作成されます。次の手順では、このローカル コピーを変更します。Desktop インストールのチュートリアルで指定された設定場所は、ShotGrid のプロジェクトの[パイプラインの設定]（Pipeline Configurations）ページに記録されています。    ShotGrid のパイプラインの設定エンティティ次のセクションに備えて、このフォルダの内容を理解しておいてください。設定の構成単純なパイプラインの作成プロセスを開始する前に、パイプライン設定の構成方法とその仕組みについて理解しておく必要があります。次の図に、設定の主な構成要素とその目的を示します。設定とその管理の詳細については、「ツールキットを管理する」の記事を参照してください。    プロジェクト スキーマこのチュートリアルで作成する単純なパイプラインでは、既定の設定で提供されるプロジェクト スキーマを使用します。config/core/schema フォルダを参照して、Toolkit アプリがディスクにファイルを書き込むときに作成される構造を把握することができます。プロジェクト ディレクトリ構造の設定方法の詳細については、「ファイル システム設定リファレンス」を参照してください。テンプレートこのチュートリアルでは、既定のパイプラインの設定で定義されたテンプレートも使用します。config/core/templates.yml ファイルを開いて、入出力ファイルをディスク上のパスにマップするためにアプリで使用されるテンプレートを確認できます。テンプレート システムの詳細については、「ファイル システム設定リファレンス」を参照してください。フックこのチュートリアルの大部分では、アーティスト ワークフローをカスタマイズするためにアプリのフックを変更します。カスタマイズの詳細を調べる前に、フックの内容、その仕組み、および格納先についての基本を理解する必要があります。「管理」および「設定」の「フック」セクションを参照してください。このチュートリアルの手順を進めると、Toolkit アプリのいずれかで定義されたフックを「引き継ぐ」ように要求されます。アプリのフックを引き継ぐプロセスは簡単です。この操作を行うように要求されるたびに、次に示す手順を実行するだけです。      設定のインストール フォルダ内で、オーバーライドするフックを含むアプリを特定します。このアプリの hooks サブディレクトリを検索して、オーバーライドするフック ファイルを特定します。        設定の上位にある hooks ディレクトリにフックをコピーします(必要に応じて名前を変更します)。      ファイルが設定の hooks フォルダに格納されたら、変更を加えて、コードをカスタマイズすることができます。対応するアプリがこの新しい場所を参照するように設定するには、追加手順が必要です。この手順については、チュートリアルの後半で説明します。パイプラインを作成するこの時点で、パイプラインの作成を開始する準備ができています。ShotGrid にプロジェクトが設定されていて、Desktop を介して Maya および Nuke を起動することや、プロジェクトの設定をコントロールすることができます。また、設定の構造の基本を理解していて、アーティスト ワークフローを具体的に作成する作業を開始することができます。次のセクションでは、パイプラインの各手順について説明します。すぐに使用できる機能を示し、ShotGrid 統合のカスタマイズ プロセスを紹介します。これらのセクションが終了するころには、単純な、機能をすべて備えた、エンドツーエンドのプロダクション パイプラインが作成されています。また、アーティストがプロダクション作業で行う必要のある手順についても理解できるでしょう。                    注: このチュートリアルのすべてのコードおよび設定は、tk-config-default2 リポジトリの pipeline_tutorialブランチ内にあります。ファイルの保管場所や、コードの追加場所などについてのヒントが必要な場合は、このブランチを参照してください。    モデリング ワークフローシンプルなパイプラインの最初の手順はモデリングです。このセクションでは、プロジェクト内でティーポット アセットの最初の繰り返しを作成します。作成した繰り返しは、ディスクのプロジェクトのフォルダ構造内に保存してからパブリッシュします。最初に ShotGrid Desktop から Maya を起動します。Maya が完全にロードされると、[ファイルを開く]（File Open）ダイアログ ボックスが表示されます。このダイアログ ボックスで、プロジェクト内にある既存の Maya ファイルを参照できます。また、ShotGrid 統合で認識される新しいファイルを作成することができます。[アセット]（Assets）タブを選択して、ティーポットのモデリング タスクにドリル ダウンします。このタスクのアーティスト作業ファイルはまだないため、[+ New File]ボタンをクリックします。    このボタンをクリックすると、新しい空の Maya セッションが作成されて、現在の作業コンテキストがティーポット アセットのモデル タスクに設定されます。                    注: このチュートリアルを使用している場合はいつでも、Maya または Nuke の ShotGrid メニューを介して ShotGrid Panel を起動することができます。このパネルでは、DCC を終了しなくても、プロジェクト データを表示できます。現在の作業コンテキスト、およびこのコンテキスト内の最近のアクティビティが表示されます。フィードバック用のノートをパネルに直接追加することもできます。詳細については、「ShotGrid Panel」を参照してください。    次に、ティーポットをモデリングするか、指定されたディーポットをダウンロードして読み込みます。    ティーポット モデルに問題がなければ、[ShotGrid] &amp;gt; [File Save…]メニュー アクションを選択します。 このダイアログ ボックスで、ファイルを指定した名前、バージョン、タイプで保存するように求められます。    このダイアログ ボックスで完全な保存パスを指定するよう求められない理由に注目してください。これは、maya_asset_work テンプレートに保存するようにアプリが設定されているためです。このテンプレートは、既定では次のように定義されます。@asset_root/work/maya/{name}.v{version}.{maya_extension}アプリがフル パスを入力するために必要なのは、トークン化されたフィールド {name}、{version}、および {maya_extension} のみです。テンプレートの @asset_root の部分は、次のように定義されます。assets/{sg_asset_type}/{Asset}/{Step}上記の新しいファイルを作成したときに設定した現在の作業コンテキストが与えられている場合、ここに示したトークン化されたフィールドは Toolkit プラットフォームによって自動的に推定できます。また、ダイアログ ボックスの下部に、記述するファイル名およびパスのプレビューが表示されます。プロジェクトの設定を引き継ぐときに定義したプライマリ ストレージおよびプロジェクト フォルダが、テンプレート パスのルートに配置されます。[Save]ボタンをクリックして、ティーポット モデルを保存します。この時点において重要なのは、アーティストがワークフローを開く手順、および保存する手順は、パイプラインのどの段階においても、ここで完了したのと同じ手順になることです。[File Open]および[File Save]ダイアログ ボックスは、Workfiles アプリに含まれています。この「マルチ」アプリは、ShotGrid 統合でサポートされているすべての DCC で実行され、すべてのアーティストに一貫性のあるワークフローを提供します。次の手順では、ティーポットにいくつかの変更を行います。ふたのジオメトリはモデルの残りの部分から独立しているため、後でリギングすることができます。    作業内容に問題がなければ、[ShotGrid] &amp;gt; [File Save…]メニュー アクションをもう一度実行します。今度は、ダイアログ ボックスのバージョン番号が既定の 2 になります。ファイルのバージョンは自動的に増分するため、アーティストは完了した作業の完全な履歴を維持することができます。[Save]ボタンをクリックします。    ティーポット モデルをバージョン 2 に保存したら、チュートリアルのこのセクションの最後の手順に進むことができます。ティーポット モデルの準備ができたので、モデルをパブリッシュして、サーフェスの作成やリギングを実行できるようにする必要があります。パブリッシュするには、[ShotGrid] &amp;gt; [Publish…]メニュー アクションをクリックします。[Publish App]ダイアログ ボックスが表示されます。    このダイアログ ボックスには、パブリッシュされる内容を表す項目がツリー表示されます。ツリーには、パブリッシュ対象の項目を表すいくつかのエントリと、パブリッシュ操作中に実行されるアクションを表すいくつかのエントリが含まれています。ダイアログ ボックスの左側には、現在の Maya セッションを表す項目が表示されます。その下に、[Publish to ShotGriid]子アクションが表示されます。 すべてのセッション ジオメトリを表す追加項目が、現在のセッションの子項目として表示されます。[Publish to ShotGrid]子アクションも表示されます。                    注: [すべてのセッション ジオメトリ]（All Session Geometry）項目が表示されない場合は、Maya でAlembic 書き出しプラグインが有効になっていることを確認してください。    ツリーの左側の項目をクリックして、Publish アプリを調べます。操作を行う項目を選択すると、パブリッシュする内容の説明を入力できます。また、右側のカメラ アイコンをクリックして、項目に関連付けられるスクリーンショットを作成することもできます。準備ができたら、右下の[Publish]ボタンをクリックして、現在の作業ファイルおよびティーポット ジオメトリをパブリッシュします。完了したら、ShotGrid でティーポット アセットを参照し、パブリッシュが正常に完了したことを確認できます。    上図に、ティーポット モデルを含む、パブリッシュされた Alembic ファイルが示されています。また、Maya セッション ファイルのパブリッシュも示されています。これらのパブリッシュは、パブリッシュ アプリのツリー表示内の項目に対応します。[File Save]ダイアログ ボックスを使用して作成された作業ファイルと同様に、これらの 2 つのパブリッシュの出力パスはテンプレートによって制御されます。次に、これらのテンプレートの内容を示します(アプリに対してこれらのテンプレートが設定される場所については、後で示します)。Maya セッションのパブリッシュ:@asset_root/publish/maya/{name}.v{version}.{maya_extension}このテンプレートは、既定では作業ファイル テンプレートと非常に似ています。唯一の違いは、フォルダが publish であることです。アセットのパブリッシュ:@asset_root/publish/caches/{name}.v{version}.abcこのテンプレートは、Maya セッションのパブリッシュ テンプレートに似ていますが、ファイルは caches フォルダに書き込まれます。[File Save]ダイアログと異なり、パブリッシュするときに、名前、バージョン、またはファイル拡張子の値を指定する必要がありません。これは、パブリッシャーが作業ファイルのパスからこれらの値を取得するように既定で設定されているためです。パブリッシャーは作業テンプレートを介してこれらの値を内部で抽出し、パブリッシュ テンプレートに適用します。この概念は、Toolkit プラットフォームに関して重要であると同時に、パイプライン ステップの出力を別のステップの入力に接続するためにテンプレートをどのように使用するのかという点においても重要です。これについては、以降のセクションで詳細に説明します。ディスクのファイルを参照して、これらが正しい場所に作成されていることを確認します。お疲れ様でした。最初にパブリッシュされたティーポットの繰り返しが正常に作成されました。テーブル プロップのモデリング タスクからテーブルのモデルをパブリッシュする際に、学習した内容を使用できるかどうかを確認します。結果は以下のようになります。    次に、サーフェス作成ワークフローについて説明します。サーフェス作成ワークフローこのセクションでは、モデリング セクションで学習した内容を基に作成します。Loader アプリを使用して、前のセクションで作成したティーポット モデルをロードする方法について学習します。また、ティーポットのシェーダをパブリッシュするために Publish アプリをカスタマイズする方法についても学習します。Desktop から Maya を起動して開始します。前のセクションの作業を行った後も Maya が開いている場合は、再起動する必要はありません。Maya が開いたら、[ShotGrid] &amp;gt; [File Open…]を使用して作業ファイル アプリを開きます。モデリング セクションと同様に、[Assets]タブを使用してティーポット アセットのタスクにドリル ダウンします。今回は、サーフェス作成タスクを選択して、[+ New File]をクリックします。    ティーポットのサーフェス作成タスクの作業が開始しました。右側のプロダクション コンテキスト内で作業していることを確認する最も簡単な方法は、ShotGrid メニューの最初のエントリを調べることです。    次に、ティーポット モデルを新しいサーフェス作成作業ファイルにロードする必要があります。このためには、Maya の [ShotGrid] &amp;gt; [ロード…]（Load…）メニュー項目を使用して、Loader アプリを起動します。    Loader アプリのレイアウトは作業ファイル アプリと似ていますが、今は、作業ファイルを参照して開くのではなく、パブリッシュされたファイルを参照してロードします。[Assets]タブでティーポットのキャラクタを参照して、前のセクションで作成したティーポットのパブリッシュを表示します。Maya シーンおよび Alembic キャッシュ パブリッシュが表示されます。Alembic キャッシュ パブリッシュを選択して、ダイアログ ボックスの右側にその詳細を表示します次に、Alembic キャッシュ パブリッシュの[Actions]メニューで、[Create Reference]項目をクリックします。ローダーは既定で開いたままになるため、追加のアクションを実行できますが、ローダーを閉じて続行することもできます。モデリング タスクからティーポット パブリッシュを示す参照が作成されていることが、Maya に表示されます。    次に、ティーポットに単純なプロシージャ シェーダを追加します。    パイプライン作成時のシェーダ管理は時間がかかり、複雑な作業になる場合があります。これは通常、スタジオに対して非常に固有な作業になります。付属の Maya 統合で、すぐに使用できるシェーダまたはテクスチャ管理が処理されないのは、このためです。[ShotGrid] &amp;gt; [File Save…]メニュー アクションを使用して、現在のセッションを保存してから続行します。カスタム シェーダ パブリッシュこの単純なパイプラインの目的に合わせて、サーフェス作成ステップで Maya シェーダ ネットワークを追加のパブリッシュ項目として書き出すように、Publisher アプリをカスタマイズします。チュートリアルの後半では、下流工程の参照時にシェーダが Alembic ジオメトリ キャッシュに再接続できるスピード重視のソリューションを作成します。                    注: 追加するカスタマイズは、明らかに、非常に単純かつ不安定です。より堅牢なソリューションを作成する場合は、サーフェス キャラクタの代替表現と、テクスチャ マップとして外部イメージを使用するというアセット管理の側面を取り入れることができます。この例は、実際のソリューションを作成する際の第一歩として使用してください。                        注: パブリッシャー プラグインの作成方法の詳細についてはこちらを参照してください。    Maya コレクタをオーバーライドする最初に、Publish アプリのコレクション ロジックを修正する必要があります。パブリッシャーには、アプリ内でパブリッシュおよび表示する項目を「収集」するためのロジックを定義する、コレクタ フックが設定されています。構成されたアプリの設定は、プロジェクトの環境設定内のこのファイルに含まれています。env/includes/settings/tk-multi-publish2.ymlこのファイルでは、すべてのアーティスト環境内での Publish アプリの使用方法を定義します。ファイルを開き、Maya セクション、特にアセット ステップの設定を検索します。これは、次のようになります。    コレクタの設定は、パブリッシャーの収集ロジックが配置されるフックを定義します。既定では、値は次のようになります。collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;この定義には 2 つのファイルが含まれます。フックの設定に複数のファイルが表示されている場合は、フックが継承されています。最初のファイルには、インストールされた Publish アプリのフック フォルダに対して評価する {self} トークンが含まれています。2 番目のファイルには、現在のエンジン(この場合はインストールされた Maya エンジン)のフック フォルダに対して評価する {engine} トークンが含まれています。要約すると、この値は，Maya 固有のコレクタが Publish アプリのコレクタを継承することを示します。これは、パブリッシャー設定の一般的なパターンです。Publish アプリのコレクタ フックには、実行中の DCC に関係なく、便利なロジックが含まれているためです。DCC 固有のロジックは、この基本ロジックから継承され、現在のセッションに固有の項目を収集するように拡張されます。                    注: アセットのステップ環境のコレクタ設定のみが変更されているため、ショット ステップなどの他のコンテキストで作業しているアーティストには、修正が認識されません。このようなアーティストは、付属している既定の Maya コレクタを使用し続けます。    「環境設定」セクションでは、フックの引き継ぎ方法について学習しました。カスタマイズ プロセスを開始するには、まず、設定内の Maya エンジンのコレクタ フックを引き継ぎます。    上図に、このための方法を示します。まず、プロジェクト設定の hooks フォルダ内にフォルダ構成を作成します。こうすると、後で他の DCC に合わせて同じフックをオーバーライドできるため、コレクタ プラグインに名前空間が提供されます。次に、インストール フォルダから新しいフック フォルダ構造に Maya エンジンのコレクタフックをコピーします。これで、設定内に、次のパスを持つ Maya コレクタのコピーが作成されました。config/hooks/tk-multi-publish2/maya/collector.py次に、新しいフックの場所を指すように、publish2 設定ファイルを更新します。コレクタ設定に、この値が含まれるようになりました。collector: &quot;{self}/collector.py:{config}/tk-multi-publish2/maya/collector.py&quot;{config} トークンをメモします。このパスは、プロジェクト設定内のフック フォルダに解決されるようになりました。コレクタの新しいコピーは、アプリ自体によって定義されたコレクタから継承されます。                    注: この時点でパブリッシュする場合、パブリッシュ ロジックは新しい場所から単にコピーおよび参照されているコレクタとまったく同じになります。    推奨 IDE またはテキスト エディタでコレクタのコピーを開いて、process_current_session メソッドを特定する必要があります。このメソッドは、現在の DCC セッション内のすべてのパブリッシュ項目を収集します。新しいパブリッシュ タイプが収集されるため、このメソッドの下部に移動して、以下の行を追加します。self._collect_meshes(item)これが、現在のセッションにあるすべてのメッシュを収集する際に追加される、新しいメソッドです。このメソッドは、(後で作成される)シェーダ パブリック プラグインが作用するメッシュ項目を作成します。渡される項目は、メッシュ項目の親となるセッション項目です。                    注: これは、既存のパブリッシュ プラグインを変更するための、対象が非常に限定されたアプローチです。パブリッシャーの構造およびそのすべての移動パーツを詳しく調べるには、開発者向けドキュメントを参照してください。    ここでは、ファイルの末尾に、次の新しいメソッド定義を追加します。    def _collect_meshes(self, parent_item):       &quot;&quot;&quot;       Collect mesh definitions and create publish items for them.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;mesh.png&quot;       )       # iterate over all top-level transforms and create mesh items       # for any mesh.       for object in cmds.ls(assemblies=True):           if not cmds.ls(object, dag=True, type=&quot;mesh&quot;):               # ignore non-meshes               continue           # create a new item parented to the supplied session item. We           # define an item type (maya.session.mesh) that will be           # used by an associated shader publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name (the group name). In the future, other publish           # plugins might attach to these mesh items to publish other things           mesh_item = parent_item.create_item(               &quot;maya.session.mesh&quot;,               &quot;Mesh&quot;,               object           )           # set the icon for the item           mesh_item.set_icon_from_path(icon_path)           # finally, add information to the mesh item that can be used           # by the publish plugin to identify and export it properly           mesh_item.properties[&quot;object&quot;] = objectコードにはコメントが付いていて、実行される機能を把握できるようになっています。重要なのは、現在のセッション内のいずれかの最上位メッシュに対して、メッシュ項目を収集するためのロジックが追加されたことです。ただし、この時点でパブリッシャーを実行する場合は、項目ツリーにメッシュ項目が表示されません。これは、これらに作用するパブリッシュ プラグインが定義されていないためです。次に、これらのメッシュ項目にアタッチされ、下流工程で使用できるようにこれらのパブリッシュを処理する、新しいシェーダ パブリッシュ プラグインを記述します。                    注: 上記のコードに、メッシュ項目のアイコンを設定するための呼び出しが含まれる可能性があります。このため、指定したパスの設定にアイコンを追加する必要があります。    config/hooks/tk-multi-publish2/icons/mesh.pngシェーダ パブリッシュ プラグインを作成する次の手順では、新たに収集されたメッシュ項目を、メッシュのシェーダをディスクに書き出してパブリッシュできるパブリッシュ プラグインに接続します。このためには、新しいパブリッシュ プラグインを作成する必要があります。このリンクに従ってこのフックのソース コードを特定し、hooks/tk-multi-publish2/maya フォルダに保存して、publish_shader_network.py という名前を付けます。                    注: このプラグインには、Toolkit プラットフォームおよびパブリッシュ コードを初めて使用する場合に使用するコードが多数含まれています。今のところ、これについて悩む必要はありませんこのチュートリアルの進行状況や、パブリッシャーの機能に対する理解度に応じて行われる操作については、時間をかけて調査し、内容を理解するようにしてください。今は、ファイルを作成し、ファイルの目的が、シェーダ ネットワークのディスクへの書き込みを処理することであることを理解しておきます。    シェーダをパブリッシュできるようになる前に行う最後のステップでは、新しいシェーダ パブリッシュ プラグインで定義されたテンプレートおよび設定を追加します。settings プロパティに、このプラグインで定義された設定が表示されます。    @property    def settings(self):       &quot;”” … &quot;””       # inherit the settings from the base publish plugin       plugin_settings = super(MayaShaderPublishPlugin, self).settings or {}       # settings specific to this class       shader_publish_settings = {           &quot;Publish Template&quot;: {               &quot;type&quot;: &quot;template&quot;,               &quot;default&quot;: None,               &quot;description&quot;: &quot;Template path for published shader networks. &quot;                              &quot;Should correspond to a template defined in &quot;                              &quot;templates.yml.&quot;,           }       }       # update the base settings       plugin_settings.update(shader_publish_settings)       return plugin_settingsこのメソッドは、プラグインの設定インタフェースを定義します。シェーダ ネットワークをディスクに書き込む場所をプラグインに指示するには、「パブリッシュ テンプレート」の設定が必要です。パブリッシャーの設定に新しいパブリッシュ プラグインを追加して、テンプレートの設定を含めます。これは、コレクタを引き継ぐ前に修正されたのと同じ設定ブロックです。これは、次のファイルで定義されます。env/includes/settings/tk-multi-publish2.yml設定は次のようになります。    最後に、設定内で新しい maya_shader_network_publish テンプレートを定義する必要があります。このファイルを編集して、これを追加します。config/core/templates.ymlアセット関連の Maya テンプレートが定義されているセクションを見つけて、新しいテンプレート定義を追加します。定義は次のようになります。    これで終了です。シェーダをパブリッシュするメッシュを検索するように、Publish アプリのコレクタ フックが上書きされました。収集されたシェーダ項目にアタッチする新しいパブリッシュ プラグインが実装されました。また、シェーダ ネットワークがディスクに書き込まれる新しいパブリッシュ テンプレートが定義および設定されました。                    注: 設定のカスタマイズ中に Maya を終了しても、問題はありません。Maya を単に再起動し、[File Open]ダイアログ ボックスを使用してサーフェス作成作業ファイルを開くことができます。次の再ロード ステップはスキップできます。    ShotGrid 統合を再ロードするカスタマイズを試すには、Maya セッション内で統合を再ロードする必要があります。このためには、[ShotGrid] &amp;gt; [[タスク名]] &amp;gt; [Work Area Info…]メニュー アクションをクリックします。    この操作を行うと、現在のコンテキストに関する情報を示す Work Area Info アプリが起動します。設定を変更しながら統合を再ロードするための便利なボタンもあります。このボタンをクリックして、アプリおよびエンジンを再ロードしてから、ダイアログ ボックスを閉じます。    シェーダ ネットワークをパブリッシュするこれで、プロジェクトの設定を変更した場合の結果を確認できるようになりました。ShotGrid メニューから Publish アプリを起動します。Publish Shaders プラグインがアタッチされている、収集されたティーポット メッシュ項目が表示されます。    作業の説明を入力し、サーフェス ティーポットのサムネイルを取り込んで、パブリッシュされたファイルに関連付けます。最後に、パブリッシュをクリックして、ティーポット シェーダをディスクに書き出して、このファイルをパブリッシュとして ShotGrid に登録します。完了すると、セッションのパブリッシュ プラグインによって、作業ファイルが次に使用可能なバージョンに自動的に保存されます。これが、ShotGrid 統合でサポートされているすべての DCC の既定の動作です。これで、ShotGrid 内のティーポット アセットを参照して、すべてが予測どおりに機能したことを確認できるようになりました。    お疲れ様でした。パイプラインが正常にカスタマイズされ、ティーポットのシェーダがパブリッシュされました。 学習した内容を使用して、テーブル プロップのサーフェス作成タスクからシェーダをパブリッシュできるかどうかを確認します。結果は以下のようになります。    次に、リギング ワークフローについて説明します。リギング ワークフロー現在、ShotGrid に付属している Workfile アプリおよび Publish アプリを使用すると、作業ファイルを開く(または作成する)、保存する、パブリッシュする操作を極めて快適に行うことができます。また、上流工程からパブリッシュをロードする Loader アプリを使用する機会もありました。学習した内容を使用して、次のタスクを完了します。      ShotGrid Desktop から Maya を起動する        ティーポット アセットのリギング ステップで、新しい作業ファイルを作成する        モデリング ステップでティーポット Alembic キャッシュ パブリッシュをロード(参照)する        開け閉めするティーポットのふたをリギングする(単純にする)        ティーポットのふたを保存してパブリッシュする  最終的には、ShotGrid で次のようになります。    次に、アーティストが上流工程の変更をワークフロー内でどのように処理するのかを見てみましょうモデリング作業ファイルを開いて、ティーポット モデルに何らかの変更を加えます。次に、更新された作業をパブリッシュします。結果は次のようになります。    ティーポットのリギング ステップで、作業ファイルを再び開きます([ShotGrid] &amp;gt; [File Open…]を使用)。[ShotGrid] &amp;gt; [Scene Breakdown…]メニュー アクションを起動します。この操作を行うと、Breakdown アプリが起動し、作業ファイル内で参照した上流工程のパブリッシュがすべて表示されます。この場合は、上流工程のティーポット モデルのみがあります。次のように表示されます。    アプリは参照ごとに 2 つのインジケータのいずれかを表示します。参照されたパブリッシュが最新バージョンであることを示す緑のチェックと、新しいパブリッシュが公開されていることを示す赤の「x」です。この場合は、新しいパブリッシュが公開されていることがわかります。参照されたティーポット Alembic キャッシュ項目を選択して(または下部の[Select All Red]ボタンをクリックして)、[Update Selected]をクリックします。Maya 参照がティーポット Alembic キャッシュの最新の繰り返しに更新されます。ファイル内に新しいモデルが含まれています。    新しいモデルについて考慮する必要があるリギング ステップを調整して、変更をパブリッシュします。次のセクションでは、ショットのコンテキスト内で作業します。次に、ショットのレイアウトについて説明します。レイアウト ワークフローこのセクションでは、プロジェクトのために作成したショット内で作業を開始します。以前のセクションで作成したアセットをロードし、ショットを作成します。次に、パブリッシャーを再びカスタマイズし、今回はショット カメラをパブリッシュします。まず、以前のセクションで学習した内容に基づいて、次のタスクを完了します。      ShotGrid Desktop から Maya を起動する        ショットのレイアウト ステップで新しい作業ファイルを作成する(ヒント: ローダー内の[Shots]タブを使用する)        ティーポットのリギング ステップでティーポットのパブリッシュをロード(参照)する        テーブルのモデル ステップでティーポットのパブリッシュをロード(参照)する  ここで、テーブルに置かれたティーポットを含む、単純なシーンをブロックします。camMain という名前のシーンにカメラを追加して、いくつかのフレームをアニメートし、ショットのカメラ移動を作成します。    ショットのレイアウトに問題がなければ、[ShotGrid] &amp;gt; [File Save…]メニュー アクションを使用してファイルを保存します。先に進んで、この時点でパブリッシュする場合は、Maya セッション全体のみがパブリッシュ可能な項目として表示されます。簡単なカスタマイズを追加する場合、およびパイプラインの柔軟性を高めるためにカスタマイズする場合は、他のパッケージに簡単に読み込むことができるファイル形式にスタンドアロン カメラをパブリッシュします。これにより、カメラを一度作成すれば(通常はレイアウト内)、アニメーション、ライト、および合成など、他のすべてのパイプラインの手順でこのカメラを直接使用できるようになります。カメラを収集するシェーダのパブリッシュと同様に、最初にコレクタ フックをカスタマイズします。Maya のコレクタ フックをすでに引き継いで、アセット ステップで設定してあります。この設定を、ショットのパイプライン ステップに合わせて更新する必要があります。このためには、パブリッシャーの設定ファイルを修正し、Maya ショット のステップ コレクタ設定を編集します。    ショットのコンテキスト内でタスクを実行している場合は、カスタム コレクタ ロジックが実行されます。次のステップでは、カスタムのカメラ コレクション ロジックを追加します。カスタム コレクタ フックを開き、サーフェス作成セクションでメッシュを収集するための呼び出しを追加した process_current_session メソッドの最下部に、次のメソッド呼び出しを追加します。self._collect_cameras(item)次に、ファイルの末尾にメソッド自体を追加します。    def _collect_cameras(self, parent_item):       &quot;&quot;&quot;       Creates items for each camera in the session.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;camera.png&quot;       )       # iterate over each camera and create an item for it       for camera_shape in cmds.ls(cameras=True):           # try to determine the camera display name           try:               camera_name = cmds.listRelatives(camera_shape, parent=True)[0]           except Exception:               # could not determine the name, just use the shape               camera_name = camera_shape           # create a new item parented to the supplied session item. We           # define an item type (maya.session.camera) that will be           # used by an associated camera publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name. In the future, other publish plugins might attach to           # these camera items to perform other actions           cam_item = parent_item.create_item(               &quot;maya.session.camera&quot;,               &quot;Camera&quot;,               camera_name           )           # set the icon for the item           cam_item.set_icon_from_path(icon_path)           # store the camera name so that any attached plugin knows which           # camera this item represents!           cam_item.properties[&quot;camera_name&quot;] = camera_name           cam_item.properties[&quot;camera_shape&quot;] = camera_shapeここでも、コードにはコメントが付いていて、実行される機能を把握できるようになっています。現在のセッション内のすべてのカメラに対してカメラ項目を収集するロジックを追加しました。ただし、以前と同様に、この時点でパブリッシャーを実行する場合は、項目ツリーにカメラ項目が表示されません。これは、これらに作用するパブリッシュ プラグインが定義されていないためです。次に、これらの項目にアタッチされ、下流工程で使用できるようにこれらのパブリッシュを処理する、カメラ パブリッシュ プラグインを記述します。                    注: 上記のコード内に、カメラ項目のアイコンを設定するための呼び出しが含まれる可能性があります。このため、指定したパスの設定にアイコンを追加する必要があります。    config/hooks/tk-multi-publish2/icons/camera.pngカスタム カメラ パブリッシュ プラグイン次の手順では、新たに収集されたメッシュ項目を、メッシュのシェーダをディスクに書き出してパブリッシュできるパブリッシュ プラグインに接続します。このためには、新しいパブリッシュ プラグインを作成する必要があります。このリンクに従ってこのフックのソース コードを特定し、hooks/tk-multi-publish2/maya フォルダに保存して、publish_camera.py という名前を付けます。カメラ パブリッシュの設定最後に、ショット ステップで Publish アプリの設定を更新する必要があります。設定ファイルを編集して、新しいプラグインを追加します。env/includes/settings/tk-multi-publish2.yml設定は次のようになります。    新しいプラグインの settings メソッドで定義されているとおりに、ファイルに 2 つの設定が追加されています。シェーダ プラグインと同様に[Publish Template]設定があり、そこでカメラ ファイルが書き込まれる場所を定義できます。カメラの設定は、プラグインが作用するカメラを制御する、カメラに関する文字列のリストのことです。何らかのタイプのカメラ命名規則があり、この設定によって、規則に合わないカメラのパブリッシュ項目がユーザに表示されなくなると予測されます。上図では、パブリッシュ用の camMain カメラのみが表示されます。cam* などのワイルドカード パターンを使用した場合も、追加したプラグインの実装は機能します。変更をテストする前の最終ステップでは、新しいカメラ パブリッシュ テンプレートの定義を追加します。config/core/templates.yml ファイルを編集し、Maya ショット テンプレートのセクションにテンプレートの定義を追加します。    この時点で、新しいプラグインを使用してカメラをパブリッシュする準備が整っています。Work Area Info アプリを使用して統合を再ロードしてから、パブリッシャーを起動します。    図に示されているように、新しいカメラ項目が収集されて、パブリッシュ プラグインがアタッチされます。先に進んで、[Publish]をクリックしてディスクにカメラを書き込み、ShotGrid に登録します。                    注: Alembic 書き出しと同様、カメラのパブリッシュ プラグインには FBX 書き出しプラグインをロードする必要があります。カメラのパブリッシュ プラグイン項目が表示されない場合は、FBX プラグインがロードされていることを確認し、パブリッシャを再起動してください。    ShotGrid では次のように表示されます。    これで操作は終了しました。次に、アニメーションについて説明します。アニメーション ワークフローここまでの手順で、Publish アプリのみをカスタマイズすることにより、カスタム ファイル タイプ/コンテンツをディスクに書き込み、他のパイプライン ステップにこれらを共有しました。このセクションでは、Loader アプリの設定をカスタマイズし、ラウンド トリップを完了してカスタム パブリッシュの読み込み/参照を実行できるようにします。以前のセクションで学習した内容に基づいて、次の作業を完了します。      ShotGrid Desktop から Maya を起動する        ショットのアニメーション ステップで新しい作業ファイルを作成する        ショットのレイアウト ステップで Maya セッションのパブリッシュをロード(参照)する                      注: レイアウト セッションのパブリッシュ ファイルに、このカメラが含まれていました。堅牢なパイプラインでは、カメラを明示的に非表示にするか、またはセッションのパブリッシュから除外して、独立したカメラ パブリッシュ ファイルを実際のカメラ定義の 1つに設定することができます。先に進んで、参照によって含まれているカメラを削除または非表示にします。    カスタム カメラ ローダー アクションカメラのパブリッシュを読み込む/参照するように Loader アプリをカスタマイズするには、アプリの設定ファイルを編集する必要があります。設定内のファイルのパスは、次のようになります。config/env/includes/settings/tk-multi-loader2.ymlMaya のアプリが設定されているセクションを見つけて、action_mappings 設定のアクション リストに次の行を追加します。FBX Camera: [reference, import]カスタム カメラ パブリッシュ プラグインでは、カメラをディスクに書き込む際に Maya の FBXExport mel コマンドを使用しました。ShotGrid にファイルを登録する際に使用したパブリッシュ タイプは FBX Camera でした。設定に追加された行は、ローダーに対して、タイプ FBX Camera の任意のパブリッシュの reference および import アクションを表示するように指示します。これらのアクションは、Loader アプリの tk-maya-actions.py フックで定義されています。 これらのアクションは、Maya が参照できる、または読み込むことができる任意のファイル タイプを処理するように実装されています。カスタム プラグインによって生成された .fbx ファイルはこのカテゴリに分類されるため、これが、パブリッシュされたカメラをロードできるようにするために必要な唯一の変更になります。アプリの設定は次のようになります。    ここで、Work Area Info アプリを使用して統合を再ロードし、新しい設定を選択してから、レイアウト内のパブリッシュされたカメラを参照します。    新しいパブリッシュ タイプでフィルタしてから、カメラの参照を作成します。ローダーを閉じると、新たな参照カメラを使用して、前のセクションで作成したカメラの移動を再生できるようになります。次に、何らかの動作を行うようにティーポット モデルをアニメートします(単純にします)。    アニメーションがうまく作成されたら、以前のセクションと同じように作業ファイルを保存してパブリッシュします。次に、照明について説明します。照明ワークフローこのセクションでは、以前のセクションでパブリッシュしたすべてのものを組み合わせて、ショットをレンダリングします。このためには、ティーポット アセットのサーフェス作成ステップでパブリッシュ済みのシェーダをロードするように Loader アプリをカスタマイズします。最初に、以前のセクションで学習した内容に基づいて、次の作業を完了します。      ShotGrid Desktop から Maya を起動する        ショットの照明ステップで新しい作業ファイルを作成する        ショットの照明ステップで Maya セッションのパブリッシュをロード(参照)する        ショットのレイアウト ステップでカメラ パブリッシュをロード(参照)する  カスタム シェーダのローダー アクションサーフェス作成手順でパブリッシュしたシェーダをロードするには、前のセクションで説明した tk-maya-actions.py フックを引き継ぐ必要があります。インストール場所から設定にこのフックをコピーします。    このフックは、指定されたパブリッシュに対して実行できるアクションのリストを生成します。Loader アプリは、付属の統合でサポートされている DCC ごとに、このフックの異なるバージョンを定義します。サーフェス作成ワークフロー セクションでパブリッシュされたシェーダは単なる Maya ファイルであるため、書き出されたカメラと同様に、既存のロジックを変更しなくても、ローダーから参照することができます。必要な変更は、シェーダをファイル内で参照した後に、シェーダを適切なメッシュに接続するための新しいロジックをアクション フックに追加することだけです。アクション フックの末尾(このクラスの外部)に次のメソッドを追加します。    def _hookup_shaders(reference_node):       &quot;&quot;&quot;       Reconnects published shaders to the corresponding mesh.       :return:       &quot;&quot;&quot;       # find all shader hookup script nodes and extract the mesh object info       hookup_prefix = &quot;SHADER_HOOKUP_&quot;       shader_hookups = {}       for node in cmds.ls(type=&quot;script&quot;):           node_parts = node.split(&quot;:&quot;)           node_base = node_parts[-1]           node_namespace = &quot;:&quot;.join(node_parts[:-1])           if not node_base.startswith(hookup_prefix):               continue           obj_pattern = node_base.replace(hookup_prefix, &quot;&quot;) + &quot; d*&quot;           obj_pattern = &quot;^&quot; + obj_pattern + &quot;$&quot;           shader = cmds.scriptNode(node, query=True, beforeScript=True)           shader_hookups[obj_pattern] = node_namespace + &quot;:&quot; + shader       # if the object name matches an object in the file, connect the shaders       for node in (cmds.ls(references=True, transforms=True) or []):           for (obj_pattern, shader) in shader_hookups.iteritems():               # get rid of namespacing               node_base = node.split(&quot;:&quot;)[-1]               if re.match(obj_pattern, node_base, re.IGNORECASE):                   # assign the shader to the object                   cmds.select(node, replace=True)                   cmds.hyperShade(assign=shader)ここで、_create_reference メソッドの末尾に次の 2 行を追加して、シェーダ フック ロジックを呼び出します。    reference_node = cmds.referenceQuery(path, referenceNode=True)    _hookup_shaders(reference_node)&amp;lt;/td&amp;gt;新しい参照が作成されると、必ずコードが実行されるため、ファイル内にシェーダが既に存在する場合に新しいジオメトリを参照すると、シェーダが割り当てられます。同様に、ジオメトリが既に存在するときにシェーダを参照した場合は、コードが機能します。                    注: このフック ロジックは非常に力任せであるため、プロダクション対応パイプラインを実装するときに考慮する必要がある名前空間やその他の Maya 関連の微妙な動作は、適切に処理されません。    最後に、次のファイルを編集して、ショットのローダー設定が新しいフックを指すように指定します。config/env/includes/settings/tk-multi-loader2.ymlそれと同時に、Maya シェーダ ネットワーク パブリッシュ タイプの参照アクションへの関連付けも行います。ローダーの設定は次のようになります。    ここで、Work Area Info アプリを使用して統合を再ロードし、新しい設定を選択してから、サーフェス内のパブリッシュされたシェーダを参照します。ティーポット シェーダ ネットワーク パブリッシュに対する参照を作成します。    ここで、テーブル シェーダ ネットワークをロードします。Maya でハードウェア テクスチャリングが有効になっている場合は、アニメーション ステップ中にシェーダがメッシュ参照に自動的に接続されています。    ここで、シーンにライトをいくつか追加します(単純にします)。    Maya レンダーをパブリッシュするショットをディスクにレンダリングします。                        注: ご覧のとおり、ティーポットとテーブル アセットのサーフェスには共に問題があります。このチュートリアルでは、これらが意図的かつ芸術的な選択肢であると想定します。これらの問題を解決する場合は、これらのアセットのサーフェス作成作業ファイルをロードして、シェーダを調整し、再びパブリッシュしてください。この操作を行う場合は、照明作業ファイル内の参照を忘れずに更新して、再度レンダリングしてください。これらの手順を実行する場合は、参照を再ロードした後に、詳細情報アプリが更新済みのシェーダを再接続しないことがあります。シェーダの参照をフックするようにローダーを変更した経験に基づいて、ユーザは詳細情報アプリのシーン操作フックを更新し、必要なロジックを追加できるようになっています。ヒント: このファイル内の update メソッドを参照してください。    付属の ShotGrid 統合は、ファイル内で定義されたレンダリング レイヤを調べて、イメージ シーケンスを収集します。レンダリングが完了したら、パブリッシャーを起動します。レンダリングされたシーケンスがツリー内の項目として表示されます。    先に進んで、セッションおよびレンダリングされたイメージ ファイル シーケンスをパブリッシュします。ShotGrid では次のように表示されます。    次に、コンポジットについて説明します。コンポジット ワークフローチュートリアルのこの最終セクションでは、Nuke が提供する既定の統合をいくつか紹介します。以前のセクションで参照したアプリの他に、ShotGrid 対応書き込みノードや、レビューのためにレンダーを他のユーザにすばやく送信するためのアプリについて学習します。最初に、次に示す手順を行って作業ファイルを準備します。      ShotGrid Desktop から Nuke を起動する        Maya と同様に、[ShotGrid] &amp;gt; [File Open]メニュー アクションを使用して、ショットのコンポジット ステップ内で新しい作業ファイルを作成します。  Loader アプリを使用して前のセクションでレンダリングおよびパブリッシュしたイメージ シーケンスをロードします。    Image および Rendered Image パブリッシュ タイプに対して定義されているアクションは、ノードの作成と読み取りです(タイプはファイル拡張子によって異なります)。このアクションをクリックして、Nuke セッション内で新しい Read ノードを作成します。Nuke プロジェクト設定の出力フォーマットが、レンダリングされたイメージと一致することを確認します。バックグラウンドとして使用する一定のカラーを作成して、読み取りノードと結合します。ビューアをアタッチしてコンポジットを表示します。    コンポジットに問題がなければ、[ShotGrid] &amp;gt; [File Save…]メニュー アクションを使用して、作業ファイルを保存します。次に、Nuke の左側メニューで ShotGrid のロゴをクリックします。このメニューの ShotGrid 対応書き込みノードの 1 つをクリックします。    ShotGrid Write Node アプリは、現在の ShotGrid のコンテキストに基づいて出力パスを自動的に評価する組み込みの Nuke 書き込みノードの上に、レイヤを配置します。    ディスクにイメージ フレームをレンダリングします。Nuke セッションをパブリッシュして、レンダリングされたイメージに作業ファイルを関連付けられるようになりました。既定では、パブリッシャーはレンダリングされたフレームを収集し、ShotGrid にフレームを登録するプラグインをアタッチします。2 番目のプラグインは、レビュー提出と呼ばれる、バックグラウンドで実行される統合方法を使用して、フレームをアップロードします。このアプリは Nuke を使用して QuickTime を生成します。生成された QuickTime は、アップロードしたり、レビューしたりできます。    もう 1 つの便利な統合は、Quick Review アプリです。これは、QuickTime をすばやく生成して、レビューのために ShotGrid にアップロードする出力ノードです。このアプリは、左側メニュー内の、ShotGrid 書き込みノードの横にあります。    Quick Review ノードを作成してから、[Upload]ボタンをクリックして、ディスクへの入力のレンダリング、QuickTime の生成、レビューのための ShotGrid への結果のアップロードを行います。フレームを提出する前に、いくつかの標準オプションが表示されます。    ShotGrid の[メディア]（Media）タブを調べて、アップロードされた QuickTime を両方とも確認します。    ShotGrid でメディアをレビューする方法の詳細については、公式のドキュメントを参照してください。結論おめでとうございます。これで完了です。このチュートリアルが、ShotGrid 統合を使用して独自のカスタム パイプラインを作成する際の第一歩になるはずです。スタジオ固有のニーズに合わせて既存の ShotGrid アプリを拡張する方法について理解できたことでしょう。Toolkit に関する質問がある場合や、他のスタジオで Toolkit がどのように使用されているかを知りたい場合は、shotgun-dev Google Group にアクセスしてください。常に最新の投稿を読むことができるよう、サブスクライプすることをお勧めします。機能やワークフローを既定の統合で実現できないと感じた場合は、独自のアプリをいつでも作成できます。初めてアプリを作成する場合は、こちらを参照してください。このチュートリアルの詳細または ShotGrid や Toolkit プラットフォームの概要に関して質問がある場合は、チケットを送信してください。",
    "url": "/cb8926fc/",
    "relUrl": "/cb8926fc/"
  },
  "69": {
    "id": "69",
    "title": "Planning Your Setup",
    "content": "Planning Your SetupPick your optionsPick which features you want to activate  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media ReplicationAWS Account CreationBefore going further, you will require an AWS Account. If you don’t already have an AWS Account, create your AWS Account.Choose an AWS RegionChoose an AWS Region for your AWS S3 bucket and VPC. Which region to use? You should chose the a region that is the closest possible to your studio.If your company is located in different locations, consider enabling the media replication feature to reduce latency and improve performancePlan the VPC IP rangesPlan your AWS VPC and subnets IP ranges.IP Range Example            Region      VPC      Subnet 1      Subnet 2      Subnet 3                  ap-southeast-2      10.1.0.0/16      10.1.0.0/24      10.1.1.0/24      10.1.2.0/24      Plan how you will privately access your AWS VPCIf you plan to activate any of the Traffic Isolation feature, you will need a way to connect your AWS VPC and your network infrastructure. The main options are:  AWS Direct Connect  Other VPN solutionWe highly recommand you to leverage Direct Connect. Direct Connect guarantees the lowest latency possible to the ShotGrid services, a consistent network experience, and allow you to leverage the optimization AWS is relying on to guarantee an optimal performance across the globe.Next StepWith your plan layed down, you are ready to start implementing the AWS building blocks that will allow you to activate the isolation features. To avoid disruption on your production site, you will first materialize and test your setup on your Migration Test Site",
    "url": "/7897b2e2/",
    "relUrl": "/7897b2e2/"
  },
  "70": {
    "id": "70",
    "title": "Private Link",
    "content": "Private LinkAWS PrivateLink is an AWS service that connects different AWS VPCs without going through the public internet.In conjunction with AWS Direct Connect, PrivateLink helps create a dedicated connection between your studio and ShotGrid’s infrastructure.",
    "url": "/9da985a7/",
    "relUrl": "/9da985a7/"
  },
  "71": {
    "id": "71",
    "title": "Python 3 Porting Best Practices",
    "content": "Python 3 Porting Best PracticesWhy the move to Python 3?There are a few compelling reasons to make the leap to Python 3.  Perhaps the most dramatic is the Python 2 end of life, which occurred on January 1, 20201. With the sunsetting of Python 2, all support for Python 2 ceases, meaning that even new security vulnerabilities found in Python 2 will not be addressed.For CY2020, the VFX reference platform makes the switch as well, targeting Python version 3.7.x.  As a practical matter for many of us, all of this will mean we don’t have much choice in when to add support for Python 3 – as DCCs (digital content creation applications) that we develop for begin to move to Python 3 interpreters, it will become a necessity to support them.Things to Consider Before StartingWhen considering moving to support Python 3, it’s good to look at the requirements and application of your codebase to set expectations.  Obviously, any host applications your code runs in will help drive this decision.  Knowing whether you need to support many different Python interpreter versions and, if so, which ones, will be important information as you decide on the porting process that makes sense for you.Next, take an audit of what libraries your code depends on.  If any of these libraries do not have Python 3 compatible versions, you’ll need to find an alternative library, or fork the library to provide compatibility yourself. Both of these options could potentially be costly decisions and are important to consider early on.  Additionally, even libraries that do offer Python 3 compatible versions may not be drop-in replacements, and some libraries choose to fork for Python 3 support rather than maintain compatibility for both Python 2 and 3 as a single source.  We’ll discuss this in more depth in the “Porting Options” section below.Finally, it’s worth noting that while it is possible to continue to support Python versions older than 2.5 and Python 3 simultaneously2, this will make your life much harder.  Since Python 2.5 is very old and not used in modern DCC versions, this guide will work under the assumption that Python 2.5 and earlier will not be targeted.  If you do need to support older versions of Python, a branching approach as described in the “Porting Options” section below may be your best option.What’s Different in Python 3Python 3 comes with some slight syntax changes, changes to builtin functions, new features, and small behavior changes.  There are many great guides that enumerate these specific changes and provide examples.  Rather than dive into specifics here, the goal of this guide will be to describe the porting process from a higher-level perspective, with a few small deep dives where compatibility may be more complicated than just matching syntax.Porting OptionsFor most of us, porting our code to only support Python 3 is not yet an option.  Many DCCs still require Python 2 support, and this is unlikely to change overnight.  This means that in the real world, it will be a necessity to be able to support both Python 2 and 3.There are two major approaches to supporting Python 2 and 3 simultaneously.  We’ll discuss both of them briefly:BranchingIn this approach, a new Python 3 compatible branch of your code is maintained in parallel with the current (Python 2 compatible) branch.  This has the advantage of letting you write cleaner, easier to read Python 3 code, and allows you to fully leverage new features without needing branching logic to maintain Python 2 support.  It also means that when the time comes to drop support for Python 2, you’ll be left with a cleaner, more modern starting point in your Python 3 branch.  The obvious downside here is that maintaining two branches can be unwieldy and mean more work, especially if the Python 3 and Python 2 code starts to diverge as the Python 3 branch can leverage new features that can significantly change how your code looks (e.g. asyncio.)Cross-CompatibilityIn this approach, a single branch is maintained that uses the subset of syntax and builtins that are compatible with both Python 2 and 3.  This allows for a graceful transition from Python 2 to 3 without maintaining multiple branches of your code.  There are a few popular libraries designed to help with this approach, and it’s a commonly-used solution to the problem of transition from Python 2 to 3.  In addition to the reduced complexity compared to maintaining multiple branches, this approach also means you don’t need to change your code distribution mechanisms or worry about using the correct (Python 2 or 3) version of your code at import time.The two most commonly used libraries for this approach are future and six.futureThe future module is probably the most popular choice for Python 2 + 3 compatibility.  It backports many Python 3 libraries to Python 2, and aims to allow you to move your codebase to a pure Python 3 syntax.  Because it backports modules and works by shadowing builtins, it is slightly more invasive than six.  Given the variety of DCCs and unknown client code in VFX environments, future may be too invasive and in an environment like this may pose a greater risk of causing problems down the road.  For this reason, we will focus on using six instead.sixThe six module does not attempt to backport Python 3 modules, or allow you to write pure Python 3 syntax, but instead unifies renamed modules and changed interfaces inside the six.moves namespace.  This allows you to update imports and use six’s helper functions to write code that is both Python 2 and 3 compatible.Testing and LintingBlackThe porting process requires an examination of the entire python codebase, and introduces a fair amount of noise in the revision control history.  This makes it a good opportunity to take care of any other housekeeping that may have similar impacts.  We took this opportunity to apply black to our code.  This is not strictly necessary or directly related to Python 3 compatibility (unless your code is mixing tabs and spaces3), but given the reasons identified above, we decided this was a good opportunity to modernize our code formatting.TestsTest coverage was incredibly valuable during the porting process since it allowed us to quickly find problems that still needed to be addressed, and verify that large sections of code were working as expected without as much manual intervention.  In many cases, we found it worthwhile to increase test coverage as part of the porting process to ensure that Python 2/3 specific cases (e.g. unicode handling) were being addressed correctly.  This being said, we recognize that in many cases the realities of production mean that test coverage is sparse, and that adding tests to code that has little or no coverage may be too time consuming to be worthwhile as part of a project like adding Python 3 compatibility.  For those in this situation, there may still be some value in using coverage measurement tools and some more basic testing code during the porting process, as these tools can provide fast feedback on what code has been covered and what may still need attention.Porting ProcedureAutomated Porting using modernizepython-modernize is a tool that can be very useful for automatically generating Python 3 compatible code.  modernize usually produces runnable code with minimal human intervention, and because of this can be a great tool to get most of the way to Python 3 compatibility very quickly.  Of course, as an automated tool it does come with the drawbacks one would expect.  It frequently produces less readable and less efficient code (e.g. wrapping all iterables in a list() instantiation.)  In some cases, modernize can even introduce regressions that might be difficult to spot.  There are also some areas where you’ll find modernize is not much help at all, like when dealing with bytes and text.  Since these decisions require a bit more understanding of context, you’ll likely have to spend some time manually addressing the handling of strings in your code even if you do rely on modernize for the bulk of the compatibility work.The alternative to using an automated tool like modernize, of course, is to go through code manually to fix incompatibilities.  This can be tedious, but in our experience generally produces nicer looking code.For our process we went with a hybrid approach, using modernize with a select set of fixers, and doing some of the work manually.  We also broke the process into two stages; first doing a pure syntax compatibility and code formatting pass, and then doing a more manual Python 3 port.  Our process was as follows:In a branch:  Run modernize with the except, numliterals, and print fixers  python-modernize --no-diffs --nobackups -f except -f numliterals -f print -w .  Make sure the resulting code is Python 3 syntax compliant by compiling it with Python 3.  The goal here is not to have your code work in Python 3, but to ensure that the basic formatting and automatable syntax fixes are in place.  If your code does not successfully compile after this step, you’ll need to find the source of the problem and either add additional fixers to the above step, or manually fix the incompatibilities.  Ensure that any changes you make manually at this stage are syntax only and will not change the behavior of the code in Python 2.  python3 -m compileall .  Run black on the resulting codeThis branch should not change any behavior or functionality, and should not introduce regressions, so it is considered safe to merge at this point.  This helps keep the history easier to read, and means that the Python 3 compatibility branch and master will diverge less during the porting process, making for an easier merge once the work is done.In a new branch, the actual Python 3 port can now begin:  Search for method names that may require some work to deal with list/view/iterator differences between Python 2 and 3.  In Python 3 .values(), .items() and .keys() return an iterator or view instead of a list, so in cases where these methods are called the code should be able to handle both iterator and list returns, otherwise the result will need to be cast to a list.  Similarly, the filter() method returned a list in Python 2, but now returns an iterator.  Change calls from dict.iteritems() and dict.itervalues() to dict.items() and dict.values() if the returned collection won’t be too big.  In these cases, the resulting cleaner code at the cost of a slight performance hit in Python 2 is preferable.  In cases where the collection might contain thousands of items or more, use six.iteritems and six.itervalues instead.  If dict.iterkeys() was used, simply replace the code with something like for key in dictionary:, since this will iterate on keys in both Python versions.  Watch out that returning an iterator in Python 3 doesn’t change the semantics of the code however. If a method used to return dict.values(), you’ll need to wrap the call inside list(dict.values()) to ensure the method always returns a list in all versions on Python.  Search for str, basestring, unicode, open, pickle, encode, decode since these will be areas of the code that likely require some attention to handling of bytes and strings.  We used the coercion helper methods provided by six (e.g. ensure_string) where needed.  See the sections on bytes and pickle below.  Unless generating a super long range, xrange can be changed to range for simplicity, otherwise six.range can be used.  After committing the manual changes from above, run a full python-modernize and go through the diff manually.  Many of the resulting changes will be unwanted, as discussed above, however this is a good way to catch potential problems that were overlooked in the manual porting process.  python-modernize --no-diffs --nobackups -f default . -w &amp;amp;&amp;amp; git diff HEAD  Test the resulting code to find the remaining problems.  There are some incompatibilities that don’t have fixers (this is a good resource to look at to get an idea of what those changes entail), and it’s easy to overlook text/binary problems during the port process.We chose to use this process because we believe it allowed us to maintain a standard of more readable, efficient code than would have been automatically generated by using modernize on its own.GotchasBytes WoesPython 3 introduces a strict separation between binary and textual data.  This is a long-called-for addition that most see as an improvement, but for Python 2 + 3 compatible code it adds some headaches.  Since Python 2 does not enforce this separation, and Python 3 introduces new types to do so, code that deals with data and strings will likely need some attention.  For the most part this just means making sure that strings are encoded / decoded properly, for which the six.ensure_binary and six.ensure_text helper functions are invaluable.  See the examples below for common applications of these methods.  In some cases, however, this can be more complicated.  For an example of this, see the pickle section below.# base64.encodestring expects str in Python 2, and bytes in Python 3.# By using six.ensure_binary() we can ensure that the we always# pass it the correct type.base64.encodestring(six.ensure_binary(some_string))# In this example (from tk-multi-publish2), we get a list of files# from a QDropEvent in Pyside.  The  filenames are unicode, however# they're being passed to code that expects str.# In Python 2, this had looked like:if isinstance(category_type, unicode):                    category_type = category_type.encode(&quot;utf-8&quot;)# Using six, we can get the same behavior in Python 2, and ensure# compatibility with Python 3 with:category_type = six.ensure_str(category_type)The pickle PicklePickle in Python 3 returns a bytes object from dumps(), where previously it had returned a str.  Additionally, the output of pickle.dumps() in Python 3 contains  x00 bytes, which cannot be decoded. This is not a  problem if the data is being stored in a file, but if the pickled data is being stored in, for example, an environment variable, this can become problematic.  As a workaround, we found that by forcing pickle to use protocol 0, no 0 bytes were included, and the output is once again decodable.  This comes at the cost of the slightly less efficient and fewer-featured older protocol.# Dumping data to a pickle string:DUMP_KWARGS = {&quot;protocol&quot;: 0}# Force pickle protocol 0, since this is a non-binary pickle protocol.# See https://docs.python.org/2/library/pickle.html#pickle.HIGHEST_PROTOCOL# Decode the result to a str before returning.pickled_data = six.ensure_str(cPickle.dumps(data, **DUMP_KWARGS))# Loading data from a pickle string:LOAD_KWARGS = {&quot;encoding&quot;: &quot;bytes&quot;} if six.PY3 else {}data = cPickle.loads(six.ensure_binary(data), **LOAD_KWARGS)Regex  W flagIn Python 3, regular expression metacharacters match unicode characters where in Python 2 they do not.  To reproduce the previous behavior, Python 3 introduces a new re.ASCII flag, which does not exist in Python 2.  To maintain consistent behavior across Python 2 and 3, we wrapped re functions to include this flag across the board in Python 3.Dictionary OrderPrior to Python 3.7, dictionary order was not guaranteed.  As of Python 3.7, insertion order is preserved in dictionaries[11].  In practice, on Python 2.7 dictionary order was random but deterministic (though this was not guaranteed), on some versions of Python (including some version of Python 3) dictionary order is non-deterministic[10].  While code prior to Python 3.7 should not rely on dictionary key order being deterministic, there were instances where this assumption was made in our unit tests.  These tests broke in Python 3.7, and needed to be updated to ensure that dictionary key order was not relied upon.sys.platformIn Python 3.3+ sys.platform on Linux returns linux, where previously it had returned “linux” appended with the kernel major version (i.e. linux2).  Of course when testing for Linux it is easy enough to check sys.platform.startswith('linux').  We chose to centralize these tests and platform “normalization”, and introduced functions sgtk.util.is_windows(), sgtk.util.is_linux(), sgtk.util.is_macos(), as well as a sgsix.platform constant that contains a normalized platform string that can be used for consistent mapping to platform names across python versions.Notes            https://www.python.org/doc/sunset-python-2/ &amp;#8617;              https://docs.python.org/3/howto/pyporting.html#drop-support-for-python-2-6-and-older &amp;#8617;              https://portingguide.readthedocs.io/en/latest/syntax.html#tabs-and-spaces &amp;#8617;      ",
    "url": "/5583eab1/",
    "relUrl": "/5583eab1/"
  },
  "72": {
    "id": "72",
    "title": "ShotGrid Desktop を使用して Toolkit プロジェクトを再セットアップするにはどうすればいいですか?",
    "content": "ShotGrid Desktop を使用して Toolkit プロジェクトを再セットアップするにはどうすればいいですか?既にプロジェクト用に Toolkit 構成をセットアップしていて、最初からやり直す必要がある場合、以前のセットアップ構成を削除しない限り ShotGrid Desktop の詳細セットアップ ウィザードでプロジェクトを再セットアップすることはできません。これらの設定を手動で削除する手順は次のとおりです。  ShotGrid でプロジェクトにリンクされているすべての PipelineConfiguration エンティティを削除します。  ShotGrid の Project エンティティの Tank Name フィールドを空白の値に設定します。  ディスク上で対応するパイプライン設定ディレクトリをすべて削除します。  ShotGrid Desktop で、セットアップするプロジェクトを選択します。既にプロジェクトを表示していた場合は、プロジェクト リスト ビューに移動してから、もう一度プロジェクトに戻ります。  これでプロジェクト セットアップ プロセスを再び実行できます。別の方法コマンド ラインで tank setup_project コマンドを使用してプロジェクトをセットアップすることに慣れている場合は、コマンドの最後に --force 引数を追加します。これにより、上記の手動での手順に従わずに、以前にセットアップしたプロジェクトをセットアップできます。tank setup_project --force&quot;",
    "url": "/fb5544b1/",
    "relUrl": "/fb5544b1/"
  },
  "73": {
    "id": "73",
    "title": "Client Responsibilities",
    "content": "Client ResponsibilitiesBelow, we have outlined setup responsibilities between Autodesk and You.Isolation SetupYou are entirely responsible for the validity, security, and execution of the Isolation setup in Your AWS Account. Autodesk should not, under any circumstances, be granted access to Your AWS environment.Autodesk is available during the process for assistance, but the configuration of Isolation features in Your AWS Account is to be executed by You on Your own.Isolation feature set activation requires the ShotGrid Support team’s intervention. Activation delays are to be expected and will depend on demand. You understand that an estimated period of 2-8 weeks is usually required to complete the setup necessary to implement the isolation feature set. The setup time is highly dependent on your cooperation, so please plan to dedicate resources for the setup before beginning the onboarding process.Autodesk does not guarantee any timeline for setup completion.Onboarding            Type      Description / Agreement      Responsibility      Available for Assistance                  AWS Knowledge      Acquiring the AWS-specific knowledge required to set up the isolation features.      You      N/A              S3      Setting up the S3 Bucket that will host Your media Securing access to the S3 Bucket. Additional high-availability measures (versioning, bucket replication, etc.)      You      ShotGrid and *AWS              Closed VPC      Setting up DirectConnect/VPN, etc. to allow closed access to the VPC. Securing the VPC by putting the correct Security Groups in place.      You      *AWS              Media Isolation      Creating the S3 end-points. Deploying the S3 Proxy.      You      ShotGrid and *AWS              Traffic Isolation      Creating VPCs. Creating Subnets.      You      ShotGrid              Private Access Point      Checking that the access point is only available from Your network.      ShotGrid      N/A              Monitoring and Reliability      Maintaining uptime up to Autodesk standards. High availability and redundancy of Cloud Services. Metadata and database resiliency and redundancy. Maintaining Recovery Point Objective (RPO) for metadata and database.      ShotGrid      N/A              Service Level Objective      Maintaining ShotGrid target RPO and RTO (See ShotGrid Security White Paper for more details).      ShotGrid      N/A              Security and Governance      Maintaining the ShotGrid Cloud Services that Isolation clients are interfacing with, so that they are meeting expectations in terms of security, vulnerability patching, scanning, auditing, etc. (See ShotGrid Security White Paper for more details).      ShotGrid      N/A      *You are solely responsible to seek or obtain any support services AWS may provide under any existing relationship between You and AWS. Autodesk teams are not parties to Your relationship with AWS and therefore not responsible or liable for any services or lack thereof provided by AWS to You.",
    "url": "/2f59bc69/",
    "relUrl": "/2f59bc69/"
  },
  "74": {
    "id": "74",
    "title": "Review",
    "content": "ReviewLearn to how to get the most out of RV, the award-winning suite of digital review tools that allows you to play back, compare, and convert digital media with collaboration tools and many deep integrations.Dig into RV’s Reference Manuals for a complete understanding of node graphs, custom shaders, event handling, and networking.Check out the RV-SDI manual to learn about our implementation of the NVIDIA SDI video device as a presentation mode device.Look to our Integration Packages for seamless workflows with Maya, Nuke, and even ShotGrid itself.",
    "url": "/61e62b21/",
    "relUrl": "/61e62b21/"
  },
  "75": {
    "id": "75",
    "title": "S3",
    "content": "S3Amazon S3 is an object storage service offered by AWS. It can be thought of as a highly durable storage space in the cloud. ShotGrid uses S3 to store uploaded media and files.In order to use ShotGrid isolation features, you will bring your own S3 bucket and configure ShotGrid to use it for storage. Please refer to our S3 Bucket Setup article for details on how to do this.",
    "url": "/dfc0cc1b/",
    "relUrl": "/dfc0cc1b/"
  },
  "76": {
    "id": "76",
    "title": "Media Isolation",
    "content": "Media Isolation                    Disclaimer: The security of your S3 bucket is solely a client responsibility, and the integrity of your data will be at risk without it. We very strongly recommend securing your S3 bucket properly.    AWS Account CreationYou can quickly create your AWS Account.You should also contact your AWS contacts to get help with your AWS account setup.AWS CloudFormation templateIt’s possible to start from the Private S3 bucket AWS CloudFormation template and customize it for your needs for a faster deployment.                    Disclaimer: This template is provided as an example only. It is your responsibility to validate that running the template will result in the configuration/policy/security settings your studio requires.      Go the CloudFormation service in AWS Console  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-s3-bucket.yml  Next  Set a stack name like ShotGrid-s3-bucket  Set your S3 bucket name and your ShotGrid site name  Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  NextCORS ConfigurationCORS policy on your S3 bucket will be minimally configured, allowing only the required origin (your site) and methods, amongst other things.IAM RoleThe template will create an AWS Role with the following permissions on your bucket:  Allow ShotGrid to access your S3 bucket.  Allow the ShotGrid account to assume the role by setting the role Trust Relationship.Media Isolation ActivationPlease contact ShotGrid support via the dedicated Slack channel and provide the following information:  S3 bucket name  AWS Region  ShotGrid Role ARNShotGrid will configure your test site to use your own S3 bucket.ValidationAt this stage, you should be able to upload and download media. The ShotGrid Transcoding Service should also be able to read, transcode and write back the thumbnails, filmstrip and web friendly versions of your media back to your S3 Bucket. To validate this:  Log in your Migration Test Site.  From the Navigation Bar, go the the Media app  Once in the Media App, drag and drop or upload an image or a video from your computer. If you didn’t created a Project yet, you may have to create one first.  A version should appear, with a thumbnail, in the Media App.  Validate that you can playback the media by clicking the Play button.  To validate that the media has been stored in your S3 bucket, from the media viewer, click on the cog and then select or hover over ‘view source’. The HTTPS link should contain your bucket name.Next StepsSee Media Traffic Isolation to activate the Media Traffic Isolation feature.See Web Traffic Isolation to activate the Web Traffic Isolation feature.See Media Replication to activate the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/439f0627/",
    "relUrl": "/439f0627/"
  },
  "77": {
    "id": "77",
    "title": "Media Replication",
    "content": "Media ReplicationDescriptionIt’s possible to add S3 replication between two S3 buckets in different regions and configure ShotGrid to leverage it for faster access to media.Features  Support one replica bucket in another region leveraging the AWS S3 replication featureHow it worksWhen S3 bucket replication is activated, users will be able download media files from the replica S3 bucket.For each user, the S3 replication is activated by the Use S3 Replication field.            Value      Behavior                  no      Never use replica S3 bucket (default)              yes      Use replica S3 bucket when delay is over              auto      Use replica S3 bucket when delay is over and the client IP is in IP Adresses for S3 replication range      The IP Adresses for S3 replication preference can be edited in Site Preferences under the Isolation category.Limitations  Only one replica S3 bucket can be configured  Only downloading from the replica bucket is supported  Configurable delay for new media to be replicated before being made available to usersSetup steps  Create the replica S3 bucket in a new AWS region. See Media Isolation  Update your existing ShotGrid role policy to allow ShotGrid to also access the replica bucket  Setup the replication rules on the primary S3 bucket. See How do I add a replication rule to an S3 bucket?  Setup a VPC + Direct Connect + S3 proxy in the new AWS region. See Media Traffic Isolation  Contact ShotGrid Support to configure your site to use the new S3 replica bucket, providing the following information:          Replica Bucket Name      Replica Bucket Region      Replica S3 proxy URL      FAQCopy existing mediaS3 replication only applies to media uploaded after the feature has been enabled. Existing media in the primary bucket must be copied to the replica bucket manually. You can simply use aws-cli sync or use Amazon S3 Batch Operations if you have a lot of media to achieve this.Next StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/44623c83/",
    "relUrl": "/44623c83/"
  },
  "78": {
    "id": "78",
    "title": "ソフトウェアを起動する前に環境変数を設定するにはどうすればいいですか?",
    "content": "ソフトウェアを起動する前に環境変数を設定するにはどうすればいいですか?ShotGrid Toolkit では、起動プロセス中にフックを使用して環境を設定し、カスタム コードを実行することができます。Nuke や Maya などのソフトウェアを ShotGrid Desktop またはブラウザ統合を使用して起動すると、tk-multi-launchapp が実行されます。このアプリには、ソフトウェアを起動し、ShotGrid 統合が予測どおりに起動したことを確認するという役割があります。このプロセス内にフックを使用して公開されている 2 つのポイントがあり、そこでカスタム コードを実行することができます。before_app_launch.pybefore_app_launch.py フックは、ソフトウェアを起動する直前に呼び出されます。このフックを使用すると、起動されたソフトウェアに渡す任意のカスタム環境変数を完全に設定することができます。例:import osimport tankclass BeforeAppLaunch(tank.Hook):    def execute(self, app_path, app_args, version, engine_name, **kwargs):        if engine_name == &quot;tk-maya&quot;:            os.environ[&quot;MY_CUSTOM_MAYA_ENV_VAR&quot;] = &quot;Some Maya specific setting&quot;                    警告: ShotGrid で設定された環境変数を完全に再定義しないよう注意してください。たとえば、NUKE_PATH (Nuke の場合)、または PYTHONPATH (Maya の場合)にパスを追加する必要がある場合は、既存の値を置き換えるのではなく、そこにパスを追加するようにしてください。このための便利な方法が提供されています。tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)    カスタム ラッパースタジオによっては、環境変数の設定とソフトウェアの起動を処理するカスタム ラッパーが用意されている場合があります。このようなカスタム コードを使用する場合は、Software エンティティのパス フィールドが実行可能なラッパーを示すように指定すると、tk-multi-launchapp が代わりに実行されます。                    警告: この方法を使用する場合は、ShotGrid で設定された環境変数を保持するよう注意してください。そうしないと、統合が起動しなくなります。    ",
    "url": "/624f2593/",
    "relUrl": "/624f2593/"
  },
  "79": {
    "id": "79",
    "title": "Setup",
    "content": "ShotGrid Isolation Feature Set - SetupIsolation the isolation features are independent of each other, and can be activated independently of each other. Media replication have as pre-requisite for Media Isolation to be implemented.The setup process will depend on which feature you want to activate for your site.In This Section  Planning your Setup  Migration Test Site  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media Replication  Isolation Fine Tuning  MigrationSetup OverviewUnderstand your responsibilitiesMake sure that you understand the client responsibilities and the implication of activating any of the Isolation feature.Start the onboarding processLeveraging the isolation features requires adopters to become AWS users. The features activation also requires Autodesk Support intervention. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering. Kick-start the onboarding process before going further.Planning your SetupBefore you start working on your setup, put a plan in place. Choose the features you need and get the required security/legal approval from your team to get started with the Isolation feature set.Migration Test SiteTo help you setting up the Isolation features without breaking your production environment and to helping smooting the migration to your isolated environment, ShotGrid propose to use a test site on which to test your setup before applying the result to production.Media IsolationThis feature allow you to use a S3 Bucket owned by your studio to store media.Media Traffic IsolationThis feature allows for private routing of the media through the AWS Backbone and your studio network, isolating the media traffic from the public internet.Web Traffic IsolationThis feature isolate the web traffic on AWS Backbone and your studio network, isolating the traffic from the public internet.Media ReplicationThis feature allows the media to be replicated between AWS Regions, for faster access in your world wide studios. Media Isolation is required.Fine TuningOnce the isolation features you need are activated, make sure that you everything is properly configured for security and cost-efficiency by reviewing this fine tuning guide.MigrationOnce everything is ready, it’s now time to migrate your production site to use the isolation features.",
    "url": "/8128c5fb/",
    "relUrl": "/8128c5fb/"
  },
  "80": {
    "id": "80",
    "title": "ShotGrid Desktop は Ubuntu のような Debian システムで動作しますか?",
    "content": "ShotGrid Desktop は Ubuntu のような Debian システムで動作しますか?現在、ShotGrid Desktop では Debian ベースのディストリビューションをサポートしていません。cpio を使用して RPM から ShotGrid Desktop を抽出し、そのライブラリの依存関係を維持して、うまく動作させようとしたクライアントが過去にいましたが、良い結果は得られませんでした。参考として、当社の開発グループで次のスレッドを確認することができます。Python 自体が多くのシステム レベル ライブラリの最上部に配置されているため、ライブラリの依存関係の明示的なリストはありません。現在、Debian をサポートする正式な予定はありません。Ubuntu 向けの開発を行うのには問題があります。変更ごとに追加オペレーティング システムの QA とサポートを更新する必要があり、これが大きな負担になります。ShotGrid Desktop を使用せずに Toolkit を手動で実行して有効にする場合(このドキュメントの説明を参照) - そのドキュメントのページから activate_shotgun_pipeline_toolkit.py スクリプトをダウンロードしてください。ガイドの手順 8 にある「クリックして ShotGrid Pipeline Toolkit アクティベーション パッケージをダウンロード」という見出しをクリックします。",
    "url": "/3830df9d/",
    "relUrl": "/3830df9d/"
  },
  "81": {
    "id": "81",
    "title": "Developing apps",
    "content": "Developing your own appIntroductionThis guide outlines what a Toolkit app is, covers how to create one, and explains some basics around app development.ShotGrid Pipeline Toolkit is not only a collection of apps and engines maintained by ShotGrid Software, it is also a development platform that makes it easy to quickly build custom pipeline tools!  What is a Toolkit app?  Creating your own appSteps:  Creating a development sandbox  Forking or downloading the starter app repository  Adding the app to your config  Developing the app          Anatomy of the Template Starter App      Configuration settings      Frameworks      Reloading your changes        Testing  Preparing your first releaseAdditional info:  Modifying an existing app          Contributing      What is a Toolkit app?A Toolkit app can be defined as follows:  A tool that is usually run by an end-user, using the ShotGrid integrations.  Apps usually have a graphical user interface with which the user can guide the app’s operations, but they don’t have to. An app can also be a command registered with the integrations, triggered by the user from the ShotGrid menu in the host software.  They can have an API/public methods in which other processes or apps could interact.  They can be multi-platform, and software agnostic.  They can be set up to be configured differently per environment.  They can be contextually aware. For example, an app can know the task the user is working on, and act accordingly.  They can only be run from a Toolkit engine.Toolkit apps are initialized by Toolkit engines. Engines are designed to run within a specific software environment, where they then provide an interface from which to run Toolkit apps. The engine abstracts away the complexity of needing to handle the various software environments from the app.This means the app only needs to focus on providing the functionality to fulfill its purpose and doesn’t need to, for example, handle window parenting, keeping track of the user’s context, or providing a shortcut for launching itself.Creating your own app.All apps and engines maintained and released by ShotGrid Software are open source and you can find them in GitHub.This section goes through how to create a new app using our starter template. We assume that you are familiar with GitHub and git workflows, but please note that you can do Toolkit development even if you are not using git as your source control solution.Part 1: Creating a development sandboxBefore you do anything else, we recommend that you set up a development sandbox by cloning the project configuration by cloning your project’s configuration.This will result in a separate configuration where you can develop your code and test changes without affecting anyone else on the production.Part 2: Forking or downloading the starter app repositoryWe provide a template starter app that you can use as a starting point for your own app.By using this app you get all the standard Toolkit boilerplate code set up for you, and a basic example GUI.To use it, you can either fork the git repository and then clone it to your local dev area on disk, or if you don’t want to use git source control at this stage, you can just download the files from GitHub as a zip file, and unzip them locally (you can always set up a git repository later).Either way, the goal is to have a local copy of the starter app code so you can start making changes.Part 3: Adding the app to your configWe recommend reading the “Adding an app” guide, as it explains in more detail how to add an app to your configuration.When adding the app to your config, you need to consider where your app will be used, i.e. perhaps only in Nuke or in multiple different software, or standalone from ShotGrid Desktop.You also need to think about the context that your app will depend on.For example, can your app only run when you know the task the user is working on, or can it run with just the project known?Knowing this will dictate which environment YAMLs and engines you need to add your app settings to.If you’re not sure right now, it’s a good idea to start by adding it to the tk-shell engine in the project environment. That way you can run it from your IDE or via the command line with the tank command if you have a centralized config. This will make it quicker to develop with.To start, use a dev descriptor for the location of your app.tk-multi-starterapp:  location:    type: dev    path: /path/to/source_code/tk-multi-starterappThis instructs Toolkit to load the app code directly from disk in the given location, which is great for development, where you want to change the code all the time.Later when you add the app to your production config, you may want to use a different descriptor.Now you’ve added the app to an environment; you should be able to go ahead and launch it. How you launch it will depend on the engine and environment you defined it in.Part 4: Developing the appYou are now all set to start developing your app!Anatomy of the Template Starter AppThe template starter app contains the following basic structure:  app.py - The app entry point and menu registration can be found in the app.py file. This is where you typically set up your classes, get things initialized, and get menu items registered.  info.yml - Also known as the manifest file. It defines all the different settings that this app requires when it is installed, along with their default values if supplied. Settings are often useful if you want reusable apps and you don’t want to hard code any values in the app itself.  python/app/dialog.py - This contains the logic, event callbacks, etc. that produce the main app window.  python/app/ui - This folder contains the automatically generated UI code and resource file. You don’t edit this directly; instead, you edit the Qt UI file in the resources folder.  resources/ - In the resources folder, the dialog.ui file is a Qt Designer file that you can open up and use to rapidly design and define the look and feel of the app. Once you have made changes, you have to execute the build_resources.sh script, which will convert the UI file to python code and store it as /python/app/ui/dialog.py.  style.qss - You can define QSS (Qt style sheets) for your UI in this file.                    Note: An app doesn’t need to have a UI however, and the minimum requirements for a valid app are an app.py containing an Application class and an info.yml.    Configuration settingsInside the manifest file, there should be a configuration section where you can define app settings.Defining a setting in the manifest file allows you to configure different setting values for your app in the environment YAML files.This is useful if your app needs to behave differently depending on the environment it is in.For example, you may wish to have a setting that defines a template to use when saving a file.save_template:    type: template    default_value: &quot;maya_asset_work&quot;    description: The template to use when building the path to save the file into    allows_empty: FalseCreating a setting for this means you don’t have to hard code the template name in your app code, and can instead get the value from the settings defined either by default in the info.yml or overridden in the environment YAML file settings.template = app.get_setting(&quot;save_template&quot;)This means that you could configure your app to use a different template depending on the environment the app is running in.You can read more on configuration settings in the reference documentation.FrameworksIf you know that you will be using frameworks, you can add them to the manifest file.For example, if you plan to use the Qt Widgets and ShotGrid Utils frameworks for your app, add the following to the info.yml:# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;}Minimum required framework versionsIf there is a required minimum version for a framework, the minimum_version setting can be used in the info.yml:# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;, &quot;minimum_version&quot;: &quot;v1.5.0&quot;}The above will ensure that v1.5.0 of tk-framework-qtwidgets is available for the app to use. If it is not, the app will not be loaded at startup time and an error will be printed to the console. When the app is updated using tank updates, any configured frameworks not meeting their required minimum versions will be automatically updated along with the app.For more information about frameworks and how they can be useful, check out the following links:  The Qt Widgets Framework  The ShotGrid utils FrameworkReloading your changesIf you are testing your app within software such as Maya, then as soon as you have one or more dev items in your configuration, Toolkit will automatically add a Reload and Restart option to the ShotGrid menu.Clicking this will reload your configuration and code and then restart your engine. This means that you can iterate quickly: start Maya once, and then each time you make code or configuration changes that you want to try out, simply hit the Reload and Restart button and your changes will be pulled in.                    Note: If you have any UIs active on screen, these will not automatically update, but you have to go in and re-launch the UIs from the menu.    Part 5: TestingWhen you want to test your code, you can easily invite other users to your dev sandbox by adding them to the User Restrictions field on the PipelineConfiguration entity in ShotGrid. As soon as you have added a user, they will see new entries on their menus inside of ShotGrid Create and the browser actions, as well as an option to pick the configuration inside of ShotGrid Desktop.                    Note: Make sure they have access to see your app code as well, otherwise the app will not load.    Part 6: Preparing your first releaseIn part three you set your configuration to point to your app using a dev descriptor.For released software, you will want to ensure that your app can be accessed by all users and that things are versioned so that they can be upgraded safely and easily.All apps provided by ShotGrid use the Toolkit app store to track updates and releases, and they will have a location tag that looks something like this:location:   name: tk-multi-setframerange   type: app_store   version: v0.1.7This allows Toolkit (for example the tank updates command) to check when updates are available, update and maintain configurations in a very safe way. Whenever the updates command is run and a new version is available, Toolkit will download the code and place it in a local “bundle cache” on disk and ensure that users have access to it.There are a few different options for sourcing your app releases.  Git and GitHub  ShotGrid Uploads  Local pathsIn your production config, you add your app and switch to using the descriptor that suits your needs.Git-based descriptorsWe recommend that you start using source control to make sure that changes are tracked, regardless of if you intend to use a git descriptor.Toolkit supports git (http://git-scm.com/) out of the box, and when running tank updates on a configuration, it can check for the latest release in your git repository and update your configuration, just like with the app store descriptor.The requirements for this are:  Your git repo needs to contain just a single app  Your git repo should have the same structure as the starter app repository.  You use Semantic Versioning when creating your tags. Toolkit will use these version numbers to try to determine which version is the most recent, and by following the convention vX.Y.Z.Once you have created your first tag in git (eg. v1.0.0), you could then set up your config to use a git descriptor that points to your tag.Then you can simply run tank updates, and if new tags have been created, you will be prompted if you want to upgrade. The workflow is now identical to the one which happens with official app store apps.                    Caution: The git descriptor works well with centralized configs, where the caching of apps is usually run by an admin and is stored to a central location where all users can access it. However, if you are using a distributed config, then it may not be as suitable. Your app will be downloaded per user, which means each user will need to have git installed and setup to authenticate with your repo and access the code.    Modifying an existing appRather than starting from an empty starter template, it is sometimes necessary to add a minor feature to an existing app, for example, one of ShotGrid Software’s standard apps. When you work with a modified version of an app, you typically want to ‘track’ against the source app and make sure to regularly pull in changes and bug fixes.When you do this type of development, you pick up the parent code, then apply some of your changes, then release this to your pipeline. Your release effectively consists of the base version of the app PLUS your applied local changes. We recommend that you add a version suffix to the existing version number. This will work seamlessly with Toolkit and is relatively straight forward. The following workflow illustrates how to proceed:  You fork the parent app and create your own repository. With the fork, you get all the git tags. Let’s say the latest tag is called v0.2.12 and the master branch basically equals the contents in this tag.  You apply your changes and commit to your master branch. You now have v0.2.12 PLUS your changes. When you release this to production you need to create a tag. Name the tag v0.2.12.1, to indicate that your code is based on v0.2.12 and it is the first release.  Now someone finds a bug in your modifications. Fix the bug and tag up and release v0.2.12.2.  A number of important bug fixes have been released in the parent repository. Pull them down to your repository. The most recent tag is now v0.2.15 due to releases that have happened in the parent repository. Now merge your changes with master and test. You now basically have parent app v0.2.15 merged with your changes. Tag up v0.2.15.1.The tagging scheme outlined above guarantees that the Toolkit updates work correctly and make it easy to quickly see what code each tag in your fork is based on.ContributingWe love pull requests! If you feel you have made a change that can benefit others, don’t hesitate to feed it back to us as a pull request.We may then fold it back into the main version of the app.Alternatively, add a suggestion for a new idea on our roadmap page.If you’ve made an entire app that your willing to share with the community, let us all know on the forums!",
    "url": "/2e5ed7bb/",
    "relUrl": "/2e5ed7bb/"
  },
  "82": {
    "id": "82",
    "title": "Bootstrapping and running an app",
    "content": "Bootstrapping and running an appThis guide walks you through the process of initializing a Toolkit engine so that you can run custom code or launch apps, also known as bootstrapping.Bootstrapping is useful in situations where a Toolkit engine has not already been started and you need to use the API.For example, you might have a processing script that runs on a render farm and needs to utilize the Toolkit API to handle paths and context.Or you may wish to be able to run your Toolkit app from your favorite IDE.                    Note: If you are using a distributed config, a Toolkit engine must be initialized before running Toolkit API methods. It is possible to use the API without bootstrapping an engine if you are using a centralized config, using the factory methods, however, you will need to manually find the path to the correct core API for your project when importing sgtk.    Requirements  An understanding of Python programming fundamentals.  A project with an advanced configuration. If you haven’t set up a configuration before you can follow the “Getting started with configurations” guide.Steps  Importing the Toolkit API for bootstrapping  Logging  Authentication  Bootstrapping an engine  launching an app  Complete scriptPart 1: Importing the Toolkit API for bootstrappingWhere should I import sgtk from?If you’ve followed the “generating a path and publishing it” guide then you’ll have covered the step of importing sgtk.That guide states that you must import the sgtk package from the project configuration you wish to work with.With bootstrapping, this is still true, however, it doesn’t matter which initial sgtk package you import, as any Toolkit API can perform the bootstrap operation into a different project configuration.The bootstrap process will swap out the currently imported sgtk package for the new project config’s Toolkit API.Downloading a standalone Toolkit core APITo start, you need to import an sgtk API package which is found in tk-core.You could import one from an existing project, however, this might be tricky to conveniently locate.A recommended approach would be to download a standalone copy of the latest core API which will be used purely for the purpose of bootstrapping.You should store it in a convenient place where it can be imported. Make sure that the path you add points to the python folder inside the tk-core folder as this is where the sgtk package is located.Code# If your sgtk package is not located in a location where Python will automatically look# then add the path to sys.path.import syssys.path.insert(0, &quot;/path/to/tk-core/python&quot;)import sgtkPart 2: LoggingIf you are running this script via an IDE or shell, then you will most likely want to enable the logging to be output.To do this you need to run LogManager().initialize_custom_handler().You don’t need to provide a custom handler for this purpose, as not providing one will set up a standard stream-based logging handler.Optionally you can also set the LogManager().global_debug = True to give you more verbose output. This means that any logger.debug() calls in our code or yours will now be output.Logging can have an impact on performance, so you should only enable debug logging when developing, and try to limit the amount of logger.info() method calls to those that are important to have visibility over during normal operation.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = TruePart 3: AuthenticationWhen running a script that uses the Toolkit API outside of an environment where ShotGrid Toolkit has already been started, you will always need to authenticate.So before you can perform the bootstrapping, you need to authenticate the Toolkit API with your ShotGrid site.You can authenticate with user credentials or with script credentials.  If the purpose is to bootstrap for a user-facing process like launching an app, or running some code that will require user input,then user authentication is the best way to go, (This is how all our integrations work by default).  If you’re writing a script to automate something and a user is not present to authenticate then you should use script credentials.Authentication is handled via the ShotGridAuthenticator class.Here is an example of both user and script authentication.User Authentication# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Optionally you can clear any previously cached sessions. This will force you to enter credentials each time.authenticator.clear_default_user()# The user will be prompted for their username,# password, and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating an `Sgtk` instance.sgtk.set_authenticated_user(user)Script Authentication# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)Part 4: Bootstrapping an engineNow that you have authenticated the Toolkit API for the session, you can start the bootstrapping process.You can find a lot of information on the bootstrap API in our reference docs.The bootstrapping process at a high level essentially performs the following steps:  Retrieves or locates the Toolkit configuration folder.  Ensures that the configuration dependencies such as the apps and engines are present in the bundle cache. If they are not present, and they are using cloud-based descriptors such as app_store, or ShotGrid then it will download them to the bundle cache.  Swaps out the current loaded sgtk core for the one appropriate to the config.  Initializes the engine, apps, and frameworks.                    Note: Usually bootstrapping should take care of everything that is needed for that engine to run successfully.However, in some situations, the engine may have specific setup requirements that fall outside of the bootstrap process, and must be handled separately.    Bootstrap PreparationTo bootstrap, you must first create a ToolkitManager instance.mgr = sgtk.bootstrap.ToolkitManager()For Toolkit to bootstrap, it needs to know at least the entity, plugin id, and engine.This guide won’t cover all the available parameters and options, as they are covered in the reference documentation.Plugin IDYou can define the plugin id by passing a string to the ToolkitManager.plugin_id parameter before calling the bootstrap method.In this guide, you will be bootstrapping the tk-shell engine so you should provide a suitable plugin id name following the conventions described in the reference docs.mgr.plugin_id = &quot;basic.shell&quot;EngineIf your goal is to launch an app or run Toolkit code in a standalone python environment outside of software such as Maya or Nuke, then tk-shell is the engine you will want to bootstrap into.If you are wanting to run Toolkit apps within supported Software, then you will want to pick the appropriate engine, such as tk-maya or tk-nuke.This parameter is passed directly to the ToolkitManager.bootstrap_engine() method. See the example in the entity section bellow.EntityThe ToolkitManager.bootstrap_engine() methods entity parameter, is used to set the context and therefore environment for the launched engine.The entity can be of any entity type that the configuration is set up to work with. For example, if you provide a Project entity, the engine will start up in a project context, using the project environment settings.Likewise, you could provide a Task entity (where the task is linked to an Asset), and it will start up using the asset_step.yml environment.This is based on the default configuration behavior, the environment that is chosen is controlled via the core hook, pick_environment.py, and so could be changed to pick a different environment based on the context or other parameters.You need to provide the entity in the format of a ShotGrid entity dictionary which must contain at least the type and id:task = {&quot;type&quot;: &quot;Task&quot;, &quot;id&quot;: 17264}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=task)If you bootstrap into an entity type other than Project, you may need to ensure your path cache is in sync, otherwise, it may not be able to load the environment if, for example, it tries to resolve a template.Since you don’t have an Sgtk instance before bootstrapping, you will need to tell the bootstrap process to perform the synchronization after it’s created an Sgtk instance but before it starts the engine.You can do this by setting the ToolkitManager.pre_engine_start_callback property to point to a custom method.In that method you can then run the synchronization:def pre_engine_start_callback(ctx):    '''    Called before the engine is started.    :param :class:&quot;~sgtk.Context&quot; ctx: Context into        which the engine will be launched. This can also be used        to access the Toolkit instance.    '''    ctx.sgtk.synchronize_filesystem_structure()mgr.pre_engine_start_callback = pre_engine_start_callbackChoice of configurationYou have the choice of explicitly defining which configuration to bootstrap, or leaving the bootstrap logic to autodetect an appropriate configuration.You can even set a fallback configuration in case one is not automatically found.In this guide, we assume that your project has a configuration already setup and that it will be found automatically.BootstrappingOnce all the ToolkitManager parameters have been set, and you call the ToolkitManager.bootstrap_engine() method, it will start the engine, and return a pointer to the engine instance.Here is a recap of the code so far:# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap. mgr = sgtk.bootstrap.ToolkitManager()mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)Part 5: Launching an appNow that you have an engine instance, you’re ready to start using the Toolkit API.Before covering how to launch the app, it’s worth pointing out you can get hold of the current context, Sgtk instance, and ShotGrid API instance via the engine.engine.contextengine.sgtkengine.shotgunWhilst the end goal of this guide is to show you how to launch an app, you could from this point make use of the above attributes and test some code snippets or run some automation that makes use of the Toolkit API.Launching the AppWhen the engine starts, it initializes all the apps defined for the environment. The apps in turn register commands with the engine, and the engine usually displays these as actions in a menu, if running in Software like Maya.Finding the commandsTo first see what commands have been registered, you can print out the Engine.commands property:# use pprint to give us a nicely formatted output.import pprintpprint.pprint(engine.commands.keys())&amp;gt;&amp;gt; ['houdini_fx_17.5.360', 'nukestudio_11.2v5', 'nukestudio_11.3v2', 'after_effects_cc_2019', 'maya_2019', 'maya_2018', 'Jump to Screening Room Web Player', 'Publish...',...]With that list, you can see which commands have been registered and can be run.Running the commandHow you run the command will be different depending on the engine, as there is currently no standardized method.For the tk-shell engine, you can use the convenience method: Engine.execute_command().It expects a command string name, which we listed out earlier, and a list of parameters that the app’s command expects to be passed.if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])If you’re not running in the tk-shell engine, then you can fallback to calling the registered callback directly.# now find the command we specifically want to executeapp_command = engine.commands.get(&quot;Publish...&quot;)if app_command:    # now run the command, which in this case will launch the Publish app.    app_command[&quot;callback&quot;]()Your app should now have started, and if you’re running the tk-shell engine then the output should be appearing in the terminal/console.Part 6: The complete script# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminalsgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing)sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap. mgr = sgtk.bootstrap.ToolkitManager()mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)# Optionally print out the list of registered commands:# use pprint to give us a nicely formatted output.# import pprint# pprint.pprint(engine.commands.keys())if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])",
    "url": "/3d8cc69a/",
    "relUrl": "/3d8cc69a/"
  },
  "83": {
    "id": "83",
    "title": "Developing engines",
    "content": "Developing your own engineIntroductionThis document outlines some of the technical details relating to Toolkit engine development.Table of Contents:  What is a Toolkit engine?  Things to know before you start  Approaches to engine integration          Host software includes Qt, PyQt/PySide and Python      Host software includes Qt and Python but not PySide/PyQt      Host software includes Python      Host software does not contain Python but you can write plugins      Host software provides no scriptability at all        Qt window parenting  Startup behavior  Host software wish listWhat is a Toolkit engine?When developing an engine, you effectively establish a bridge between the host software and the various Toolkit apps and frameworks that are loaded into the engine. The engine makes it possible to abstract the differences between software so that apps can be written in more of a software-agnostic manner using Python and Qt.The engine is a collection of files, similar in structure to an app. It has an engine.py file and this must derive from the core Engine base class. Different engines then re-implement various aspects of this base class depending on their internal complexity. An engine typically handles or provides the following services:  Menu management. At engine startup, once the apps have been loaded, the engine needs to create its ShotGrid menu and add the various apps to this menu.  Logging methods are typically overridden to write to the software’s log/console.  Methods for displaying UI dialogs and windows. These methods are usually overridden, if the way the engine handles Qt is different from the default base class behavior, to ensure seamless integration of windows launched by Toolkit apps and the underlying host software window management setup.  Provides a commands dictionary containing all the command objects registered by apps. This is typically accessed when menu entries are created.  The base class exposes various init and destroy methods that are executed at various points in the startup process. These can be overridden to control startup and shutdown execution.  Startup logic that gets called by the tk-multi-launchapp at launch time, as well as automatic software discovery.Engines are launched by the Toolkit platform using the sgtk.platform.start_engine()  or the sgtk.bootstrap.ToolkitManager.bootstrap_engine() methods. This command will read the configuration files, launch the engines, load all apps, etc.The goal with the engine is that once it has launched, it will provide a consistent Python/Qt interface to the apps. Since all engines implement the same base class, apps can call methods on the engines, for example, to create UIs. It is up to each engine to implement these methods so that they work nicely inside the host software.Things to know before you startwe provide integrations for the most commonly used content creation software.There are also engines that Toolkit Community members have built and shared back. But sometimes you’ll need pipeline integrations for software that doesn’t have a Toolkit engine yet.If you have the time and resources, we encourage you to help the Toolkit Community (and yourselves) in writing a missing engine you would like to use!Before embarking on writing code, talk to us! We can’t promise anything, but we will be happy to discuss your plans with you. We may also be able to connect you to other users who are interested in or have done work on the same engine.If you can, open a channel of communication with a technical contact or developer of the software you are looking to integrate Toolkit into. This helps gain insight into what the possibilities and/or roadblocks are for getting something going. Once you establish a contact and talk through the basics of what you are trying to do, you can bring us into the conversation and set up a meeting with all of us to talk through some of the specifics of the engine.Also, you can engage directly with the Toolkit community in the ShotGrid community forum.We love to see new integrations, and are always eternally grateful for people’s generous contributions to the Toolkit Community!                    Tip: The Developing your own app contains a step by step guide to developing an app, which contains principles that apply to developing an engine as well that are not covered in this guide.    Approaches to engine integrationDepending on what the capabilities of the host app are, engine development may be more or less complex. This section outlines a couple of different complexity levels that we have noticed during engine development.Host software includes Qt, PyQt/PySide, and PythonThis is the best setup for Toolkit and implementing an engine on top of a host software that supports Qt, Python, and PySide is very straight forward. The Nuke engine or the Maya engine is a good example of this. Integration is merely a matter of hooking up some log file management and write code to set up the ShotGrid menu.Host software includes Qt and Python but not PySide/PyQtThis class of software includes for example Motionbuilder and is relatively easy to integrate. Since the host software itself was written in Qt and contains a Python interpreter, it is possible to compile a version of PySide or PyQt and distribute it with the engine.This PySide is then added to the Python environment and will allow access to the Qt objects using Python. Commonly, the exact compiler settings that were used when compiling the shot application must be used when compiling PySide, to guarantee it to work.Host software includes PythonThis class of software includes for example, the third party integration Unreal.These host software have a non-Qt UI but contain a Python interpreter. This means that Python code can execute inside of the environment, but there is no existing Qt event loop running. In this case, Qt and PySide will need to be included with the engine and the Qt message pump (event) loop must be hooked up with the main event loop in the UI. Sometimes the host software may contain special methods for doing precisely this. If not, arrangements must be made so that the Qt event loop runs regularly, for example via an on-idle call.Host software does not contain Python but you can write pluginsThis class includes Photoshop and After Effects.There is no Python scripting, but C++ plugins can be created. In this case, the strategy is often to create a plugin that contains an IPC layer and launches Qt and Python in a separate process at startup. Once the secondary process is running, commands are sent back and forth using the IPC layer.  This type of host software usually means significant work to get a working engine solution.                    Tip: With the Photoshop and After Effects engines we actually created a framework that handles the adobe plugin.  Both engine make use of the framework to communicate with the host software, and it makes it easier to build other engines for the rest of the adobe family.    Host software provides no scriptability at allIf the host software cannot be accessed programmatically in any way, it is not possible to create an engine for it.Qt window parentingSpecial attention typically needs to be paid to window parenting. Usually, the PySide windows will not have a natural parent in the widget hierarchy and this needs to be explicitly called out. The window parenting is important to provide a consistent experience and without it implemented, Toolkit app windows may appear behind the main window, which can be quite confusing.Startup behaviorThe engine is also responsible for handling how the software is launched and its integration is started. This logic will be called when the tk-multi-launchapp tries to launch the software with your engine.You can read more about how this is set up in the core documentation.Host software wish listThe following host software traits can be taken advantage of by Toolkit engines. The more of them that are supported, the better the engine experience will be!  Built-in Python interpreter, Qt, and PySide!  Ability to run code at software startup/init.  Ability to access and auto-run code in two places: once when the software is up and running and once when the UI has fully initialized.  API commands that wrap filesystem interaction: Open, Save, Save As, Add reference, etc.      API commands to add UI elements          Add a custom Qt widget as a panel to the app (ideally via a bundled PySide)      Add custom Menu / Context Menu items      Custom nodes in node-based packages (with an easy way to integrate a custom UI for interaction)      Introspection to get at things like selected items/nodes        Flexible event system          “Interesting” events can trigger custom code        Support for running UI asynchronously          For example, pop up a dialog when a custom menu item is triggered that does not lock up the interface      Provide a handle to a top-level window so custom UI windows can be parented correctly      ",
    "url": "/be19bc87/",
    "relUrl": "/be19bc87/"
  },
  "84": {
    "id": "84",
    "title": "Developing frameworks",
    "content": "Developing your own frameworkIntroductionThis document outlines some of the technical details relating to Toolkit framework development.Table of Contents:  What is a Toolkit framework?  Pre-made ShotGrid frameworks  Creating a Framework  Using Frameworks from hooksWhat is a Toolkit framework?Toolkit frameworks are very similar to Toolkit apps. The main difference is that a framework is not something you would run on its own.Instead, you would import a framework into your app or engine. It allows you to keep reusable logic separate so that it can be used in multiple engines and apps.An example of a framework would be a library of reusable UI components, that might contain a playlist picker component.You could then import that framework in your app, and plug in the playlist picker component to your main app UI.Pre-made ShotGrid frameworksShotGrid supplies some premade frameworks that you may find useful when creating your own apps.The Qt Widgets and ShotGrid Utils frameworks are especially useful in app development.Creating a FrameworkWhen it comes to creating your own framework, the setup is pretty much the same as writing an app, and you can get more information on that in the “Developing your own apps” guide.Instead of an app.py file, a framework has a framework.py at the root of the framework package, that contains a class deriving from the Framework base class.Also, your framework won’t register a command with the engine.Instead, you can either store methods directly on the framework instance itself, or store modules inside the python/ folder.For example, the shotgunutils framework stores them in the python folder.To access them, you would import the framework, and then use the import_module() method, to access the submodules.The API docs contain examples on how to import frameworks.Using Frameworks from hooksIt can be useful to create a framework so that you can share some common logic across hooks.A framework can be used in an app, or other framework hooks, even if the app/framework doesn’t explicitly require it in the manifest file, via theHook.load_framework() method. Note frameworks can’t be used in core hooks even with this method.",
    "url": "/312b792f/",
    "relUrl": "/312b792f/"
  },
  "85": {
    "id": "85",
    "title": "Generating a path and publishing it",
    "content": "Generating a path and publishing itThis guide covers getting started with the ShotGrid Toolkit Python API, which is what our pipeline integrations are built with.The purpose of this guide is to walk through a basic example of how you can use the API, and by the end, you will be able to import the Toolkit API and generate a path and publish it.Requirements  An understanding of Python programming fundamentals.  A project with an advanced configuration. If you haven’t set up a configuration before you can follow the “Getting started with configurations” guide.Steps  Importing sgtk  Getting an Sgtk instance  Getting context  Creating folders  Using a template to build a path  Finding existing files and getting the latest version number  Registering a published file  Pulling it all together into a complete scriptPart 1: Importing sgtkThe Toolkit API is contained in a python package called sgtk. Each Toolkit configuration has its own copy of the API, which comes as part of tk-core.To use the API on a project’s configuration, you must import the sgtk package from the configuration you wish to work with; importing it from a different configuration will lead to errors.                    Note: You may sometimes come across references to a tank package. This is the legacy name for the same thing. While both work sgtk is the correct name to use going forward.    To import the API you need to make sure that the path to the core’s python folder exists in the sys.path.However, for this example, we recommend that you run this code in the ShotGrid Desktop’s Python console.This will mean that the correct sgtk package path is already added to your sys.path.Equally, you don’t need to add the path if you are running this code within software where the ShotGrid integration is already running.When running your code in an environment where ShotGrid is already started you can import the API by simply writing:import sgtkIf you want to use the API outside of a ShotGrid integration, for example, if you’re testing it in your favorite IDE, then you will need to set the path to the API first:import syssys.path.append(&quot;/shotgun/configs/my_project_config/install/core/python&quot;)import sgtk                    Note: If you’re using distributed configs and you want to import sgtk in an environment where Toolkit hasn’t already been bootstrapped, you will need to take a different approach. Please see the bootstrapping guide for more details.    Part 2: Getting an Sgtk instanceIn order to start using the Toolkit API, you’ll need to create an instance of the Sgtk class.Sgtk is a class in the sgtk package that acts as the main interface to the API.Once you create an instance of Sgtk, you will be able to do things like get a context, create folders, or access the templates.As the API documentation states, you don’t create an instance of Sgtk directly. Here are some options for getting an Sgtk instance.      You can get an Sgtk instance from the current engine, if you are running the Python code within an environment where the ShotGrid integrations are already running, (such as the Maya Python console, if Maya was launched from ShotGrid.)The Engine.sgtk property holds the engine’s Sgtk instance.So for example, in Maya, you could run the following:     # Get the engine that is currently running. current_engine = sgtk.platform.current_engine()     # Grab the already created Sgtk instance from the current engine. tk = current_engine.sgtk        You can access the Sgtk instance through the Engine.sgtk property.    Note: The Engine.sgtk property should not be confused with or considered the same as the sgtk package that you imported in part 1.        sgtk.sgtk_from_entity() -  If you are running in an environment where an engine hasn’t already been started, you can use this method to get an Sgtk instance based upon an entity id. The entity whose id you are supplying must belong to the project that the sgtk API was imported from. This doesn’t work with distributed configs, please see the bootstrapping guide for more details.        sgtk.sgtk_from_path() - much like the sgtk_from_entity() except this will accept a path to a configuration or a path to or inside the project root folder, for example, a work file or shot folder. This doesn’t work with distributed configs, please see the bootstrapping guide for more details.  Throughout this guide we will assume you are running this code in an environment where an engine has already been started, so we’ll use option 1.Also you will store the Sgtk class instance in a variable called tk.If you’re using the ShotGrid Python Console then the tk variable is already pre-defined as a global variable.You now have an Sgtk instance and you’re ready to start using the API.Your publish script should now look like this:import sgtk# Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtkPart 3: Getting contextWhat is a context and why do I need it?A lot of what happens in Toolkit revolves around context, in other words knowing what you are working on and being able to act accordingly.With the Toolkit API, you will need to be able to store important details about the entities you are working with, and share them with apps or other processes so they can operate in a contextually aware way.For example, when Toolkit knows what task you’re working on, it can automatically link your published files to that task in ShotGrid.The Context class acts as a container for this information.You can store the Task, Step, entity (such as a Shot or Asset), Project, and current HumanUser within an instance of the class, among a few other things.You can create as many different context objects as you like in a given session. However, when there is an engine present, there is a concept of a single current context, which the engine keeps track of.This is the context that the user is currently working in, and that the apps should be working with.In a later step, you will be using the context to help resolve a path that can be used for saving or copying a file.Acquiring a ContextTo create a context you must use one of the following constructor methods Sgtk.context_from_entity(), Sgtk.context_from_entity_dictionary() or Sgtk.context_from_path().You access these methods through the Sgtk instance you created in the previous step, which you stored in the tk variable.                    Note: To get a context from a path, you must have already created folders, which is covered in the next step of this guide.    Instead of creating a new context however, you could grab the current context from the engine, that you gathered in part 2, like this:context = current_engine.contextSince you will be using the context to help resolve a file path for a Task on a Shot in later steps, you need to be certain the context contains the relevant information.If your code was running as part of a Toolkit app, and your app was configured to only run in a shot_step environment then you could safely assume you would get an appropriate current context.However, for the sake of avoiding ambiguity in this guide, you will create a context explicitly from a Task, (that must belong to a Shot), using the Sgtk.context_from_entity().When you create a context you provide the deepest level required for your operations.For example, you could create a context from a Task and Toolkit will work out the rest of the context parameters for you.context = tk.context_from_entity(&quot;Task&quot;, 13155)If you print out a representation of the context instance you will get something like this:print(repr(context))&amp;gt;&amp;gt; &amp;lt;Sgtk Context:   Project: {'type': 'Project', 'name': 'My Project', 'id': 176}  Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}  Step: {'type': 'Step', 'name': 'Comp', 'id': 8}  Task: {'type': 'Task', 'name': 'Comp', 'id': 13155}  User: None  Shotgun URL: https://mysite.shotgunstudio.com/detail/Task/13155  Additional Entities: []  Source Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}&amp;gt;Even though you only provided the task, it should have filled in the other related details.The publish script should now look like this:import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)Part 4: Creating FoldersToolkit can dynamically generate a folder structure on disk based upon your project entities.This fulfills two purposes.  You get an organized structure created on disk where you can place your files.  It allows Toolkit to programmatically understand your structure, derive context from it, and know where to place files.You need to ensure that the folders exist on disk so that you can resolve the path in a later step.You will use the Sgtk.create_filesystem_structure() method to achieve this:tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])You can use the context object to get the task id to generate the folders.Your code should now look like this:import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task, this Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])You’ve now completed all the preparation steps and are ready to move onto generating a path using a template.Part 5: Using a template to build a pathGenerating the pathWhenever you need to know where a file should be placed or found in Toolkit you can use the templates to resolve an absolute path on disk.Templates are essentially tokenized strings that when you apply the context and other data to, can be resolved into filesystem paths.They are customizable via your project’s pipeline configuration, and their purpose is to provide a standardized method for working out where files should be stored.The first thing you need to do is get a template instance for the path you wish to generate.Using the Sgtk instance you created, you can access the desired Template instance via the Sgtk.templates attribute, which is a dictionary where the keys are the template names, and the values are Template instances.template = tk.templates[&quot;maya_shot_publish&quot;]In this example, you will use the maya_shot_publish template. In the Default Configuration the unresolved template path looks like this:'sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{maya_extension}'The template is made up of keys that you will need to resolve into actual values.Since the context contains enough information for the majority of the keys, you can start by using that to extract values:fields = context.as_template_fields(template)&amp;gt;&amp;gt; {'Sequence': 'seq01_chase', 'Shot': 'shot01_running_away', 'Step': 'comp'}The Context.as_template_fields() method gives you a dictionary with the correct values to resolve the template keys. However, it hasn’t provided values for all the keys. The name, version and maya_extension are still missing.The maya_extension key defines a default value in the template keys section so you don’t need to provide a value for that, although you could if you wanted a value other than the default.Which leaves the name and version. Since the name is a matter of choice, you can either hard code a default or provide an opportunity for the user to enter a value, for example, by popping up an interface.For now, you will hard code both, but in the next step, we’ll cover how to find the next available version number.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1Now you have all the fields, you’re ready to resolve the template into an absolute path using Template.apply_fields():publish_path = template.apply_fields(fields)&amp;gt;&amp;gt; /sg_toolkit/mysite.shotgunstudio.com/my_project/sequences/seq01_chase/shot01_running_away/comp/publish/maya/myscene.v001.maEnsuring the folders existAlthough you ran the folder creation method earlier you may need to perform an additional step to ensure that all the folders exist.This can be required if, for example, your template defines folders that are not present in the schema, and so were not created in the original create_filesystem_structure() call.There are a couple of convenience methods you can use to do this.If, your code is running in a Toolkit app or hook you can use the Application.ensure_folder_exists() method.If, there is an engine present you can use Engine.ensure_folder_exists() method.Or if you’re running code outside of an engine, there’s sgtk.util.filesystem.ensure_folder_exists().Make sure to only create the folders for the directory and not the full file path.You can import the os module and run os.path.dirname(publish_path) to extract the folder portion of the full file path.Creating or copying a file using the pathAt this point you have a path, and you could use this, for example, to tell Maya to save a file there, or perhaps copy the file from a different location. It’s not important for the sake of this guide that you implement any behavior that actually creates a file on disk in that location.You can still publish the path even if there is no file there. However, you can use sgtk.util.filesystem.touch_file() to get Toolkit to create an empty file on disk.Bringing it all together so farimport sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Get a template instance by providing a name of a valid template in your config's templates.yml.template = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folders.current_engine.ensure_folder_exists(os.path.dirname(publish_path))# Create an empty file on disk. (optional - should be replaced by actual file save or copy logic)sgtk.util.filesystem.touch_file(publish_path)The next step is to dynamically work out the next version number rather than hard coding it.Part 6: Finding existing files and getting the latest version numberThere two methods you could use here.  Since in this particular example you are resolving a publish file, you could use the ShotGrid API to query for the next available version number on PublishedFile entities.  You can scan the files on disk and work out what versions already exist, and extract the next version number. This is helpful if the files you’re working with aren’t tracked in ShotGrid (such as work files).While the first option would probably be most suitable for the example in this guide, both approaches have their uses so we’ll cover them both.Querying ShotGrid for the next version number.Using the ShotGrid API and the summarize() method you can get the highest version number amongst the PublishedFile entities, that share the same name and task, and then add 1.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1Searching the file system for the next version number.Using the Toolkit API you can gather a list of existing files, extract the template field values from them, and then figure out the next version.In the example below, it’s gathering the latest version from the work file template. Assuming the work file template and publish file template have the same fields, you could call the method below twice with the same fields to work out the highest publish and work file version and decide using a combination of the two.def get_next_version_number(tk, template_name, fields):    template = tk.templates[template_name]    # Get a list of existing file paths on disk that match the template and provided fields    # Skip the version field as we want to find all versions, not a specific version.    skip_fields = [&quot;version&quot;]    file_paths = tk.paths_from_template(                 template,                 fields,                 skip_fields,                 skip_missing_optional_keys=True             )    versions = []    for a_file in file_paths:        # extract the values from the path so we can read the version.        path_fields = template.get_fields(a_file)        versions.append(path_fields[&quot;version&quot;])        # find the highest version in the list and add one.    return max(versions) + 1# Set the version number in the fields dictionary, that will be used to resolve the template into a path. fields[&quot;version&quot;] = get_next_version_number(tk, &quot;maya_shot_work&quot;, fields)The sgtk.paths_from_template() method will gather all the files on disk that match the provided template and fields.This is method is also useful for scenarios where you want to find and display a list of files to the user.You can chose to use either option, but the guide will use the code from option one however to keep it simple.Part 7: Registering a published fileNow that you have a path you’re ready to publish it. To do this you can use the utility method sgtk.util.register_publish().It is possible to use the ShotGrid API’s ShotGrid.create() method to create a PublishedFile entity as well, but we strongly recommend using the Toolkit API for this as it will ensure all the required fields are provided and filled in correctly.# So as to match the Publish app's default behavior, we are adding the extension to the end of the publish name.# This is optional, however.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)At this point, it’s also worth noting that our Publish app also comes with its own API as well.Although that is still essentially using this same sgtk.util.register_publish() method, it builds upon the publishing process by providing a framework to handle collection, validation, and publishing.Part 8: The complete script# Initialization# ==============import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the tasktk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Generating a Path# =================# Get a template instance by providing a name of a valid template in your config's templates.ymltemplate = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;# Get an authenticated Shotgun API instance from the enginesg = current_engine.shotgun# Run a Shotgun API query to summarize the maximum version number on PublishedFiles that# are linked to the task and match the provided name.# Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the# extension in our filter.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folderscurrent_engine.ensure_folder_exists(os.path.dirname(publish_path))# Creating a file# ===============# This is the bit where you would add your own logic to copy or save a file using the path.# In the absence of any file saving in the example, we'll use the following to create an empty file on disk.sgtk.util.filesystem.touch_file(publish_path)# Publishing# ==========# So as to match publishes created by the Publish app's, we are adding the extension to the end of the publish name.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)                    Tip: By this point, the code is getting a bit long, so a recommended next step would be to tidy it up a bit and break things into methods.    Final ThoughtsThis guide has hopefully left you with a foundational understanding of how to get started with the Toolkit API.There are of course many other uses for the API, so we recommend reading through the tk-core API for more information.Also our forums are an excellent place to discuss API questions and get answers, and even leave feedback for us about the this guide.",
    "url": "/836446f3/",
    "relUrl": "/836446f3/"
  },
  "86": {
    "id": "86",
    "title": "Integrations Developer Guide",
    "content": "Integrations Developer GuidePanelsSee https://github.com/shotgunsoftware/tk-multi-shotgunpanel/tree/master/hooks  for examples of panel actions.Configuring what is being displayedThe values in the detail area and the listings are both configurable through the shotgun_fields hook. You can subclass this hook and change the implementation in order to display the exact values you want.Templating SystemThe hook supports a simple templating language, allowing for great flexibility. It also supports the HTML subset supported by Qt, so you can control color, font size, weight, etc. of your displayed values.The template language works in the following way:      ShotGrid values are enclosed in {brackets}, for example &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}. When this template is rendered, the {description} part will be replaced with the description field value.        If you want an optional pre- or post-fix for a value which is only shown if the value is not empty, you can use the syntax {[Prefix]sg_field[suffix]}. The template {[Start: ]start_date} {[End: ]end_date} will render Start: 12 July 2009 End: 14 July 2012 if both values are populated but Start: 12 July 2009 if end date isn’t set.        You can define fallbacks in the case some values are not set. For ShotGrid Versions, the artist fields takes precedence over the created_by field in order to support a workflow where a producer submits versions on behalf of an artist. In this case, the Version will be created by the producer but the artist field will be set to the artist. This, however, is not always the case - in some cases, artist is left blank in pipelines where artists submit their own work. When displaying versions, it is therefore useful to be able to check the artist field first, and in case this isn’t set, fall back on the created_by field. This is done using the {field1|field2} syntax, for example: Created By: {artist|created_by}. You can combine this with optional fields too, e.g. {[Created By: ]artist|created_by}.  This hook contains the following methods:Controlling items appearing in listsThe get_list_item_definition() method returns a dictionary that controls the appearance of items in the various listings, given a ShotGrid entity type. It returns a dictionary with the keys top_left, top_right and body, for example:{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}Controlling the top detail areaThe get_main_view_definition() method returns a dictionary with the keys title and body given a ShotGrid entity type. These values controls the appearance of an object in the detail area, for example:{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}Controlling the fields shown in the Info tabThe get_all_fields() methods returns a list of fields to display for a given entity when this is rendered in the Info tab.Configuring ActionsActions are little snippets of code that operate on a piece of ShotGrid data. Examples include:  An action that launches RV for a given ShotGrid Version  An action that allows a user to assign herself to a given Task  An action that loads a ShotGrid publish into Maya as a Maya reference.The actual payload of an action is defined in an  action hook. Once you have defined the action logic, you can then map that action to ShotGrid objects in the app configuration. These action mappings may for example look like this:action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}In the above example, we use the actions reference, import, texture_node, assign_task and play_in_rv. We then map the actions to various ShotGrid objects and conditions. For example, we are requesting the import action to appear for all publishes of type Maya Scene.When an object is loaded into the Panel, the action configuration above is read in and analyzed. A list of suitable actions for the current object is determined and the generate_actions() hook method will be executed. ShotGrid data for the given entity will be passed to the hook at this point so that the hook code can determine if the action can be run for this particular ShotGrid object. This is a way to allow each hook to run a check prior to being displayed. For example, the play_in_rv hook may only be relevant in the case there is media available locally - the action mappings set up in the configuration tells the panel which actions to enable for a given ShotGrid entity but they may not all be displayed because the generate_actions() method may determine that they are not suitable for the given object.The actions returned from the generate_actions() method will be displayed on the actions menu and when a user clicks on it, the execute_acton() hook method is called to run the action.For each application that the panel supports, there is an actions hook which implements suitable actions. For example, with something like Maya, the default hook will implement reference, import and texture_nodeactions, each carrying out specific Maya commands to bring publishes into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.The panel uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app’s hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/panel/maya_actions.py. This will tell Toolkit to use a hook called hooks/panel/maya_actions.py in your configuration folder.For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks like this:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot; Returns a list of action instances for a particular object. The data returned from this hook will be used to populate the  actions menu. The mapping between ShotGrid objects and actions are kept in a different place (in the configuration) so at the point when this hook is called, the app has already established *which* actions are appropriate for this object. This method needs to return detailed data for those actions, in the form of a list of dictionaries, each with name, params, caption and description keys. Because you are operating on a particular object, you may tailor the output  (caption, tooltip etc) to contain custom information suitable for this publish. The ui_area parameter is a string and indicates where the publish is to be shown.  - If it will be shown in the main browsing area, &quot;main&quot; is passed.  - If it will be shown in the details area, &quot;details&quot; is passed. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :param actions: List of action strings which have been defined in the app configuration. :param ui_area: String denoting the UI Area (see above). :returns List of dictionaries, each with keys name, params, caption and description &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot; Execute a given action. The data sent to this be method will represent one of the actions enumerated by the generate_actions method. :param name: Action name string representing one of the items returned by generate_actions. :param params: Params data, as specified by generate_actions. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :returns: No return value expected. &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}By deriving from the hook as shown above, the custom hook code only need to contain the actual added business logic which makes it easier to maintain and update.PublisherThe Publish app is highly customizable by way of hooks that control how items are presented to artists for publishing and how those items are then processed.The full developer documentation for the publisher app can now be found on the  Toolkit Developer Site.For more information on how to use the Publish app, see the User Guide. If you are looking for more information about the first generation Publisher, please visit the classic Publisher docs.LoaderSee https://github.com/shotgunsoftware/tk-multi-loader2/tree/master/hooks for examples of load actions.Advanced functionalityShotGrid Toolkit makes it easy to develop toolsDid we mention that you can write your own Apps? Each Engine exposes a consistent interface based on Python and PySide, so you can write a single App that works in both Nuke, Photoshop and 3dsmax. With the Core API functionality, there is no need to build a big pipeline stack for the studio - instead focus dev resources on solving production problems. Reusing tools between projects is easy with our Toolkit - if file naming conventions or other requirements are changing, simply reconfigure the app. Roll out tools safely via the Toolkit’s built-in Git and Github support and quickly hot-load your code when doing development. Work in your own Dev Sandbox and invite TDs and early adopters to test your code without having to roll it out to everyone on the project.",
    "url": "/93c6e555/",
    "relUrl": "/93c6e555/"
  },
  "87": {
    "id": "87",
    "title": "How to Submit Integrations Fixes",
    "content": "How to Submit Integrations FixesWe welcome contributions from the Toolkit community! If you have a potential fix for a bug you’ve discovered or have implemented a feature you think we should include, we welcome you to follow the guidelines below in order to sent it through the right channels.Talk to UsWe encourage you to talk to us about what you want to develop or fix. We may have information that will help steer you in the right direction, or prevent you from doing a lot of unnecessary work. Most importantly, we love talking to our users about what they want to build, how they use Toolkit, and how we can make it more awesome.Fork the Repo from GithubMost of the Toolkit engine, app, and framework code is developed in the public on Github. Fork the repo you’re modifying from Github to your local environment.Make Your ChangesDo your development work locally in a branch and test it out in your own environment to the point you feel confident that it’s ready to submit to us. Try and match the style of the existing codebase. Keep your changes focused on your purpose. For example, if you’re fixing a bug in 3 lines of code, don’t try and modify whitespace issues throughout the file. That will make the Toolkit gremlins angry.Comment!Make sure you add detailed comments about what it is you’re doing any why you’re doing it. Keep in mind, there will be other people like you who may fork this repo later and will need to understand what your code does and why. Be clear, but don’t over-comment either. :)TestRemember that other users will have a wide variety of environments and variables in play that may not match what you have at your studio. Toolkit tries to minimize the impact of these types of things for users but there are always things that could be different in other users’ environments. Some examples:  Will your code work the same on OS X, Windows, and Linux?  Will it work in all supported versions of a Software?  Will it work the same whether the user launches from a terminal, SG Desktop, ShotGrid, or perhaps their own custom app?Create a Pull RequestOnce you’re ready, push your changes back to Github and create a pull request. Your pull request should be detailed, explain what your code does, and why the changes are required. When writing this up, think about the user who is coming into this with very little knowledge about this area of code. The public will see your pull request and other users will be happy to understand your well written description!Then What?We will review your pull request when we have time in our sprint. It’s very likely we’ll comment and ask questions about your code or use case. We may kick back the request and ask you to make changes. Don’t be offended! We love contributions but also have deep knowledge about how things will work. We are in this code every day so we don’t expect everyone to submit perfect code.Once we review it, if we accept your pull request, we’ll queue it for QA and then it will be merged into our repo and released at some point. The timeline can vary depending on a lot of factors. Please be patient.We may also politely turn down your pull request. Again, please don’t be offended. We appreciate your efforts and contribution. There can be any number of factors that contribute to this. But if you follow the guidelines above, hopefully this won’t happen.",
    "url": "/924c14e8/",
    "relUrl": "/924c14e8/"
  },
  "88": {
    "id": "88",
    "title": "How do I work with authentication and login credentials in custom scripts?",
    "content": "How do I work with authentication and login credentials in custom scripts?Error MessageIf you’re seeing an error like the one below coming from your script, then it means your script is not authorized to talk to your ShotGrid site.tank.errors.TankError: Missing required script user in config '/path/to/your/project/config/core/shotgun.yml'If user authentication or script authentication is not provided up front, then Toolkit falls back to checking credentials have been defined in the config’s shotgun.yml file.Defining credentials in your shotgun.yml file is the old method of handling authentication.You should avoid defining them in the shotgun.yml file, and instead use one of the approaches detailed below:User-facing scriptsIf the script is user-facing, you can add this at the beginning, before creating a Sgtk instance:# Import the Toolkit API so we can access Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either programmatically or, in this# case, interactively.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Optionally clear the current user if you've already logged in before.authenticator.clear_default_user()# Get an authenticated user. In this scenario, since we've passed in the# CoreDefaultsManager, the code will first look to see if there is a script_user inside# shotgun.yml. If there isn't, the user will be prompted for their username,# password and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating a Sgtk instance.sgtk.set_authenticated_user(user)## Add your app code here...## When you are done, you could optionally clear the current user. Doing so# however, means that the next time the script is run, the user will be prompted# for their credentials again. You should probably avoid doing this in# order to provide a user experience that is as frictionless as possible.authenticator.clear_default_user()If QApplication is available, you’ll get something akin to this:                    Note: If you are importing a Toolkit API (sgtk package) that isn’t associated with a configuration, for example one that you have downloaded to use to bootstrap into a different configuration, then you shouldn’t attempt to create a CoreDefaultsManager. Instead, create a ShotgunAuthenticator() instance without passing a defaults manager.authenticator = ShotgunAuthenticator()    Non-user-facing scriptsIf the script is not user-facing, like on a render farm or in the event handler, you can add this at the beginning, before creating a Sgtk/Tank instance:# Import Toolkit so we can access to Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either interactively or, in this# case, programmatically.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Create a user programmatically using the script's key.user = authenticator.create_script_user(    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;)# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)                    Note: As noted at the end of the user facing scripts section, you shouldn’t create a defaults manager if the sgtk package you imported is standalone/isn’t from a configuration. Also you should provide the host kwarg to the create_script_user() method:user = authenticator.create_script_user(    host=&quot;https://yoursite.shotgunstudio.com&quot;,    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Shotgun site&amp;gt;&quot;)    ",
    "url": "/724152ce/",
    "relUrl": "/724152ce/"
  },
  "89": {
    "id": "89",
    "title": "プロジェクト間でアセットを共有するにはどうすればいいですか?",
    "content": "プロジェクト間でアセットを共有するにはどうすればいいですか?他のプロジェクトのショットにロードできるアセットを含むアセット ライブラリとして使用されるプロジェクトを指定するのは珍しくありません。これを実現するには、このアセット ライブラリ プロジェクトのアセットをリストするLoader アプリにタブを追加します。このためには、作業しているエンジンと環境のローダー設定でこのタブを定義する必要があります。このタブは複数の場所で更新する必要があります。たとえば、ショットのステップ環境の Maya エンジンにこのタブを追加するには、次のスニペットを追加します。caption: Asset Libraryhierarchy: [project, sg_asset_type, code]entity_type: Assetfilters:- [project, is, {'type': 'Project', 'id': 207}]207 をライブラリ プロジェクトの ID と置き換えます。Maya のショットのステップ環境で作業している場合、このプロジェクトで使用可能なすべてのパブリッシュを表示する新しいタブが追加されます。他のエンジンのローダーにこのタブを追加する場合(Nuke や 3dsmax)、各エンジンで tk-multi-loader2 設定を変更する必要があります。他の環境でこの設定を有効にする場合は、アセットのステップ環境と設定する他の環境で同じ手順を実行する必要があります。手間が少しかかりますが、詳細に制御できるようになります。これらの設定を使用すると、Loader アプリで一般的なプロジェクトのパブリッシュをリストするタブを表示できます。",
    "url": "/2088a677/",
    "relUrl": "/2088a677/"
  },
  "90": {
    "id": "90",
    "title": "概要",
    "content": "ShotGrid の開発プロダクション管理では、すべての個別の要素を同期させる必要があるため、多大な労力を必要とします。データに直接接続するには、ShotGrid REST API または Python API を使用します。反復的なタスクを自動化するにはイベント トリガ フレームワーク、ShotGrid の Web インタフェースからアプリを直接起動するにはアクション メニュー アイテムを使用します。独自のサービスまたは許可されたユーザ用のサービスを基に動作する、または一緒に動作するサービス、アプリケーション、モジュール、およびコンポーネントを独自に開発するには、ShotGrid API を使用することをお勧めします。                    認証キー: オートデスクからユーザのみなさまにお願いしたいことは、API 情報を開示しないこと(および許可されたユーザに開示を許可しないこと)ことのみです。ユーザは API 情報に含まれている認証キーなどを使用することで、ログオンしなくても、サービスやその機能にアクセスできるようになります。また、ログオンすることなくサービスまたはその機能にアクセスできる権限を、API を使用して自分自身に与えることや、ユーザに与えることも行わないでください。    ",
    "url": "/6dfa5d53/",
    "relUrl": "/6dfa5d53/"
  },
  "91": {
    "id": "91",
    "title": "Migration Test Site",
    "content": "ShotGrid Migration Test SiteActivating the isolation feature set is an intrusive procedure that can have an impact on the usability of your site. To prevent a production stopping event, we require clients to follow an approach where the configuration is first validated on a test site, before being applied to the production site.The ShotGrid team will create a temporary site to be used as a Proof of Concept for your ShotGrid Isolation deployment. Upon the successful completion of the setup process, your existing ShotGrid site can be migrated to your ShotGrid Isolation environment.If your Migration Test Site has not been created yet, please reach out to our Support team through your Zendesk ticket or your dedicated on-boarding Slack Channel.Next StepsOnce you have your test site, you can the implementation of the feature you need.See Media Isolation for activating the Media Isolation feature.See Web Traffic Isolation for activating the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/0bbe0010/",
    "relUrl": "/0bbe0010/"
  },
  "92": {
    "id": "92",
    "title": "Isolation Features",
    "content": "Isolation Feature SetThe isolation feature set is an hybrid solution that satisfies strict security and legal requirements, while minimizing ShotGrid System Admin specific required knowledge and maintenance. These features enable creative studios to confidently meet their supplier’s and studio’s highly stringent security, privacy, and performance requirements—from the cloud.Continue to About the isolation feature set for more details.Go to Setup if you are ready to activate the Isolation features.In This SectionGetting Started  About Isolation  Client Responsibilities  Onboarding Process  Planning your SetupFeatures Description  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media ReplicationSetup  Setup Overview  Migration Test Site  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media Replication  Isolation Fine Tuning  MigrationAWS Knowledge  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/f378a164/",
    "relUrl": "/f378a164/"
  },
  "93": {
    "id": "93",
    "title": "3ds Max",
    "content": "3dsMaxThe ShotGrid engine for 3dsMax contains a standard platform for integrating ShotGrid Toolkit (Sgtk) Apps into 3dsMax. It is light weight, straight forward and adds a ShotGrid menu to the main menu.",
    "url": "/bb1266cb/",
    "relUrl": "/bb1266cb/"
  },
  "94": {
    "id": "94",
    "title": "After Effects",
    "content": "After EffectsThe ShotGrid engine for After Effects provides a platform for integrating ShotGrid into your After Effects workflow. It consists of a standard ShotGrid Toolkit engine and relies on the tk-framework-adobe (CEP).Once enabled, a ShotGrid Adobe Panel panel becomes available in After Effects. It displays information about the current ShotGrid context as well as the commands that are registered for the apps installed in that context.Interface OverviewThe ShotGrid extension panel uses the same color palette and basic layout as native After Effects panels. It is comprised of five components:  Context Header - Thumbnail and fields for the current context.  Favorites Shelf - Designed to show the most commonly-used apps for the current context.  Command List - All non-favorited commands for the current context.  Context Menu - Additional context-related commands and debugging tools.  Logging Console - A console overlay that displays logging output for debugging.InstallationInstallation of the ShotGrid Engine for After Effects follows the same protocol as the other ShotGrid integrations. For information on installing engines and apps, see the Administering Toolkit article. In addition, you can reference the default toolkit config as an example of how to configure the integration.Enabling the extensionOnce the extension is installed, it will need to be launched via the extensions menu in After Effects.This will only need to be done once and the ShotGrid extension panel can remain in the After Effects layout without having to be enabled on subsequent launches.Once enabled, and on future launches, the extension panel will display a loading screen while the ShotGrid integration is bootstrapping.This screen typically displays for a few seconds before the current context is determined and the commands are displayed.Interface componentsThe following sections outline the components of the ShotGrid After Effects integration.Context headerThe context header is a customizable area which can display information about the current ShotGrid context.The context is determined by the currently-active document. Once the context is determined by the engine, the header will update to display the context’s thumbnail field detail. The field information is controlled by a hook. For information on how to customize the field display, see the Context Fields Display Hook section below.It should also be noted that the context switching will only be recognized in if ShotGrid open was used.Favorites shelfThe favorites shelf is similar to the menu favorites available in other ShotGrid DCC integrations such as Maya and Houdini. This section of the interface makes the most commonly used Toolkit apps readily available and easy to find just under the context header.The shelf displays the favorited commands as buttons that, when moused over, transition from grayscale to color and display their name in the label at the top. Tooltips for the buttons will show by hovering the mouse above them.Clicking one of the buttons will trigger the callback for the registered command to execute.For details on how to specify command favorites, see the Shelf Favorites section below.Command listThe command list shows the other “regular” commands that are registered for the current context.Typically, apps installed within a pipeline configuration will register one or more commands that are displayed here. If the commands are not identified as favorites, and are not identified as context-menu commands, they will display here.The command list buttons behave in a manner similar to those in the favorites shelf. The only real difference is that they display as a list with the full name to the right of their icon.Context menuAny commands registered as context menu commands will show in the ShotGrid extension panel’s context menu.Like the other command areas, these commands will change along with the context. Commands such as Jump to ShotGrid and Jump to Filesystem will always be available here.Logging consoleThe logging console shows all of the logging output from both the CEP Javascript interpreter and Toolkit’s Python process.If there are any issues with the extension that require support, the logging console output is extremely useful for helping the ShotGrid support team debug the problem.Configuration and technical detailsThe following sections outline some of the more technical aspects of the integration to help configure the integration to the specific needs of your studio pipeline.PySideThe ShotGrid engine for After Effects relies on PySide. Please see the official instructions for Installing PySide.CEP extensionThe extension itself is bundled with the engine and the engine handles installation automatically on the first launch of After Effects. The extension is installed on the artist’s local machine in the standard, OS-specific CEP extension directories:# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Each time After Effects is launched, the engine bootstrap code will check the version of the extension that is bundled with the engine against the version that is installed on the machine. This means that after an engine update, assuming a new version of the extension came with it, the installed extension will be automatically updated to the newly-bundled version.Configuring favoritesThe Favorites Shelf can be configured to display any of the registered commands for your installed apps. To do this, simply add the shelf_favorites setting to the tk-aftereffects section of your environment configuration. Here’s an example:shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}The value of the setting is a list of dictionaries identifying a registered command provided by one of the installed apps in the configuration. The app_instance key identifies a particular installed app and the name key matches the command’s display name registered by that app. In the example above, you can see four favorited commands: the file open and save dialogs from the tk-multi-workfiles2 app as well as the standard Toolkit publish and snapshot dialogs. These four commands will now show in the favorites shelf.Environment variablesTo aid in debugging, there are a set of environment variables that change some of the engine’s default values:  SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - The Python heartbeat interval in seconds (default is 1 second).  SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - The number of heartbeat errors before quitting (default is 2). The legacy environment variable  SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE is also respected if set.  SHOTGUN_ADOBE_NETWORK_DEBUG - Include additional networking debug messages when logging output. The legacy environment variable  SGTK_PHOTOSHOP_NETWORK_DEBUG is also respected if set.  SHOTGUN_ADOBE_PYTHON - The path to the Python executable to use when launching the engine. If not set, the system Python is used. If Photoshop is launched from a Python process, like ShotGrid Desktop or via the tk-shell engine, the Python used by that process will be used by the Photoshop integration.Note: Additional environment variables exist in the Adobe Framework. For details, please see the developer documentation.Context fields display hookThe engine comes with a hook to control the fields displayed in the Context Header section of the panel. There are two methods in the hook that can be overridden to customize what is displayed.The first method is the get_entity_fields() method. This method accepts an entity type representing the current ShotGrid context. The expected return value is a list of fields for that entity that should be queried for display. The engine itself handles querying the data asynchronously.Once the data has been queried from ShotGrid, the second method in the hook is called. This method, get_context_html(), receives the context entity dictionary populated with the queried fields specified by the get_entity_fields() method. The expected return value is a string containing formatted HTML to display the queried entity fields.The default hook implementation is a good reference as to what is required by these methods.It should be noted that the engine will always display the entity thumbnail if one is available.Import Footage HookThe engine comes with a hook to control the import behaviour of certain file types. One may want that a psd file will be imported as single layer instead of a composition. In this case the this hook may be used to overwrite this behaviour.The default hook implementationAfter Effects APIPlease see the developer documentation for details on the After Effects API.",
    "url": "/1eca509c/",
    "relUrl": "/1eca509c/"
  },
  "95": {
    "id": "95",
    "title": "Alias",
    "content": "AliasThe ShotGrid engine for Alias contains a standard platform for integrating ShotGrid Apps into Alias. It is lightweight and straight forward and adds a ShotGrid menu to the Alias menu.Information for App DevelopersPySideThe ShotGrid engine for Alias uses a PySide installation shipped with the ShotGrid Desktop and will activate this whenever this is necessary.Alias Project ManagementWhenever the ShotGrid engine for Alias starts, it will set the Alias Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the Alias project is set based on a file can be configured in the configuration file, using the template system.Working with tk-aliasThis ShotGrid integration supports the Alias application family (Concept, Surface, and AutoStudio).When Alias opens, a ShotGrid menu (the Alias engine) is added to the menu bar.File Open and SaveUse the My Tasks and Assets tabs to see all your assigned tasks and browse for assets. To the right, use these tabs to view all files, working or published files associated with what is selected to the left.SnapshotOpens the Snapshot dialog to create a quick backup of the current scene.PublishOpens the Publish dialog for publishing the file to ShotGrid, which can then be used by artists downstream. For more information, see Publishing in Alias. LoaderOpens the Content Loader app, allowing you to load data into Alias. For more information see Loading in AliasScene BreakdownOpens the Breakdown dialog, which displays a list of referenced (WREF References) content, along with what in the scene is out-of-date. Select one or more items and click Update Selected to switch and use the latest version of the content. For more information see Scene Breakdown in Alias",
    "url": "/8229b689/",
    "relUrl": "/8229b689/"
  },
  "96": {
    "id": "96",
    "title": "Desktop",
    "content": "DesktopThe tk-desktop engine is an application to let you easily run your Toolkit apps. It is a system tray based window that makes it easy to get started with Toolkit, setup Projects for Toolkit, and access your Projects’ pipeline.Site configuration and Project configurationWhen you launch the desktop application, it will startup the tk-desktop engine for your site configuration.  This configuration is usually automatically managed, although it is possible to disable that behavior and take control over what is in that environment.One of the fundamental principles of Toolkit is that projects can be completely isolated from each other.  This is usually done to make sure that changes made to one project cannot adversely effect another project (possibly nearing delivery). In order to offer this project isolation, the desktop engine makes sure that whenever you are looking at the commands for a particular project, you will run them in a separate python interpreter that has been initialized just for that project.When you click on a project, a python interpreter is launched in the background. This python interpreter is the one the project has been configured to use and on startup will initialize the tk-desktop for that project.  That instance of the engine will communicate back to the GUI what commands it can launch.When you click on a command, that background python process is responsible for launching the command.  This makes it possible (for example) to have one project running python 2.6 while testing python 2.7 on another project.Registering custom panelsToolkit apps which have panel based UI will be automatically docked in tabs inside of Desktop when they execute.If you have a panel based app such as the ShotGrid Panel, and want it to appear as a tab in ShotGrid Desktop, just configure it to run at startup. When Desktop starts up in its site context mode (where it displays all projects), it will launch all items registered to auto start. If any of these items are panels, these will get docked. Items will be processed in the order they are defined in the configuration and this will dictate the tab order.For example, if you wanted the ShotGrid Panel to show as a tab in ShotGrid Desktop, add the following configuration for your site level environment:tk-desktop:  apps:    tk-multi-shotgunpanel:      actions_hook: ...      action_mappings: ...      location: ...  location: ...  run_at_startup:  - {app_instance: '', name: Apps}  - {app_instance: tk-multi-shotgunpanel, name: ''}Please note that the special Apps entry controls where (in the tab order) the default Apps tab should appear.",
    "url": "/75097ed0/",
    "relUrl": "/75097ed0/"
  },
  "97": {
    "id": "97",
    "title": "Flame Export",
    "content": "Flame ExportThe ShotGrid Flame Export App helps kickstart your project!Once you have created an initial conform in Flame, the Shot Exporter can help you quicklygenerate content in ShotGrid, render out plates to disk and send content to review.Once you are up and running, the exporter app will also track all the renders happening in Flare or in Flame batch mode, making it easy to send content to review as part of your workflow.Pushing a conform to ShotGridOnce you have your conform set up in Flame for a sequence, and have allocated shot names to all the segments in your timeline, select the sequence, right click and choose the ShotGrid Shot Export option.This will bring up a ShotGrid UI where you can enter some initial comments for your publish. These comments will be sent to review and also used when adding description to publishes and other content.In addition to the description, you can also select which output data format you want to use for your exported plates. These presets are part of the toolkit app configuration and can be configured to suit the needs of your studio.Once you click the submit button, a number of things will happen straight away:      Shots and Tasks will be created in ShotGrid. The list of tasks to associate with each new Shot that gets created is configurable via a Task template setting to make it quick and painless to create consistent structures. The shots will be parented under a sequence by default, but this is also configurable and if you are working with Scenes or Episodes, it is possible to reconfigure the exporter to work with these instead.        Once ShotGrid contains the right data, folders will be created on disk using the standard folder creation mechanism. This ensures that the project can be kick-started with a set of consistent folders for all shots that are being created.  Once the two steps above have been carried out, you have the basic structure to proceed with further steps. These will happen in the background:      Plates will be exported on disk for each shot according to the presets defined in your configuation. File locations are defined using the Toolkit Template system, meaning that the location of these plates will be well defined and understood by other tools downstream in the pipeline.        Batch files and clip xml files will be exported. These are used by Flame to enable an iterative workflow where you can quickly render out new versions that are later pulled in to the main conform in Flame.        Quicktimes are generated and uploaded to ShotGrid for review.  Sending batch renders to ReviewOnce you have published a Flame batch file for a Shot, you can launch Flare directly from that Shot in order to open up the batch file with render and output settings pre-populated. In order to render out a new version, simply click the Render Range Button.Toolkit will display a dialog at this point where you can choose to send the render to ShotGrid review or not.Files will be published and tracked by ShotGrid and optionally also sent to review.Want to learn more?If you want to learn more, and see this workflow in action, head over tothe Flame engine documentation where we also have some video content that demonstrates the various workflows in action.LINKBOX_ENGINE:ShotGridsoftware/tk-flame:The Flame EngineAs always, if you have question regarding integration or customization, don’t hesitate to visit our support site.Advanced TopicsBelow you’ll find more advanced details relating to configuration and customizationUsing export presetsThe exporter uses a concept of Export Presets in its configuration. When you launch the Export UI inside of Flame you see a dropdown with the available export presets. Each preset is a configuration option which allows you to configure how files are written to disk and uploaded to ShotGrid. High level settings such as file locations on disk are controlled directly in the environment configuration, making it easy to adjust the default configuration options to work with your pipeline.More advanced settings and control over the actual export xml content that is being passed to flame in order to control Flame, is handled by a hook where the behaviour is defined for each preset. In the hook, you have complete control over how media is being generated by the exporter.Bypassing ShotGrid server side transcodingBy default, Quicktimes are uploaded to ShotGrid review by setting the Version.sg_uploaded_movie field. This in turn will trigger ShotGrid server side transcoding; the uploaded quicktime will be further converted to mp4 and webm representations tailored for playback in browsers and mobile. Sometimes, it can be beneficial to bypass this server side transcoding. This is possible by setting the bypass_shotgun_transcoding configuration setting. When this is set to true, the integration will upload directly to the Version.sg_uploaded_movie_mp4 field in ShotGrid, thereby bypassing the server side transcoding. In this case, no webm version is generated, so review playback will not be possible in Firefox.For more information, see https://support.shotgunsoftware.com/entries/26303513-TranscodingCustomizing ffmpegWhen the exporter generates quicktimes, it uses a version of ffmpeg which comes distributed with Flame. By modifying the settings hook in the exporter, you can specify an external version of ffmpeg to use instead of the built-in one. The version of ffmpeg distributed with Flame is tracking the very latest advancements in ffmpeg transcoding and performance, so sometimes using the latest version may result in performance improvements.Please note that the way h264 parameters are passed to ffmpeg has changed between the version that is used by default and the latest versions. By switching to the latest generation of ffmpeg, it is possible to implement exactly the recommended transcoding guidelines that results in optimal upload and performance on the ShotGrid side. You can find these guidelines here:https://support.shotgunsoftware.com/entries/26303513-TranscodingWe only recommend changing the ffmpeg version if you are an advanced user. In that case, follow these steps:Copying the settings hookAll settings that need to be modified can be found in the settings hook that comes shipped with the Flame export app. In order to modify this hook, you first need to copy this hook file from its default location inside the app location into your configuration. Inside your project configuration, you’ll typically find the hook file in a location similar to install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py. Copy this file into the hooks location inside of your configuration, e.g. config/hooks. We recommend renaming it to something a little more verbose than just settings.py in order to make it clear what it is:install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py -&amp;gt; config/hooks/flame_export_settings.pyNow edit your Flame environment configuration file. This is typically config/env/includes/flame.yml. Under the tk-flame-export heading, you’ll find the path to the hook being defined as settings_hook: '{self}/settings.py'. This essentially means that the configuration will look for the hook file inside the app location (e.g. {self}). Changing this to settings_hook: '{config}/flame_export_settings.py' will tell Toolkit to look for the hook file inside the configuration instad. In summary:settings_hook: '{self}/settings.py' -&amp;gt; '{config}/flame_export_settings.py'Modifying the hookNow we are ready to start modifying our config/hooks/flame_export_settings.py hook! Open it up in a text editor. You’ll notice several methods relating to ffmpeg and ffmpeg settings. The first one to modify is the following:def get_external_ffmpeg_location(self):    &quot;&quot;&quot;    Control which version of ffmpeg you want to use when doing transcoding.    By default, this hook returns None, indicating that the app should use    the built-in version of ffmpeg that comes with Flame.    If you want to use a different version of ffmpeg, simply return the path    to the ffmpeg binary here.    :returns: path to ffmpeg as str, or None if the default should be used.    &quot;&quot;&quot;    return NoneBy returning None by default, the exporter will use Flame’s built-in ffmpeg. Change this to return a full path to your ffmpeg. Keep in mind that if you are running a backburner cluster, ffmpeg may be called from any machines in the cluster, so make sure the executable is installed everywhere.Now that once the ffmpeg location is updated, you most likely either need or want to tweak the parameters passed to ffmpeg. This needs to be changed in two different methods:      get_ffmpeg_quicktime_encode_parameters will return the parameters used when generating a quicktime to be uploaded to ShotGrid.        get_local_quicktime_ffmpeg_encode_parameters will return the parameters used when a quicktime is written to disk.  For the ShotGrid upload, we recommend using the default ShotGrid encoding settings as a starting point:def get_ffmpeg_quicktime_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -vf 'scale=trunc((a*oh)/2)*2:720' -g 30 -b:v 2000k -vprofile high -bf 0&quot;For the local ShotGrid transcode, we recommend basing your settings on the ShotGrid transcode settings but removing the resolution constraints and increasing the bit rate:def get_local_quicktime_ffmpeg_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -g 30 -b:v 6000k -vprofile high -bf 0&quot;",
    "url": "/04a6342b/",
    "relUrl": "/04a6342b/"
  },
  "98": {
    "id": "98",
    "title": "Flame Review",
    "content": "Flame ReviewThe ShotGrid Flame Review App makes it easy to push one or more sequences from Flame into ShotGrid review.Simply right click a sequence or a selection of sequences that you want to review:Select the ShotGrid Review Option:A Toolkit UI will appear where you can add some review notes:When you click ok, a background job will be generated and everything will happen behind the scenes.The following steps will be carried out:      The Sequence will be exported to disk as a quicktime. This export is handled as a Flame Quicktime export and you have complete control of the various settings via a configuration hook.        Once the sequence is complete, Toolkit will check if there is a matching Sequence in ShotGrid. If not, a Sequence will be created automatically.        A review version will be generated and associated with the sequence.        Lastly, the quicktime will be uploaded to the review version.  The process supports audio tracks, transitions etc and should be a “what you see is what you get”. Once in ShotGrid, you can review the media in many different ways, including the client review site and the ShotGrid iPhone app.Customization and SettingsThe Flame Review app can be customized in a couple of different ways:      You can control which Entity Type that should be used in ShotGrid to represent a Sequnce in Flame. For example, if you are working on episodic content, it may make more sense to link your review versions to episodes in ShotGrid rather than sequences.        You can customize which tasks the app should automatically add to new items created in ShotGrid. This is done via a task template setting and allows you to standardize the structure that’s created.        Via a hook, you get complete control over the xml preset that the app uses to generate a quicktime out of Flame.  ",
    "url": "/b38dc286/",
    "relUrl": "/b38dc286/"
  },
  "99": {
    "id": "99",
    "title": "Flame",
    "content": "FlameInstallationThe ShotGrid engine for Flame relies on new integration hooks that were added in Flame 2015 Extension 2.  This version of Flame must be used in order for the engine to function.  For more info on Flame 2015 Extension 2 (including how to get it), reach out to Flame Support.The simplest way to get started with the ShotGrid engine for Flame is to set up a new test project with our example pipeline configuration. You can do this by launching the ShotGrid Desktop, running the Project Setup for a new project and choosing the default Flame configuration (in the default configurations section).Flame Project SetupThe ShotGrid engine for Flame also helps associate the ShotGrid project with a Flame project, and creates it if need be.  This is key to the integration, as it ensures data from Flame gets associated with the right things in ShotGrid.  As an added feature, the engine provides functionality for managing the naming conventions of Flame projects as well as the other various settings for the project.When Flame is launched via ShotGrid for the first time, a Flame project creation UI will appear that lets the artist edit the usual settings from the standard Flame project creation screen:But with the ShotGrid integration, the settings can be pre-populated with pipeline-friendly values, helping artists quickly get the right thing without having to think about it.  The defaults can be customized via the project_setup_hook, which supports the following options:use_project_settings_uiIf set to True, the project creation UI will appear.  If False, the Flame project will automatically be created based on the rest of the defaults in the hook.get_server_hostnameBy default this is set to ‘localhost’, but it can be overridden if desired.get_project_nameBy default this is set to the same value as the ShotGrid project, but it can be overridden if desired.get_volumeBy default this is set to the first available storage, but it can be overridden if desired.get_workspaceBy default Flame will create a default workspace according to its standard workspace creation logic, but it can be overridden if desired.get_userThis will try to associate the user logged into the Flame machine with a user in ShotGrid.get_project_settingsThis is where the main Flame settings are configured and the hook helps build the Flame project XML stream.  The following parameters must be supplied:  FrameWidth (e.g. 1280)  FrameHeight (e.g. 1080)  FrameDepth (16-bit fp, 12-bit, 12-bit u, 10-bit, 8-bit)  FieldDominance (PROGRESSIVE, FIELD_1, FIELD_2)  AspectRatio (4:3, 16:9, or floating point value as string)Proxy settings can also be supplied.  For more info, see the Autodesk Wiretap SDK docs!To view the entire codebase for the project_setup hook, please see our Github repo for the engine.",
    "url": "/d5d7b724/",
    "relUrl": "/d5d7b724/"
  },
  "100": {
    "id": "100",
    "title": "Admin UI",
    "content": "Toolkit Admin UI FrameworkThe Admin UI Framework implements a place that holds standard user interfaces that wrap Toolkitadministrative commands.Currently the only interface is for the setup_project command.SetupProjectWizard API ReferenceThis is a QWizard implementation that walks somebody through setting up a Projectfrom their ShotGrid instance for Toolkit.  To use the wizard, simply create aninstance of the class, passing in the project to setup (as a standard ShotGrid APIentity dictionary) and the window to parent to.adminui = sgtk.platform.import_framework(&quot;tk-framework-adminui&quot;, &quot;setup_project&quot;)setup = adminui.SetupProjectWizard(project, parent)dialog_result = setup.exec_()This will run the wizard and return a standard QDialog Accepted or Rejected value.SetupProjectWizard ConstructorInitialize a SetupProjectWizard.  This is a subclass of QtGui.QWizard.SetupProjectWizard()",
    "url": "/02fa2cba/",
    "relUrl": "/02fa2cba/"
  },
  "101": {
    "id": "101",
    "title": "Desktop Server Framework",
    "content": "Toolkit Desktop Server FrameworkThe desktopserver framework provides the functionality behind ShotGrid’s local file linkingand Toolkit integration.  It provides a local websocket server that securely listens forrequests from ShotGrid websites for an action that requires desktop access.For local file linking, these requests allow ShotGrid access to local file paths from the web interface and the ability to open those files directly from ShotGrid pages when requested. For Toolkit, they allow ShotGrid to determine what pipeline actions have been registered for a given entity and to execute them.How to get desktop integration runningFor these ShotGrid features to work, some supported desktop integration must be running.This page covers the various options for howShotGrid can integrate with your desktop.  The Websocket Server section covers the functionality thatthis framework provides.ShotGrid DesktopThis framework is bundled with ShotGrid Desktop, which can be downloaded here. When ShotGrid Desktop is run it will automatically start up the websocket server.  If you are already running ShotGrid Desktop then your setup process is complete.Configuring the serverYou can store the browser integration settings in a configuration file. This configuration file can be specified by setting the environment variable SGTK_BROWSER_INTEGRATION_CONFIG_LOCATION. More details on how you can configure the local server can be found in our sample file.Removing a certificateIf you wish to remove a certificate you have created, you can run the python certificates.py --remove command.Launching via a wrapperBy default, the server will use the operating-system default to launch a command (the equivalent of“xdg-open” on Linux, “open” on OS X, and “run” on Windows). If you wish to provide your own wrapper forlaunching files you can set the SHOTGUN_PLUGIN_LAUNCHER environment variable to point to yourcustom wrapper. If that is set, the wrapper will be called with the path as its only argument.CertificatesThe first time you run the server it will generate the certificate required to establish a secure connection. These certificates are stored local to your machine and are never shared with the public.They allow the encrypted connection that websockets requires, which is necessary despite all traffic remaining local (from your browser to the server); ShotGrid’s websocket traffic is never made available over the Internet.When the certificates are registered with the system you will see dialogs appear like the following.Click “Ok” to allow the registration to proceed.When using the ShotGrid Desktop, the generated certificates will be stored in the following locations:OS X: ~/Library/Caches/Shotgun/desktop/config/certificatesWindows: %AppData% Shotgun desktop config certificatesLinux: ~/.shotgun/desktop/config/certificatesSecurity Setup - Local ShotGrid InstallsBy default, the websocket server is setup to listen to hosted ShotGrid sites on port 9000.If you run a local ShotGrid server, you will need to update the configuration for the ShotGrid server to allow connections from your websocket server.When running ShotGrid Desktop, you will need to setup a config.ini file that lives with theShotGrid binary.  There are detailed instructions for where this file needs to livehere.Within that file there is a section that controls the functionality of the websocket server.A typical configuration would look like this:[BrowserIntegration]low_level_debug=0port=9000enabled=1whitelist=*.shotgunstudio.comTroubleshootingOn Linux the server introduces a dependency on libffi.  If Desktop crashes on startup and you see a message about libffi not found in your logs, then you need to install this package.Visit our support site if you have any issues or questions during setup.  If there is a problemrunning the server, please set debug to 1 in the config.ini file and include Desktop’s logfile.The log file can be found in the following locations:OS X: ~/Library/Logs/Shotgun/tk-desktop.logWindows: ~ %APPDATA% Shotgun tk-desktop.logLinux: ~/.shotgun/tk-desktop.log",
    "url": "/c79f1656/",
    "relUrl": "/c79f1656/"
  },
  "102": {
    "id": "102",
    "title": "Desktop Startup",
    "content": "Toolkit Desktop Startup FrameworkThe Desktop Startup framework implements the startup logic of the ShotGrid Desktop. Its main function is to:  initialize the browser integration  log the user in  download Toolkit  configure the site configuration  auto update itself and the site configuration when necessary  launch the tk-desktop engine.  This is an internal Toolkit framework and therefore the interface it implements is subject to change. We advise that you do not use this framework in your projects.Locking-down the startup logic  Note, this requires the ShotGrid Desktop app version 1.3.4. If you are unsure of your application version, launch the ShotGrid Desktop. Once you are logged in, click on the user icon at the bottom right and click About.... The App Version should be 1.3.4 or greater.By default, ShotGrid Desktop downloads tk-framework-desktopstartup updates locally on the user’s machine and uses it during the launch sequence of the application. When you launch the application, Toolkit automatically checks for updates to the framework. If an update is available, it will also download and install it automatically.Alternately, you can configure the ShotGrid Desktop to use a specific copy of the framework instead of using the local copy. This will disable the auto-update function and you will now be responsible for updating your the startup logic. In order to be kept up to date with updates, we suggest you subscribe to this page.Download a specific release from GitHubYou will need to download updates from GitHub manually. The bundles can easily be downloaded from the Releases page and you can find more information about each official release here.Configure the ShotGrid Desktop to use a specific copyThe only way to lock down the startup logic is to use an environment variable. By setting SGTK_DESKTOP_STARTUP_LOCATION to the root folder of a copy of the framework, you will tell the ShotGrid Desktop to use this copy of the code when starting up. Once the variable is set, you can launch the ShotGrid Desktop and it will use this specific copy of the startup logic.  Note that as of this writing the Startup Version field in the About... box will be Undefined when locking the startup logic due to a technical limitation.Reverting to the old behaviourTo revert back your changes, simply unset the environment variable and launch the ShotGrid Desktop.",
    "url": "/3414fbb3/",
    "relUrl": "/3414fbb3/"
  },
  "103": {
    "id": "103",
    "title": "Hiero/Nuke Studio Export",
    "content": "Hiero/Nuke Studio ExportIntroductionThis app adds ShotGrid awareness to Hiero’s export dialog for sequences.Overview Video &amp;amp; DemoIf you’re new to ShotGrid Toolkit or the Hiero integration, check out the following video which gives a fast-paced overview of what you can do in your pipeline with the ShotGrid Toolkit Hiero integration.If you’re already familiar with Toolkit and Hiero, then feel free to continue on to the docs below.ShotGrid Shot ProcessorWhen this app activates itself it registers a bunch of changes with the Hiero export dialog:The first thing to notice is the new processor that is registered:When you click on this processor, there are some new things to notice.At the top of the dialog, there is extra UI that helps control how shots get created/updated in ShotGrid as a result of exporting the sequence:TagsBy adjusting the dropdowns you can map various Hiero tags into ShotGrid shot statuses and shot task templates.  Thus via Hiero’s tagging workflow you can set a ShotGrid shot to being in progress or setup the tasks for the Shot for a green screen, cg extra, or whatever makes sense for your configuration.  This UI is populated via a hook and is easy to configure for extra functionality.CollatingThere are also options to control collating track items together that mirror Hiero’s built in logic.  If you have multiple items that make up a shot (either overlapping, on different tracks or with the same shot name on multiple tracks) then you should turn these options on. This will cause the ShotGrid Toolkit Shot updater to treat the matching collated items as a single Shot.For example, assume we have two track items representing shots 010 and 020. 010 comes first and 020 overlaps with the end of 010 on a different track. Since 010 comes first, it’s the hero and with collating enabled, ShotGrid treats the two items as a single shot, 010. This means Shot 010 will be created or updated in ShotGrid. The cut in will match the beginning of track item 010 and the cut out will match the end of track item 020. A Screening Room-ready Version will be created for each item, but both will be linked to Shot 010. A plate will be created for each item as a Published File but both will be linked to Shot 010. A single Nuke script will be published linked to Shot 010 containing 2 read nodes, one for each item. Note that in this situation, there is no creation or update to Shot 020 in ShotGrid, since it has been collated into Shot 010.PathsBelow the ShotGrid UI is the standard paths dialog.  There are three items that are added to Shots via Hiero by default… a default Nuke script, a default Nuke write location, and a default location for a plate transcode.  The locations of these items are determined by the app configuration and can make full use of the templating system:This app adds a {tk_version} token to Hiero which will be replaced by the version string, correctly formatted for ShotGrid Toolkit.Custom Template FieldsAny tokens you define in the custom_template_fields setting that are resolved by the resolve_custom_strings hook will automatically be added to Hiero’s list of valid replacement tokens and will be considered valid replacements in your Toolkit template paths.For example, in your Toolkit templates.yml file, say you define a key with the following:    resolution:         type: str         filter_by: alphanumeric  In your project.yml settings for tk-hiero-export you have:  ...  ...  tk-hiero:    apps:      tk-hiero-export:        custom_template_fields:        - {description: Shot Resolution, keyword: resolution}  ...  ...And then you modify the resolve_custom_strings hook with something like the following:# Copyright (c) 2014 ShotGrid Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights# not expressly granted therein are reserved by ShotGrid Software Inc.from tank import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    RESOLUTION_TOKEN_NAME = &quot;{resolution}&quot;    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        &quot;&quot;&quot;        self.parent.log_debug(&quot;attempting to resolve custom keyword: %s&quot; % keyword)        if keyword == self.RESOLUTION_TOKEN_NAME:            translated_value = self._clip_resolution_string(task)        else:            raise RuntimeError(&quot;No translation handler found for custom_template_field: %s&quot; % keyword)        self.parent.log_debug(&quot;Custom resolver: %s -&amp;gt; %s&quot; % (keyword, translated_value))        return translated_value    # Handle the {resolution_fs} token     def _clip_resolution_string(self, task):         &quot;&quot;&quot; returns sequence resolution or task format override&quot;&quot;&quot;         width = &quot;&quot;         height = &quot;&quot;        sequence_format = task._sequence.format()        width = sequence_format.width()         height = sequence_format.height()        if &quot;reformat&quot; in task._preset.properties():             task_reformat_settings = task._preset.properties()[&quot;reformat&quot;]             if task_reformat_settings['to_type'] != &quot;None&quot;:                 width = task_reformat_settings['width']                 height = task_reformat_settings['height']        return &quot;%sx%s&quot; % (width, height)You can now not only use the resolution token in Hiero but it will validate against any template paths you have defined in Toolkit so you can export to a location like:    hiero_plate_path: &quot;sequences/{Sequence}/{Shot}/hiero_plates/{resolution}/v{version}/{project}_{Shot}.mov&quot;ShotGrid TasksThere are two new task types registered.ShotGrid Transcode ImagesThis is a subclass of the standard Hiero transcoding task, which will register the results of the transcode as a Publish in ShotGrid.  Optionally a Version will also be created in ShotGrid.  If a Version is created, then a Quicktime will also be created and uploaded as Screening Room media.ShotGrid Nuke Project FileThis is a subclass of the standard Hiero Nuke script exporter, which registers the resulting Nuke script as a PublishedFile in ShotGrid linked to the Shot. The settings allow you to specify which Toolkit-enabled WriteNodes to include in the file on export.The app settings plate_published_file_type and nuke_script_published_file_type allow you to control what file type the PublishedFiles are registered as. In addition, nuke_script_toolkit_write_nodes allows you to control which WriteNode settings should be available in the export dialog.Export processWhen the export is run, there will be some extra tasks that show up in the export queue:Each shot will run a ShotGridShotUpdater tasks that is responsible for creating the Shot in ShotGrid and creating the full Shot structure specified in the schema configuration:Sequence and Shot updates in ShotGridThe name of the Hiero sequence will be used for the sequence name, and theshots will have their cut info filled in (Cut Order, Head In, Cut In, Cut Out,Tail Out, Cut Duration, and Working Duration).  In addition if poster frameswere selected for the sequence or the items that make up the shot, they will beuploaded as the thumbnails for the shots.If your workflow uses an entity other than Sequence as the shot parent(like Episode), then you can override the get_shot_parent method in thehook_get_shot hook. The default implementation creates (if necessary) andreturns a Sequence.Cut Schema SupportIf your ShotGrid site supports the Cuts schema (v7.0.0 or later), then this appwill automatically generate a Cut with corresponding CutItems inShotGrid.  The Cut entity corresponds to the Hiero sequence and theCutItems correspond to the items in the sequence. The Cut will belinked to the parent entity (Sequence by default) as returned by theget_shot_parent method in the hook_get_shot hook. The CutItems will beassociated with a Shot entity and linked to the reviewable Versioncreated during the export. After exporting, the Cut will be playable in theMedia tab in ShotGrid and in RV.All of the meta data associated with the Cut and CutItem entities isinferred from Hiero except the Cut Type field which can be specified in theexport UI.The value here will show up in the Type field of the Cut.It should be noted that the Cut schema is not supported when either of theCollate options are selected, and creation of Cut and CutItem entrieswill be skipped.In addition, the Cut schema does not handle retimed clips. A debug warning will be logged when exporting retimed clips.Alternate Shot HierarchiesFor studios that don’t work in the standard Sequence &amp;gt; Shot hierarchy, but  perhaps use Episodes and/or Scenes,  there is a hook hiero_get_shot that allows you to configure the app to work with whatever Shot hierarchy is in use at your studio.",
    "url": "/523d3720/",
    "relUrl": "/523d3720/"
  },
  "104": {
    "id": "104",
    "title": "Hiero/Nuke Studio Open in ShotGrid",
    "content": "Hiero/Nuke Studio Open in ShotGridThis app adds a context menu to the Hiero spreadsheet and timeline that allows you to open a given track item in ShotGrid if there is a Shot for that item.You typically configure this app by adding it to the time line and spreadsheet menus in Hiero by adding the following to the ShotGrid Engine for Nuke configuration:    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}",
    "url": "/88ae1c1d/",
    "relUrl": "/88ae1c1d/"
  },
  "105": {
    "id": "105",
    "title": "Houdini Alembic Node",
    "content": "Houdini Alembic NodeThe Houdini Alembic Node App provides a custom ShotGrid Alembic Output node which makes it easy to standardise the location where alembic files are output.  It can be configured for each environment.General UseIn order to use the ShotGrid Alembic Output, save your script as a Toolkit work file first and then create a new node via the TAB menu in Houdini. This will create a node which looks similar to a normal Alembic output node:The node can be configured with multiple output profiles, each using a different template path for where the alembic cache should be written to disk.Rather than entering a path by hand, you just specify which output profile to use and the node will compute the rest of the path automatically. You can see the computed path in the UI.The output alembic files will be versioned and the version number will always follow the current Houdini scene file version which will be incremented automatically when you publish using Multi Publish.ConfigurationThe Toolkit alembic node provides the ability to specify multiple output profiles for an environment configuration. Here’s an example of configuring the node with multiple profiles:  tk-houdini:    apps:      tk-houdini-alembicnode:        location:           name: tk-houdini-alembicnode          type: app_store          version: v0.2.2        work_file_template: houdini_shot_work        default_node_name: tk_alembic_out        output_profiles:          - name: For Publishing            settings: {}            color: [1.0, 0.5, 0.0]            output_cache_template: houdini_shot_work_alembic_cache          - name: Local Testing            settings: {}            color: [0.0, 0.5, 1.0]            output_cache_template: houdini_shot_local_alembic_cacheYou can use the output profiles to alter the look of the node via the color field, and you can adjust individual parms on the underlying Alembic node by supplying key/value pairs matching those parms in the settings field. Finally, the output_cache_template field drives the output path for the alembic cache written to disk.",
    "url": "/55f75584/",
    "relUrl": "/55f75584/"
  },
  "106": {
    "id": "106",
    "title": "Houdini Mantra Node",
    "content": "Houdini Mantra NodeThe Houdini Mantra Node App provides a custom ShotGrid Mantra Output node which makes it easy to standardise the location where render files are output.  It can be configured for each environment.General UseIn order to use the ShotGrid Mantra Node, save your script as a Toolkit work file first and then create a new node via the TAB menu in Houdini. This will create a node which looks similar to a normal Mantra output node:The node can be configured with multiple output profiles, each using a different set of template paths for where the render output (images, ifd, dcm, aov, etc) should be written to disk.Rather than entering a path by hand, you just specify which configuration to use and the node will compute the rest of the path automatically. You can see the computed path in the UI.The rendered files will be versioned and the version number will always follow the current Houdini scene file version which will be incremented automatically when you publish using Multi Publish.ConfigurationThe Toolkit mantra node provides the ability to specify multiple output profiles for an environment configuration. Here’s an example of configuring the node with multiple profiles:  tk-houdini:    apps:      tk-houdini-mantranode:        location:           name: tk-houdini-mantranode          type: dev          version: v0.2.2        default_node_name: tk_mantra_out        work_file_template: houdini_shot_work        output_profiles:          - name: Primary Render            settings: {}            color: [1.0, 0.5, 0.0]            output_render_template: houdini_shot_render            output_ifd_template: houdini_shot_ifd            output_dcm_template: houdini_shot_dcm            output_extra_plane_template: houdini_shot_extra_plane          - name: Local Render            settings: {}            color: [0.0, 0.5, 1.0]            output_render_template: houdini_shot_local_render            output_ifd_template: houdini_shot_local_ifd            output_dcm_template: houdini_shot_local_dcm            output_extra_plane_template: houdini_shot_local_extra_planeYou can use the output profiles to alter the look of the node via the color field, and you can adjust individual parms on the underlying Alembic node by supplying key/value pairs matching those parms in the settings field. Finally, the output_*_template fields drive the output paths for the files written to disk by the mantra renderer.",
    "url": "/2c47f879/",
    "relUrl": "/2c47f879/"
  },
  "107": {
    "id": "107",
    "title": "Houdini",
    "content": "HoudiniThe ShotGrid Engine for Houdini contains a standard platform for integrating ShotGrid Apps into Houdini.Information for App DevelopersSupported platformsThe ShotGrid Engine for Houdini is currently supported on Windows, Linux, and OSXPySideFor older versions of Houdini (13 and older) an external build of PySide is required. On Windows, we have bundled a compatible PySide build that will work with the python that Houdini runs. On Linux, Houdini uses the system python (per http://www.sidefx.com/docs/houdini12.0/hom/) which needs to have PySide or PyQt support.Menu loadingA dynamic menu system was introduced by Side Effects as of Houdini 15, so the engine now supports rebuilding of the ShotGrid menu on context switches.In Houdini 14 and older, the ShotGrid menu in Houdini is generated before Houdini starts and is static throughout the session. Due to this, the toolkit commands registered in the menu will not update on context changes.ShotGrid shelfRelease v0.2.4 introduced a dynamic ShotGrid shelf to the engine. The shelf displays any registered app commands as tool buttons. The buttons will be displayed in roughly the same order as the menu commands.Use the enable_sg_shelf setting to turn on the shelf within an environment. If using a version of Houdini (14 or older) that does not support dynamic menus, you may also want to turn off the ShotGrid menu when using the shelf. This can be done by setting the enable_sg_menu setting to false.To enable context switching via the shelf, you’ll also need to add entity types to the sg_entity_types setting of the tk-multi-workfiles app in your engine configuration.Here’s a look at the settings related to the ShotGrid shelf:tk-houdini:  apps:    # ... other app definitions    tk-multi-workfiles:       # ... other app settings       sg_entity_types: [Shot, Asset] # allow context switching to Shots or Assets       # ... other app settings  enable_sg_shelf: true  enable_sg_menu: false  # ... other engine settingsOnce you’ve enabled the ShotGrid shelf, you need to manually add it to a shelf set inside houdini.Once added to a shelf set the ShotGrid shelf will remain there between houdini sessions and will update dynamically as your ShotGrid context changes.PanelsAs of v0.2.8 the engine adds support for embedded toolkit panels.The panel support currently requires Houdini version 15.0.272 or later for proper embedded panels. Registered panels will show up as panes in the pane  menu for supported versions of Houdini.Older versions of Houdini will display the registered panels as dialogs. SESI may backport some bug fixes to newer builds of Houdini 14. If and when that happens, we will make embedded panels work for those versions as well.Apps with OTLsThe ShotGrid Engine for Houdini makes it easy to load application supplied OTLs. If you are writing an app which uses OTLs, you can just drop them into a folder called otls and the engine will automatically load them into your session:You can then easily access your nodes via the usual Houdini methods.Warning!! Please note that while the use of OTLs may be convenient, it is typically NOT the right solution if you want to create nodes that persist in a scene. The reason for this is because as soon as you have put an OTL in the scene, you have introduced a dependency between that scene and the OTL code. Not only will you need to load the ShotGrid Toolkit every time you load the scene, but you also need to carefully manage your code so that any updates to the code does not break old OTLs being used in scenes.Startup Debugging via Terminal on OSXTurning on debug_logging for the tk-houdini engine on OS X will not send all debug messages to the Terminal. This is because, by default, the tk-multi-launchapp app uses the open command to launch executables. This does not spawn a new subprocess from the Terminal, but rather uses OS X’s Launch Services to create a new process elsewhere. As a result, the log statements are not shown. Even having a python shell saved in the user’s default desktop in houdini does not seem to show debugging statements during startup. After startup, and embedded Python shell will show debug logging statements, but there is a gap in available output during startup. If you need access to debug logging statements during engine startup, you can make 2 changes.First, change your houdini_mac path (temporarily) in your test configuration to point to the executable inside the Houdini app bundle. For example:#houdini_mac: /Applications/Houdini 15.0.272/Houdini Apprentice.apphoudini_mac: /Applications/Houdini  15.0.272/Houdini  Apprentice.app/Contents/MacOS/happrenticeNext, you can make a copy of the tk-multi-launchapp app’s app_launch hook in your test configuration’s config/hooks directory and point to it in your config/env/includes/app_launchers.yml file:launch_houdini:  defer_keyword: ''  engine: tk-houdini  extra: {}  hook_app_launch: app_launch    # &amp;lt;----- use a custom app_launch hook  hook_before_app_launch: default  icon: '{target_engine}/icon_256.png'  linux_args: ''  linux_path: '@houdini_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.6.6}  mac_args: ''  mac_path: '@houdini_mac'  menu_name: Launch Houdini  versions: []  windows_args: ''  windows_path: '@houdini_windows'Then all you have to do is modify the launch logic to launch the executable directly. As an example, you could keep the old behavior for directories (application bundles) and otherwise execute the command directly. Here’s an example:        elif system == &quot;darwin&quot;:            # on the mac, the executable paths are normally pointing            # to the application bundle and not to the binary file            # embedded in the bundle, meaning that we should use the            # built-in mac open command to execute it            if os.path.isdir(app_path):                cmd = &quot;open -n  &quot;%s &quot;&quot; % (app_path)                if app_args:                    cmd += &quot; --args  &quot;%s &quot;&quot; % app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;)            # not a directory, execute directly            else:                cmd = &quot;%s %s&quot; % (app_path, app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;))The next time you run launch_houdini via tank in the Terminal, you should get all the debug output. Once you’re done testing, don’t forget to revert your path and undo your app launch changes. Happy debugging!",
    "url": "/797202da/",
    "relUrl": "/797202da/"
  },
  "108": {
    "id": "108",
    "title": "Mari Project Manager",
    "content": "Mari Project Manager",
    "url": "/82aaf735/",
    "relUrl": "/82aaf735/"
  },
  "109": {
    "id": "109",
    "title": "Mari",
    "content": "MariThe ShotGrid engine for Mari contains a standard platform for integrating ShotGrid Toolkit Apps into Mari. It is light weight and straight forward and adds a ShotGrid menu to the main menu.",
    "url": "/301f5e66/",
    "relUrl": "/301f5e66/"
  },
  "110": {
    "id": "110",
    "title": "Maya",
    "content": "MayaThe ShotGrid engine for Maya contains a standard platform for integrating ShotGrid Apps into Maya. It is lightweight and straight forward and adds a ShotGrid menu to the Maya menu bar.Maya Project ManagementWhenever the ShotGrid engine for Maya starts, it will set the Maya Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the maya project is set based on a file can be configured in the configuration file, using the template system.",
    "url": "/9e62da4a/",
    "relUrl": "/9e62da4a/"
  },
  "111": {
    "id": "111",
    "title": "Motion Builder",
    "content": "Motion BuilderThe ShotGrid engine for Motion Builder contains a standard platform for integrating ShotGrid Toolkit Apps into Motion Builder. It is light weight and straight forward and adds a ShotGrid menu to the main menu.",
    "url": "/54009c12/",
    "relUrl": "/54009c12/"
  },
  "112": {
    "id": "112",
    "title": "About",
    "content": "AboutThis app gives a graphical breakdown of the current work area and all the apps running in the current environment. You can find it on the Context Menu:Reload all appsThere is a handy button this app that reloads the entire environment. This is useful if you are doing development and have made some code changes you want to try out! No need to restart Maya or Nuke, just hit the reload button!In addition to the reload feature, this apps shows a breakdown of your current work area and all the apps that are currently loaded.Three separate views exist:Current Work AreaThis shows the current Shot or Asset, the current Task etc. If you double click any of the items in the list, the system will open the ShotGrid Detail page for that item.Running AppsA view of all the currently running apps, along with their version and description. Double clicking an app will launch the documentation page for that app.Current EnvironmentA view of the currently loaded environment file and engine. This can be useful for debugging purposes 🎀",
    "url": "/c542e4dd/",
    "relUrl": "/c542e4dd/"
  },
  "113": {
    "id": "113",
    "title": "Breakdown",
    "content": "BreakdownThe Scene Breakdown app shows you a list of referenced content and tells you which items are out of date. You access it from the ShotGrid Menu.You can select one more more items and hit update selected. This will switch the items to use the latest version of the content.Scanning the SceneWhen the breakdown app scans the scene for references, it will call a special scanning hook. The scanning hook will return a list of nodes with file corresponding paths. For each reference it finds, it returns the file path, and tank will look at the file path and first check if it recognizes it as a publish, and if it does, see if there is a more recent version available.If the user clicks the update button that is shown for outdated versions, the app will call another hook to do the actual update work. This means that by customizing these hooks it is relatively simple to add new custom nodes to the breakdown.Accessing ShotGrid DataIf you need to access ShotGrid data for the publish you are about to update to in the hook, this is straight forward; a single call to find_publish will retrieve metadata for all the items passed in from the app, like this:class BreakdownHook(Hook):    def update(self, items):        &quot;&quot;&quot;        Perform replacements given a number of scene items passed from the app.        Once a selection has been performed in the main UI and the user clicks        the update button, this method is called.        The items parameter is a list of dictionaries on the same form as was        generated by the scan_scene hook above. The path key now holds        the that each node should be updated *to* rather than the current path.        &quot;&quot;&quot;        engine = self.parent.engine        # resolve ShotGrid data for all paths passed via the items dictionary        sg_data = tank.util.find_publish(engine.sgtk,                                         [i[&quot;path&quot;] for i in items],                                         fields=[&quot;id&quot;, &quot;code&quot;, &quot;version_number&quot;])        for i in items:            node_name = i[&quot;node&quot;]            node_type = i[&quot;type&quot;]            new_path = i[&quot;path&quot;]            # now that each item is processed, it is easy to access the            # ShotGrid data via a dictionary lookup:            sg_data = sg_data.get(i[&quot;path&quot;])            # once we have all our desired info and metadata, we can go ahead            # and apply the update business logic.            # [-business logic here-]API AccessYou can access the breakdown app programatically using its API. The following methods exist:Showing the breakdown UIapp_object.show_breakdown_dialog()If you want to show the breakdown UI, execute the show_breakdown_dialog() method. Assuming the app is included under a tk-multi-breakdown section in your currently running environment, this could for example be done like this:&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; e = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; e.apps[&quot;tk-multi-breakdown&quot;].show_breakdown_dialog()Running the scene analysisitems = app_object.analyze_scene()You can programmatically run the scene analysis logic by executing the analyze_scene() method. This executes exactly the same logic that the breakdown UI uses when it builds the listing of scene items.The method returns a list of breakdown items. Each item is represented by a dictionary with a number of keys to describe the item. Only files whose path corresponds to a template in the Toolkit templates file will be detected. Files do not need to exist as publishes in ShotGrid, however if they do, this method will return basic ShotGrid publish metadata for them.The two keys node_name and node_type are used to return a DCC-centric “address” or representation which makes it possible to identify the path within the DCC. In for example Maya and Nuke, this will return the node name and type. The logic for this is implemented in the hooks and will vary between DCCs. This method will attempt to connect to ShotGrid, but the number of calls made are constant and independent of the scene complexity.Here is an example of what a dictionary in the return data typically looks like:{'fields': {'Sequence': 'aaa',            'Shot': 'aaa_00010',            'Step': 'Comp',            'eye': '%V',            'height': 1556,            'name': 'test',            'output': 'output',            'version': 1,            'width': 2048}, 'template': &amp;lt;Sgtk TemplatePath nuke_shot_render_pub_mono_dpx&amp;gt;,  'node_name': 'Read2', 'node_type': 'Read',  'sg_data': {'code': 'aaa_00010_test_output_v001.%04d.dpx',             'entity': {'id': 1660, 'name': 'aaa_00010', 'type': 'Shot'},             'id': 1424,             'name': 'test',             'published_file_type': {'id': 3,                                     'name': 'Rendered Image',                                     'type': 'PublishedFileType'},             'task': {'id': 4714, 'name': 'Comp', 'type': 'Task'},             'type': 'PublishedFile',             'project': {'id': 234, 'name': 'Climp', 'type': 'Project'},             'version_number': 1}, }Handy Tip!: As you can see above, each item returns a template object and a fields dictionary to represent the path. If you want to see the actual raw path for the item, you can simply run template_obj.apply_fields(fields_dict). In the context of one of the item dictionaries returned by this method, the code would bebreakdown_items = analyze_scene()for item in breakdown_items:   path = item[&quot;template&quot;].apply_fields(item[&quot;fields&quot;])Computing the highest version for an itemhighest_version = app_object.compute_highest_version(template, fields)In order to figure out the highest version for an item, use the compute_highest_version(template, fields) method. The template and fields parameters represent a path that should be analyzed are typically grabbed from the output of the analyze_scene() method. With the breakdown app, the template key containing the version number is always required to be named {version}.This will perform a scan on disk to determine the highest version. The method returns the highest version number found on disk. See the usage example below for more details.Updating a scene itemapp_object.update_item(node_type, node_name, template, fields)In order to update an item, you can use the update_item(node_type, node_name, template, fields) method. The template and fields parameters represent a path that should be updated to. The node_name and node_type parameters are used to identify which node in the scene should be modified. Typically, these  values are grabbed from the output of the analyze_scene() method.This is similar to running the update in the breakdown UI. The actual update call will be dispatched to a hook which handles the DCC specific logic. See the usage example below for more details.Breakdown API exampleBelow is an example showing how to retrieve the scene breakdown and update all items that are not using the latest version.# find the breakdown app instanceimport sgtkengine = sgtk.platform.current_engine()breakdown_app = engine.apps[&quot;tk-multi-breakdown&quot;]# get list of breakdown itemsitems = breakdown_app.analyze_scene()# now loop over all itemsfor item in items:    # get the latest version on disk    latest_version = breakdown_app.compute_highest_version(item[&quot;template&quot;], item[&quot;fields&quot;])        # if our current version is out of date, update it!    current_version = item[&quot;fields&quot;][&quot;version&quot;]    if latest_version &amp;gt; current_version:                # make a fields dictionary representing the latest version        latest_fields = copy.copy(item[&quot;fields&quot;])        latest_fields[&quot;version&quot;] = latest_version                # request that the breakdown updates to the latest version        breakdown_app.update_item(item[&quot;node_type&quot;], item[&quot;node_name&quot;], item[&quot;template&quot;], latest_fields)",
    "url": "/3c0c0ab6/",
    "relUrl": "/3c0c0ab6/"
  },
  "114": {
    "id": "114",
    "title": "Demo",
    "content": "DemoThe Demo App provides live demonstrations of ShotGrid’s native developer platform components including the ShotGrid Utilities framework, the Qt Widgets frameworks and Toolkit core.Each demo displayed in the app includes a working, interactive UI that shows how to use one or more components of the native platform. In addition, the code that is running is readily available to copy and paste into your own app.The app is simple to use. Just select a demo from the list on the left and then interact with the components on the right. Some demos are as simple as displaying a single widget from the Qt Widgets framework. Other demos provide examples of how ShotGrid platform components are commonly wired up for use in production apps.New demos will be added as new components are added to the platform and as time permits. If there is a common pattern of component usage or a demo that you’d like to see, please let us know by submitting a ticket.InstallationTo install the demo app, run the following command:tank install_app project tk-shell tk-multi-demoOnce installed, you can run the following command to launch the app:./tank demos",
    "url": "/42395ae7/",
    "relUrl": "/42395ae7/"
  },
  "115": {
    "id": "115",
    "title": "Launch App",
    "content": "Launch AppThis app provides a shortcut to make it easy to jump from ShotGrid to any supported application. It registers a ShotGrid Action entry called for various entities in ShotGrid according to your configuration choices.How It WorksDepending on your configuration options a menu entry will appear in ShotGrid when right-clicking entities or using the ShotGrid actions menu or gear menu.For example, this screenshot comes from a site who’s configuration uses this app three times to implement menus for Maya, Nuke and Photoshop.Currently supported applications and engines are:  3DSMax  Hiero  Maya  MotionBuilder  Nuke  Photoshop  Mari  Houdini  Softimage  FlameUse Command Line Arguments at LaunchMany applications have command line options that can be called to choose a different edition of the application (ex. Nuke vs. NukeX) or to specify other various usage aspects.  The launcher app has an ‘args’ setting for each OS that can be configured for this purpose.  For example if you put ‘–nukex’ there, it will add that to the command line launch and NukeX will run instead of regular Nuke:—FOLD—Launch NukeX Examplelaunch_nuke:  engine: tk-nuke  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: '--nukex'  linux_path: '@nuke_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.15}  mac_args: '--nukex'  mac_path: '@nuke_mac'  menu_name: Launch Nuke  windows_args: '--nukex'  windows_path: '@nuke_windows'—FOLD—Set Environment Variables and Automate Behavior at LaunchApplications often require certain certain environment variables, plugin paths, etc. to be set in order to properly function in a studio pipeline. The launch app helps cover this case via the ‘before_app_launch’ hook, which allows you to define a snippet of code to run each time an application starts up. By default, the ‘before_app_launch’ hook is a simple pass-through that does nothing, but it can be overridden by following the instructions in this doc.For example, if you use Zync Render, the Zync Maya plugin directory needs to be part of both $PYTHONPATH and $XBMLANGPATH. To have the launch app set these environment variables, update the ‘before_app_launch’ hook with a few lines of code, as follows:—FOLD—Set Environment Variables Exampledef execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # Example to show how to set env vars on Maya launch    # Append the desired path to the existing $PYTHONPATH to ensure    # everything upstream still works    os.environ[&quot;PYTHONPATH&quot;] = os.environ[&quot;PYTHONPATH&quot;] + os.pathsep + &quot;~/Library/zync/zync-maya&quot;    # Set $XBMLANGPATH to the desired path, may need to append it as    # with $PYTHONPATH if already defined in your pipeline    os.environ[&quot;XBMLANGPATH&quot;] = &quot;~/Library/zync/zync-maya&quot;—FOLD—You can also use the ‘before_app_launch’ to automate other behavior, including ShotGrid updates. For example, you can configure the launch app to update the Task status (in this case, to “in progress”) each time it’s run (as long as the launch is from a Task, of course), as follows:—FOLD—Automate Task Status Update Exampledef execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # If there is a Task in the context, set its status to 'ip'    if self.parent.context.task:        task_id = self.parent.context.task['id']        data = {            'sg_status_list':'ip'        }        self.parent.shotgun.update(&quot;Task&quot;, task_id, data)—FOLD—As you can imagine, there are many possibilities here, and the launch app aims to provide the flexibility your pipeline needs.Launching Applications that do not have an Engine YetYou can also use the launch app to start up applications that do not have a Toolkit engine yet. In this case, folders will be created on disk for the shot, task or asset you are launching from and the application will be launched, but no code will run after application startup and no ShotGrid menu will appear inside the application. This means that you can launch applications that are not yet supported by Toolkit from within ShotGrid.In order to do this, configure the app with paths to the application you wish to launch, but leave the engine option as an empty string.Technical Details3DSMaxThis app automatically adds a MaxScript, init_tank.ms, to the 3DSMax command line that 3DSMax will run as part of its boot process.When 3DSMax is booting, the following will happen:  3DSMax will run init_tank.ms upon starting  init_tank.ms makes sure a Python interpreter is available and runs tank_startup.py  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.MayaThis app registers a userSetup.py auto start script with Maya which Maya will call as part of its boot process.When Maya is booting, the following will happen:  Maya starts execution of the userSetup.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.MotionBuilderThis app registers a init_tank.py auto start script with MotionBuilder which MotionBuilder will call as part of its boot process.When MotionBuilder is booting, the following will happen:  MotionBuilder starts execution of the init_tank.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.NukeThis app registers a menu.py auto start script with Nuke which Nuke will call as part of its boot process.When Nuke is booting, the following will happen:  Nuke starts execution of the menu.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.PhotoshopThis app will use the Adobe Extension Manager to install or make sure the Tank plugin is installed.When Photoshop is booting, the following will happen:  Photoshop will start the execution of the Tank Plugin  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.Extra configsIf you intend to use this app to launch Photoshop you will need to supply four config values in the extra section. Here are the configs and sane default values which you would need to adjust for your system and installation locations:mac_python_path: &quot;/usr/bin/python&quot;windows_python_path: &quot;C:  Python27  python.exe&quot;mac_extension_manager_path: &quot;/Applications/Adobe Extension Manager CS6/Adobe Extension Manager CS6.app&quot;windows_extension_manager_path: &quot;C:  Program Files (x86)  Adobe  Adobe Extension Manager CS6  XManCommand.exe&quot;",
    "url": "/1b9c259a/",
    "relUrl": "/1b9c259a/"
  },
  "116": {
    "id": "116",
    "title": "Loader",
    "content": "LoaderThis document describes functionality only available if you have taken control over a Toolkit configuration. Please refer to the ShotGrid Integrations User Guide for details.ConfigurationThe loader is highly configurable and you can set it up in many different ways. There are two main configuration areas:  Setting up what tabs and what content to display in the left hand side tree view.  Controlling which actions to display for different publishes and controlling what the actions actually do.The following sections will give a high level overview how you can configure the loader.For technical minutiae relating to the configuration, please see the separate section further down in the documentation.The tree viewThe tree view is highly configurable and you can control the content of the various tabs using standard ShotGrid filter syntax. Each tab consists of a single ShotGrid API query which is grouped into a hierarchy. You can add arbitrary filters to control which items are being shown, and you can use the special keywords {context.entity}, {context.project}, {context.project.id}, {context.step}, {context.task} and {context.user} to scope a query based on the current context. Each of these keywords will be replaced with the relevant context information, either None, if that part of the context is not populated or a standard ShotGrid link dictionary containing the keys id, type and name.By default, the loader will show assets and shots belonging to the current project. By reconfiguring, this could easily be extended to for example show items from other projects (or a specific asset library project for example). You could also for example use filters to only show items with certain approval status or group items by status or by other ShotGrid fields. Below are some sample configuration settings illustrating how you could set up your tree view tabs:# An asset library tab which shows assets from a specific# ShotGrid projectcaption: Asset Libraryentity_type: Assethierarchy: [sg_asset_type, code]filters:- [project, is, {type: Project, id: 123}]# Approved shots from the current projectcaption: Shotshierarchy: [project, sg_sequence, code]entity_type: Shotfilters:- [project, is, '{context.project}']- [sg_status_list, is, fin]# All assets for which the current user has tasks assignedcaption: Assetsentity_type: Taskhierarchy: [entity.Asset.sg_asset_type, entity, content]filters:- [entity, is_not, null]- [entity, type_is, Asset]- [task_assignees, is, '{context.user}']- [project, is, '{context.project}']Filtering publishesIt is possible to apply a ShotGrid filter to the publish query that the loader carries out when it loads publish data from ShotGrid. This is controlled via the publish_filters parameter and can be used for example to hide publishes that have not been approved or where their associated review version has not been approved.Help, no actions are showing up!The loader comes with a number of different actions for each engine. For example, in the case of Nuke, there are two actions: “import script” and “create read node”. Actions are defined in hooks, meaning that you can modify their behaviour or add additional actions if you wanted to. Then, in the configuration for the loader, you can bind these actions to certain publish types you have. Binding an action to a publish type basically means that the action will appear on the actions menu for all items of that type inside the loader.As an example, by default, the mappings for Nuke are set up like this:action_mappings:  Nuke Script: [script_import]  Rendered Image: [read_node]If you are finding that no action menus are showing up, it may be because you have chosen different names for the publish types that you are using. In that case, go into the config and add those types in order to have them show up inside the loader.Managing actionsFor each application that the loader supports, there is an actions hook which implements the actions that are supported for that application. For example, with something like Maya, the default hook will implement the reference, import and texture_node actions, each carrying out specific Maya commands to bring content into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.Once you have defined a list of actions in your actions hook, you can then bind these actions to Publish File types. For example, if you have a Publish File type in your pipeline named “Maya Scene” you can bind this in the configuration to the reference and import actions that are defined in the hook. By doing this, Toolkit will add a reference and an import action to each Maya Scene publish that is being shown. Separating the Publish Types from the actual hook like this makes it easier to reconfigure the loader for use with a different publish type setup than the one that comes with the default configuration.The loader uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings that are installed for the loader, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/loader/my_hook.py. This will tell Toolkit to use a hook called hooks/loader/my_hook.py in your configuration folder.Another second generation hooks feature that the loader is using is that hooks no longer need to have an execute() method. Instead, a hook is more like a normal class and can contain a collection of methods that all makes sense to group together. In the case of the loader, your actions hook will need to implement the following two methods:def generate_actions(self, sg_publish_data, actions, ui_area)def execute_multiple_actions(self, actions)For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.Note that in versions previous to v1.12.0, the application invoked the execute_action hook to execute an action. Newer versions invoke the execute_multiple_actions hook. In order to provide backward compatibility with existing hooks, the execute_multiple_actions hook actually invokes execute_action for each actions provided. If the application is reporting that the execute_multiple_actions hook is not defined after upgrading to v1.12.0 or later, make sure that the actions_hook setting in your environment correctly inherits from the builtin hook {self}/{engine_name}_actions.py. To learn more about how you can derive custom hooks from the builtin ones, see our Toolkit reference documentation.LINKBOX_DOC:5#The%20hook%20data%20type:Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks likethis:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_publish_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular publish.        This method is called each time a user clicks a publish somewhere in the UI.        The data returned from this hook will be used to populate the actions menu for a publish.        The mapping between Publish types and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the loader app        has already established *which* actions are appropriate for this object.        The hook should return at least one action for each item passed in via the        actions parameter.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular publish, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        - If it will be shown in the history area, &quot;history&quot; is passed.        Please note that it is perfectly possible to create more than one action &quot;instance&quot; for        an action! You can for example do scene introspection - if the action passed in        is &quot;character_attachment&quot; you may for example scan the scene, figure out all the nodes        where this object can be attached and return a list of action instances:        &quot;attach to left hand&quot;, &quot;attach to right hand&quot; etc. In this case, when more than        one object is returned for an action, use the params key to pass additional        data into the run_action hook.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_publish_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_publish_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        # resolve local path to publish via central method        path = self.get_publish_path(sg_publish_data)        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_publish_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  Maya Scene: [import, reference, my_new_action]  Maya Rig: [reference, my_new_action]  Rendered Image: [texture_node]By deriving from the hook as shown above, the custom hook code only need to contain the actual added business logic which makes it easier to maintain and update.ReferenceThe following methods are available on the app instance.open_publish()Presents an ‘Open File’ style version of the Loader that allows the user to select a publish.  The selected publish is then returned.  The normal actions configured for the app are not permitted when run in this mode.app.open_publish( str title, str action, list publish_types )Parameters and Return Value  str title - The title to be displayed in the open publish dialog.  str action - The name of the action to be used for the ‘open’ button.  list publish_types - A list of publish types to use to filter the available list of publishes.  If this is empty/None then all publishes will be shown.  Returns: A list of ShotGrid entity dictionaries that were selected by the user.Example&amp;gt;&amp;gt;&amp;gt; engine = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; loader_app = engine.apps.get[&quot;tk-multi-loader2&quot;]&amp;gt;&amp;gt;&amp;gt; selected = loader_app.open_publish(&quot;Select Geometry Cache&quot;, &quot;Select&quot;, [&quot;Alembic Cache&quot;])&amp;gt;&amp;gt;&amp;gt; print selected",
    "url": "/a4c0a4f1/",
    "relUrl": "/a4c0a4f1/"
  },
  "117": {
    "id": "117",
    "title": "Publish",
    "content": "Publish",
    "url": "/bc718491/",
    "relUrl": "/bc718491/"
  },
  "118": {
    "id": "118",
    "title": "Python Console",
    "content": "Python ConsoleThis is a python console panel for use in DCCs with access to a python interpreter that have limited or no support for interacting with said interpreter.PanelOnce installed, the console is registered as a panel in the DCC and is available in the ShotGrid menu. In apps that support embedded Toolkit panels(maya, nuke, houdini), the console will display in a docked panel. When using with older versions of these DCCs or in a DCC that does not support panels, the console will simply be shown as a regular Toolkit dialog.TabsThe python console displays one or more tabs, each containing an editor and an output window. New tabs can be created by clicking the + button in the bottom right hand corner. Tabs have an x button next to the tab name that allow you to delete the tab. Double clicking the tab itself will prompt you to enter a new name for the tab. Tabs can be rearranged via drag and drop. The state of the tabs is saved when the DCC is closed and restored on the next launch.EditorThe console has an input area for editing python. The editor includes line numbers, highlights the cursor’s current line, and does some basic syntax highlighting. The console attempts to use the palette of the DCC to give it an integrated look and feel.Block indenting and unindenting is supported. Select one or more lines and press tab to indent by four spaces or shift + tab to unindent by four spaces. It tries to keep the indentation in blocks of four so it will indent/unindent to the nearest whole block of four spaces.Block commenting and uncommenting is also supported. Select one or more lines and press cmd + / on Mac, ctrl + / for Windows and Linux. If any of the selected lines don’t have a # at the start it will add one to all selected lines. If all the lines do have a #, then it will remove them.OutputThe output area displays the results of the executed python. Echoing the source python commands is turned on by default and is differentiated in the output by being prefixed with &amp;gt;&amp;gt;&amp;gt;. Each execution is also marked with a timestamp. There is a toggle for turning the echo off. Syntax and Runtime errors are shown in red with a full stack trace for debugging.ButtonsOutput  Clear - Clear the contents of the output browser.  Echo - Toggle echoing the executed commands in the output browser.Editor  Execute - Execute the contents of the editor  Save - Save the current contents of the editor to a file.  Open - Open a file in the editor.  Clear - Clear the contents of the editor.  Lines - Toggle line numbers for the current tabGlobalsSome ShotGrid/Toolkit globals are pre-defined in the console, similar to what is available in the ShotGrid Engine for the shell.  Tk API handle is available via the tk variable  ShotGrid API handle is available via the shotgun variable  The current context is stored in the context variable  The shell engine can be accessed via the engine variableExternal sourcesThe app comes with a hook that can be implemented to load python source from an external location. The hook is called external_sources_hook and requires implementing a method called get_external_source_actions. The method should return a list of QActions that, when triggered, add a new tab (with content)to the console. An example implementation is provided that loads gists from github for a list of predefined users. The actions returned by the hook are shown in the popup menu displayed when the Open button is pressed and held.Hotkeys  Execute selected with Ctrl + Enter  Create a new tab with Ctrl + T  Navigate tabs with Ctrl + Shift + [ or Ctrl + Shift + ]  Resize input/output font via Ctrl + WheelNOTE: These hotkeys may not be available in all DCCs.Other notes  In some older versions of DCCs, leaving the python console open when closing the session may cause a crash. We believe this may be a bug in some older versions of PySide. More recent versions of DCCs, bundled with newer versions of PySide, do not appear to crash on exit. If you encounter this issue with a recent DCC release, please submit a ticket so that we can investigate further.",
    "url": "/770a748a/",
    "relUrl": "/770a748a/"
  },
  "119": {
    "id": "119",
    "title": "Review Submission",
    "content": "Review SubmissionHow do I use this App?As an APIThis app have a mode that is meant to be called from inside other apps like the multi-publish app.This mode creates quicktimes from image sequences and submits them as Versions to ShotGrid in order to facilitate review. The generated quicktimes will have slates and burnins. Things such as font, logo position, movie compression options and burnin / slate information are currently hardcoded in the default hooks and as such you are encouraged to re-implement the hook function to adjust the behaviour.Here are a the current default formats for slate and burnin:Should you want to leverage this app from within your own apps or hooks here is a quick rundown of the simple way to go about it.  Get the tk-multi-reviewsubmission app from the current engine. This can be donefrom inside a hook using the call self.parent.engine.apps.get('tk-multi-reviewsubmission').  If the app is available, call the render_and_submit_version() method.Here’s an example of what this can look like inside your hook code:review_submission_app = self.parent.engine.apps.get(&quot;tk-multi-reviewsubmission&quot;)if review_submission_app:    review_submission_app.render_and_submit_version(        template,        fields,        first_frame,        last_frame,        sg_publishes,        sg_task,        comment,        thumbnail_path,        progress_cb,        color_space    )The arguments that you need to pass to render_and_submit_version are as follows:  template: A template that defines where the files to publish are located  fields: Fields that will be used to fill out the template  first_frame: The first frame of the image sequence to process  last_frame: The last frame of the image sequence to process  sg_publishes: A list of ShotGrid Published File objects to link the version to.  sg_task: A ShotGrid Task link dictionary to link the version to.  comment: Text to add to the Version’s description.  thumbnail_path: The path to a thumbnail to use for the version when the movie isn’t being uploaded to ShotGrid (this is set in the config)  progress_cb: A callback to report progress with.  This should be of the form: callback(percent, message)  color_space: The color space that the input frames are in.  In Nuke, this would be one of the enumeration values on the colorspace knob for the Write node.As a menu itemThis mode adds a menu item to the ShotGrid menu inside the DCC. This mode creates a quick snapshot of the current viewport and sends it to ShotGrid Create as a Version draft. Then, the user can extend the review submission inside of ShotGrid Create by adding annotations, text or comparison notes.In order to add this functionality to your context, you need to:  Set the display_name field to have it in the menu item.  Set the render_media_hook field to a hook that tells how to render media in your DCC (tk-photoshopcc and tk-maya have a default implementation)  Set the submitter_hook field to {self}/submitter_create.pyLike this:tk-multi-reviewsubmission:  display_name: Send for review  render_media_hook: '{self}/render_media.py:{self}/{engine_name}/render_media.py'  submitter_hook: '{self}/submitter_create.py'  location:     type: app_store    name: tk-multi-reviewsubmission    version: v1.0.1",
    "url": "/4badd856/",
    "relUrl": "/4badd856/"
  },
  "120": {
    "id": "120",
    "title": "Screening Room",
    "content": "Screening RoomThis is a small app that hooks up your current Maya session with Screening Room. It will add an item to the ShotGrid menu saying Jump to Screening Room. Clicking this button will launch Screening Room and point it at the current ShotGrid Toolkit Context - for example a Shot, Asset or a Task. You can then use Screening Room to browse all submitted content.",
    "url": "/f3e452a2/",
    "relUrl": "/f3e452a2/"
  },
  "121": {
    "id": "121",
    "title": "Set Frame Range",
    "content": "Set Frame RangeThis app helps managing the frame range in the currently open scene. You can access it from the ShotGrid menu by clicking the Sync Frame Range with ShotGrid menu option.When you click it, the ShotGrid Toolkit will look at the ShotGrid entity associated with the current work area (typically a Shot) and look for in and out fields which contain the in and out frame information. Typically, this is something used in conjunction with Shots and in that case the app uses the standard shot in and out fields defined in ShotGrid’s default config. However, it is perfectly possible to configure the app to pull the frame ranges from other fields too.Once you run the App, it will update the current scene with those ins and outs and finally display a summary message:Multiple ShotGrid field synchronisation optionsYou can define multiple instances of this app in the ShotGrid Menu by setting the menu_name property. This allows the possibility to define a multiple menu actions for synchronization of different ShotGrid fields.To do this, set a different app instance name, menu_name and in and out frame fields for each instance:tk-multi-setframerange_cuts:  menu_name: Sync frame range using cut fields  sg_in_frame_field: sg_cut_in  sg_out_frame_field: sg_cut_out  location: &quot;@apps.tk-multi-setframerange.location&quot;tk-multi-setframerange_handles:  menu_name: Sync frame range using handle fields  sg_in_frame_field: sg_handle_in  sg_out_frame_field: sg_handle_out  location: &quot;@apps.tk-multi-setframerange.location&quot;These should then appear as separate options in the ShotGrid menu:Note: this is new to version v0.4.0 of the app.Operations hookThe software specific logic for getting the current scene frame range or setting the frame range is handled in the frame operations hook. If you are wanting to add support for a new engine or want to change how the behaviour is implemented, you can take over the frame operations hook by setting the hook_frame_operation app property and implementing your own get and set logic.Note: this is new to version v0.4.0 of the app.",
    "url": "/8ac43263/",
    "relUrl": "/8ac43263/"
  },
  "122": {
    "id": "122",
    "title": "ShotGrid Panel",
    "content": "ShotGrid PanelThis document describes functionality only available if you have taken control over a Toolkit configuration. Please refer to the ShotGrid Integrations User Guide for details.Configuring the ShotGrid PanelThere are two main areas that you can configure extensively in the ShotGrid Panel: The appearance of text in the UI and the actions you want to associate with data. The sections below outline how to control the configuration for the two systems.Configuring what is being displayedThe values in the detail area and the listings are both configurable through the ShotGrid_fields hook. You can subclass this hook and change the implementation in order to display the exact values you want:Templating SystemThe hook supports a simple templating language, allowing for great flexibility. It also supports the HTML subset supported by Qt, so you can control color, font size, weight, etc. of your displayed values. The template language works in the following way:      ShotGrid values are enclosed in {brackets}, for example &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}. When this template is rendered, the {description} part will be replaced with the description field value.        If you want an optional pre- or post-fix for a value which is only shown if the value is not empty, you can use the syntax {[Prefix]sg_field[suffix]}. The template {[Start: ]start_date} {[End: ]end_date} will render Start: 12 July 2009 End: 14 July 2012 if both values are populated but Start: 12 July 2009 if end date isn’t set.        You can define fallbacks in the case some values are not set. For ShotGrid Versions, the artist fields takes precedence over the created_by field in order to support a workflow where a producer submits versions on behalf of an artist. In this case, the Version will be created by the producer but the artist field will be set to the artist. This, however, is not always the case - in some cases, artist is left blank in pipelines where artists submit their own work. When displaying versions, it is therefore useful to be able to check the artist field first, and in case this isn’t set, fall back on the created_by field. This is done using the {field1|field2} syntax, for example: Created By: {artist|created_by}. You can combine this with optional fields too, e.g. {[Created By: ]artist|created_by}  This hook contains the following methods:Controlling items appearing in listsThe get_list_item_definition() method returns a dictionary that controls the appearance of items in the various listings, given a ShotGrid entity type. It returns a dictionary with the keys top_left, top_right and body, for example:{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;} Controlling the top detail areaThe get_main_view_definition() method returns a dictionary with the keys title and body given a ShotGrid entity type. These values controls the appearance of an object in the detail area, for example:{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;} Controlling the fields shown in the Info tabThe get_all_fields() methods returns a list of fields to display for a given entity when this is rendered in the Info tab.Configuring ActionsActions are little snippets of code that operate on a piece of ShotGrid data. Examples include:  An action that launches RV for a given ShotGrid Version  An action that allows a user to assign herself to a given Task  An action that loads a ShotGrid publish into Maya as a Maya reference.The actual payload of an action is defined in an action hook. Once you have defined the action logic, you can then map that action to ShotGrid objects in the app configuration. These action mappings may for example look like this:action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}In the above example, we use the actions reference, import, texture_node, assign_task and play_in_rv. We then map the actions to various ShotGrid objects and conditions. For example, we are requesting the import action to appear for all publishes of type Maya Scene.When an object is loaded into the Panel, the action configuration above is read in and analyzed. A list of suitable actions for the current object is determined and the generate_actions() hook method will be executed. ShotGrid data for the given entity will be passed to the hook at this point so that the hook code can determine if the action can be run for this particular ShotGrid object. This is a way to allow each hook to run a check prior to being displayed. For example, the play_in_rv hook may only be relevant in the case there is media available locally - the action mappings set up in the configuration tells the panel which actions to enable for a given ShotGrid entity but they may not all be displayed because the generate_actions() method may determine that they are not suitable for the given object.The actions returned from the generate_actions() method will be displayed on the actions menu and when a user clicks on it, the execute_action() hook method is called to run the action.For each application that the panel supports, there is an actions hook which implements suitable actions. For example, with something like Maya, the default hook will implement reference, import and texture_node actions, each carrying out specific Maya commands to bring publishes into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.The panel uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app’s hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/panel/maya_actions.py. This will tell Toolkit to use a hook called hooks/panel/maya_actions.py in your configuration folder.For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.LINKBOX_DOC:5#The%20hook%20data%20type:Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks like this:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular object.        The data returned from this hook will be used to populate the         actions menu.            The mapping between ShotGrid objects and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the app        has already established *which* actions are appropriate for this object.                This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.                Because you are operating on a particular object, you may tailor the output         (caption, tooltip etc) to contain custom information suitable for this publish.                The ui_area parameter is a string and indicates where the publish is to be shown.                 - If it will be shown in the main browsing area, &quot;main&quot; is passed.         - If it will be shown in the details area, &quot;details&quot; is passed.                        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption, group and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;group&quot;: &quot;Pipeline Utils&quot;,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.                :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}By deriving from the hook as shown above, the custom hook code only need to contain the actual addedbusiness logic which makes it easier to maintain and update.",
    "url": "/c0b0ce05/",
    "relUrl": "/c0b0ce05/"
  },
  "123": {
    "id": "123",
    "title": "Snapshot",
    "content": "Snapshot",
    "url": "/233f8961/",
    "relUrl": "/233f8961/"
  },
  "124": {
    "id": "124",
    "title": "Workfiles",
    "content": "WorkfilesFile Open dialogNavigating your work areasThe main dialog is split in two halves. On the left hand side, there is a series of tabs. The first tab is called “My Tasks” and will display all the tasks that are assigned to the current user. It is very reminiscent of the “My Tasks” page on the ShotGrid website.Alternatively, the user can also browse for a ShotGrid entity using the entities tabs. By default, the workfiles application allows to browse for any tasks associated on shots or assets by looking at the respective tab.The set of tabs is entirely configurable through the entities settings in the environment files.You can disable/enable this dialog by setting the show_file_open: true/false in the app settings.Finding filesOn the right hand-side you will see the working files and publishes associated with the selection from the left hand-side. Working files and publishes can be viewed together or separately using the tabs “All”, “Working” and “Publishes”.Accessing previous versionsThere are two ways to access previous versions. First, the user can click on the “All versions” box at the top of the browser, which will uncollapse the versions and list them all individually in the browser. Another option is to right-click on a file, which will allow you to access the last 10 versions.User sandboxesIf your pipeline configuration uses user sandboxes, only the files for the current user will be seen by default. If the user wants to see the files from other user’s sandboxes, a button at the top will allow to pick which sandboxes to show files from.Narrowing resultsYou can narrow results in the any of the views by typing text. The search will match any item’s name.File Save dialogBy default, the “File Save” dialog allows the user to save a file in the current context. The user will be prompted for a scene name, version number and an optional file extension, if available and the “Save” button will be greyed out. Only once the application has confirmed the next available version number for a scene name will the Save button at the bottom right be enabled.You can disable/enable this dialog by setting the show_file_save: true/false in the app settings.Saving in a different contextIn order to save a file in a different context, a user can click on the expand button at the top-left of the dialog which will expand the “File Save” dialog and allow to pick another context to save into.Adding the file extension dropdownWith the new file save dialog, it is possible to pick the extension of the file being saved. In order to enable this, you need to tweak your pipeline configuration’s templates.yml file. First, a token needs to be defined in the token list inside templates.yml.maya_extension:    type: str    choices:        ma: Maya Ascii (.ma)        mb: Maya Binary (.mb)    default: ma    alias: extensionmaya_extension is the token’s name. choices is a dictionary of file types that will be displayed in the dropdown. The keys (ma and mb) are the possible values that this template token can have. The values (Maya Ascii (.ma) and Maya Binary (.mb)) are UI friendly descriptions that can be used by a Toolkit application. The alias is an hint that is required by the workfiles application. It tells the application that this token is an extension and should be displayed in the dropdown widget.Then, this token can be added to any Maya specific template.maya_shot_work:    definition: '@shot_root/work/maya/{name}.v{version}.{maya_extension}'    root_name: 'primary'Context Change dialogThe context change dialog is similar to the open dialog except that it doesn’t have a the right hand side for file browsing. You can select a task or entity and change your current engine context by pressing press the change context button.You can disable/enable this dialog by setting the show_change_context: true/false in the app settings.Step filteringWhen retrieving Tasks, and if step is included in the hierarchy, the amount of data retrieved from ShotGrid can be reduced with Pipeline Step filtering: only Tasks linked to the selected list of Steps will be retrieved.The list of Steps displayed in a tab is controlled with the step_filter_on setting. If not set, all existing Pipeline Steps are displayed.The example below defines two tabs, respectively displaying Tasks for Assets and Shots:  - caption: Assets Tasks    entity_type: Task    step_filter_on: Asset    filters:    - [entity, type_is, Asset]    hierarchy: [entity.Asset.sg_asset_type, entity, step, content]  - caption: Shots Tasks    entity_type: Task    step_filter_on: Shot    filters:    - [entity, type_is, Shot]    hierarchy: [entity.Shot.sg_sequence, entity, step, content]Deferred queriesFor better performances, building the Entities tree can be broken into two step queries:  A first query is used to retrieve records from ShotGrid and populate the top of the tree.  A second query is used to retrieve children as the user expand the tree.With the following settings, Assets and Shots would be retrieved from ShotGrid when the app is started. And then Tasks linked to a particular Asset or Shot would only be retrieved when this Asset or Shot is selected or expanded in the tree view.  entities:  - caption: Assets    entity_type: Asset    hierarchy: [sg_asset_type, code]    filters:    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]  - caption: Shots    entity_type: Shot    filters:    hierarchy: [sg_sequence, code]    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]",
    "url": "/9a736ee3/",
    "relUrl": "/9a736ee3/"
  },
  "125": {
    "id": "125",
    "title": "Nuke Quickreview",
    "content": "Nuke QuickreviewThe Quickreview app makes it easy to submit Nuke renders for review in ShotGrid. A Version in ShotGrid will be created with each quickreview submission. It appears as a node in Nuke, located on the ShotGrid Node menu. Simply create a new node, attach it to your Nuke network, double click it and click the Upload button.You get presented with the following UI, allowing you control how your Version is created in ShotGrid:The following items can be controlled:  The version name is pre-populated based on the currently loaded nuke script and can be adjusted if needed.  The entity link and task associated with the version is based on the current context and can be adjusted.  The frame range to be submitted can be adjusted.  The created Version can be added to a playlist. A dropdown with recent playlist are being displayed.Once you press the Upload button, a quicktime will be generated in nuke and then uploaded to ShotGrid. Once uploaded, the following screen will be shown, allowing you to either show the Version in the Built-in ShotGrid Panel in Nuke or in the web overlay player.Burnins and slateBy default, the app will generate a Quicktime with a slate and burn-ins:CustomizationMost aspects of the review submission can be adjusted using hooks. Documentation can be found here.",
    "url": "/40da6878/",
    "relUrl": "/40da6878/"
  },
  "126": {
    "id": "126",
    "title": "Nuke Write Node",
    "content": "Nuke Write NodeThe Nuke Write Node App provides a custom ShotGrid Write node which makes it easy to standardise the location where images are rendered to.  It can be configured for each environment.  In addition to the path, the configuration will also determine the render format to be used.General UseIn order to use the ShotGrid Write Node, save your script as a Toolkit work file first and then create a new node via the Nuke menu. This will create a node which looks similar to a normal write node:Rather than entering a path by hand, you just specify an output name and Toolkit will then compute the rest of the path automatically. You can see the computed path in the UI and open up the location on disk by clicking the Show in File System button. The location where the renders are written to depends on the Toolkit configuration.The renders will be versioned and the version number will always follow the current nuke script version which will be incremented automatically when you publish using Multi Publish.Resetting the render pathThe Write Node will cache the current path so that it is still valid if the file is opened outside a Toolkit Work Area.  Occasionally, this can mean that the path becomes out of sync and ‘locked’.  If the render path is locked then renders created with this Write Node cannot be published.To reset a render path, either version-up the scene using the Work-files app’s ‘Version Up Scene’ command or select the Write node individually and in the properties, click Reset Path:Adding Another Write Node ProfileThe ShotGrid Write Node wraps Nuke’s built-in write node, so any format supported by Nuke can be used with the app and additional nodes can be added via configuration.  The simplest way to start is to set up a simple Nuke write node with the parameters you want. For the example, let’s imagine you are doing 16-bit tifs with LZW compression. If you look at your Nuke script in a text editor, the write node will look something like this:Write {    file /Users/ryanmayeda/Desktop/test.%04d.tif    file_type tiff    datatype &quot;16 bit&quot;    compression LZW    checkHashOnRead false    name Write1    xpos -145    ypos -61}The text will tell you what the parameter names and values you need are. In this case it’s datatype and compression. Next, go into your environment configuration (for example: /path/to/pipeline/config/env/shot_step.yml) and find the area where the tk-nuke-writenode app is configured.  Add another Write Node, with these two parameters in the settings:tk-nuke-writenode:  location: {name: tk-nuke-writenode, type: app_store, version: v0.1.6}  template_script_work: nuke_shot_work  ...  write_nodes:  - file_type: exr    ...  - file_type: dpx    ...  - file_type: tiff    name: Mono Tif    publish_template: nuke_shot_render_pub_mono_tif    render_template: nuke_shot_render_mono_tif    proxy_publish_template: null    proxy_render_template: null    settings: {datatype: 16 bit, compression: LZW}    tank_type: Rendered Image    tile_color: []    promote_write_knobs: []The updated configuration will then result in the additional ShotGrid Write Node appearing in Nuke:Note: Be sure to add any new templates (e.g. nuke_shot_render_mono_tif) to your templates.yml file which can be found in your project’s configuration (&amp;lt;configuration root&amp;gt;/config/core/templates.yml).Another example, showing how to add a ShotGrid Write Node that outputs to JPEG with 0.5 compression and a 4:2:2 sub-sampling is shown below. This profile also makes use of the “promote_write_knobs” option to promote the jpeg quality knob to the gizmo’s user interface. This allows the profile to set the default value for quality, but also provide the user the slider to alter that setting themselves:tk-nuke-writenode:  write_nodes:    - file_type: jpeg      name: Compressed JPEG      publish_template: nuke_shot_render_pub_jpeg      render_template: nuke_shot_render_jpeg      proxy_publish_template: null      proxy_render_template: null      settings: {_jpeg_quality: 0.5, _jpeg_sub_sampling: &quot;4:2:2&quot;}      tank_type: Rendered Image      tile_color: []      promote_write_knobs: [_jpeg_quality]Promoting Write KnobsAs shown in the profile example above, knobs from the encapsulated write node can be promoted to become visible in the ShotGrid Write Node’s properties panel. The promoted write knobs are defined as part of a profile and are identified by knob name. Multiple knobs may be promoted.Render Farm IntegrationIt’s common for studios to use a render farm that runs job management tools such as Deadline,  which typically launch Nuke directly when rendering. Because these tools do not launch Nuke in a ShotGrid-aware way (e.g., via Desktop or the tank command), the ShotGrid write node does not have the information it needs to run. We offer a couple options to get around this limitation.Convert ShotGrid write nodes to standard Nuke write nodesA simple solution is to convert the ShotGrid write nodes to regular Nuke write nodes before sending the script to be rendered. There are two options 1. you can enable and use the convert menu options, 2. you can use the API convert methods on the app.Enabling the convert menu optionsThere is a configuration option called show_convert_actions that can be added to the app’s settings in the environment yml files. When you add the setting show_convert_actions: True, the Convert SG Write Nodes to Write Nodes… and Convert Write Nodes back to SG format… menu options become available.However if you have any ShotGrid Write node profiles defined that promote write knobs, then these menu options will be hidden even if the show_convert_actions is set to True. This is because at present the convert back functionality does not support promoted knobs.Using the API to ConvertThere is a convert_to_write_nodes() method that performs this conversion available on the tk-nuke-writenode app.To convert all ShotGrid write nodes in a script to regular Nuke write nodes, run the following code inside Nuke:import sgtkeng = sgtk.platform.current_engine()app = eng.apps[&quot;tk-nuke-writenode&quot;]if app:    app.convert_to_write_nodes() This will remove the ShotGrid write nodes from the scene, so our suggested workflow is that you make a copy of the script to be rendered, perform the conversions on the copy, and submit the copy to the farm. The scene no longer has any Toolkit references and thus Toolkit is not required when the nuke script opened on the render farm.Note: There is a corresponding convert_from_write_nodes() method available, but to ensure data integrity, we recommend that it only be used for debugging and not as part of your pipeline.Bootstrap the ShotGrid Pipeline Toolkit engine using init.pyNuke will run any init.py scripts found in its plugin path. This option consists of adding code to init.py that will perform a minimal bootstrap of the tk-nuke engine, so that ShotGrid write nodes behave as expected on the render farm.There are a few steps to this workflow: First, a “pre-flight” submission script that runs in a ShotGrid-aware Nuke session gets data that will be used to set the environment for your farm job. Next, additional environment variables used to authenticate the ShotGrid session on the render farm are set by render farm administrators. Finally, an init.py with the ShotGrid bootstrap code is placed in a location where the Nuke session on the render farm will detect and run it, bootstrapping the tk-nuke engine within the session, and allowing the ShotGrid write nodes to function properly.1. Pre-flight submission scriptThis approach assumes that artists are submitting farm jobs within a ShotGrid-aware session of Nuke. At submission time, the following code should run. It pulls environment information like Toolkit context, Pipeline Configuration URI, Toolkit Core API location, etc. from the current Nuke session to populate a dictionary that will be passed to the render job, where it will be used to set environment variables.# Populating environment variables from running Nuke:# http://developer.shotgridsoftware.com/tk-core/platform.html#sgtk.platform.create_engine_launchercurrent_engine = sgtk.platform.current_engine()launcher = sgtk.platform.create_engine_launcher(     current_engine.sgtk,     current_engine.context,     current_engine.name)# Get a dictionary with the following keys:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234environment = launcher.get_standard_plugin_environment()# Get the current pipeline config descriptorenvironment[&quot;SHOTGUN_CONFIG_URI&quot;] = os.path.join(current_engine.sgtk.configuration_descriptor.get_uri(),&quot;config&quot;)# Get the current tk-core installation pathenvironment[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;] = sgtk.get_sgtk_module_path()Once you’ve gathered this information, you can pass it to your render submission tool. This process will vary depending on the render farm management system you’re using. Consult your farm management system documentation for more information on how to write render submission scripts.2. ShotGrid authenticationThe bootstrap API’s ToolkitManager requires a script user in order to initialize. In our example, we’re assuming that your site name, script user, and script key exist as environment variables on the farm machine. Typically this is managed by the render farm administrator. Here are the environment variable names our code is expecting, with sample values:SHOTGUN_SITE = “https://mysitename.shotgunstudio.com”SHOTGUN_FARM_SCRIPT_USER = “sg_api_user”SHOTGUN_FARM_SCRIPT_KEY = “xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”For more information on authentication, see our developer documentation.A note on securing your script user: It’s good practice to lock down the script user you use on the farm so that it doesn’t have admin-level permissions. You can learn more about API user permissions here.3. The init.py scriptAt this point, Toolkit environment data is being passed from the render submission tool, and authentication data is in environment variables on the render farm machine. The final piece to bootstrapping Toolkit within your render job is to place the following example init.py code in Nuke’s plugin path, so that Nuke will launch it at startup time. (See the Foundry’s documentation on startup scripts for more details.)# This script shows how a Toolkit as a plugin approach could be used to bootstrap# Toolkit in Nuke on the render farm.# http://developer.shotgridsoftware.com/tk-core/bootstrap.html#bootstrapping-toolkitimport sysimport os# If your render nodes can access the same tk-core install location as# artist workstations, retrieve its path from the environment and ensure# it is in the PYTHONPATHTK_CORE_PATH = os.environ[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;]if TK_CORE_PATH not in sys.path:    sys.path.append(TK_CORE_PATH)# If your render nodes don’t have access to the Toolkit Core API in the same filesystem location as artist workstations, you have to make sure that it is available in the PYTHONPATH, so that render nodes can import it. An easy way # to install tk-core in a centralized location is with pip. You can read more # about it here:# http://developer.shotgridsoftware.com/tk-core/bootstrap.html#installing-the-sgtk-module-using-pipimport sgtk# Authenticate using a pre-defined script user.sa = sgtk.authentication.ShotgunAuthenticator()# Here we retrieve credentials from environment variables, assuming a script user# will be used when rendering. This should be typically be handled by your render# farm administrators.SG_SITE_URL = os.environ[&quot;SHOTGUN_SITE&quot;]SG_SCRIPT_USER = os.environ[&quot;SHOTGUN_FARM_SCRIPT_USER&quot;]SG_SCRIPT_KEY = os.environ[&quot;SHOTGUN_FARM_SCRIPT_KEY&quot;]user = sa.create_script_user(    api_script=SG_SCRIPT_USER,    api_key=SG_SCRIPT_KEY,    host=SG_SITE_URL)# Start up a Toolkit Manager with our script usermgr = sgtk.bootstrap.ToolkitManager(sg_user=user)# Set the base pipeline configuration from the environment variable:mgr.base_configuration = os.environ[&quot;SHOTGUN_CONFIG_URI&quot;]# Disable ShotGrid lookup to ensure that we are getting the Pipeline # Configuration defined in SHOTGUN_CONFIG_URI, and not a dev or override# Pipeline Configuration defined in ShotGrid.mgr.do_shotgun_config_lookup = False# Set a plugin id to indicate to the bootstrap that we are starting# up a standard Nuke integrationmgr.plugin_id = &quot;basic.nuke&quot;# Retrieve the Toolkit context from environment variables:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234sg_entity = mgr.get_entity_from_environment()# Now start up the Nuke engine for a given ShotGrid Entitynuke_engine = mgr.bootstrap_engine(&quot;tk-nuke&quot;, entity=sg_entity)You may need to extend this if your configuration is more complex than this example or if you are passing a Python script to the command line using the -t flag instead of a nuke (.nk) script.Deadline-specific stepsDeadline can copy Nuke scripts to a temporary location when rendering. This will cause problems with Toolkit as the files will no longer be in a disk location that it recognizes. To disable this behavior and load the scripts from their original location:  In Deadline, navigate to Tools &amp;gt; Configure Plugin (In the super user mode)  Disable the ‘Enable Path Mapping’ optionTechnical DetailsThe following API methods are available on the App:get_write_nodes()Return a list of all ShotGrid Write Nodes in the current scene.list app.get_write_nodes()Parameters &amp;amp; Return Value  Returns: list - a list of Toolkit Write nodes found in the sceneExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()get_node_name()Return the name of the specified Write Node.string get_node_name(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the name of the node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_name(nodes[0])get_node_profile_name()Get the name of the configuration profile used by the specified Write node.string get_node_profile_name(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the profile name for this Write Node as defined by the configurationExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_profile_name(nodes[0])get_node_render_path()Get the path that the specified Write node will render images to.string get_node_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the render path for this nodeExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_path(nodes[0]) get_node_render_files()Get a list of all image files that have been rendered for the specified Write Node.list get_node_render_files(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: list - a list of the image files rendered by this Write node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_files(nodes[0])get_node_render_template()Get the template that determines where rendered images will be written to for the specified Write Node as defined in the configuration.template get_node_render_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the render template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_template(nodes[0]) get_node_publish_template()Get the template that determines where rendered images will be published to for the specified Write Node as defined in the configuration.template get_node_publish_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the publish template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_publish_template(nodes[0]) get_node_proxy_render_path()Get the path that the specified Write node will render proxy images to.string get_node_proxy_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the proxy render path for this nodeExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_path(nodes[0]) get_node_proxy_render_files()Get a list of all proxy image files that have been rendered for the specified Write Node.list get_node_proxy_render_files(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: list - a list of the proxy image files rendered by this Write node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_files(nodes[0])get_node_proxy_render_template()Get the template that determines where proxy rendered images will be written to for the specified Write Node as defined in the configuration.If there is no proxy render template configured for the specified node then this will return the regular render template instead.template get_node_proxy_render_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the proxy render template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_template(nodes[0]) get_node_proxy_publish_template()Get the template that determines where proxy rendered images will be published to for the specified Write Node as defined in the configuration.If there is no proxy publish template configured for the specified node then this will return the regular publish template instead.template get_node_proxy_publish_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the proxy publish template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_publish_template(nodes[0]) get_node_published_file_type()Get the Published File Type to be used when Published files are created for images rendered by the specified Write node as defined in the configuration.string get_node_published_file_type(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the Published File Type this node is configured to useExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_published_file_type(nodes[0]) generate_node_thumbnail()Generate a thumbnail for the specified Write Node.  This will render a frame from the middle of the sequence with a maximum size of 800x800px to a temp file (.png).  It is the responsibility of the caller to clean up this file when it is no longer needed.string generate_node_thumbnail(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the path to the rendered thumbnail image on diskExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.generate_node_thumbnail(nodes[0]) reset_node_render_path()Reset the render path for the specified Write Node to match the current script.None reset_node_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: None - no value is returnedExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.reset_node_render_path(nodes[0]) is_node_render_path_locked()Determine if the render path for the specified Write node is locked or not.bool is_node_render_path_locked(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: bool - True if the render path is locked, otherwise FalseExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.is_node_render_path_locked(nodes[0]) convert_to_write_nodes()Convert all ShotGrid write nodes found in the current Script to regular Nuke Write nodes.  Additional toolkit information will be stored on user knobs named ‘tk_*’None convert_to_write_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_to_write_nodes() convert_from_write_nodes()Convert all regular Nuke Write nodes that have previously been converted from ShotGrid Write nodes, back into ShotGrid Write nodes.None convert_from_write_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_from_write_nodes() process_placeholder_nodes()Convert any placeholder nodes into full ShotGrid Write Nodes.  This is primarily used to convert placeholder nodes created by the Hiero Toolkit script exporter when a script is first opened in Nuke.None process_placeholder_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.process_placeholder_nodes() ",
    "url": "/09168e73/",
    "relUrl": "/09168e73/"
  },
  "127": {
    "id": "127",
    "title": "Nuke",
    "content": "NukeThe ShotGrid engine for Nuke contains a standard platform for integrating ShotGrid Apps into Nuke, Nuke Studio, and Hiero. It is light weight and straight forward and adds a bunch of new things to Nuke.It creates a ShotGrid Menu in Nuke on which various items are displayed:It creates a ShotGrid Node Menu in Nuke on which various items are displayed:It adds ShotGrid shortcuts to the file dialogs which makes it easy to jump to various file system locations:You can add your own shortcuts based on template paths in your current environment with the favourite_directories setting. The setting expects a list of dictionaries, with each item in the list representing a new favourite directory. Here is an example of the format you would use: (the icon can also be left unspecified by providing “” as the value.)  favourite_directories:  - display_name: &quot;Shot Publish Path&quot;    template_directory: &quot;shot_publish_area_nuke&quot;    icon: &quot;icons/custom_publish_icon.png&quot;  - display_name: &quot;Shot Work Path&quot;    template_directory: &quot;shot_work_area_nuke&quot;    icon: &quot;icons/custom_work_icon.png&quot;The “ShotGrid Current Project” favourite is added automatically for each root defined. You can customize the name with the project_favourite_name setting, or disable these favourites by setting the value to an empty string ''Note: There is currently a bug in Nuke 8.0 running specifically on CentOS 6.5 that causes Nuke to crash when running Toolkit. Other versions of CentOS are unaffected. The Foundry is aware of this issue (bug 43766). If you are running into this, please contact us so we can try and help you workaround it until it is resolved in a future update of Nuke.Information for App DevelopersContext TrackingThe ShotGrid engine for Nuke will switch context automatically when files are loaded. Whenever a file is loaded, the engine will look at the file, try and resolve a context from it.Apps with custom gizmosThe ShotGrid engine for Nuke makes it easy to handle custom gizmos. If you are writing an app which uses custom gizmos, you can just drop them into a folder called gizmos and the engine will automatically add that location to the nuke path:You can then easily access your gizmo via the create node functionality:  nuke.createNode(&quot;WriteTank&quot;)                    Warning: Please note that while the use of gizmos may be convenient, it is typically NOT the right solution if you want to create nodes that persist in a scene. The reason for this is because as soon as you have put a gizmo in the scene, you have introduced a dependency between that scene and the gizmo code. Not only will you need to load the ShotGrid Toolkit every time you load the scene, but you also need to carefully manage your code so that any updates to the code does not break old gizmos being used in scenes.    Apps Creating NodesApps that create custom nuke nodes need to be carefully crafted. We recommend not using gizmos since these require a dependency between the scene and the gizmo code. Instead, save your custom nodes as a nuke file and import them into the scene:    group_node_script = os.path.join(self.disk_location, &quot;resources&quot;, &quot;my_group_node.nk&quot;)    group_node = nuke.nodePaste(group_node_script)Any code calling the node from within the app can just use the instance returned.Any code needing to call the app from inside the group should do so carefully so that the code is backwards compatible. We recommend the following approach:At app startup, register app handle as part of the nuke namespace:    def init_app(self):        nuke.tk_nuke_nameofmyapp = selfIf you for example have a button on your group node and want to call some ShotGrid app code, try to gracefully fail if the ShotGrid Toolkit cannot be found. The below code is code that is associated with a python button knob that belongs to the group node that the app can create:# have to gracefully support the case when # sgtk is not in the system at all!import nuketry:  app = nuke.tk_nuke_nameofmyapp  app.do_something_v1(nuke.thisNode())except:  nuke.warning(&quot;Could not do XYZ! Most likely Sgtk is not currently active.&quot;)If you make changes to the app behaviour, just keep versioning up the version number on the app callback and that way your app code can support both the new and the old behaviour.Using the ShotGrid Engine for Nuke within HieroThe ShotGrid engine for Nuke is also used for ShotGrid-aware integrations running within Hiero.It allows you to place ShotGrid App actions in several places in the application, both in a specific ShotGrid menu on the main menu bar and in the various right click context menus that you find in the different Hiero panels.How to Configure Hiero MenusBecause Hiero has several different menus, there are more options to configure where menu items go than in Maya or Nuke, for example. The ShotGrid engine for Nuke’s Hiero workflow configuration may look like this:  tk-hiero:    location: {name: tk-nuke, type: app_store, version: v0.6.9}    debug_logging: false    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    bin_context_menu:    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Version up Current Scene...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot History...&quot;, requires_selection: true}    - {app_instance: tk-multi-publish, keep_in_menu: false, name: &quot;Publish Project...&quot;, requires_selection: true}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Shotgun File Manager...}Most engines have a menu_favourites option, a list where you can specify “shortcuts” which are put on the main ShotGrid menu. In addition to this, the Hiero-specific configuration has three special sections:  timeline_context_menu represents the menu you get when you right click on a clip in thetime line editor.  spreadsheet_context_menu represents the menu you get when you right click on a selection ofitems in the spreadsheet editor.  bin_context_menu represents the menu you get when you right click on a selection in of itemsin the bin editor, where you see all the different projects and media.In order to add items to these menus, just make sure that the name field you define in the config matches what the App is displaying on its menus.Apps which require the concept of a current sceneSome Toolkit Apps requires a notion of a default scene or default project. For example, the snapshot app knows how to snapshot the current scene. However, unlike Maya or Nuke, Hiero does not have a concept of a current scene. Several projects can be opened in Hiero at the same time. Therefore, you often need to add special logic in your hooks to help an app (like the snapshot app) to find out which project is being clicked on. We show how this works in the following doc sections.Information for App DevelopersBecause Hiero does not have the notion of a current project, we have added more powerful tools so that Apps can easily find out what is being clicked on inside of Hiero. Therefore, two methods have been added to the ShotGrid engine for Hiero:get_menu_selection()Returns the list of Hiero objects selected in the most recent menu click.This list may contain items of various types. To see exactly what is beingreturned by which methods, turn on debug logging - this will print out detailsof what is going on.Examples of objects that are being returned are:  Selecting a project in the bin view: hiero.core.Bin  Selecting an item in a bin view: hiero.core.BinItem  Selecting a track: hiero.core.TrackItemlist engine_object.get_menu_selection()Parameters &amp;amp; Return Value  Returns: List of Hiero ObjectsExampleGet the objects selected in the most recent click,ensure that a single object was selected and that thisobject is a valid Hiero project. This can be useful for example if you want to triggersave, load or publish operations for a project in Hiero.# get the menu selection from the engineselection = engine_obj.get_menu_selection()if len(selection) != 1:    raise TankError(&quot;Please select a single Project!&quot;)if not isinstance(selection[0] , hiero.core.Bin):    raise TankError(&quot;Please select a Hiero Project!&quot;)project = selection[0].project()if project is None:    # apparently bins can be without projects (child bins I think)    raise TankError(&quot;Please select a Hiero Project!&quot;)HieroEngine.get_menu_category()Returns the UI area where the last menu click took place. This command is lesslikely to be used - you may need it in cases where you have an app command that you wantto behave differently depending on which menu it was called from.area_enum engine_object.get_menu_category()Parameters &amp;amp; Return ValueReturns one of the following constants:  HieroEngine.HIERO_BIN_AREA  HieroEngine.HIERO_SPREADSHEET_AREA  HieroEngine.HIERO_TIMELINE_AREA  None for unknown or undefinedHow to configure your hooks to work with HieroMulti Apps configured for Hiero will typically need to find out which project was being clicked on. For example, the tk-multi-workfiles App needs to do a “ShotGrid Save As” of a project. We therefore add the Tank Save As command to the bin menu in Hiero so that a user can right click a project in the bin view and select the Save As option.The engine configuration would look like this:bin_context_menu:- {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}Now, in the app itself, each engine needs to configure a hook which handles scene events such assave and load. For an application like Maya or Nuke, this is normally just doing a save, a load etc.But for Hiero, we need to start by finding out which project was actually clicked. The hook codein our example above would look like this:class SceneOperation(Hook):    &quot;&quot;&quot;    Hook called to perform an operation with the    current scene    &quot;&quot;&quot;    def execute(self, operation, file_path, context, **kwargs):        &quot;&quot;&quot;        Main hook entry point        :operation: String                    Scene operation to perform        :file_path: String                    File path to use if the operation                    requires it (e.g. open)        :context:   Context                    The context the file operation is being                    performed in.        :returns:   Depends on operation:                    'current_path' - Return the current scene                                     file path as a String                    'reset'        - True if scene was reset to an empty                                     state, otherwise False                    all others     - None        &quot;&quot;&quot;        if operation == &quot;current_path&quot;:            # return the current script path            project = self._get_current_project()            curr_path = project.path().replace(&quot;/&quot;, os.path.sep)            return curr_path        elif operation == &quot;open&quot;:            # open the specified script            hiero.core.openProject(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;save&quot;:            # save the current script:            project = self._get_current_project()            project.save()        elif operation == &quot;save_as&quot;:            project = self._get_current_project()            project.saveAs(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;reset&quot;:            # do nothing and indicate scene was reset to empty            return True        elif operation == &quot;prepare_new&quot;:            # add a new project to hiero            hiero.core.newProject()    def _get_current_project(self):        &quot;&quot;&quot;        Returns the current project based on where in the UI the user clicked        &quot;&quot;&quot;        # get the menu selection from the engine        selection = self.parent.engine.get_menu_selection()        if len(selection) != 1:            raise TankError(&quot;Please select a single Project!&quot;)        if not isinstance(selection[0] , hiero.core.Bin):            raise TankError(&quot;Please select a Hiero Project!&quot;)        project = selection[0].project()        if project is None:            # apparently bins can be without projects (child bins I think)            raise TankError(&quot;Please select a Hiero Project!&quot;)        return projectUsing debug logging to see menu eventsIf you want to see which objects are returned by Hiero when a certain selection is clicked on,just turn on the engine debug mode. In the script editor you get a summary of the objectsthat are selected with each click:",
    "url": "/4dc252e5/",
    "relUrl": "/4dc252e5/"
  },
  "128": {
    "id": "128",
    "title": "Photoshop",
    "content": "PhotoshopThe ShotGrid engine for Photoshop CC provides a platform for integrating ShotGrid into your Photoshop CC workflow. It consists of a standard ShotGrid Pipeline Toolkit engine and relies on the tk-framework-adobe (CEP).Once enabled, a ShotGrid panel becomes available in Photoshop CC. It displays information about the current ShotGrid context as well as the commands that are registered for the apps installed in that context.Interface OverviewThe ShotGrid extension panel uses the same color palette and basic layout as native Photoshop CC panels. It is comprised of five components:  Context Header - Thumbnail and fields for the current context.  Favorites Shelf - Designed to show the most commonly-used apps for the current context.  Command List - All non-favorited commands for the current context.  Context Menu - Additional context-related commands and debugging tools.  Logging Console - A console overlay that displays logging output for debugging.InstallationInstallation of the ShotGrid Engine for Photoshop CC follows the same protocol as the other ShotGrid integrations. For information on installing engines and apps, see the Administering Toolkit article. In addition, you can reference the default toolkit config as an example of how to configure the integration.Enabling the extensionOnce the extension is installed, it will need to be launched via the extensions menu in Photoshop CC.This will only need to be done once and the ShotGrid extension panel can remain in the Photoshop CC layout without having to be enabled on subsequent launches.Once enabled, and on future launches, the extension panel will display a loading screen while the ShotGrid integration is bootstrapping.This screen typically displays for a few seconds before the current context is determined and the commands are displayed.Interface componentsThe following sections outline the components of the ShotGrid Photoshop CC integration.Context headerThe context header is a customizable area which can display information about the current ShotGrid context.The context is determined by the currently-active document. Once the context is determined by the engine, the header will update to display the context’s thumbnail field detail. The field information is controlled by a hook. For information on how to customize the field display, see the Context Fields Display Hook section below.It should also be noted that since Photoshop CC is a multi-document interface, the context, and therefore the ShotGrid extension, will update as you change the active document. It is important that artists understand this behavior, especially when working in multiple ShotGrid contexts simultaneously.Favorites shelfThe favorites shelf is similar to the menu favorites available in other ShotGrid DCC integrations such as Maya and Houdini. This section of the interface makes the most commonly used Toolkit apps readily available and easy to find just under the context header.The shelf displays the favorited commands as buttons that, when moused over, transition from grayscale to color and display their name in the label at the top. Tooltips for the buttons will show by hovering the mouse above them.Clicking one of the buttons will trigger the callback for the registered command to execute.For details on how to specify command favorites, see the Shelf Favorites section below.Command listThe command list shows the other “regular” commands that are registered for the current context.Typically, apps installed within a pipeline configuration will register one or more commands that are displayed here. If the commands are not identified as favorites, and are not identified as context-menu commands, they will display here.The command list buttons behave in a manner similar to those in the favorites shelf. The only real difference is that they display as a list with the full name to the right of their icon.Context menuAny commands registered as context menu commands will show in the ShotGrid extension panel’s context menu.Like the other command areas, these commands will change along with the context. Commands such as Jump to ShotGrid and Jump to Filesystem will always be available here.Logging consoleThe logging console shows all of the logging output from both the CEP Javascript interpreter and Toolkit’s Python process.If there are any issues with the extension that require support, the logging console output is extremely useful for helping the ShotGrid support team debug the problem.Configuration and technical detailsThe following sections outline some of the more technical aspects of the integration to help configure the integration to the specific needs of your studio pipeline.PySideThe ShotGrid engine for Photoshop CC relies on PySide. Please see the official instructions for Installing Pyside.CEP extensionThe extension itself is bundled with the engine and the engine handles installation automatically on the first launch of Photoshop CC. The extension is installed on the artist’s local machine in the standard, OS-specific CEP extension directories:# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Each time Photoshop CC is launched, the engine bootstrap code will check the version of the extension that is bundled with the engine against the version that is installed on the machine. This means that after an engine update, assuming a new version of the extension came with it, the installed extension will be automatically updated to the newly-bundled version.Configuring favoritesThe Favorites Shelf can be configured to display any of the registered commands for your installed apps. To do this, simply add the shelf_favorites setting to the tk-photoshopcc section of your environment configuration. Here’s an example:shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}The value of the setting is a list of dictionaries identifying a registered command provided by one of the installed apps in the configuration. The app_instance key identifies a particular installed app and the name key matches the command’s display name registered by that app. In the example above, you can see four favorited commands: the file open and save dialogs from the tk-multi-workfiles2 app as well as the standard Toolkit publish and snapshot dialogs. These four commands will now show in the favorites shelf.Context fields display hookThe engine comes with a hook to control the fields displayed in the Context Header section of the panel. There are two methods in the hook that can be overridden to customize what is displayed.The first method is the get_entity_fields() method. This method accepts an entity type representing the current ShotGrid context. The expected return value is a list of fields for that entity that should be queried for display. The engine itself handles querying the data asynchronously.Once the data has been queried from ShotGrid, the second method in the hook is called. This method, get_context_html(), receives the context entity dictionary populated with the queried fields specified by the get_entity_fields() method. The expected return value is a string containing formatted HTML to display the queried entity fields.The default hook implementation is a good reference as to what is required by these methods.It should be noted that the engine will always display the entity thumbnail if one is available.Photoshop APIThe engine exposes the Javascript API for Photoshop CC to Python. The full docs for this API can be found here.The Photoshop API object is exposed as engine.adobe. The examples below show how it is possible to directly manipulate the Photoshop DOM from within Toolkit apps and hooks. The standard Toolkit apps also contain working examples of how to interact with Photoshop documents.ExamplesLoad a file:f = adobe.File('/Path/To/File.jpeg')adobe.app.load(f)Set the ruler units to PIXELS:pixels = adobe.Units.PIXELSadobe.app.preferences.rulerUnits = pixelsExport the current doc for the web with default options:temp_thumb_file = adobe.File(out_path)save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()adobe.app.activeDocument.exportDocument(temp_thumb_file, save_for_web, export_options)Export each layer as a separate file:doc = adobe.app.activeDocumentlayers = doc.artLayerslayers = [layers[i] for i in xrange(layers.length)]original_visibility = [layer.visible for layer in layers]save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()for layer in layers:    layer.visible = Falsefor layer in layers:    layer.visible = True    out_file = adobe.File(&quot;c:/layer.%s.jpg&quot; % str(layer.name))    doc.exportDocument(        out_file,        save_for_web,        export_options,    )    layer.visible = Falsefor (i, layer) in enumerate(layers):    layer.visible = original_visibility[i]Environment variablesTo aid in debugging, there are a set of environment variables that change some of the engine’s default values:SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - The Python heartbeat interval in seconds (default is 1 second). The legacy environment variable SGTK_PHOTOSHOP_HEARTBEAT_INTERVAL is also respected if set.SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - The number of heartbeat errors before quitting (default is 2). The legacy environment variable SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE is also respected if set.SHOTGUN_ADOBE_NETWORK_DEBUG - Include additional networking debug messages when logging output. The legacy environment variable SGTK_PHOTOSHOP_NETWORK_DEBUG is also respected if set.SHOTGUN_ADOBE_PYTHON - The path to the Python executable to use when launching the engine. If not set, the system Python is used. If Photoshop is launched from a Python process, like ShotGrid Desktop or via the tk-shell engine, the Python used by that process will be used by the Photoshop integration.Note: Additional environment variables exist in the Adobe Framework. For details, please see thedeveloper documentation.App Developer notes  Because the python process is separate from the Photoshop CC process, there is some work done within the engine to try to make the app windows show above the Photoshop window in as clean a manner as possible. One gotcha with this setup is the default option to use native OS windows for QFileDialog. If you are developing an app for use with this engine, be sureto set the option to not use the native dialog. See an example of this in the tk-multi-pythonconsole app.",
    "url": "/8d461cbe/",
    "relUrl": "/8d461cbe/"
  },
  "129": {
    "id": "129",
    "title": "Shell",
    "content": "ShellThe ShotGrid engine for the shell handles command line interaction and is tightly integrated with the tank command which is distributed as part of the Core API. When you execute the tank command in a terminal, Toolkit launches the engine to handle app execution.",
    "url": "/2ad59ee8/",
    "relUrl": "/2ad59ee8/"
  },
  "130": {
    "id": "130",
    "title": "ShotGrid Folders",
    "content": "ShotGrid FoldersShotGrid Toolkit has a built in system that handles the creation of standardized directory structures based on a configuration. This makes it easy to quickly produce consistent file system layouts for multiple shots.This App hooks up the file system creation API methods in the Sgtk Core API with ShotGrid. This makes folder creation an easy task; just select a collection of Shots or assets and click the Create Folders action.How it worksSimply select one or more Tasks, Shots or other entities (depending on the configuration). Now select create folders from the action menu. Once the process has completed, you will get a report of how many folders were created.",
    "url": "/134adb0e/",
    "relUrl": "/134adb0e/"
  },
  "131": {
    "id": "131",
    "title": "ShotGrid Launch Folder",
    "content": "ShotGrid Launch FolderThe Launch Folder App is a ShotGrid utility which allows you to jump from ShotGrid into the File System.How it worksThe Launch Folder App allows you to jump from ShotGrid into the File System. You can register it for ShotGrid entity types such as Shots, Assets and Sequences. Once activated, it will appear on the Action menu:You can select a single or multiple entries in ShotGrid and when you click the menu action a standard file browser will be launched (Explorer on Windows, Finder on Mac etc.)",
    "url": "/0c3049eb/",
    "relUrl": "/0c3049eb/"
  },
  "132": {
    "id": "132",
    "title": "ShotGrid Launch Publish",
    "content": "ShotGrid Launch PublishThis app adds an “Open in Associated Application” action to the Published File entity in ShotGrid. This makes it easy to open up an already published file: Just navigate to that file, right click on it and select the action.The app makes it easy to configure different app launch sequences for different files – all this is done inside a hook. It also dispatches image sequences to a viewer (such as RV). Files not recognized by the hook will be dispatched to the os-level app.",
    "url": "/a01dbeb7/",
    "relUrl": "/a01dbeb7/"
  },
  "133": {
    "id": "133",
    "title": "ShotGrid",
    "content": "ShotGridThe ShotGrid engine manages apps that can be launched from within ShotGrid. Sometimes we refer to these Toolkit Apps as Actions. They typically appear as items on menus inside of ShotGrid.Using ShotGrid Pipeline Toolkit ActionsActions are visible on the ShotGrid Home page:They can also be found on the standard ShotGrid context menu, which can be shown by right clickingon an object or a selection:When you click on an action, processing will immediately start. Once the app has completed, a message is typically displayed with some status information, or an error message if things didn’t work.Developing Apps for ShotGridDeveloping apps that run inside of ShotGrid is easy! If you are not familiar with how app development works in general, head over to the Platform documentation and read the introductory material over there. In this section we will just cover the ShotGrid specific aspects of the app development process!As of Core v0.13, you can use all the multi apps with the ShotGrid Engine. Technically speaking there is little difference between the ShotGrid engine and other engines. There are, however, some subtle differences:  You will need to manually install PySide or PyQt into your standard python environment if you want to execute QT based apps in the ShotGrid Engine.  It is possible in the ShotGrid engine to make an action visible to a user depending on which permissions group they belong to. This is useful if you want example want to add a command to the ShotGrid Action menu and you only want admins to see it.A hello-world style ShotGrid App, only visible to admins, would look something like this:from tank.platform import Applicationclass LaunchPublish(Application):        def init_app(self):        &quot;&quot;&quot;        Register menu items with ShotGrid        &quot;&quot;&quot;                params = {            &quot;title&quot;: &quot;Hello, World!&quot;,            &quot;deny_permissions&quot;: [&quot;Artist&quot;],        }                self.engine.register_command(&quot;hello_world_cmd&quot;, self.do_stuff, params)            def do_stuff(self, entity_type, entity_ids):        # this message will be displayed to the user        self.engine.log_info(&quot;Hello, World!&quot;)    ",
    "url": "/02c2d8aa/",
    "relUrl": "/02c2d8aa/"
  },
  "134": {
    "id": "134",
    "title": "VRed",
    "content": "VRedThe ShotGrid engine for VRED contains a standard platform for integrating ShotGrid Apps into VRED. It is lightweight and straight forward and adds a ShotGrid menu to the VRED menu.Information for App DevelopersPySideThe ShotGrid engine for VRED contains a PySide installation, and will activate this whenever this is necessary.VRED Project ManagementWhenever the ShotGrid engine for VRED starts, it will set the VRED Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the VRED project is set based on a file can be configured in the configuration file, using the template system.Working with tk-vredThis ShotGrid integration supports the VRED product family (Pro &amp;amp; Design).When VRED opens, a ShotGrid menu (the VRED engine) is added to the menu bar.File Open and SaveUse the My Tasks and Assets tabs to see all your assigned tasks and browse for assets. To the right, use these tabs to view all files, working or published files associated with what is selected to the left.SnapshotSnapshot: Opens the Snapshot dialog to create a quick backup of the current scene. PublishPublish: Opens the Publish dialog for publishing the file to ShotGrid, which can then be used by artists downstream. For more information on VRED Publishing, see hereLoaderLoad: Opens the Content Loader app, along with instructional slides explaining how it works.To see more info about VRED loading see hereScene BreakdownScene Breakdown: Opens the Breakdown dialog, which displays a list of “referenced” files (and their links), along with what in the scene is out-of-date. Select one or more items and click Update Selected to switch and use the latest version of the content.",
    "url": "/9d824e0b/",
    "relUrl": "/9d824e0b/"
  },
  "135": {
    "id": "135",
    "title": "APIs",
    "content": "Toolkit APIsHere you’ll find reference documentation for APIs provided by the Toolkit platform.",
    "url": "/6c5b0b61/",
    "relUrl": "/6c5b0b61/"
  },
  "136": {
    "id": "136",
    "title": "Apps",
    "content": "Toolkit AppsHere you’ll find reference documentation for apps available for the Toolkit platform.",
    "url": "/f8596e35/",
    "relUrl": "/f8596e35/"
  },
  "137": {
    "id": "137",
    "title": "Environment Configuration",
    "content": "Environment Configuration ReferenceIntroductionAt the heart of a Toolkit pipeline is the environment configuration. Within a Toolkit pipeline configuration, the environment configuration files are where you define which Toolkit apps are available within different DCCs and customize the settings for each. This document is a complete reference to the structure and function of the environment configuration files. It covers the Toolkit concept of environments for configuring different workflows within a project, configuration structure, file referencing, and ways to discover what customizations are available.                    Note: While this document acts as a reference to the environment configuration files, you can  see a step-by-step example of editing a configuration setting in the Toolkit Basics Guide on Editing a pipeline configuration.    What is an environment?The ShotGrid Toolkit platform provides a fully customizable set of integrations for commonly used content creation software with which you can build your studio pipeline. Within a project’s configuration, you can specify which software packages have integrations, which specific Toolkit apps are available in each, and your options for each app—building out artists workflows to suit your studio’s needs.But often in studio pipelines, it’s common for different types of artists to have different workflows. As a simple example, for artists working on assets, you might want to make texture painting software such as Mari available, whereas for artists working on shots, you might want to make compositing software such as Nuke available.Beyond just software packages, you might have different settings for the same Toolkit app for different artists. For example, both shot artists and asset artists might use the Workfiles app, but you might want to limit the file navigation to files associated with Shot entities for the former and Asset entities for the latter.To support these different workflows within a project, Toolkit divides its app and engine configurations across environments. An environment contains the integrations and their settings for a set of software packages, all with a certain context in common.In the above example, artists working on assets would be working in an asset step environment, whereas artists working on shots would be working in a shot step environment. Each environment is configured independent of any others, allowing you to have distinct workflows within a project.A note on Toolkit’s Default ConfigurationToolkit gives you a lot of freedom in the way you structure your environment configuration. This document is a reference for all of the options that are available to you, so that you’ll have the necessary knowledge to make choices that best suit the needs of your pipeline.This document will also occasionally cover some of the specific choices we’ve made in the pipeline configuration provided as a starting point, known as the Default Configuration. When you’re ready to customize your pipeline, the first step is to create an editable pipeline configuration for your project.While these choices are only conventions and not hardcoded into the Toolkit workflow, it’s helpful to refer to the Default Configuration as an example for learning what features are available once you start customizing your pipeline and best practices for structuring your own configurations. And, since it’s the suggested starting point for new Toolkit users, it’s helpful to know some of its conventions. We will always distinguish between general features of the Toolkit environment configuration and specific choices in the Default Configuration in this document. For specific details on the Default Configuration’s environment structure, see its README file.File locationsWithin your Pipeline Configuration, the config/ directory contains all the files and folders that are meant to be customized. In config/, you’ll find three sub-directories: cache, core, and env. The env directory holds the environment configuration files, so this document will refer to the files in config/env.In the Default Configuration, you’ll see the following files in config/env/:asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.ymlEach of these files corresponds to an environment; having separate files allows each environment to be configured separately.How Toolkit determines the current environmentToolkit uses a core hook called pick_environment to determine which environment file to use at a given time based on the current context. The pick_environment hook’s return values correspond to environment configuration files. For example, if pick_environment returns shot_step, Toolkit will use config/env/shot_step.yml to configure the Toolkit environment.Custom environmentsThe environment configuration files listed above are the ones provided with the Default Configuration. However, some studios may want to employ different or additional environments. For example, a studio might want different configuration settings for every stage in the pipeline—asset_step_rig, asset_step_model, shot_step_anim, shot_step_light, and so on. Fortunately, you can fully customize the available environments.To do so, add the desired environment config files to the config/env directory. Then, override the pick_environment core hook, adding to it the logic that defines when to use your new environments.Basic structureToolkit’s configuration files are written in YAML. The general configuration structure for any bundle (an app, engine, or framework) is as follows:bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:     type: descriptor_type    descriptor_setting1: value    descriptor_setting2: valueTo demonstrate this structure, here is a very simple example: an environment in which there is a single engine, with a single app defined within it. The following might be the contents of project.yml in this config:engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4The engines blockEvery environment configuration file starts with an engines block. Nested within it are all of the engines defined for that environment.In our example, only a single engine is defined, tk-maya. It has two settings listed, apps and location.location is a special setting that every bundle requires. The apps setting is a list of all the apps defined for the engine, each with its own settings. In this case, only one app is defined for the engine, tk-multi-workfiles2.The location descriptorEvery Toolkit bundle has a location setting, which we refer to as the bundle’s descriptor. The descriptor tells Toolkit where to find the given bundle, and depending on its type, whether to access it directly or cache it locally. Some examples of locations that a Toolkit bundle can come from are the ShotGrid App Store, a git repository, a path on disk, or a zip file uploaded to your ShotGrid site. Each of these has a corresponding descriptor type, with settings specific to that type. Here again is the descriptor for the tk-maya engine from the example above:    location:        type: app_store        name: tk-maya        version: v0.9.4This is a descriptor of type app_store, which tells Toolkit to get the given bundle from the ShotGrid App Store. Descriptors of type app_store have the settings name and version.In contrast, if you are actively developing a custom bundle—say you’re working on writing a Toolkit app for a specific workflow in your studio, you may want to get it directly from a path on disk. In this case you’d use a descriptor of type dev, which might look like this:    location:        type: dev        path: /path/to/appThe dev descriptor has different settings from the app_store descriptor. While it can take other settings, it can be set up simply with a path setting pointing to where the app lives on disk.See the Descriptor section of the Toolkit Core API docs for details on all available descriptor types and their settings.The apps blockApps are Toolkit’s user tools, and each can run independently of any others. You can choose which apps you want to use based on your pipeline needs, and the apps setting within an engine block is where you define which apps are available in a given engine.Here again is the apps setting from our example above:engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8You can see that we have a single app defined, the tk-multi-workfiles2 app. It currently only has a single setting defined:  its descriptor.If you wanted to make other apps available in the tk-maya engine in the project environment, you’d add them here. Let’s add the Panel, tk-multi-shotgunpanel, and the About app, tk-multi-about, to our engine. Our example project.yml file now looks like this:engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4There are a few important things to note at this time:  The Default Config lists bundles in alphabetical order, and this example follows that convention.  The file is beginning to get long, and we haven’t even added any configuration settings yet.  You might imagine that you’ll be using these same apps in other engines and other environments. For example, you’ll probably have all three of these apps—the Panel, the About app, and the Workfiles app—in different engines (say, Houdini, Nuke, or Photoshop), and in different environments (like asset_step or shot_step). Defining common app settings in many places in your config means that when it comes time to make a change, you’ll have to make the modification in many places.To mitigate the last two issues, Toolkit configurations support includes.IncludesIncludes allow you to reference a section of one file in another file in your configuration. Using includes allows you set a configuration setting in one place, but use it in multiple environments.Includes consist of two parts:  The includes list: a YAML dictionary whose key is includes, and whose value is a list of all files we want to include from.  A reference within your configuration settings, prefixed by the @ symbol, and named to point to the name of the section you want to reference from the included file.To flesh out our above example, you might have a single file where you hold the location descriptors for all of your engines. Let’s put that file in an includes subfolder, and call it engine_locations.yml.The contents of engine_locations.yml would look like this:config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...This file can act as a single source for all engine locations, and all of your environment configurations can reference it. Using this include file, our example now looks like this:config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationYou can see here that the value of the location setting for the tk-maya engine is now a reference to a key from the included YAML file.                    Note: Having all engine locations in a config/env/includes/engine_locations.yml file, as we do in this example, follows the convention of the Default Configuration.    You can add a second include file for app locations, and in fact, the Default Configuration does just that. Let’s expand our example:config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationWe’re now getting the tk-maya engine’s descriptor from the included engine_locations.yml file, and the descriptor for each app defined for the tk-maya engine from the included app_locations.yml file.                    Note: The Default Configuration employs a second level of nesting that’s not demonstrated here. Every app or engine that has settings beyond just a descriptor has a settings file in includes/settings (e.g., includes/settings/tk-maya.yml, includes/settings/tk-multi-workfiles2.yml). The engine settings files include app settings from the app settings files, and the environment configuration files include from the engine settings files. For details on the Default Configuration’s structure, see its README file. For a detailed walkthrough of modifying a configuration setting, see the Toolkit Basics Guide on Editing a Configuration Setting.    Sparse configurationsEvery Toolkit bundle has a set of available configuration settings, with a default value for each. Toolkit allows sparse configurations: if a configuration setting is not explicitly specified in the environment config files (and/or the files they include), then the default value from the bundle will be used.In our example, we haven’t specified any settings for our apps aside from location. So, in our configuration’s current state, our three apps will use the default values for all of their settings. So, how do we know what configuration settings are available?                    Note: While it’s not a requirement that Toolkit configurations be sparse, the Default Configuration is a sparse configuration.    Discovering available configuration settingsWith sparse configurations, it’s not immediately evident what configuration settings are available for an app simply by looking at your configuration files. To find out what configuration settings an app has available, you have two choices:  App documentation: Each of our apps has its own documentation page, and each of these pages has a “Configuration Options” section. This section lists all of the available configuration settings for the app, with description and default values for each. You can see the Workfiles documentation page as an example. The Apps and Engines page lists the documentation pages for all apps and engines.  The manifest: Every Toolkit bundle includes a file called info.yml in its root directory. We refer to this file as the bundle’s manifest, and it defines all of the available configuration settings for the bundle, with a description and default value for each. You can find the manifest in your own cache of the bundle (e.g., install/app_store/tk-multi-workfiles2/v0.11.8/info.yml within your pipeline configuration), or in Github (here it is for Workfiles as an example).Modifying configuration settingsTo modify a configuration from the default value, simply add it to the proper block, in the proper environment in your Pipeline Configuration, and set its value.Going back to our example, let’s say that we want to configure tk-multi-workfiles2 so that it launches automatically when Maya is launched in the project environment. We can see in the app’s manifest that there is a launch_at_startup setting that controls whether to launch the Workfiles UI at application startup time, and that its default value is False. So, we’ll just add the launch_at_startup option, and set it to True. Our project.yml file now looks like this:config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationNote that if the settings for tk-multi-workfiles2 were coming from an included file, we’d make this change in that file.Additional resources  Toolkit Basics Guide: Editing a pipeline configuration  Toolkit Basics Guide: Adding an app  Animation pipeline tutorial  Descriptor reference documentation  Webinar: Toolkit administration  File system configuration reference  Default Configuration environment structure README",
    "url": "/c73fcb84/",
    "relUrl": "/c73fcb84/"
  },
  "138": {
    "id": "138",
    "title": "Configuration",
    "content": "Toolkit ConfigurationHere you’ll find reference documentation for configuring the Toolkit platform",
    "url": "/10e8ee51/",
    "relUrl": "/10e8ee51/"
  },
  "139": {
    "id": "139",
    "title": "ShotGrid Event デーモンを使用してさまざまな Toolkit コア モジュールをロードするにはどうすればいいですか?",
    "content": "shotgunEvent デーモンを使用してさまざまな Toolkit コア モジュールをロードするにはどうすればいいですか?Benoit Leveau @ Milk VFX の協力に感謝します。問題Toolkit の sgtk API はプロジェクト中心です。つまり、API を使用するプロジェクトから明示的に API を読み込まなければなりません。つまり、1 つの Python セッションで複数のプロジェクトに対して sgtk API 操作を使用すると、Python では同じ名前のモジュールを 1 回しか読み込めないため、問題が発生します。ShotGrid Event デーモンを使用している場合、特定のイベントについてはプラグイン内で Toolkit のアクションを実行することができます。これは、Python がモジュールを一度しか読み込まないため少々厄介です。そのため、プロジェクト A の Toolkit Core API をプラグインの初回実行時に読み込む場合、このバージョンはデーモンの存続期間中読み込まれたままになります。つまり、プラグインに割り当てられる次のイベントがプロジェクト B 用である場合、プロジェクト A の Core API を使用してプロジェクト B の新しい Toolkit オブジェクトのインスタンスを作成しようとすると、Toolkit にエラーが表示されます。一元管理設定を使用する場合の問題の例:  イベント 123 はプロジェクト A 用である。  プロジェクト A 用の Core API が /mnt/toolkit/projectA/install/core/python に配置されている。  このディレクトリの先頭に sys.path を追加する。  import sgtk でこの場所から読み込む。  この Core API を使用して Toolkit のインスタンスを作成していくつかのアクションを実行する。  sys.path から Core API ディレクトリを取り出す。  イベント 234 はプロジェクト B 用である。  プロジェクト B 用の Core API が /mnt/toolkit/projectB/install/core/python に配置されている。  このディレクトリの先頭に sys.path を追加する。  Python に sgtk が既に読み込まれていると表示されるため、import sgtk は何も実行しない  この Core API を使用して Toolkit のインスタンスを作成していくつかのアクションを実行する。  これにより、Toolkit コアがアクションの実行対象のプロジェクト(B)とは異なるプロジェクト(A)用であるため、エラーが発生します。解決策次の例では、異なるバージョンのモジュールが既に読み込まれている場合にスクリプトやプラグインで正しいバージョンの sgtk コアを読み込む方法を説明します。元の読み込みのロードが解除され、Python のメモリから削除されるため、モジュールの新しいインスタンスを読み込んで適切に使用することができます。&quot;&quot;&quot;Example of how to import the correct sgtk core code in a script wherea different instance of the module may have already been imported. Theoriginal import is unloaded and removed from memory in Python so the newinstance of the module can be imported and used successfully.Thanks to Benoit Leveau @ Milk VFX for sharing this.&quot;&quot;&quot;import osimport sysdef import_sgtk(project):    &quot;&quot;&quot;    Import and return the sgtk module related to a Project.    This will check where the Core API is located on disk (in case it's localized or shared).    It shouldn't be used to get several instances of the sgtk module at different places.    This should be seen as a kind of 'reload(sgtk)' command.    :param project: (str) project name on disk for to import the Toolkit Core API for.    &quot;&quot;&quot;    # where all our pipeline configurations are located    shotgun_base = os.getenv(&quot;SHOTGUN_BASE&quot;, &quot;/mnt/sgtk/configs&quot;)    # delete existing core modules in the environment    for mod in filter(lambda mod: mod.startswith(&quot;tank&quot;) or mod.startswith(&quot;sgtk&quot;), sys.modules):        sys.modules.pop(mod)        del mod    # check which location to use to import the core    python_subfolder = os.path.join(&quot;install&quot;, &quot;core&quot;, &quot;python&quot;)    is_core_localized = os.path.exists(os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;_core_upgrader.py&quot;))    if is_core_localized:        # the core API is located inside the configuration        core_python_path = os.path.join(shotgun_base, project, python_subfolder)    else:        # the core API can still be localized through the share_core/attach_to_core commands        # so look in the core_Linux.cfg file which will give us the proper location (modify this        # to match your primary platform)        core_cfg = os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;core_Linux.cfg&quot;)        if os.path.exists(core_cfg):            core_python_path = os.path.join(open(core_cfg).read(), python_subfolder)        else:            # use the studio default one            # this assumes you have a shared studio core installed.            # See https://support.shotgunsoftware.com/entries/96141707            core_python_path = os.path.join(shotgun_base, &quot;studio&quot;, python_subfolder)    # tweak sys.path to add the core API to the beginning so it will be picked up    if sys.path[0] != &quot;&quot;:        sys.path.pop(0)    sys.path = [core_python_path] + sys.path    # Remove the TANK_CURRENT_PC env variable so that it can be populated by the new import    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    # now import the sgtk module, it should be found at the 'core_python_path' location above    import sgtk    return sgtk分散設定上の例では、一元管理設定を使用していると想定しており、分散設定を使用している場合は、状況が多少異なります。分散設定用の sgtk API を読み込むには、ブートストラップ APIを使用する必要があります。ブートストラップ API を使用する場合は、通常プロジェクト中心ではない sgtk API を読み込むことから始め、それを使用して特定のプロジェクトのエンジンをブートストラップします。ブートストラップ プロセスは sgtk モジュールのスワップ アウトを処理するので、ブートストラップ プロセスの最後にはエンジン オブジェクトがあります。ブートストラップの後に sgtk を読み込むと、プロジェクトに適した適切な sgtk モジュールが読み込まれます。上記の例のように複数のプロジェクトに対して sgtk をロードする必要がある場合は、代わりに複数のプロジェクトに対してブートストラップする必要があります。ここで少し問題になるのは、一度に実行できるエンジンは 1 つであるため、別のエンジンをロードする前に現在のエンジンを破棄する必要があることです。                    警告: 設定をブートストラップする場合、設定をローカルにキャッシュし、すべての依存関係をダウンロードする必要があるため、処理が遅くなる可能性があります。Event デーモン プラグインのブートストラップはパフォーマンスに深刻な影響を与える可能性があります。考えられるアプローチの 1 つは、プロジェクトのブートストラップごとに別々の Python インスタンスを生成し、プラグインからの通信によりコマンドを送信することです。これにより、必要になるたびにプロジェクトをブートストラップし直す必要がなくなります。    次に例を示します。# insert the path to the non project centric sgtk APIsys.path.insert(0,&quot;/path/to/non/project/centric/sgtk&quot;)import sgtksa = sgtk.authentication.ShotgunAuthenticator()# Use the authenticator to create a user object.user = sa.create_script_user(api_script=&quot;SCRIPTNAME&quot;,                            api_key=&quot;SCRIPTKEY&quot;,                            host=&quot;https://SITENAME.shotgunstudio.com&quot;)sgtk.set_authenticated_user(user)mgr = sgtk.bootstrap.ToolkitManager(sg_user=user)mgr.plugin_id = &quot;basic.&quot;engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity={&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176})# import sgtk again for the newly bootstrapped project, (we don't need to handle setting sys paths)import sgtk# perform any required operations on Project 176 ...# Destroy the engine to allow us to bootstrap into another project/engine.engine.destroy()# now repeat the process for the next project, although we don't need to do the initial non-project centric sgtk import this time.# We can reuse the already import sgtk API to bootstrap the next...                    注: 一元管理設定もブートストラップすることができるので、両方の設定が混在する場合は別の方法は必要ありません。    ",
    "url": "/3520ad2e/",
    "relUrl": "/3520ad2e/"
  },
  "140": {
    "id": "140",
    "title": "Engines",
    "content": "Toolkit EnginesHere you’ll find reference documentation for engines available for the Toolkit platform.",
    "url": "/3a69db47/",
    "relUrl": "/3a69db47/"
  },
  "141": {
    "id": "141",
    "title": "Frameworks",
    "content": "Toolkit FrameworksHere you’ll find reference documentation for frameworks available for the Toolkit platform.",
    "url": "/c6db88dd/",
    "relUrl": "/c6db88dd/"
  },
  "142": {
    "id": "142",
    "title": "An Overview of Toolkit",
    "content": "An Overview of ToolkitAn overview of the different concepts in the ShotGrid Pipeline Toolkit.Here, we cover the main concepts in detail: How apps and Engines work, how Toolkit is launched and manages the current context (work area), how folders are created on disk, etc. We recommend that anyone involved in configuration or development start here.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For details, see the  ShotGrid Integrations Admin Guide.IntroductionThis document explains some of the key features in more depth. With explanations, examples and small demos, we show what Toolkit is all about. This document is a good starting point if you want to familiarize yourself with Toolkit or if you want to understand how Toolkit could add value to your studio. After you have read it, you’ll have a good grasp of some of the key concepts and how they work in practice.Below is a brief description of Toolkit (SGTK):  Toolkit is a  Pipeline Toolkit  based on the ShotGrid platform - it makes it easier to write and install tools for a studio.  Toolkit is filesystem based - it helps you organize where things are stored on disk so that what you have on disk is nicely structured.  Toolkit is an assistant - it does not try to take over or abstract the data in your pipeline, but rather is there to provide artists with compelling tools to make finding information easier and avoid making mistakes.  Toolkit is helping you to share work by storing all of its publishes in ShotGrid. Toolkit makes it easy to share updates and work that is going on across a production.In the following sections, we will be looking in depth at the Toolkit and how it works.Projects and ConfigurationsIn Toolkit, everything is project centric. A project typically starts its lifecycle inside of ShotGrid, goes through a bidding and a pre-production phase, and then once it is ready for the content-creation phase Toolkit can be set up for that project.When you set up a new project, you use a template configuration. This is a predefined config containing engines and apps, filesystem configuration, and other settings. If you are just starting with Toolkit, you can use our example configuration as a starting point for your exploration. If you have already been using Toolkit on another project, we suggest that you take that configuration and use that as the starting point for your new project. That way, you will be evolving a studio configuration and it will be refined with each new project. Of course, you can also maintain a studio configuration separately and use this as a template for all new projects.Each configuration defines a number of storage points. For the standard sample configuration, tk-config-default, we define a single storage point called  primary. This means that all your production data will be under a single filesystem project root. You can also set up configs with more than a single file system root. We call these multi-root configurations. Examples of when you might need multi-root configurations include having a separate storage for renders, a separate storage for editorial, etc. Each of these storage points need to exist as a Local File Storage in ShotGrid, which can be set up in the Site Preferences, under the File Management tab.Toolkit will install the actual project configuration in any location you like. Typically this will go into a  software install area on disk and not into the project data area itself.Let your studio configuration evolveWhen you set up a new project, you can base it off of an existing project. Toolkit will then copy the configuration folder from that project to your new project. This means that your new project will get exactly the same versions of apps and engines, the same settings and the same customizations as the project you are basing it on. This can be useful if you want to evolve your pipeline and take advantage of improvements and tweaks that have happened as part of an existing production.Alternatively, you can just take the configuration folder from a project when you are happy with that project’s setup and save it in a central location somewhere. This config can then be used as a studio template and each time you create a new project you can base it off this config. If you want, you can even source control this studio template config using a revision control system, such as git or something similar, and tracking how the pipeline configuration template evolves over time becomes simple and transparent. Whenever you want to update it, just copy the config from one of your projects and commit the changes.For detailed information about configuration management, check out our detailed docs:Managing your project configuration.Each Project has a Pipeline ConfigurationWhenever you set up Toolkit for a project, a pipeline configuration is created. This configuration contains all the settings and files needed for the project. The configuration has a dedicated tank command which you can run in a shell if you want to address the project directly (there is also a global tank command that works with all projects). In ShotGrid, the Pipeline Configuration has been registered as a special Pipeline Configuration Entity to make it easy to keep track of where your project configurations reside on disk.In addition to the master config that is created when the project is set up, you can create additional configurations for a project. This is often useful if you want to make changes to the configuration without affecting everyone on the project. If you want to do this, you can navigate to a pipeline configuration in ShotGrid, right click it and choose to clone it. This will create a new pipeline configuration for a project, based on another one, and using the new configuration you can safely test out a new app without affecting other users.Please note that the main configuration for a project needs to be named Primary. If you rename, modify or delete it, things may not work as expected. The Pipeline Configurations stored in ShotGrid are not intended to be manipulated by hand, but rather through various specific tank administration commands.Example:How to clone a configurationChecking for updatesSimilar to other App stores out there, the Toolkit app store constantly gets new versions for apps and engines. These new versions may contain important bug fixes or interesting new features. Upgrading your apps and engines is completely optional. It is normally a quick process and the upgrade scripts will always prompt you before making any changes. Likewise, it is straightforward to roll back should you have accidentally installed an unsatisfactory version.A single command handles the upgrade process. Simply run the  tank  command located in your project configuration folder and add an  updates  parameter:/software/shotgun/bug_buck_bunny/tank updatesRunning this command with no parameters will check all environments, engines and app. This may take a long time, but you can also run the updater on a subset of your installed apps and engines.General syntax:tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:  Check everything:  tank updates  Check the Shot environment:  tank updates Shot  Check all maya apps in all environments:  tank updates ALL tk-maya  Check all maya apps in the Shot environment:  tank updates Shot tk-maya  Make sure the loader app is up to date everywhere:  tank updates ALL ALL tk-multi-loader  Make sure the loader app is up to date in maya:  tank updates ALL tk-maya tk-multi-loaderIn addition to checking the app store, this script checks all other registered locations too, so it may query your local git, a GitHub repository, a file on disk and the app store, depending on where you have deployed your apps.Please note that a new version of an app may introduce changes to the app configuration. For example, there may be a new feature which requires a new configuration parameter. In that case, the tank upgrade script will prompt you to type in values for these parameters.Checking for updates to the Core APISometimes we release new versions of the Toolkit Core API. A separate command is used to update the Core API. In this case, the command is tank core.Creating folders on diskOnce Toolkit has been set up for your project, you can use it to help you create a consistent folder structure. This folder structure is configured by creating a filesystem template as part of the pipeline configuration on disk. In this folder structure, some of the paths will be dynamic - for example, you may have a folder called asset that represents a ShotGrid Asset entity. These dynamic folders can be connected to ShotGrid queries and many other things.Toolkit provides a number of different dynamic folder types that handle different setups and scenarios. You can use the standard ShotGrid API query syntax when you set up your folder creation, so you could organize your filesystem so that assets with different types end up in different folders on the filesystem.For a detailed walkthrough of how this works, see the admin guide:Administering the ShotGrid Pipeline ToolkitToolkit’s folder creation happens in two passes: a direct pass, which can be run by anyone at any time, and a deferred pass, which is typically run by the artist just before application launch. This deferred pass is completely automatic and can be used to set up application-specific folders and user sandboxes.The Current ContextOnce the filesystem structure has been created, Toolkit knows the relationship between a folder on disk and the ShotGrid object that the folder came from. This is important, because it allows Toolkit to easily associate an object in ShotGrid with a folder or disk, or file, when publishing, loading or resolving paths. It also relates to what we call the context or sometimes the current work area. The context object is part of the Toolkit Core and tracks the current thing that is being worked on. It is a central mechanism when Toolkit resolves filesystem paths.The context can be created either from a ShotGrid object, such as a Task, Asset or Shot, or from a path on disk. When apps are running, they can always access the context, and this makes it easy to construct apps that have no knowledge of the filesystem naming conventions or whether the app is used in an Asset or Shot pipeline. This is all handled by the Toolkit Core API and the context.Filesystem TemplatesThe Toolkit Core contains a system for handling file paths. It is called the Templates System. Since Toolkit is filesystem based, apps will need to resolve file paths whenever they need to read or write data from disk. Apps are filesystem-structure agnostic, meaning that they don’t know how the filesystem is organized. The template system handles all this for them.At the heart of the template system, there is a Templates Configuration File. This file contains all the important filesystem locations for a project. A  Template looks something like this:maya_shot_publish: 'shots/{Shot}/{Step}/pub/{name}.v{version}.ma'It defines a path which contains certain dynamic fields. Each field can be configured with validation and typing, so that, for example, you can define that the {version} field in the template above is an integer padded with three zeros (e.g. 001, 012, 132). Whenever and app needs to write or read something from disk, a template is added to the templates file to describe that location. Since apps often are set up to form a pipeline, the output template of one app (e.g. a publishing app) is often the input template of another app (e.g. a loading app). This is why all of the filesystem locations are kept in a single file.The template API lets you jump between a list of field values and paths:# get a template object from the API&amp;gt;&amp;gt;&amp;gt; template_obj = sgtk.templates[&quot;maya_shot_publish&quot;]&amp;lt;SGTK Template maya_asset_project: shots/{Shot}/{Step}/pub/{name}.v{version}.ma&amp;gt;# we can use the template object to turn a path into a set of fields...&amp;gt;&amp;gt;&amp;gt; path = '/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'&amp;gt;&amp;gt;&amp;gt; fields = template_obj.get_fields(path){'Shot': '001_002', 'Step': 'comp', 'name': 'main_scene', 'version': 3}# alternatively, we can take a fields dictionary and make a path&amp;gt;&amp;gt;&amp;gt; template_obj.apply_fields(fields)'/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'Note how the above path and template has two different types of fields. The Shot and Step fields are high-level fields with equivalent objects in ShotGrid (a Shot and a Pipeline Step) where the name and the version fields are very specific to this particular type of template. If we wanted to describe a publish path for an Asset rather than a Shot, we would still have a name and a version field, since this is needed for all publishes, regardless of what type of data it is. However, we would not have a Shot and a Step field. Instead, we may have an Asset and a Step field, where the asset field would be associated with an asset in ShotGrid.When we develop an app that does publishing, we obviously don’t want to have a separate app that does Shot publishing and one that does Asset publishing. Instead, we want a single publishing app that can handle any publish scenario, regardless of whether it is a Sequence, Shot, Asset or whatever.This is where the Toolkit Context comes into play. The Toolkit Context allows us to split the template fields into two distinct groups: the Context fields (Shot, Step, Asset, etc) are fields that we want to ensure are resolved outside of the app in such a way that the app’s logic will not have to have code that specifically handles concepts such as Shots and Assets. Instead, the app should only populate the fields that are directly associated with the particular  business logic of the app. In our example of a publish app, the business logic consists of the name and the version fields. As the figure above illustrates, Toolkit therefore splits the field resolution into two distinct phases: some fields are populated by the context and some fields are populated by the business logic inside the app. This way, apps can be designed that are not tied to a particular filesystem layout. We believe this is an important aspect of building good pipeline tools.The App Code that would deal with the path resolve would typically look something like this:# start with an empty fields dictionaryfields = {}# first let the context populate all its fieldsfields.update( self.context.as_template_fields( publish_template_obj ) )# fields is now {'Shot': '001_002', 'Step': 'comp' }# now the app can add its business logicfields[&quot;name&quot;] = &quot;main_scene&quot;fields[&quot;version&quot;] = 234# and finally the app can produce the path it needs in# order to save out the filepath = publish_template_obj.apply_fields(fields)For more details of how you can configure and use the Templates API, see the following:File System Configuration ReferenceCore API ReferenceChoosing which Engines and Apps to runAnother important role that the Toolkit Core plays is in deciding which Apps should be presented to a user. If you are working on character rigging and start up Maya, you probably want a different collection of apps than if you are doing lighting on a shot. Furthermore, the apps can be configured differently depending on how you want them to operate, so a review app for rigging may be generating a turntable, whereas the same review app is doing a playblast using the shot camera when an animator runs it.In order to allow for this flexibility, a Toolkit project configuration contains a collection of environments. An environment is a configuration file that defines a collection of apps and engines and all their configuration parameters.When Toolkit starts up, it needs to decide which environment to initialize. This is done via a piece of Python code called a hook, where you can add your own business logic. The context object is passed into this piece of code and this is often what is used to determine which environment to use.This makes it possible to configure separate collections of apps for different parts of the pipeline. Furthermore, you can also update them independently and even have different supervisors managing them separately.Environments in the Default ConfigurationTo give you a practical example of how environments work and can be structured, let’s take a look at the environments that come with the default configuration:  project.yml - Apps and Engines to run when the context only contains a project.  shot_and_asset.yml - Apps and Engines to run when the context contains a shot or an asset.  shot_step.yml - Apps ane Engines when the context contains a Shot and a Pipeline Step.  asset_step.yml - Apps and Engines when the context contains an Asset and a Pipeline Step.The default config has organized its filesystem based on pipeline steps. This means that under a Shot location, you can find folders for modeling, rigging, etc. Essentially, there is one folder for each pipeline step you work on. Each of these folders have its own work and publish areas on disk. This means that a publish template may look like this:maya_shot_publish: 'sequences/{Sequence}/{Shot}/{Step}/pub/{name}.v{version}.ma'In order to use this template, the context needs to contain both an entity and a Pipeline Step. For Shot 1122, parented under Sequence ABC and pipeline step Modeling, the above template would resolve to  sequences/ABC/1122/Modeling/.... This means that a context that contains a Shot but not a Pipeline Step is not enough to populate the above template. You cannot launch Maya for a Shot-only context and use the above template. In order for it to be functional, a Step is required.This leads us to the environment breakdown shown above. Because the filesystem structure defined in the default configuration is centered around steps, all the main apps need to run in a context which has a step defined. We define two such environments in the default config: the asset_step.yml file and the shot_step.yml file. Each of these files contain engines for a number of DCCs, such as Maya, Nuke, 3dsmax, Motionbuilder, and Photoshop to mention a few. When you launch Maya from a Task inside of ShotGrid, the pick environment hook will choose the shot_step environment, start Maya and load up the Maya app configuration.It can also be useful to launch Maya directly from a Shot object inside of ShotGrid. More importantly, it can be really useful to be able to type in a console tank Shot 1122 launch_maya. This is where the shot and asset environments come in. When you load Maya with a context which contains a Shot or Asset but no Pipeline Step, it will load one of these environments. Since the filesystem structure is all organized per Pipeline Step, it is not really possible to do any loading or publishing if we are missing that information in our context. Maya instead launches with a bare configuration, only containing the Workfiles app. This app lets you choose a Task to work on. Once you have picked a Task, Toolkit switches the context and restarts the engine for you and will load up the shot_step environment with the full range of apps.Similarly, the project environment is a catch-all fallback, also just containing the Workfiles app. This makes it possible to launch Maya from pretty much anywhere inside the project and it will initialize Toolkit in a minimal state, allowing you to jump to a valid work area using the Workfiles app.Configuring AppsEach app has number of configuration parameters that need to be specified. When you install or upgrade an app, Toolkit makes sure that you have specified all the required settings.Simple setting values such as strings or integers are specified directly in the environment config. Templates are different, and since Toolkit wants to keep all templates in a single place, the environment file merely points to templates defined in the templates file. Each app will require different fields to be present in the templates that it uses in its configuration. In our previous example, the publish app was using a template with the fields name and version when creating its output files on disk. The app would therefore have a configuration setting which requires a template containing the fields name and version.If you try to configure the app using a template that has more than the context fields (name and version), the app would not know how to populate these additional fields and would not be able to generate a path from that template. Similarly, if you provided a template that was missing one of the fields it would lead to confusing results; in our case, version numbers would not be written out of the app. Therefore, Toolkit will validate the configuration at startup to make sure that the necessary fields are provided for all templates. Toolkit also supports several ways of using default values and optional fields.For a complete reference, check the following links:Apps and Engines Configuration ReferenceFile System Configuration ReferenceHooksIn addition to app settings using templates, Toolkit also supports a concept called hooks. Hooks are small snippets of Python code, allowing you to customize parts of the app as part of your configuration.Here’s how it works and why it is useful:Apps are powerful because they can be reused across multiple engines and projects. But apps tend to need some small snippets of engine-specific logic. For example, if we are building a loader app which should work both in Nuke and Maya, there will need to be code that handles the actual file load and this code will have to be different in Nuke and Maya. Furthermore, it would be great if it would be possible to use this app with any engine! Different studios may also have different ways to load items into a scene, and someone may need to support a custom Maya reference node where other studios may just do an import.This situation is handled in Toolkit using a hook. The hook is a customizable piece of code. The App comes with a default hook which contains a base level implementation, meaning that the app will work fine right out of the box. However, if you want to customize the behaviour you can copy that hook file into your configuration and Toolkit will use that code instead.Read more about how to work with hooks in the Admin guide.Running from ShotGrid and the ShellOnce Toolkit is installed, you can access it from several primary entry points:  ShotGrid Actions will appear on the right-click menus inside of ShotGrid  Launch icons will appear for the project in the ShotGrid Desktop app  You can use the tank command in a console.  The Toolkit Python API is available both inside applications and in the shell.Running the Toolkit from within ShotGrid is a common way of starting applications and carrying out tasks. ShotGrid will use ShotGrid Desktop to communicate with the Toolkit install that is local on your machine and use a local Python to execute a Toolkit command. This means that you can run local operations such as folder creation right from inside of ShotGrid.You can also access Toolkit from a shell. Each project configuration comes with its own tank command. Simply navigate to your project configuration root and execute the ./tank command from there.Lastly, you can simply add the Toolkit API to the PYTHONPATH environment variable and import it. Using the API is straightforward and if you want to start up Toolkit inside of Maya manually or as part of an existing studio launch system instead of using ShotGrid Desktop, all you need to execute is a couple of simple commands.PublishingWhen you want to share files that you are working on with others, you can publish them. What this means is that a PublishedFile entity is created in ShotGrid which other users can import using Toolkit’s loader app.The details of exactly what this means in terms of the data management (where on disk things are saved, what the file contains, etc) is left to the app doing the actual work. The Toolkit API provides developers with methods to easily create publishes inside of ShotGrid and link these up to the right objects to ensure that ShotGrid can go ahead and push notifications to all the right people. We also provide a default publish app that is meant to be versatile and highly configurable, but this is by no means the only way to implement version control using Toolkit. Because Toolkit is extensible, you could build your own custom version control and publishing system using Toolkit if this is desirable.As a starting point, however, we recommend our Publish App:The Default Multi Publish App.Building Reusable AppsToolkit is not just a collection of apps and engines. It is also a framework that you can use to develop your own tools and technologies! We have included a lot of features to make Toolkit a rich studio development platform. With Toolkit as a foundation, you can focus on the problems at hand rather than building the underlying platform yourself. We have tried to make it easy for developers to build, evaluate and release software without accidentally breaking the pipeline for artists.  The engines ensure that apps can be written in Python and Qt (PySide/PySide2) regardless of the underlying foundation. This means that some engines are very simple, while some engines are more complex depending on their provided APIs. This means that there is a straightforward, consistent way to develop tools for the studio. In our experience, Python and Qt is often found being the development environment studios use and many TDs are familiar with it.  The engine layer also means that apps can be written once and then be deployed in multiple environments. We have developed the standard app suite as Multi Apps, meaning that the same app is used in all engines. There will inevitably be specific code that needs to be tailored to work with the specific API that each DCC application exposes, but this is typically contained in one or more hooks, making it easy to reuse an app. Another consequence of being able to create multi apps like this is that when a new engine is being developed, all the standard apps can be easily configured to work with that new engine.  Via Pipeline Configurations and Cloning, it is easy to create a development sandbox, allowing developers to do work on a production without interfering with the day-to-day production activity. Once the tools are ready to be deployed, the main project configuration can be easily updated and the tool is rolled out to all artists.  Since apps run inside an engine, it is easy to reload them. Instead of having to restart Nuke or Maya every time you want to test a new code change, simply hit the reload button in Toolkit and the latest code is loaded in.For an more extensive introduction to App Development, see the following documents:An Introduction to the Toolkit App Development.The Toolkit API ReferenceApps and Engines Configuration Reference",
    "url": "/e95205a8/",
    "relUrl": "/e95205a8/"
  },
  "143": {
    "id": "143",
    "title": "概要",
    "content": "Toolkit プラットフォームToolkit は、アーティスト向けアプリケーションおよびパイプライン ツールを ShotGrid と統合するための拡張可能なプラットフォームです。Toolkit のコア API は、すべての統合を構築するためのプラットフォームです。Core API は、アプリケーション、エンジンおよびプラットフォームの基本、ファイル システムの整理とツールの配置を処理します。",
    "url": "/3d1cd26d/",
    "relUrl": "/3d1cd26d/"
  },
  "144": {
    "id": "144",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationThe goal is to set up an AWS PrivateLink to privately access your ShotGrid site.Set up PrivateLink to ShotGrid      Ask ShotGrid support to provide you with the ShotGrid PrivateLink service name for your AWS region.        Update the private VPC CloudFormation stack you created earlier and set ShotGridPrivateServiceName parameter.  Manual steps if needed      Add a new VPC Endpoint in your VPC        For the security group, ShotGrid service only requires the inbound port tcp/443 to be open.  DNS ConfigurationProvide your PrivateLink DNS name to ShotGrid support. We will setup a new private URL for your site that will look like mystudio-staging.priv.shotgunstudio.com.ValidationVerify that your site private URL resolves to IPs in your AWS VPC block.nslookup mystudio-staging.priv.shotgunstudio.comTry to access your test site from inside your office ie https://mystudio-staging.priv.shotgunstudio.comNext StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/d9ef03ce/",
    "relUrl": "/d9ef03ce/"
  },
  "145": {
    "id": "145",
    "title": "トラブルシューティング",
    "content": "トラブルシューティング問題のトラブルシューティングを目的としたクイック アンサーのコレクションです。一般的なトラブルシューティングのヘルプ  パフォーマンスのトラブルシューティング  デバッグ ログをオフにするにはどうすればいいですか?  ログ ファイルはどこにありますか?  タスク/ステップがファイル名の一部としては存在しているのにコンテキストで見つからないのはなぜですか?  Python API で発生する SSL: CERTIFICATE_VERIFY_FAILED の問題の解決ソフトウェア統合  Houdini ShotGrid 統合が起動しないのはなぜですか。  SG Desktop から Nuke や Maya などを起動したが ShotGrid のメニューにエントリが表示されない  環境変数 NUKE_PATH を設定すると Nuke 統合の起動に失敗するのはなぜですか?  2 つの機能拡張がインストールされている場合の Photoshop 統合のトラブルシューティング  ShotGrid Toolkit を使用すると 3ds Max の起動時にクラッシュするのはなぜですか?ブラウザの統合  ローカル ファイル リンクを使用できず、Chrome から Toolkit アプリケーションを起動できない  ローカル ファイル リンクを使用できず、Firefox から Toolkit アプリケーションを起動できない  Linux で ShotGrid Desktop/ブラウザ統合の起動に失敗する",
    "url": "/7ef5be1d/",
    "relUrl": "/7ef5be1d/"
  },
  "146": {
    "id": "146",
    "title": "Fine Tuning",
    "content": "Fine TuningCost Management RecommendationsS3 Infrequent AccessWe recommend enabling S3 Infrequent Access to easily reduce costs without impacting performance. For the ShotGrid Cloud hosted offering, we apply a policy for all objects older than one month.With Infrequent Access, objects are stored at a lower cost. However, if they are accessed, it will involve an additional cost. ShotGrid has observed that one month was the right policy to use globally, but you may want to adapt that policy to your studio workflows as needed.Read more about S3 Infrequent Access and other storage classes here.S3 Bucket policyWe recommend you restrict access to your S3 bucket to only your VPC and ShotGrid transcoding services IPs. There is an example policy, replace your_vpc_id and your_s3_bucket by your values.We strongly recommend you test media access and media transcoding in your migration test site right after applying the bucket policy changes to be sure your S3 bucket is still accessible from your VPC and from ShotGrid transcoders.{    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Id&quot;: &quot;Policy1415115909152&quot;,    &quot;Statement&quot;: [        {            &quot;Sid&quot;: &quot;AllowSSLRequestsOnly&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: [                &quot;arn:aws:s3:::your_s3_bucket&quot;,                &quot;arn:aws:s3:::your_s3_bucket/*&quot;            ],            &quot;Condition&quot;: {                &quot;Bool&quot;: {                    &quot;aws:SecureTransport&quot;: &quot;false&quot;                }            }        },        {            &quot;Sid&quot;: &quot;Access-to-specific-VPC-only and Shotgun transcoder&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: &quot;arn:aws:s3:::your_s3_bucket/*&quot;,            &quot;Condition&quot;: {                &quot;NotIpAddress&quot;: {                    &quot;aws:SourceIp&quot;: [                        &quot;34.200.155.69/32&quot;,                        &quot;34.224.232.103/32&quot;,                        &quot;34.202.127.170/32&quot;                    ]                },                &quot;StringNotEquals&quot;: {                    &quot;aws:sourceVpc&quot;: [                        &quot;vpc-2fd62a56&quot;,                        &quot;your_vpc_id&quot;                    ]                }            }        }    ]}S3 endpoint policyWe recommend setting a VPC endpoint policy on your S3 endpoint to allow access to your S3 bucket only. See here for an example.Application Load Balancer  We recommend you enable deletion protection on the S3 proxy load balancer to prevent accidental deletion.  We recommend you enable access logging on the S3 proxy load balancer to aid in traffic analysis and identification of security issues.Next StepsSee Migration to migrate your production site to use the isolation features.Go to Setup for an overview of the possible next steps.",
    "url": "/26190270/",
    "relUrl": "/26190270/"
  },
  "147": {
    "id": "147",
    "title": "デバッグ ログをオフにするにはどうすればいいですか?",
    "content": "デバッグ ログをオフにするにはどうすればいいですか?ShotGrid Desktop によるデバッグを有効にするデバッグを有効にする最も簡単な方法は、ShotGrid Desktop アプリを使用してオンに切り替えることです。これは、ShotGrid Desktop にログインした後で設定できます。アプリの右下にあるプロファイル画像をクリックして、[Advanced] -&amp;gt; [Toggle Debug Logging]を選択します。この設定はセッションの終了後も維持されるため、デバッグが終了したら忘れずにオフにしてください。デバッグをオンにすると、ShotGrid Desktop から起動されたアプリ、またはブラウザ統合を介した Toolkit コマンドも、このデバッグ状態を継承することに注意してください。環境変数をセットアップするデバッグ ログを常にオンにする最初に、新しい環境変数 TK_DEBUG=1 をセットアップする必要があります。                    注: 手順はプラットフォームによって異なるため、スタジオ内の専門家を集めて環境変数をセットアップする方法について話し合うことをお勧めします。次の例では、Windows 7 マシンで環境変数をセットアップする方法について説明しています。    Windows 7 を使用する場合  デバッグ ログを常にオンにするには、Windows アイコン &amp;gt; [コントロール パネル] &amp;gt; [システム] &amp;gt; [システムの詳細設定] &amp;gt; [環境変数…] &amp;gt; [新規…]にアクセスします  変数名: TK_DEBUG  変数の値: 1  [OK]を選択します。これで、環境変数が正しくセットアップされ、デバッグ ログがオンになりました。                    注: ログを有効にするために Desktop を必ず再起動してください。    デバッグ ログをオフにするには、次のいずれかを実行します。a. TK_DEBUG 環境変数を 0 に設定します。b. TK_DEBUG 環境変数を削除します。環境変数が既に設定されているかどうかを確認する環境変数が正しく設定されているかどうかを確認するには、ターミナルを開いて set コマンドを実行します。次に、TK_DEBUG=1 を検索します。これにより、Desktop を起動すると、デバッグ ログがオンになります。デバッグ ログを一時的にオンにするセッションの代わりにデバッグ ログを一時的に使用する場合は、ターミナルを開き、set TK_DEBUG=1 コマンドを使用してデバッグ ログを設定できます。次に、ターミナルを介して Desktop を起動します。                    注: ShotGrid Desktop とターミナルを閉じると、デバッグ ログはオンではなくなります。    ログ ファイルでデバッグ出力を確認するログ ファイルはどこにありますか? ドキュメントを参照してログ ファイルの場所を特定します。詳細設定のデバッグ ログ オプション詳細設定にはいくつかのオプションがあります。 この機能は、Toolkit の設定をコントロールできる場合のみ利用可能です。すべてのエンジンの環境ファイルには debug_logging 設定があります。これをオンにすると、ソフトウェア(Nuke または Maya のスクリプト エディタなど)の既定の出力に追加のデバッグレベル ログ メッセージが送信されます。 エンジンで実行中のアプリすべてがこのようなデバッグ レベルのメッセージを発行するため、エンジンでこの設定をオンにすると、すべてのアプリの設定も実質的にオンになります。これにより、ファイルにログ メッセージが出力されることはありません。標準的なロギング フレームワークでこの出力が可能になるように現在取り組んでいます。例外は SG Desktop および Photoshop エンジンで、これらは出力を GUI コンソールとファイルの両方に記録します。ソフトウェアでエンジンのデバッグ ログをオンにするたとえば、ショットのステップ環境で Nuke エンジンのデバッグ出力をオンにするには、環境ファイルで Nuke エンジン(tk-nuke)セクションを見つけて、この設定を debug_logging: true に更新します。config/env/shot_step.yml を編集します。engines:  ...  ...  tk-nuke:    apps:      ...      ...    compatibility_dialog_min_version: 9    debug_logging: true    favourite_directories: []    location: {name: tk-nuke, type: app_store, version: v0.2.23}    ...   ...ファイルを保存し、ショットのステップ環境で Nuke を再起動します。これで、スクリプト エディタ ウィンドウにデバッグ出力が表示されます。tank コマンドのデバッグ ログをオンにするtank コマンドを実行し、ターミナルでデバッグ出力を確認する場合は、実行するコマンドで --debug オプションを使用すると、コマンドのデバッグ ログがオンになります。./tank --debug coreDEBUG [10:11:38 617.835998535]:DEBUG [10:11:38 618.768930435]: Running with debug output enabled.DEBUG [10:11:38 618.921995163]:DEBUG [10:11:38 619.092941284]: Core API resides inside a (localized) pipelineconfiguration.DEBUG [10:11:38 619.235992432]: Full command line passed:['/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.py','/sgtk/software/shotgun/scarlet', '--debug', 'core']DEBUG [10:11:38 619.364023209]:DEBUG [10:11:38 619.463920593]:DEBUG [10:11:38 619.575977325]: Code install root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.678020477]: Pipeline Config Root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.756937027]:DEBUG [10:11:38 619.826078415]:DEBUG [10:11:38 619.905948639]:DEBUG [10:11:38 619.978904724]: Context items:['/sgtk/software/shotgun/scarlet']DEBUG [10:11:38 620.06688118]: Command: coreDEBUG [10:11:38 620.129108429]: Command Arguments: []DEBUG [10:11:38 620.193004608]: Sgtk Pipeline Config Location:/sgtk/software/shotgun/scarletDEBUG [10:11:38 620.270967484]: Location of this script (__file__):/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.pyWelcome to the Shotgun Pipeline Toolkit!For documentation, see https://toolkit.shotgunsoftware.comStarting Toolkit for your current path '/sgtk/software/shotgun/scarlet'- The path is not associated with any Shotgun object.- Falling back on default project settings.DEBUG [10:11:39 125.463962555]: Sgtk API and Context resolve complete.DEBUG [10:11:39 126.449108124]: Sgtk API: Sgtk Core v0.15.18, config/sgtk/software/shotgun/scarletDEBUG [10:11:39 126.588106155]: Context: scarlet- Using configuration 'Primary' and Core v0.15.18- Setting the Context to scarlet.DEBUG [10:11:39 129.276990891]: No need to load up the engine for thiscommand.- Running command core...----------------------------------------------------------------------Command: Core----------------------------------------------------------------------Welcome to the Shotgun Pipeline Toolkit update checker!This script will check if the Toolkit Core API installedin /sgtk/software/shotgun/scarletis up to date.Please note that when you upgrade the core API, you typically affect more thanone project. If you want to test a Core API upgrade in isolation prior torolling it out to multiple projects, we recommend creating a special*localized* pipeline configuration. For more information about this, pleasesee the Toolkit documentation.You are currently running version v0.15.18 of the Shotgun Pipeline ToolkitNo need to update the Toolkit Core API at this time!DEBUG [10:11:39 981.74405098]: Exiting with exit code None",
    "url": "/143e0a94/",
    "relUrl": "/143e0a94/"
  },
  "148": {
    "id": "148",
    "title": "2 つの機能拡張がインストールされている場合の Photoshop 統合のトラブルシューティング",
    "content": "2 つの機能拡張がインストールされている場合の Photoshop 統合のトラブルシューティングどんな問題がありますか?After Effects 統合のリリースに伴い、ShotGrid と統合されるすべての Adobe アプリで使用できる共通プラグインが用意されました。この変更の一環として、以前の Photoshop 統合との後方互換性を保ち、スタジオが更新プログラムに正しく移行できるようにするため、機能拡張の名前を変更する必要がありました。これは残念ながら、アップグレード時に 2 つの ShotGrid 機能拡張がインストールされる可能性があることも意味します。ShotGrid Adobe Panel が新しい機能拡張であり、v1.7.0 以降の Photoshop 統合を使用している場合にはこちらを使用する必要があります。エラーの修正方法古い機能拡張を削除するには、ホーム ディレクトリの Adobe 製品のインストール場所から削除します。フォルダは、Photoshop 起動時に以下のデバッグ出力に表示されます。  ~/Library/Application Support/Adobe/CEP/extensions/com.sg.basic.psOSX:  Windows: %AppData% Adobe CEP extensions com.sg.basic.psPhotoshop を終了してそのディレクトリを削除すると、再起動時の拡張拡張は 1 つだけになります。                    注: 複数の環境または複数の設定に Photoshop 統合があり、古いプラグインと新しいプラグインが混在している場合、あるユーザがその古い統合で Photoshop を起動すると、古いプラグインが返されます。このクリーンアップが一度で済むよう、Photoshop を組織全体で更新することを推奨します。    ",
    "url": "/3fd1f835/",
    "relUrl": "/3fd1f835/"
  },
  "149": {
    "id": "149",
    "title": "アプリまたはエンジンをアンインストールするにはどうすればいいですか?",
    "content": "アプリまたはエンジンをアンインストールする方法アプリまたはエンジンを削除するには、設定の YAML 環境ファイルを編集して、アプリまたはエンジンを記述から除外します。環境ファイルを使用すると、特定のコンテキストまたはエンジンでのみ使用できるようにアプリを設定できます。アプリを完全に削除する必要はありません。環境ファイルの一般的な編集方法については、このガイドを参照してください。例次に、既定の設定から Publish アプリを完全に削除する方法について説明します。アプリは環境設定内のエンジンに追加されるため、Publish アプリが追加されたすべてのエンジンからこのアプリを削除する必要があります。エンジンからアプリを削除する各エンジンは .../env/includes/settings 内に独自の YAML ファイルを保持しています。Publish アプリはすべてのエンジンに含まれているため、各エンジンの YAML ファイルを変更する必要があります。Maya エンジンを例に挙げると、tk-maya.yml を開いて、Publish アプリに対するすべての参照を削除します。まず、includes セクションに Publish アプリに対する参照があります。.../env/includes/settings/tk-maya.yml L18アセット ステップのコンテキストの場合、このアプリは Maya エンジンにも含まれています。.../env/includes/settings/tk-maya.yml L47次の行を使用して、Favorites メニューにもこのアプリを追加します。.../env/includes/settings/tk-maya.yml L56次に、ショット ステップの設定で次の行を繰り返します。.../env/includes/settings/tk-maya.yml L106.../env/includes/settings/tk-maya.yml L115他のすべてのエンジンの yml 環境ファイル(tk-nuke、tk-3dsmaxplus、tk-desktop など)にこれらの手順を繰り返します。                    重要: この時点で、ユーザの統合環境にこのアプリが表示されないようにするのに必要な操作が完了しているので、必要な作業はここまです。ただし、設定からアプリに対する参照を完全に削除して、設定を常に整理しておくには、残りの手順を完了する必要があります。    アプリの設定を削除するこれらのエンジンのすべての YAML ファイルには、tk-multi-publish2.yml 設定ファイルが含まれていました。エンジンの YAML ファイル内にある、このアプリに対する参照が削除されたので、このファイルを完全に削除することができます。                    重要: tk-multi-publish2.yml を削除したにもかかわらず、これを指しているエンジン ファイルが存続している場合は、次の行と共にエラーが表示される可能性があります。ErrorInclude resolve error in '/configs/my_project/env/./includes/settings/tk-desktop2.yml': './tk-multi-publish2.yml' resolved to '/configs/my_project/env/./includes/settings/./tk-multi-publish2.yml' which does not exist!    アプリの場所を削除する既定の設定では、…/env/includes/app_locations.yml ファイル内にすべてのアプリの場所記述子が保存されています。tk-multi-publish2.yml はこの記述子を参照しているため、この記述子の行を削除する必要があります。",
    "url": "/86ab39ef/",
    "relUrl": "/86ab39ef/"
  },
  "150": {
    "id": "150",
    "title": "API を使用して Toolkit の設定をプログラムによって更新するにはどうすればいいですか?",
    "content": "API を使用して Toolkit の設定をプログラムによって更新するにはどうすればいいですか?アプリ、エンジン、およびフレームワークを更新するエンジン、アプリ、およびフレームワークのすべてをプログラムによって最新バージョンに更新する場合は、次のコードを使用できます。import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;updates&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):     from tank_vendor.shotgun_authentication import ShotgunAuthenticator     user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()     sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    注意: これにより、追加の操作や確認を行うことなく、このパイプライン設定のエンジン、アプリ、およびフレームがすべて最新バージョンに更新されます。作業を進める前にこの操作を把握してください。    コアを更新するスクリプトからプロジェクトのコア バージョンを非インタラクティブに更新する場合は、次のコードを使用できます。import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;core&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):    from tank_vendor.shotgun_authentication import ShotgunAuthenticator    user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()    sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    注意: これにより、追加の操作や確認を行うことなく、Toolkit コアが最新バージョンに更新されます。このコードを実行しているコアが共有コアの場合は、このコア バージョンを共有するすべてのプロジェクトで使用されているコア バージョンが更新されます。作業を進める前にこの操作を把握してください。    関連トピック  カスタム スクリプトによる認証とログイン資格情報",
    "url": "/4de9c1d6/",
    "relUrl": "/4de9c1d6/"
  },
  "151": {
    "id": "151",
    "title": "パイプライン設定のコアの場所を更新するにはどうすればいいですか?",
    "content": "パイプライン設定のコアの場所を更新するにはどうすればいいですか?ローカル コアを使用するようにパイプライン設定を更新するにはどうすればいいですか?共有 Toolkit コアを使用するようにパイプラインが設定されている場合は、基本的に、このプロセスを元に戻すことができます。つまり、コアの「共有を解除」し、tank localize コマンドを使用してパイプライン設定内に Toolkit Core API のコピーをインストールできます。これをコアの「ローカライズ」と呼んでいます。       ターミナルを開いて、Toolkit コアのインストール先のパイプライン設定に移動します。     $ cd /sgtk/software/shotgun/scarlet            次の tank コマンドを実行します。     $ ./tank localize ... ... ---------------------------------------------------------------------- Command: Localize ---------------------------------------------------------------------- This will copy the Core API in /sgtk/software/shotgun/studio into the Pipeline configuration /sgtk/software/shotgun/scarlet. Do you want to proceed [yn]        続行する前に、Toolkit がすべてを確認します。パイプライン設定が現在指定している Toolkit コアのコピーは、パイプライン設定にローカルにコピーされます。        Toolkit は、パイプライン設定で使用中のすべてのアプリ、エンジン、フレームワークを install フォルダにローカルにコピーします。次に Toolkit コアがコピーされ、新たにインストールされたローカルな Toolkit コアを使用するようにパイプライン設定内の設定ファイルが更新されます。     Copying 59 apps, engines and frameworks... 1/59: Copying tk-multi-workfiles v0.6.15... 2/59: Copying tk-maya v0.4.7... 3/59: Copying tk-nuke-breakdown v0.3.0... 4/59: Copying tk-framework-widget v0.2.2... 5/59: Copying tk-shell v0.4.1... 6/59: Copying tk-multi-launchapp Undefined... 7/59: Copying tk-motionbuilder v0.3.0... 8/59: Copying tk-hiero-openinshotgun v0.1.0... 9/59: Copying tk-multi-workfiles2 v0.7.9... ... ... 59/59: Copying tk-framework-qtwidgets v2.0.1... Localizing Core: /sgtk/software/shotgun/studio/install/core -&amp;gt; /sgtk/software/shotgun/scarlet/install/core Copying Core Configuration Files... The Core API was successfully localized. Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.                          注: 出力は、インストールしたアプリ、エンジン、およびフレームワークのバージョンによって異なります。    既存の共有コアを使用するようにパイプライン設定を更新するにはどうすればいいですか?既存の共有 Toolkit コアを使用する場合は、tank コマンドを使用して共有コアを使用するように「ローカライズされた」既存のパイプライン設定を更新できます。      ターミナルを開いて、更新するパイプライン設定に移動します。     $ cd /sgtk/software/shotgun/scarlet            次に、tank attach_to_core コマンドを実行して、現在のプラットフォーム上の共有コアへの有効なパスを指定します。     $ ./tank attach_to_core /sgtk/software/shotgun/studio ... ... ---------------------------------------------------------------------- Command: Attach to core ---------------------------------------------------------------------- After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/hgfs/sgtk/software/shotgun/studio' - Windows: 'z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]        続行する前に、Toolkit がすべてを確認します。この共有コアは複数のプラットフォーム用に既にセットアップされているため、それぞれの場所を示します。    新しいプラットフォームに場所を追加する必要がある場合、共有コア設定内の config/core/install_location.yml を更新して、必要なパスを追加します。        Toolkit は、パイプライン設定のローカル コア API をバックアップし、ローカライズされたコアを削除し、共有コアでパイプライン設定を指定するために必要な設定を追加します。     Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.        後で、パイプライン設定内で Toolkit コアをローカライズする(つまり、共有コアからパイプライン設定を切り離して、ローカルにインストールされたバージョンを使用する)場合は、tank localize コマンドを使用してこの操作を行うことができます。                      注: スタジオの共有コアは、現在のパイプライン設定のコアと同じかそれ以降のバージョンである必要があります。    プロジェクト間で Toolkit コアを共有するにはどうすればいいですか?現在、Toolkit Core API は、SG Desktop を使用してプロジェクトを設定するときに「ローカライズ」されます。つまり、この API がパイプライン設定内にインストールされます。 これは、すべてのパイプライン設定が完全に独立した Toolkit インストールであることを意味します。プロジェクト間で共有する Toolkit Core API のバージョンを使用して、メンテナンスを最小限に抑え、すべてのプロジェクトで同じコア コードが使用されるようにします。これを「スタジオの共有コア」と呼ぶこともあります。次に、異なるプロジェクト パイプライン設定間で共有できる新しい Toolkit Core API 設定を作成する方法を示します。      ターミナルを開いて、共有する Toolkit Core バージョンが含まれる既存のパイプライン設定に移動します。プロセスが完了すると、このパイプライン設定はローカライズされなくなりますが、新しく作成した共有コアは使用されます。     $ cd /sgtk/software/shotgun/pied_piper            次の tank コマンドを実行して、Toolkit core をディスクの外部の場所にコピーします。このパスがすべてのプラットフォームで見つかるように、場所を指定する必要があります(inux_path、windows_path, mac_path)。各パスに引用符を使用することをお勧めします。特定のプラットフォームで Toolkit を使用しない場合は、空の文字列 &quot;&quot; を指定するだけです。      $ ./tank share_core &quot;/mnt/sgtk/software/shotgun/studio&quot; &quot;Z: sgtk software shotgun studio&quot;   &quot;/sgtk/software/shotgun/studio&quot;            Toolkit が処理を続ける前に、加えられる変更の概要が表示されます。     ---------------------------------------------------------------------- Command: Share core ---------------------------------------------------------------------- This will move the embedded core API in the configuration '/sgtk/software/shotgun/pied_piper'. After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/sgtk/software/shotgun/studio' - Windows: 'Z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]            Toolkit は新しい共有場所にコア インストールをコピーし、新しい共有コアを指定するように既存のパイプライン設定を更新します。     Setting up base structure... Copying configuration files... Copying core installation... Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.      これで他のパイプライン設定からこの新しい共有コアを使用できます。既存の共有コア(先ほど作成したコアなど)を使用するようにパイプライン設定を更新するには、tank attach_to_core コマンドを使用します。",
    "url": "/b12f2510/",
    "relUrl": "/b12f2510/"
  },
  "152": {
    "id": "152",
    "title": "バージョンと Published File の違いは何ですか?",
    "content": "バージョンと Published File の違いは何ですか?「パブリッシュ」は、アプリケーション内で使用可能なディスク上のファイル(またはイメージ シーケンス)またはデータを表します。これには、exr シーケンス、abc、Maya ファイルなどがあります。パブリッシュは ShotGrid の PublishedFile エンティティによって表されます。「バージョン」(ShotGrid の Version エンティティ)はパブリッシュの視覚表現で、レビューやノートの作成に使用されます。Version エンティティ上に Published Files という名前のフィールドがあり、互いに接続する任意の数のパブリッシュ レコードを入力することができます。このフィールドを使用して、パブリッシュ グループに関連付けられているレビュー Version をトラックできます。パブリッシュ時にこの関係を設定することをお勧めします。バージョンは ShotGrid の Version エンティティによって表されます。究極的には、ファイル形式は異なるが実際は同じコンテンツを表す(Maya ファイル、obj、alembic などの)一連のファイルをパブリッシュ時に生成できることが理想です。これらのファイルは、同じ内容をすべて異なる形式で表現しています。その後、パブリッシュ データをプレビューしてノートを作成するために、1 つのレビュー Version に関連付けます。パブリッシュされたデータがイメージ シーケンスの場合、これは少し冗長な考え方になります。実際イメージ シーケンスは、レビュー対象であり、かつパイプラインに送信する対象でもあります。この場合、パブリッシュと Version の両方を「1 つにまとめて」作成する必要があります。この操作を行うと、(Loader アプリを使用するなどの方法により)パブリッシュされたデータのうち、Version を表すものがロードされます。",
    "url": "/b867b4b0/",
    "relUrl": "/b867b4b0/"
  },
  "153": {
    "id": "153",
    "title": "VPC / IAM / Security Group",
    "content": "VPC / IAM / Security GroupAmazon Virtual Private Cloud permits users to logically separate virtual networks that host their AWS resources and provides you complete control over access to your AWS network.Within a VPC, security groups act as a basic firewall and control what inbound and outbound connections are permitted to each given resource. For example, a security group can allow inbound HTTPS traffic to a proxy server but block all other inbound traffic.With AWS Identity and Access Management (IAM), access to AWS resources and services can be controlled at a more fine-grained level. For example, IAM can be leveraged to control who or which resources can access S3 buckets used by ShotGrid.All three of the above features are used in the ShotGrid isolation features implementation to ensure that you securely connect your closed VPC to ShotGrid and allow access to the media S3 buckets.",
    "url": "/28430132/",
    "relUrl": "/28430132/"
  },
  "154": {
    "id": "154",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationCommunication between your client systems and your ShotGrid site will traverse the open Internet by default. Web Traffic Isolation allows you to restrict access to your ShotGrid site from the public Internet entirely and ensure that all traffic transits directly between your AWS VPC and Autodesk’s AWS VPC.ConfigurationA unique VPC endpoint is provided by Autodesk. Access to the endpoint must be configured from your VPC, and the relevant DNS configuration must be completed to allow your client systems to reach the new endpoint.How it worksBy using the provided VPC endpoint, web traffic is isolated from the public Internet completely. All web traffic transits between your AWS VPC and Autodesk’s AWS VPC, rather than the public Internet.CostsThe only cost associated with Web Traffic Isolation are those related to web traffic transiting to/from your AWS VPC. See AWS VPC Pricing for more details.Next StepsSee Web Traffic Isolation for setup instructions.",
    "url": "/57122ae9/",
    "relUrl": "/57122ae9/"
  },
  "155": {
    "id": "155",
    "title": "Web フック(準備中)",
    "content": "Web フック                    ベータ: Web フックは現在ベータ版です。ベータ版への参加をご希望の場合は、次のメール アドレスにお問い合わせください: webhooks-beta@shotgunsoftware.com    Web フックを使用すると、ユーザがコントロールしているサービスに ShotGrid で発生したイベントを通知することができます。Web フックを作成する場合は、対象となるイベントのタイプを指定し、このイベントがトリガされたときにデータを送信する URL を ShotGrid に指示します。ShotGrid で関連イベントが発生すると、そのイベントを示すデータのペイロードが Web フックの URL に送信されます。これにより、ShotGrid との統合が緊密化され、ワークフローの一部を自動化することができます。Web フックを使用する例Web フックには多くの使用事例があります。このドキュメントでは役立つ事例をいくつか紹介しますが、Web フックの使用はこれらの例に限定されません。エンティティを作成するときにディスク上にディレクトリ構造を作成するShotGrid で新しいエンティティを作成するときに何度も繰り返されてきたワークフローの 1 つとして、ディスク上にディレクトリ構造を作成することが挙げられます。ShotGrid で新しいショットを作成したら、先へ進んで、アーティストの作業準備が整っていることを自動的に確認できると便利です。ステータス管理の自動化アニメーション チームが作業を終えたら、作業を進めて、同じショットに関する下流工程のタスクのステータスを変更し、開始できる作業が増えたことを知らせるようにしましょう。こうすることで、別の作業に割り当てられているアーティストに、準備ができていることを自動的に通知できます。ステータス管理の自動化が役立つもう 1 つの例は、新しいノートを作成するときに、タスクのステータス変更をトリガすることです。この方法は、アーティスト チームとプロダクション チームに、レビュー セッション後にスーパーバイザーから現在の作品を変更または修正するよう要求されたことを知らせる場合に便利です。ShotGrid のイベント デーモンではなく、Web フックを使用する場合Web フックおよび ShotGrid のイベント デーモンの機能は似ていますが、重要な違いがいくつかあります。イベント デーモンは、ユーザ独自のサービスを実行、監視、メンテナンスする必要があります。すべてのコードを Python で記述する必要があり、これによって ShotGrid との独自の接続を開始することが可能となります。対照的に、Web フックは複数の接続に対応し、任意のプログラム言語で記述することができます。Web フックは、AWS Lambda などのサーバレス環境にホストしたり、Zapier や IFTTT など、オンラインで使用可能な任意の自動化プラットフォームをトリガしたりできます。Web フックを使用できるのであれば、Web フックがお勧めのソリューションです。Web フックを作成するWeb フックの作成を開始するには、Web フックのページに移動し、Web フック リストの上にあるボタンにナビゲートします。次に、新しい Web フックを作成するのに必要な情報を入力します。シークレット トークンWeb フックにシークレット トークンを割り当てる作業は省略できます。シークレット トークンを指定した場合、Web フックの URL に送信されるすべての要求はこのトークンを使用して署名されます。この要求と一緒にトークン値が送信されます(ヘッダ名は X-SG-SIGNATURE)。署名は HMAC および SHA1 を使用して計算され、署名されたメッセージが要求の本文(JSON 形式)になります。ヘッダ形式&amp;lt;algorithm&amp;gt;=&amp;lt;signature&amp;gt;シークレット トークンを使用する理由厳密に必要なわけではありませんが、シークレット トークンを指定すると、Web フックの URL に送信されるペイロードに署名が付けられます。これにより、カスタマー サービスは、データが予測された送信元から送信されていること、および送信中にペイロードがいかなる方法でも変更されなかったことを確認できます。署名の検証Python を使用してペイロードの署名を確認する例の 1 つを、次に示します。&amp;gt;&amp;gt;&amp;gt; import hmac&amp;gt;&amp;gt;&amp;gt; import hashlib&amp;gt;&amp;gt;&amp;gt; body | `&amp;lt;json body&amp;gt;'&amp;gt;&amp;gt;&amp;gt; token | `mytoken'&amp;gt;&amp;gt;&amp;gt; 'sha1=' + hmac.new(token, body, hashlib.sha1).hexdigest()  == 'sha1=32824e0ea4b3f1ae37ba8d67ec40042f3ff02f6c'TrueSSL 証明書を検証するSSL 証明書の検証機能はオプションです。Web フックの使用者 URL に対する接続のセキュリティを確保する際に役立ちます。この機能を有効にすると、Web フックの URL に配信された場合、ShotGrid は OpenSSL の証明書検証ルーチンを使用して証明書を検証します。Web フックのステータスWeb フックはさまざまなステータスを取ることができます(健全性や、配信を引き続き受信できるかどうか)。            ステータス      例      説明                  アクティブ            Web フックの動作は安定しています。過去 24 時間以内に、この Web フックに対する配信が宛先に到達しなかったことはありません。              不安定            Web フックの動作は不安定です。過去 24 時間以内に、一部の配信が宛先に到達しませんでしたが、Web フックが停止していると ShotGrid が判断するには不十分です。              失敗            Web フックは停止していると判断されていて、配信はこれ以上試行されません。この原因は、短期間に発生した配信失敗の数が多すぎたことです。システムは、Web フックが使用できなくなったと判断しました。過去 24 時間以内に配信が 10 回失敗すると、Web フックに障害があると見なされます。              無効            Web フックは無効な状態です。再度有効になるまで、配信はこれ以上試行されません。      配信Web フック リスト内の Web フックを選択すると、この Web フックに行われたすべての配信が 5 日前まで遡って表示されます。                    注: 5 日前より古い配信のログは削除され、復元できません。    配信ステータス配信のステータスは、Web フックの URL に正常に配信されたかどうかを示します。配信の詳細配信を展開して、Web フックの URL に送信された要求およびこの要求に対する応答の詳細を表示することができます。ペイロードWeb フックの URL に送信されるペイロードには、ShotGrid で発生したイベントと、それをトリガしたユーザを示す情報が格納されています。この情報は、JSON 形式で提供されます。                    ペイロード サイズ: 配信のペイロードの最大サイズは 1 MB です。ShotGrid でトリガされたイベントのうち、ペイロード サイズが 1 MB を超えるものは、new_value および old_value キーが削除され、発生したイベントの内容と、ShotGrid からイベント ログ エントリ全体を取得する理由および方法を示すメッセージが含まれている warning キーが追加されます。    サンプル ペイロード{  &quot;data&quot;: {    &quot;id&quot;: &quot;95.0&quot;,    &quot;meta&quot;: {      &quot;type&quot;: &quot;attribute_change&quot;,      &quot;entity_id&quot;: 758,      &quot;new_value&quot;: &quot;This is the newest description ever!!&quot;,      &quot;old_value&quot;: &quot;This is the old description!&quot;,      &quot;entity_type&quot;: &quot;Asset&quot;,      &quot;attribute_name&quot;: &quot;description&quot;,      &quot;field_data_type&quot;: &quot;text&quot;    },    &quot;user&quot;: {      &quot;id&quot;: 113,      &quot;type&quot;: &quot;HumanUser&quot;    },    &quot;entity&quot;: {      &quot;id&quot;: 758,      &quot;type&quot;: &quot;Asset&quot;    },    &quot;project&quot;: {      &quot;id&quot;: 65,      &quot;type&quot;: &quot;Project&quot;    },    &quot;operation&quot;: &quot;update&quot;,    &quot;created_at&quot;: &quot;2019-07-12 21:14:36.598835&quot;,    &quot;event_type&quot;: &quot;Shotgun_Asset_Change&quot;,    &quot;session_uuid&quot;: &quot;07473c00-a4ea-11e9-b3b8-0242ac110006&quot;,    &quot;attribute_name&quot;: &quot;description&quot;,    &quot;event_log_entry_id&quot;: 248249  }}セッション UUIDShotGrid でイベントをトリガした session_uuid が、イベント ペイロードの一部として提供されます。この値を ShotGrid の Python API に提供して、この session_uuid を持つ、開いている任意のブラウザ セッションに、この API によって生成されたイベントの最新情報を表示することができます。確認応答配信を更新して確認応答を含めることができます。配信時に、要求の一部としてヘッダが提供されます。これらのヘッダには、x-sg-delivery-id キーに格納されている配信レコードの ID が含まれます。この ID を使用すると、ShotGrid REST API で配信レコードを更新し、確認応答を含めることができます。                    確認応答のサイズ: 確認応答に割り当てられた最大サイズは 4 KB です。    サンプル ヘッダ{  &quot;accept&quot;: &quot;application/json&quot;,  &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;,  &quot;x-sg-webhook-id&quot;: &quot;30f279a0-42a6-4cf2-bb5e-6fc550d187c8&quot;,  &quot;x-sg-delivery-id&quot;: &quot;dea7a71d-4896-482f-b238-b61820df8b65&quot;,  &quot;x-sg-event-batch-id&quot;: &quot;1&quot;,  &quot;x-sg-event-batch-size&quot;: &quot;4&quot;,  &quot;x-sg-webhook-site-url&quot;: &quot;http://yoursite.shotgunstudio.com/&quot;,  &quot;x-sg-event-batch-index&quot;: &quot;3&quot;}確認応答の用途確認応答を使用すると、成功または失敗を示す詳細レポートを帯域外で送信し、Web フックの URL で正常に受信された配信を処理することができます。これにより、ShotGrid からの配信に関する受信ステータスを成功または失敗から切り離し、この配信に関連付けられているイベントを処理できるようになります。このようにして、正常に配信されたイベントにデバッグに役立つ追加情報を含めることができます。この方法は、アセット作成時にトリガされる Web フックに使用すると便利です。新しいアセットごとにディスク上にディレクトリ構造を 1 つ作成する作業を Web フックで行う場合、Web フックの URL は配信を正常に受信できますが、ディスクまたはネットワークが停止しているため、関連ディレクトリを作成することはできません。配信を受信した後、Web フックは、ディレクトリ構造が作成されなかったことおよびその理由を示す詳細なエラー メッセージを使用して、配信記録を更新することができます。Web フックのテスト無料公開されている任意の Web フック URL ジェネレータをオンラインで使用して、テストすることができます。これらのサービスは特に、Web フックやその他のタイプの HTTP 要求をテストすることを目的としています。この方法は、ネットワーク上にインフラストラクチャを設定しないで、Web について学習する場合に便利です。webhook.site を使用するwebhook.site を使用することをお勧めします。このサイトでは、コピーして Web フックに貼り付けることができる一意の URL が提供されていて、このアドレスへの配信がリアルタイムに表示されます。このページは、特定のステータス コードおよび本文を含む配信に応答するようにカスタマイズできます。つまり、配信の成功と失敗をテストすることができます。webhook.site サービスの速度は積極的に制限されます。つまり、一部の配信が拒否されて、Web フックが不安定になる、または停止することが容易に発生します。テストする場合は、プロダクションのライブ データではなく、既知のコントロール可能なプロジェクト環境を使用することをお勧めします。                    プロダクション データ: プロダクション イベント データを一般公開されているサードパーティの Web サービスに送信することはお勧めしません。テスト データの使用は、webhook.site のようなサービスを使用して Web フックをテストする場合に限定してください。    配信に応答する配信が正常に行われたとシステムが判断するためには、コンシューマー サービスが配信に応答する必要があります。                    応答のタイムアウト: Web フックの URL に配信されてから 6 秒以内に応答を受信する必要があります。6 秒が経過すると、接続は終了します。時間内に応答しなかった場合は、配信が失敗します。    ステータス コード            ステータス      コード      説明                  成功      &amp;lt; 400      配信は受信されて、正常に処理されました。              エラー      &amp;gt;= 400      配信は受信されましたが、正常に処理されませんでした。              リダイレクト      3xx      配信は受信されましたが、別の URL にリダイレクトする必要があります。      ",
    "url": "/3d448f5e/",
    "relUrl": "/3d448f5e/"
  },
  "156": {
    "id": "156",
    "title": "パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?",
    "content": "パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?パス キャッシュは、ディスクのフォルダと ShotGrid のエンティティ間の関連付けをトラックするために Toolkit で使用されます。マスター キャッシュは、エンティティ タイプ FilesystemLocation を使用して ShotGrid 内に保存されます。 各ユーザには、ディスクの Toolkit キャッシュ ディレクトリにローカルに保存された独自のバージョンのパス キャッシュがあり、アプリケーションを起動するときやフォルダを作成するときはいつでもバックグラウンドで同期されます。通常は、パス キャッシュを手動で変更しないことをお勧めします。オートデスクの内部プロセスで、ローカル キャッシュと ShotGrid 内の FilesystemLocation エンティティを同期するだけでなく、イベント ログ エントリを作成して、すべてのユーザのマシンが ShotGrid との同期を維持できるようにもしています。パス キャッシュを変更するために使用できる tank コマンドがいくつかあります。  tank unregister_folders   は、パス キャッシュの関連付けを削除します。  tank synchronize_folders   は、ローカル パス キャッシュと ShotGrid を強制的に同期します。通常、これらのコマンドのいずれかを実行する必要はありませんが、状況によっては、これらが役立つことがあります。たとえば、プロジェクト内のエンティティの名前を変更するか、エンティティを再作成する場合は、その前に unregister_folders を実行する必要があります。",
    "url": "/cbbf99a4/",
    "relUrl": "/cbbf99a4/"
  },
  "157": {
    "id": "157",
    "title": "ログ ファイルはどこにありますか?",
    "content": "ログ ファイルはどこにありますか?既定では、ShotGrid Desktop および ShotGrid の統合は、ログ ファイルを次のディレクトリに保存します。Mac~/Library/Logs/Shotgun/Windows%APPDATA% Shotgun logs Linux~/.shotgun/logs/ログ ファイル名の形式は tk-&amp;lt;ENGINE&amp;gt;.log です。例として tk-desktop.log や tk-maya.log があります。ユーザのキャッシュの場所をオーバーライドするように ShotGrid_HOME 環境変数を設定している場合、ログ ファイルは次の場所にあります。$SHOTGUN_HOME/logs                    注: ShotGrid Desktop からこのディレクトリにアクセスすることもできます。プロジェクトを選択し、プロジェクト名の右側にある下矢印ボタンをクリックして、[Open Log Folder]を選択します。    ",
    "url": "/38c5c024/",
    "relUrl": "/38c5c024/"
  },
  "158": {
    "id": "158",
    "title": "キャッシュの場所",
    "content": "キャッシュの場所ルート キャッシュの場所Toolkit は、ShotGrid サーバに対する不要な呼び出しを防止するために、一部のデータをローカル キャッシュに保存します。ローカル キャッシュにはパス キャッシュ、バンドル キャッシュ、およびサムネイルが含まれます。ほとんどのユーザは既定の場所を使用しますが、変更の必要がある場合は、cache_location コア フックを使用して設定可能です。既定のキャッシュ ルートの場所は次のとおりです。Mac OS X~/Library/Caches/ShotgunWindows%APPDATA% ShotgunLinux~/.shotgunパス キャッシュキャッシュ パスは次の場所にあります。&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/path_cache.dbバンドル キャッシュ分散設定バンドル キャッシュとは、ShotGrid サイト上のプロジェクトすべてで使用される、すべてのアプリケーション、エンジン、およびフレームワークのキャッシュ コレクションです。 分散設定用のバンドル キャッシュは次の場所に保存されています。Mac: ~/Library/Caches/Shotgun/bundle_cacheWindows:%APPDATA% Shotgun bundle_cacheLinux: ~/.shotgun/bundle_cache                    注: これらの場所は SHOTGUN_BUNDLE_CACHE_PATH 環境変数を使用してオーバーライドできるため、具体的な実装は変わる可能性があります。    一元管理設定一元管理設定用のバンドル キャッシュは、一元管理設定内に配置されます。...{project configuration}/install/設定で共有コアを使用している場合は、代わりに、共有コアのインストール フォルダ内に配置されます。サムネイルToolkit アプリ(Loader など)で使用されるサムネイルは、Toolkit のローカル キャッシュに保存されます。 サムネイルは、プロジェクト、パイプライン設定、およびアプリごとに(必要に応じて)保存されます。ルート キャッシュ ディレクトリ下の構造は次のとおりです。&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/&amp;lt;app_or_framework_name&amp;gt;/thumbs/",
    "url": "/7c9867c0/",
    "relUrl": "/7c9867c0/"
  },
  "159": {
    "id": "159",
    "title": "ワークフロー",
    "content": "ワークフローToolkit ワークフローベースの関連するクイック アンサーの集まりです。  バージョンと Published File の違いは何ですか?",
    "url": "/8396394b/",
    "relUrl": "/8396394b/"
  },
  "160": {
    "id": "160",
    "title": "Workflows",
    "content": "Workflows",
    "url": "/f5a4341f/",
    "relUrl": "/f5a4341f/"
  }
}
