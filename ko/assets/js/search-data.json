{
  "0": {
    "id": "0",
    "title": "ShotGrid 툴킷 사용 시 3ds Max를 시작하면 충돌 오류가 발생하는 이유는 무엇입니까?",
    "content": "ShotGrid 툴킷 사용 시 3ds Max를 시작하면 충돌 오류가 발생하는 이유는 무엇입니까?ShotGrid 데스크톱이나 ShotGrid 웹 사이트에서 3ds Max를 실행하면 하얀색 대화상자가 움직이지 않는 상태로 3ds Max가 멈추거나 다음 메시지가 나타날 수 있습니다.Microsoft Visual C++ Runtime Library (Not Responding)Runtime Error!Program: C: Program Files Autodesk 3ds Max 2016 3dsmax.exeR6034An Application has made an attempt to load the C runtime library incorrectly.Please contact the application's support team for more information.이는 보통 경로의 msvcr90.dll 버전이 3ds Max와 번들로 제공되는 Python 버전과 충돌하기 때문입니다. 솔루션먼저, 파이프라인 구성의 config/hooks 폴더로 이동하여 before_app_launch.py 파일을 생성합니다. 이 파일에서 다음을 붙여 넣습니다.&quot;&quot;&quot;Before App Launch HookThis hook is executed prior to application launch and is useful if you needto set environment variables or run scripts as part of the app initialization.&quot;&quot;&quot;import osimport tankclass BeforeAppLaunch(tank.get_hook_baseclass()):    &quot;&quot;&quot;    Hook to set up the system prior to app launch.    &quot;&quot;&quot;    def execute(self, **kwargs):        &quot;&quot;&quot;        The execute functon of the hook will be called to start the required application        &quot;&quot;&quot;        env_path = os.environ[&quot;PATH&quot;]        paths = env_path.split(os.path.pathsep)        # Remove folders which have msvcr90.dll from the PATH        paths = [path for path in paths if &quot;msvcr90.dll&quot; not in map(            str.lower, os.listdir(path))        ]        env_path = os.path.pathsep.join(paths)        os.environ[&quot;PATH&quot;] = env_path이제 파일을 저장합니다.그런 다음, 파이프라인 구성에서 config/env/includes/app_launchers.yml을 열고 launch_3dsmax 항목을 찾습니다. hook_before_app_launch: default를 hook_before_app_launch: '{config}/before_app_launch.py'로 바꿔야 합니다.이제 ShotGrid 및 ShotGrid 데스크톱에서 3ds Max가 올바로 실행될 것입니다. 그래도 문제가 발생하면 support@shotgunsoftware.com으로 문의하시기 바랍니다.",
    "url": "/a7555f37/",
    "relUrl": "/a7555f37/"
  },
  "1": {
    "id": "1",
    "title": "About the Isolation Feature Set",
    "content": "What is the Isolation Feature SetThe isolation feature set combines our Cloud Hosted Platform with client-managed AWS resources to provide a solution that satisfies the most stringent security and privacy requirements. Clients retain control of their sensitive content without having to host ShotGrid on their infrastructure.Leveraging the isolation feature set has the following advantages over the Standard offering:  Media Isolation by hosting of assets and attachments in a client-owned S3 Bucket  Web Traffic Isolation from the public internet  Media Traffic Isolation from the public internet  Media Replication allowing you to replicate media in one additional AWS Region  Access to fully managed ShotGrid Cloud Services  Automatic and continuous version upgrades  Ephemeral compute + in-memory segration between clientsIn a nutshell, this means that with the isolation features, your ShotGrid site and the data related to it cannot be reached by anyone outside of your studio network.The isolation feature set is a solution that requires less upkeep, as well as less IT/System Administrator knowledge and skills, than hosting ShotGrid on-premise. The list of advantages compared to on-premise includes, but is not limited to:  No ShotGrid specific knowledge required  No manual ShotGrid updates required  Very low level of maintenance required for the AWS componentsMedia isolation featureMedia Isolation allows your studio to keep the ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid can be store in your studio private S3 bucket. Access to the media is provided to the ShotGrid service only, using AWS AssumeRole keyless Security Token Service. Your studio remains in control of the assets and the access to the assets, access that you can revoke at will.Traffic isolation featuresMedia and Web traffic isolation features can be enabled to prevent your traffic from being routed on the public internet, limiting it to the AWS backbone and your studio network. The traffic between ShotGrid Services and your studio stays in closed network, never going outside AWS or your Studio network.With the Media Traffic Isolation feature activated, the media will only leave your studio infrastructure once to get transcoded.Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.EligibilityThe Isolation feature set is available for all Super Awesome clients. See Getting Started for more details about how to active the different features. The activation of the isolation feature set is not instantaneous, and requires manual setup involving your AWS account.What the Isolation Feature Set is notThe isolation feature set is not a completely isolated solution. Both the compute services and the database services are shared amongst clients, and managed by ShotGrid. From a hardware standpoint, the isolation features does not guarantee complete physical isolation. However, ShotGrid services are guaranteeing isolation at the memory level. Processes are never reused to answer requests from different clients during their lifetime. Client metadata is stored in different databases. Client media is individually stored on S3.High Level ArchitectureThe ShotGrid cloud service  can be decoupled at a high level in 3 parts:Compute Stack: The part of the ShotGrid Service that handles client requests and serves data to the client.Data Stack: Metadata storage (databases).Media Storage: Where the client’s attachments, media, and assets are stored. ShotGrid uses AWS S3 to store client content.Please read Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk ShotGrid for more details about the architecture.Ephemeral compute and memory isolationEven if clients share the same infrastructure, ShotGrid guarantees a complete memory isolation, both in transit and at rest, of client data. This makes ShotGrid less prone to data leaking due to architecture flaws or software vulnerabilities exploiting memory, like buffer overflow.Ephemeral transcodingEverytime media is uploaded to ShotGrid, the transcoding service is invoked to create a web friendly versions of your assets. That process happens only once, after the initial upload. The media is directly uploaded from the client to S3, from where it is fetched by the ShotGrid Transcoding Service. Each transcoding job is handled by a single container, which is killed after that unique job. The only place the media temporarily lives is in the container memory. The ShotGrid Transcoding service doesn’t store permanently a copy of your media.",
    "url": "/84dfd5cc/",
    "relUrl": "/84dfd5cc/"
  },
  "2": {
    "id": "2",
    "title": "관리",
    "content": "관리툴킷 설정 관리 및 구성을 기반으로 한 빠른 답변 모음입니다.ShotGrid 데스크톱:  ShotGrid 데스크톱을 사용하여 툴킷 프로젝트를 다시 설정하는 방법은 무엇입니까?  Windows에서 ShotGrid 데스크톱을 자동으로 설치하려면 어떻게 해야 합니까?  Linux에서 ShotGrid 데스크톱의 데스크톱/시작 관리자 아이콘을 어떻게 설정합니까?  ShotGrid 데스크톱의 브라우저 통합을 어떻게 비활성화할 수 있습니까?구성 관리:  여러 개의 저장소 루트를 사용하도록 구성을 수정하려면 어떻게 해야 합니까?  파이프라인 구성을 새 위치로 이동하려면 어떻게 해야 합니까?  내 프로젝트 디렉토리를 새 로컬 저장소 루트로 어떻게 옮깁니까?  파이프라인 구성 코어 위치를 업데이트하려면 어떻게 해야 합니까?  프로젝트 간에 에셋을 어떻게 공유합니까?  앱 또는 엔진을 어떻게 제거합니까?캐시 기반 질문:  경로 캐시가 무엇입니까? 파일 시스템 위치가 무엇입니까?  내 캐시는 어디에 있습니까?",
    "url": "/ba09d04c/",
    "relUrl": "/ba09d04c/"
  },
  "3": {
    "id": "3",
    "title": "Administration",
    "content": "Administration",
    "url": "/a944bb05/",
    "relUrl": "/a944bb05/"
  },
  "4": {
    "id": "4",
    "title": "구성 설정",
    "content": "구성 시작하기이 안내서를 완료하면 구성에 프로젝트 정보를 추가하고, 구성을 프로젝트와 연결하고, 커스터마이즈할 파이프라인 구성을 준비하는 기본적인 지식을 갖출 수 있습니다.안내서 정보이 안내서에서는 ShotGrid 데스크톱에서 고급 프로젝트 설정 마법사를 사용하여 디지털 컨텐츠 생성 파이프라인의 구성을 생성하는 방법에 대해 설명합니다. 구성 도구에 대해 간단히 살펴보고, 마법사를 사용하는 방법을 설명하며, 자세한 내용을 확인할 수 있는 자료도 제공합니다. 마법사를 사용하면 프로젝트에 대한 파이프라인 구성이 생성되고 파이프라인의 각 단계를 지원하기 위해 편집 및 확장할 수 있는 준비가 이루어집니다. 이 구성은 UI, ShotGrid 앱 및 프로덕션 파이프라인을 지원하는 데 필요한 다양한 도구의 여러 측면을 제어합니다. 마법사를 사용하는 것은 구성을 확장하는 한 가지 방법에 불과합니다. 마법사에서는 파이프라인의 각 단계에 설정을 추가하고 소프트웨어 응용프로그램과의 통합도 추가할 수 있습니다. 이 안내서에서는 툴킷의 기본 구성을 기반으로 프로젝트의 구성을 설정할 것입니다.이 안내서를 학습하는 사용자는 다음과 같은 준비를 갖추어야 합니다.  고급 프로젝트 설정 마법사를 사용한 적이 없음  ShotGrid 사용 방법에 대한 기초적인 지식을 갖추고 있음  ShotGrid 툴킷을 처음 접함이 문서 사용이 안내서를 사용하고 프로젝트에 대해 커스터마이즈 가능한 구성을 생성하려면 다음과 같은 준비가 필요합니다.  유효한 ShotGrid 사이트. 여기서 ShotGrid에 등록하면 30일 무료 체험판을 다운로드해 직접 체험해 볼 수 있습니다.  ShotGrid 데스크톱. 데스크톱이 설치되어 있지 않은 경우 이 링크를 따라 시작할 수 있습니다.  프로젝트 파일과 파이프라인 구성을 저장할 수 있는 파일 시스템. 파일 시스템에 Shotgun 폴더를 생성하고, 이 폴더 안에 projects 및 configs 폴더를 생성합니다.고급 프로젝트 설정 마법사 정보ShotGrid 데스크톱의 고급 프로젝트 설정(Advanced Project Setup) 마법사는 기본 구성을 기반으로 파이프라인 구성을 생성합니다. 기본 구성을 사용하면 탄탄한 기초를 토대로 파이프라인 프로세스를 지원하는 커스터마이즈 가능한 설정, 앱 및 UI 요소를 작성할 수 있습니다. 이 마법사를 통해 생성되는 구성은 프로젝트의 파이프라인 요구사항을 충족하도록 편집 및 확장할 수 있습니다.기본 구성에는 다음이 포함됩니다.  디스크에서 파일이 저장되는 위치를 결정하는 기본 파일 시스템 스키마 및 템플릿  사용자의 소프트웨어 응용프로그램에서 바로 ShotGrid 및 파이프라인 기능과 상호 작용할 수 있게 해 주는, 모든 지원되는 소프트웨어 통합커스터마이즈 수준은 상상력과 기발함, 그리고 프로그래밍 지식 또는 ShotGrid 커뮤니티의 다른 사용자가 만든 것을 가져다 쓸 수 있는 능력 등에 따라 달라질 수 있습니다.구성 만들기모든 프로젝트에는 구성이 필요합니다. ShotGrid 데스크톱을 통해 프로젝트에 처음 액세스하면 기초 구성이 다운로드되고 설정됩니다. 이 기초 구성에서는 사용자의 시스템에서 지원되는 컨텐츠 생성 소프트웨어를 자동으로 탐지하고 구성을 프로젝트와 연결합니다. 지원되는 소프트웨어 응용프로그램 내 통합은 파이프라인 구성의 설정에 의해 제어됩니다. Panel 앱에는 ShotGrid의 프로젝트 정보가 표시되므로 아티스트가 작업 세션을 떠나지 않고도 노트에 회신하고 버전을 볼 수 있습니다. Publisher 앱에서는 자신의 작업물을 팀의 다른 작업자와 공유할 수 있으며 Loader 앱을 통해서는 팀원이 게시한 파일을 로드할 수 있습니다. 기초 구성에는 파일 시스템 관리 설정이나 파일 및 디렉토리의 디스크 내 명명 방식을 템플릿 개발 등이 포함되지 않습니다. 또한, 기본 구성이 설정될 때 추가되는 다양한 앱도 포함되지 않습니다. 기초 구성은 구성 파일을 직접 편집하지 않고도 툴킷을 바로 실행할 수 있게 해주는 단순한 구성입니다. 이 마법사는 기초 구성을 기본 구성으로 변환합니다. 또한, 사용자의 작업을 지원하기 위해 추가적인 앱과 소프트웨어 통합을 제공합니다. 기초 구성도 편집 가능하기는 하지만, 고급 설정을 통해 프로젝트를 커스터마이즈할 수 있도록 설정할 때까지는 편집할 수 없습니다.기초 구성과 기본 구성의 차이점            기능      기초 구성      기본 구성                  다운로드      프로젝트에 액세스하면 자동으로 다운로드됨      고급 설정 마법사를 통해 생성됨              접근성      시스템 위치에 저장됨      수동으로 편집 가능한 파일              업데이트      자동으로 업데이트됨      수동으로 업데이트됨              파일 시스템 지원      파일 시스템 스키마 지원 안 함      폴더 구조와 파일 명명 표준을 지원하는 도구 포함              소프트웨어 통합      3ds Max, Houdini, Maya, Nuke, Photoshop, Flame      Basic + Hiero, Motionbulder, Mari              툴킷 앱      ShotGrid Panel, Publisher, Loader      Basic + Workfiles, Snap Shot, Scene Breakdown, Nuke Write Node, Houdini Mantra Node 등      이 안내서에서는 ShotGrid 데스크톱의 마법사를 사용하여 기본 구성을 기반으로 프로젝트의 파이프라인 구성을 생성합니다. 이 구성을 생성하면 자체 프로덕션 파이프라인을 지원하는 데 필요한 커스터마이즈를 수행할 수 있게 됩니다.연습 시작기본 구성 사용 준비1단계: ShotGrid에 “the_other_side”라는 프로젝트를 생성합니다.2단계: ShotGrid 데스크톱 앱을 실행하고 ShotGrid 사이트의 사용자 이름 및 암호를 사용하여 로그인합니다.3단계: 썸네일 이미지를 선택하여 마법사를 실행할 프로젝트로 이동합니다.                    팁: 데스크톱이 열려 있는 상태에서 새 프로젝트를 생성한 경우 새 프로젝트를 표시하려면 프로젝트(Projects) 창을 새로 고쳐야 할 수 있습니다. 데스크톱의 오른쪽 아래에 있는 프로파일 아바타를 선택하고 프로젝트 새로 고침(Refresh Projects)을 선택하십시오.    기본 구성 액세스프로젝트에 액세스할 때 기초 구성이 다운로드되고 설정되었습니다. Publish 앱 및 지원되는 소프트웨어 패키지가 탐지되어 ShotGrid 데스크톱의 앱(Apps) 창에 자동으로 추가되었습니다.4단계: 프로젝트가 로드되면 화면 오른쪽 아래에 있는 프로파일 아바타를 선택합니다. 팝업 메뉴에서 고급 프로젝트 설정…(Advanced project setup…)을 선택하여 마법사를 시작합니다.네 개의 옵션이 있고 그중에 ShotGrid 기본값(ShotGrid Default)이 선택되어 있는 대화상자가 표시됩니다. 여기서 프로젝트의 파이프라인 구성을 기존 프로젝트의 구성, git 리포지토리의 구성, 디스크의 경로 중 무엇을 기반으로 할지 선택할 수 있습니다.이 연습에서는 ShotGrid 기본값(ShotGrid Default)을 선택하겠습니다. 이 옵션을 선택하면 ShotGrid의 기본 구성을 기반으로 프로젝트의 파이프라인 구성이 생성됩니다.5단계: 계속(Continue)을 선택합니다.두 개의 옵션이 있고 그중에서 기본값(Default)이 선택되어 있는 대화상자가 표시됩니다. 이 대화상자에는 레거시(Legacy) 기본 구성 설정을 선택할 수 있는 옵션이 있습니다. 이 구성 설정은 이전 버전의 ShotGrid을 계속 사용하는 스튜디오를 위해 제공되는 이전 버전의 설정입니다. 이 연습에서는 기본값(Default)을 사용하겠습니다.6단계: 계속(Continue)을 선택합니다.프로젝트 파일의 저장소 위치 정의Storage:라는 단어 옆에 드롭다운 메뉴가 표시되는 대화상자가 나타납니다.7단계: 이 프로젝트에 대한 프로젝트 데이터를 저장할 위치를 나타냅니다. 대화상자 맨 위에 있는 드롭다운에서 + 신규(+ New)를 선택하고 필드에 프로젝트(projects)를 입력합니다.ShotGrid 툴킷은 세 개의 운영 체제인 Linux, Mac, Windows를 지원합니다.8단계: 프로젝트 데이터를 저장하는 데 사용되는 운영 체제 옆에 있는 필드를 선택합니다. 폴더 아이콘을 선택하고 이 연습을 진행하기 전에 파일 시스템에 생성한 프로젝트 폴더로 이동합니다.이 설정을 진행하면 프로덕션 데이터 저장 위치로 지정한 폴더에만 ShotGrid이 액세스할 수 있게 됩니다. 이 연습의 준비 과정에서 ShotGrid 루트 디렉토리에 projects/ 디렉토리를 추가했습니다. projects/ 디렉토리는 툴킷이 로컬 프로젝트 관련 정보를 저장할 위치입니다.9단계: 저장(Save)을 선택하여 프로젝트 데이터를 저장할 프로젝트 폴더를 지정합니다.프로젝트 데이터가 저장되는 경로를 나타내도록 운영 체제 경로가 자동으로 업데이트됩니다.10단계: 계속(Continue)을 선택합니다.프로젝트 폴더의 이름 지정텍스트 필드에 프로젝트 이름이 입력된 상태로 대화상자가 표시됩니다. 이 이름은 프로젝트 정보에서 가져와서 자동으로 입력되며 경로도 자동으로 업데이트됩니다.툴킷은 파이프라인 구성이 ShotGrid에 업로드되고 각 사용자에 대해 로컬로 캐시되는 분산 설정이나 사용자가 디스크에서 공유된 위치에 있는 단일 구성에 액세스하는 중앙 집중식 설정에서도 작동할 수 있습니다. 이 연습에서는 중앙 집중식 설정을 사용하겠습니다. 분산 설정에 대한 자세한 내용은 여기서 확인할 수 있습니다.마지막 단계에서는 프로젝트와 관련된 구성을 생성하기 위해 적합한 폴더, 파일 및 데이터를 생성합니다.11단계: 해당하는 운영 체제에서 찾아보기…(Browse…)를 선택하고 이 연습을 준비할 때 생성한 구성 폴더 configs로 이동한 후 프로젝트 이름 the_other_side를 입력합니다. 그러면 폴더가 생성되고, 이 폴더에 프로젝트 구성이 저장됩니다. 설정 실행(Run Setup)을 선택하고 설정이 완료될 때까지 기다립니다.12단계: 완료(Done)를 선택하여 프로젝트 창에 나타나는 새 아이콘을 표시합니다.팁: ShotGrid 데스크톱에 신속하게 액세스하기 위해 메뉴 막대에 앱을 고정할 수 있습니다. 이렇게 하려면 아바타를 선택하고 메뉴에 고정(Pin to Menu)을 선택하십시오.다 되었습니다. 프로젝트 설정이 완료되었습니다. 이제 기본 구성을 기반으로 지정한 위치에 프로젝트에 대한 툴킷 파이프라인 구성이 생성되었으므로 커스터마이즈 작업을 시작할 수 있습니다.configs 폴더를 살펴보면 여러 폴더와 파일을 보실 수 있을 것입니다. 어떠한 것들이 있는지 잠시 살펴보시기 바랍니다.이제 정말로 재미있는 내용으로, 구성으로 수행할 수 있는 모든 작업에 대해 살펴보겠습니다. 여기서 살펴볼 고급 항목은 다음과 같습니다.고급 항목ShotGrid 툴킷에서는 구성을 간편하게 편집하고 복제하고 가져올 수 있는 방법을 다양하게 제공합니다. 기존의 구성을 확장하면 시간을 절약할 수 있으며 네트워크에 있는 다른 작업자가 만든 모든 멋진 구성을 이용할 수 있습니다. 필요한 구성을 찾기 위해 방대한 ShotGrid 커뮤니티를 활용할 수 있습니다. ShotGrid 커뮤니티는 정보를 공유하는 커뮤니티이므로 서로에게 친절하게 대하고, 작업에 도움이 되는 구성을 발견하면 작성자의 공로를 인정하고 감사의 인사를 전해 주시기 바랍니다. 그리고 다른 사람에게 도움이 될 새로운 정보를 게시하는 것도 잊지 마십시오. 이런 식으로 우리는 서로를 도와가며 특별한 커뮤니티를 만들어 가고 있습니다!다음은 재미있게 구성 관련 작업을 진행할 수 있는 몇 가지 방법입니다.명령행을 사용하여 기본 구성 생성프로젝트 구성에서 tank 명령을 사용하여 터미널에서 관리자 명령을 실행할 수 있습니다. 프로젝트마다 고유한 전용 tank 명령이 있습니다. tank setup_project 명령의 기능은 고급 설정 마법사와 유사합니다. 이 명령은 기존 프로젝트의 구성이나 기본 구성을 기반으로 디스크에 프로젝트에 대한 편집 가능한 구성을 생성합니다. tank setup_project를 실행하는 방법에 대한 자세한 내용은 여기서 확인하고 tank 명령에 대한 자세한 내용은 여기서 확인할 수 있습니다.프로덕션 단계에 적용된 구성 편집현재 프로덕션 단계에 적용된 구성을 수정하고 싶지만 아티스트가 사용하는 동안에는 편집하고 싶지 않은 경우가 있습니다. ShotGrid에서는 단 몇 개의 명령으로 기존 구성을 복사하여 수정된 구성을 프로덕션에 적용하기 전에 안전하게 수정 사항을 테스트해 볼 수 있습니다. 이 프로세스에서는 프로덕션 구성을 새 구성으로 교체하고 이전 구성은 자동으로 백업합니다.구성의 복사본을 작성하는 것은 대개 다음과 같은 이유 때문입니다.  구성 업데이트  라이브로 적용하기 전에 수정 사항 테스트  일부 앱 업그레이드 또는 추가  테스트 후 개발 진행 및 롤아웃구성을 복제하는 방법과 구성 관리에 대한 기타 기본 사항을 알아보려면 구성 스테이징 및 롤아웃 문서를 참조하십시오.파이프라인 구성의 클라우드 배포이 안내서에서는 공유 네트워크 위치에 있으면서 모든 사용자가 액세스하게 되는 파이프라인 구성의 단일 사본인 중앙 집중식 구성을 생성하는 과정을 살펴봅니다. 하지만 작업 인력이 여러 위치 및 네트워크에 분산되어 있는 경우 파이프라인 구성의 단일 사본을 공유하는 것이 가능하지 않을 수 있습니다. 이 시나리오의 툴킷을 사용하면 분산 구성 옵션을 통해 파이프라인 구성을 ShotGrid에 업로드할 수 있으며 사용자가 프로젝트에 액세스할 때마다 구성이 다운로드되고 로컬로 캐시됩니다. Core API 개발자 문서에서 분산 구성에 대한 자세한 내용을 알아볼 수 있습니다.둘 이상의 루트 폴더 사용스튜디오에서 대개 특정한 작업에 맞게 최적화하는 것을 이상적으로 여깁니다. 둘 이상의 루트 폴더를 사용하여 한 서버에서는 데일리를 위한 비디오 재생과 같은 작업을, 다른 서버에서는 대화식 처리를 수행하는 식으로 작업을 최적화할 수 있습니다. 툴킷에서는 이와 같은 워크플로우를 용이하게 하기 위해 둘 이상의 저장소 루트를 사용할 수 있도록 허용합니다. 단일 루트에서 다중 루트 구성으로 변환하는 방법을 확인하십시오.프로젝트에 대한 파이프라인 구성을 갖추었으므로 편집을 시작해 보시기 바랍니다. 다음 안내서인 파이프라인 구성 편집으로 이동하여 방법을 알아보십시오.",
    "url": "/5d83a936/",
    "relUrl": "/5d83a936/"
  },
  "5": {
    "id": "5",
    "title": "Apps and Engines Configuration Reference",
    "content": "Apps and Engines Configuration ReferenceThis document contains an overview of all the different options that you can include when creating configurations for Apps, Engines and Frameworks in the ShotGrid Pipeline Toolkit. It can be useful when doing advanced configuration of Apps, and it is important when you are doing development and need to add parameters to your App Configuration Manifest.This document describes functionality only available if you have taken control over a Toolkit configuration. For more info, see ShotGrid Integrations Admin Guide.IntroductionThis document contains specifications for the various file formats that Sgtk uses for its configuration and settings. Please note that this is a reference document which outlines all the various options and parameters available. For best practices on how to manage your configuration, please see the following document:Configuration Management best practices.ShotGrid Pipeline Toolkit EnvironmentsThree major components exists in Toolkit:  An engine provides a translation layer or an adapter between a host application (such as Maya or Nuke) and Sgtk Apps. Apps typically use python and PySide, and it is the responsibility of the engine to present the host application in a standardized fashion and for example add pyside on top of the host application if this doesn’t exist already.  An app provides a piece of business logic, it is essentially a tool that does something. Apps can be hand crafted to work in a specific host application, or they can be designed to run in more than one host application.  A framework is a library which can be used by engines, apps or other frameworks. A framework makes it possible to more easily manage code or behaviour which is shared between multiple apps.An environment file contains the configuration settings for a collection of engines, apps and frameworks. Such a collection is called an Environment. Sgtk launches different environments for different files or different people. You can for example have an environment for Shot production and environment for Rigging. Each environment is a single yaml file.Environment files are located at /&amp;lt;sgtk_root&amp;gt;/software/shotgun/&amp;lt;project_name&amp;gt;/config/envThe yaml file has the following basic format:    engines:        tk-maya:            location            engine settings                apps:                tk-maya-publish:                    location                    app settings                    tk-maya-revolver:                    location                    app settings            tk-nuke:            location            engine settings                apps:                tk-nuke-setframerange:                    location                    app settings                    tk-nuke-nukepub:                    location                    app settings        frameworks:        tk-framework-tools:            location            framework settingsEach app and engine can be configured via settings. These settings correspond with the list of settings that the app/engine exposes in its manifest file called info.yml. As of v0.18.x of Sgtk Core, settings only need to be specified if they differ from the default values specified in the manifest file. In addition to the manifest file, the configurable settings can typically be found on the app/engine page within the Toolkit App Store.In addition to the various settings that can be defined for each item, each app, engine and framework also needs to define where its code is located. This is done using a special location parameter.Code LocationsEach app, engine or framework defined in the environment file has got a location parameter which defines which version of the app to run and where to download it from. Most of the time this is handled automatically by the tank updates and tank install commands. However, if you are doing hand editing of configurations, a variety of options are available for you to help deploy and structure Toolkit:Toolkit currently supports app installation and management using the following location descriptors:  An app_store descriptor represents an item in the Toolkit App Store  A ShotGrid descriptor represents an item stored in ShotGrid  A git descriptor represents a tag in a git repository  A git_branch descriptor represents a commit in a git branch  A path descriptor represents a location on disk  A dev descriptor represents a developer sandbox  A manual descriptor that is used for custom deployment and rolloutFor documentation on how to use the different descriptors, please see the Toolkit reference documentation.Disabling Apps and EnginesSometimes it can be useful to temporarily disable an app or an engine. The recommended way of doing this is to to add a disabled: true parameter to the location dictionary that specifies where the app or engine should be loaded from. This syntax is supported by all the different location types. It may look like this for example:location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;disabled&quot;: true}Alternatively, if you want an app to only run on certain platforms, you can specify this using the special deny_platforms setting:location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;deny_platforms&quot;: [windows, linux]}Possible values for the  deny_platforms  parameter are windows, linux, and mac.Settings and parametersEach app, engine or framework explicitly defines a number of settings which you can override in the configuration file. These settings are strongly typed into strings, integers, lists, etc. For details, see the Toolkit reference documentation.",
    "url": "/6d10dedf/",
    "relUrl": "/6d10dedf/"
  },
  "6": {
    "id": "6",
    "title": "내 컨텍스트에 존재하는 값이 as_template_fields()에 누락되었습니다.",
    "content": "내 컨텍스트에 존재하는 값이 as_template_fields()에 누락되었습니다.as_template_fields() 메서드는 템플릿의 키에 해당하는 폴더가 아직 생성되지 않은 경우 경로 캐시를 사용하며, 그러면 필드가 반환되지 않습니다. 이 문제는 여러 이유에서 발생할 수 있습니다.  템플릿 정의 및 스키마가 동기화 상태여야 합니다. 이 템플릿 정의, 또는 파이프라인 구성의 스키마를 수정했는데 둘 모두 동기화되지 않은 경우 예상한 필드가 반환되지 않습니다.  이 특정 컨텍스트에 대해 폴더가 생성되지 않았습니다. 아직 생성되지 않았다면 경로 캐시에 일치되는 레코드가 없게 되고, 따라서 예상한 필드가 반환되지 않습니다.",
    "url": "/8d9d2658/",
    "relUrl": "/8d9d2658/"
  },
  "7": {
    "id": "7",
    "title": "AWS Knowledge",
    "content": "AWS KnowledgeBelow you can find links to additional reading material from AWS, including documentation on technologies leveraged by the Isolation feature set, as well as compliance information:  [AWS Media Blog] Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Shotgun  [AWS Media Blog] Designing for Studio-Grade Security  [Compliance] MPAA &amp;amp; Studio Security  [AWS Direct Connect] Overview          [AWS Direct Connect] User Guide        [AWS S3] Overview          [AWS S3] User Guide        [AWS EC2] Overview          [AWS EC2] User Guide        [AWS VPC] Overview          [AWS VPC] User Guide        [AWS PrivateLink] Overview",
    "url": "/5528234a/",
    "relUrl": "/5528234a/"
  },
  "8": {
    "id": "8",
    "title": "Webhooks Batch Deliveries",
    "content": "Batch DeliveryEnabling Batch DeliveryYou can choose to configure your webhook so that it will make requests with a batched payload format by selecting the “Deliver in Batched Format” option.If enabled, at the time each request is formed, it will batch up to 50 pending deliveries into its payload.This can help with managing the processing of large bursts of deliveries as a result of many SG events being generated in a short amount of time. Under typical system operation, multiple deliveries per payload will occur when subscribed events are generated more frequently than once in a 2-second period.Responding to deliveriesIf enabling batched deliveries, we recommend that your receiving service is designed to guarantee a response much faster than 1 second per event. Otherwise, you will be at increased risk for timeouts and webhook failure when batches are large.                    Note: For a receiving service that takes on order of 1 second to respond to a single event, the response time is the main performance factor, not delivery overhead. There will not be any significant benefit in batching.    Non-batched-deliveries Webhooks  timeout allowance is 6 seconds per delivery. i.e. a webhook endpoint must respond to each request within 6 seconds.Batched-deliveries Webhooks  timeout allowance is the maximum of: 6 seconds, or, 1 second per event in the batch.  throttling limits still apply: 1 minute of webhook endpoint response time per minute per ShotGrid site, across all webhooks.Comparison of Webhook Delivery FormatsNon-batched-deliveries Webhook Message Body (always 1 delivery):{  &quot;data&quot;:{    &quot;id&quot;:&quot;119.110.0&quot;,    &quot;event_log_entry_id&quot;:479004,    &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,    &quot;operation&quot;:&quot;update&quot;,    &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},    &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1419},    &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:127},    &quot;meta&quot;:{      &quot;type&quot;:&quot;attribute_change&quot;,      &quot;attribute_name&quot;:&quot;code&quot;,      &quot;entity_type&quot;:&quot;Asset&quot;,      &quot;entity_id&quot;:1419,      &quot;field_data_type&quot;:&quot;text&quot;,      &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,      &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;    },    &quot;created_at&quot;:&quot;2021-02-22 17:40:23.202136&quot;,    &quot;attribute_name&quot;:&quot;code&quot;,    &quot;session_uuid&quot;:null,  },  &quot;timestamp&quot;:&quot;2021-02-22T17:40:27Z&quot;}Batched-Deliveries Webhook Message Body (may contain 1 to 50 deliveries)When batching is enabled, a deliveries key is always present, even if there is only 1 event in the batch. Its value is an array of individual event delivery data, where the information provided for each delivery is identical to un-batched mode.{  &quot;timestamp&quot;:&quot;2021-02-22T18:04:40.140Z&quot;,  &quot;data&quot;:{    &quot;deliveries&quot;:[      {        &quot;id&quot;:&quot;170.141.0&quot;,        &quot;event_log_entry_id&quot;:480850,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;code&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,          &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.198641&quot;,        &quot;attribute_name&quot;:&quot;code&quot;,        &quot;session_uuid&quot;:null,      },      {        &quot;id&quot;:&quot;170.141.1&quot;,        &quot;event_log_entry_id&quot;:480851,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;description&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:null,          &quot;new_value&quot;:&quot;Some other *description*&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.212032&quot;,        &quot;attribute_name&quot;:&quot;description&quot;,        &quot;session_uuid&quot;:null,      },    ]  }}",
    "url": "/e7890fc8/",
    "relUrl": "/e7890fc8/"
  },
  "9": {
    "id": "9",
    "title": "Beyond Your First Project",
    "content": "Beyond your first projectHere, we explain where to go once you have got your first project up and running using the ShotGrid Desktop. It covers useful common questions and topics and lists useful documentation resources.Welcome to ToolkitWelcome to Toolkit! If you are reading this, it probably means that you have managed to successfully install your first ShotGrid Pipeline Toolkit Project using the ShotGrid Desktop.At this stage, we are hoping you are up and running and have something looking like the screenshot above, a project page with several application launchers. At this stage, try opening Maya, Nuke or any of the other Applications. You should find a ShotGrid menu with further functionality for managing files and assets.So where do you go from here? Toolkit offers a lot of flexibility in terms of its configuration and how it works. This document tries to cover some of the next steps that we recommend that you carry out once you are up and running with your first project using the ShotGrid Desktop.Basic ConfigurationThis section contains a collection of tweaks and useful things to configure. If you have just set up your very first Toolkit project, there are most likely a number of little tweaks and adjustments you need to do to get everything up and running properly. This section tries to explain these various steps. Please note that some of these things involve editing configuration files and going “under the hood” at the moment. If you have any questions about anything, please visit our support site for help.Setting up Application PathsOnce you have set up your first project and click one of the launch buttons to launch Maya, Motionbuilder or Nuke, it is possible that you see an error message looking something like this:In the toolkit project configuration, we store paths to the various executables that you can launch. If you are seeing the above message, it probably means that those paths are not matching your studio setup. You may also find that the wrong version of the application is being launched; for example, our default configuration may have a path to maya 2015 but your studio is running maya 2014. In this case, you also need to change the paths.In our default configurations, these paths are all stored in a single file called  paths.yml. In order to change a path, locate your project configuration on disk and then navigate into the config folder until you find the  paths.yml file:Open this file and make the necessary changes to the paths. Once you have saved the file, you need to leave the project inside of ShotGrid desktop and then click back into it. (but no need to restart the entire application).Further ReadingFor more information about applications, check out the following topics:  The Toolkit Application Launcher  Passing Commandline ArgumentsShotGrid IntegrationToolkit integrates with ShotGrid and extends the traditional interface by adding special toolkit action menu items to various parts of the UI:This offers a way to launch Toolkit applications or custom tools that operate on data directly from ShotGrid. You can learn more about integrating with your ShotGrid site in  the Browser Integration section of the Admin Guide.Adding Publishes to the ShotGrid UIOnce you have toolkit installed, it usually makes sense to make some minor adjustments to the ShotGrid UI layouts. The ShotGrid Pipeline Toolkit creates  Publish Entities when you publish a file, so it is handy to add a  Publishes Tab to key Assets such as Shot and Asset. To do this, make sure that you are logged in as an admin user. Start by navigating to an Asset or Shot and enter into  Design Mode:Now click the little menu triangle on one of the tabs, and select the  Add New Tab action. This will bring up a Dialog UI. Call the tab  Publishes and make sure that it is associated with  Published File Entities:Now click  Save to save your changes. You are all set!Note: ShotGrid will choose a couple of default fields to pull in when you create a new tab. You may want to add a couple of extra fields for publishes. This is done by clicking the little plus button in the top-right hand corner of the spreadsheet you can see under your new publishes tab. We recommend that you add the following fields:  Description - Holds a description of the changes in this publish  Created By - The user who created the publish  Date Created - When the publish was madeIf you make changes to your layouts, don’t forget to save the page afterwards!Multiple Operating SystemsIn some cases, you may be seeing a message popping up, informing that you  Python cannot be found with a link to this section of the documentation.Toolkit executes its scripts and functionality using a language called  Python. The ShotGrid Desktop comes with a complete Python installation built in, so normally you never need to worry about this. When you set up a new Toolkit project using the ShotGrid Desktop, the project will be set up by default to use the Python that comes bundled with the ShotGrid Desktop. However, sometimes you may explicitly have to tell Toolkit which Python you want it to use. This can happen in if you for example:  Use an older version of the ShotGrid Desktop which doesn’t set up all Python defaults automatically.  If you have installed the ShotGrid Desktop in a non-standard location on disk.  If you a running a manual or more complex Toolkit project setup.The path to Python is stored in configuration files which you can manually edit:In order to find the right file, first navigate to your project configuration. In there, find the tree files starting with  interpreter_. These contain the paths to the python interpreter for Linux, Windows and Mac (“Darwin”). These files contain the location of Python for each of the three operating systems. You now need to go in and manually add the python locations for any operating system you wish you use.If the files are blank, this indicates that you are using an older version of the ShotGrid Desktop. If this is the case, simply try to update the blank files with the default Python paths. They are as follows:  Macosx (Darwin):  /Applications/Shotgun.app/Contents/Frameworks/Python/bin/python  Windows:  C: Program Files Shotgun Python python.exe  Linux:  /opt/Shotgun/Python/bin/pythonIf you rather have installed the ShotGrid Desktop in a non-standard location or intend to use a custom python location, please ensure that the paths in the files point to a valid Python installation. It needs to be v2.6 or above (but not Python 3!). If you want to execute UI based applications and tools, please make sure that the Python you specify has either PyQt or PySide installed and is linked up to a QT v4.6 or higher.Please also note that in order to run Toolkit on multiple operating systems, you need to specify the paths to all your desired platforms when you are running the project setup wizard. If you haven’t done this, and want to add an additional operating system to a storage path or configuration location, please visit our support site for help.Next StepsHopefully at this point you now have the default ShotGrid setup working for a ShotGrid project (or test project). Applications are launching, Context menu actions and publishes are showing up in ShotGrid and things are working on all your desired operating system platforms.This next section is all about what to do next – the process of starting to take that default configuration and adjust it to work more like the rest of your studio pipeline. Toolkit is flexible and highly configurable, and we have lots of documentation. But before you get started, to see it all in action, we recommend spending a couple of minutes checking out our various walkthrough videos. These show the ShotGrid Pipeline Toolkit in action, how it works inside applications such as Maya and Nuke. It also goes through basic concepts such as publishing, version control, loading etc.ShotGrid Toolkit Video CollectionThe anatomy of a Toolkit ProjectWhen you create a new Toolkit project, you end up with a couple of key locations.  The ShotGrid Desktop and its configuration is installed on your local machine. (If you want, it is possible to relocate both the application and the configuration to a shared storage).  The data area where the Toolkit project will store textures, files, renders etc. This is normally on a shared storage, because you want to share this data with other users, however there are exceptions to this rule; user work areas can be stored on local (user only) storage, and integrations such as our perforce integration uses an external system to help distribute content.  The toolkit configuration is a fully self contained bundle, including code, apps, core API etc. This is normally stored on a shared storage so that the configuration is easily accessible by all users.Your Project configuration on disk contains a couple of different items.In the following sections we’ll walk through the various parts of the project configuration folder.Command line accessAs well as using the ShotGrid Desktop, you can also access Toolkit via a terminal or shell. Each project that you create on disk comes with a special  tank command which gives you command line based access to a lot of functionality, including starting up an API session and launching applications.If you navigate to your project configuration, you can see a  tank and a  tank.bat command in the root of the configuration. Running these commands without any options will give you a list of all the commands that are supported in your current configuration, including the following useful commands:  tank shell - Start an interactive python shell with tk api access  tank core - Check if there are any core API updates available for this project  tank updates - Check if any of the apps or engines in this configuration has got any updates availableFor more details on what you can do with the  tank command, please see the in-depth technical documentation:How to Administer ToolkitKey Configuration FilesThe  config folder contains a couple of key configuration files.Toolkit comes with a folder creation system which tries to automatically create folders on disk to make sure that when you start up an application, all the necessary structure on disk exists and has been prepared on beforehand! The configuration for this can be found in the  schema folder indicated above.Hand in hand with this goes the Toolkit  template system which makes it easy to define the various paths to files that you can configure; your publishes, work files, renders etc. This is stored in the  templates.yml file above.Together, these two parts of the project configuration makes it possible to adjust the various Apps that toolkit use to write out data to locations on disk which make sense are are understood by your existing pipeline.Read more about this in our advanced documentation:  Folder Configuration  Filesystem TemplatesA toolkit configuration is essentially made up of a collection of configured  apps and engines. This configuration is located in the  env folder. If the file system configuration files discussed above define  where resources should be located on disk, the environment configuration with its apps and engines define  what the pipeline is supposed to do.Core API platformEach project configuration uses a collection of Apps and Engines. The configuration for these apps and engines are stored in the  env folder inside the configuration. Toolkit will then automatically download and manage the various versions of the code needed to run these apps and engines. The code is placed inside the  installfolder.The configuration, apps and engines are all running on top of the Toolkit Core platform. For new projects, this is also stored inside the  install folder. Essentially, a project configuration is fully self contained - all the necessary pieces required to run toolkit are in a single place. This also means that each project is independent and updating one project will not break another.Tech Notes: Using a shared Toolkit Core (Click to expand)Further readingWe also have a more technical document that goes through the high level concepts in the ShotGrid Pipeline Toolkit and explains ‘bigger picture’ things. Once you have a good grasp of what Toolkit does out of the box, we recommend that you move on to this document to get a deeper undestanding of how Toolkit could be adjusted to suit your particular studio needs.An introduction to the high level concepts in the ShotGrid ToolkitThe Toolkit CommunityA part of Toolkit is its community of pipeline engineers and TDs! We are on a mission to create a vibrant, code sharing community where we all can help evolve Toolkit together to become a powerful and flexible pipeline environment.If you have any questions, or want to read through existing posts and conversations, please visit our  public forums section.",
    "url": "/c3b662a6/",
    "relUrl": "/c3b662a6/"
  },
  "10": {
    "id": "10",
    "title": "ShotGrid 데스크톱/브라우저 통합을 Linux에서 실행할 수 없습니다",
    "content": "ShotGrid 데스크톱/브라우저 통합을 Linux에서 실행할 수 없습니다Linux에서 ShotGrid 데스크톱을 처음 실행하면 다음 오류 메시지 중 하나가 나타날 수 있습니다. 그러면 해당 오류에 대해 아래 단계를 수행하여 오류가 해결되는지 확인해 보십시오.여전히 해결되지 않으면 support@shotgunsoftware.com으로 문의하시기 바랍니다.목차  OPENSSL_1.0.1_EC 또는 HTTPSConnection 관련 문제  libffi.so.5 관련 문제  인증서 유효성 확인 실패 관련 문제  호환되지 않는 Qt 버전OPENSSL_1.0.1_EC 또는 HTTPSConnection 관련 문제오류importing '/opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so': /opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so: symbol ECDSA_OpenSSL, version OPENSSL_1.0.1_EC not defined in file libcrypto.so.10 with link time referenceAttributeError: 'module' object has no attribute 'HTTPSConnection'솔루션OpenSSL을 설치해야 합니다. 설치하려면 다음 명령을 관리자 권한으로 실행합니다.$ yum install openssllibffi.so.5 관련 문제오류Browser Integration failed to start. It will not be available if you continue.libffi.so.5: cannot open shared object file: No such file or directory솔루션libffi를 설치해야 합니다. 설치하려면 다음 명령을 관리자 권한으로 실행합니다.yum install libffilibffi를 설치했는데도 여전히 작동하지 않으면 다음 symlink를 생성한 후 ShotGrid 데스크톱을 다시 실행해 보십시오.sudo ln -s /usr/lib64/libffi.so.6.0.1 /usr/lib64/libffi.so.5위 방법으로 성공한 사용자들도 있고, 그렇지 못한 사용자들도 있습니다. 최신 버전 ShotGrid 데스크톱에는 웹 소켓 서버에 대한 종속성이 일부 추가되었습니다. 현재 ShotGrid 팀에서 해당 내용을 살펴보고 있습니다.인증서 유효성 확인 실패 관련 문제가능한 오류Browser Integration failed to start. It will not be available if you continue.Error: There was a problem validating if the certificate was installed.certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.솔루션컴퓨터에 Google Chrome이 설치되어 있다면 이를 실행한 다음 ShotGrid 데스크톱을 다시 실행합니다. 그래도 문제가 발생하면 support@shotgunsoftware.com으로 문의하시기 바랍니다.Chrome이 없으면 터미널을 열고 다음 명령을 실행합니다.ls -al $HOME/.pki/nssdb해당 폴더가 검색되면 지원 팀에 문의하고, 다음 로그 파일의 내용을 지원 요청 티켓에 첨부해 주십시오.~/.shotgun/logs/tk-desktop.log폴더가 검색되지 않으면 다음을 입력합니다.$ mkdir --parents ~/.pki/nssdb$ certutil -N -d &quot;sql:$HOME/.pki/nssdb&quot;암호를 입력하지 마십시오.ShotGrid 데스크톱을 실행하면 이제 올바로 작동할 것입니다.호환되지 않는 Qt 버전가능한 오류호환되지 않는 Qt 라이브러리(버전 0x40805)를 이 라이브러리(버전 0x40807)와 혼합할 수 없음솔루션이 오류는 대개 재정의가 발생하면서 호환되지 않는 Qt 라이브러리를 로딩하게 됨에 따라 발생합니다.이 오류가 발생하지 않도록 하려면 다음 명령으로 환경을 수정해 보십시오.unset QT_PLUGIN_PATH",
    "url": "/9207f027/",
    "relUrl": "/9207f027/"
  },
  "11": {
    "id": "11",
    "title": "Chrome에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다",
    "content": "Chrome에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다개요간혹 ShotGrid의 액션 메뉴에 사용 가능한 툴킷 응용프로그램 목록이 표시되지 않거나, ShotGrid 데스크톱이 실행 중인데도 로컬 파일 링크를 사용하면 오류가 발생할 수 있습니다. 이 문서는 Chrome에서 ShotGrid 데스크톱의 브라우저 통합 문제를 해결하고, 원하는 기능들이 제대로 작동하도록 지원하는 안내서입니다. Firefox의 경우 별도의 안내서가 있습니다.  문제 진단  인증서 문제를 빠르게 해결하는 방법  모든 플랫폼에서 ERR_CERT_COMMON_NAME_INVALID 또는 ERR_SSL_SERVER_CERT_BAD_FORMAT 해결  Windows에서 ERR_CERT_AUTHORITY_INVALID 해결문제 진단ShotGrid 데스크톱이 실행 중입니까?예, 알고 있습니다. 이미 확인하셨을 것이라 생각했지만 다시 한번 확인했습니다. :)ShotGrid 데스크톱을 시작한 후에 Chrome을 다시 시작했습니까?ShotGrid 데스크톱이 인증서를 등록(ShotGrid 데스크톱을 처음 실행할 때에만 등록하면 되고, 이후부터는 문제 없음)하기 전에 Chrome을 실행했다면 Chrome이 오래된 인증서 사본을 사용하면서 ShotGrid 데스크톱 연결을 거부합니다. 모든 탭을 닫는다고 해서 Chrome이 닫히는 것은 아니므로 주소 표시줄에 chrome://restart를 입력하고 Enter 키를 누르는 것이 좋습니다. 이렇게 하면 모든 Chrome 관련 프로세스가 종료되고, Chrome이 다시 시작됩니다.방화벽 소프트웨어를 사용 중입니까?방화벽 소프트웨어가 localhost 또는 포트 9000 접속을 차단 중이지 않은지 확인하십시오.Chrome이 인증서를 거부합니까?https://localhost:9000으로 이동하여 Chrome이 인증서를 수락하는지 확인할 수 있습니다. 이 주소는 ShotGrid 웹 사이트가 로컬 파일 링크를 수행하고 툴킷 응용프로그램을 실행하기 위해 액세스하는 주소입니다. 보통 다음 메시지가 나타나야 합니다.이와 달리 다음 메시지 중 하나가 표시된다면 인증서 등록 프로세스에 문제가 발생했다는 의미입니다.인증서 문제를 빠르게 해결하는 방법이 문제를 방지하는 가장 쉬운 방법은 고급(ADVANCED), localhost로 진행(Proceed to localhost)(안전하지 않음)을 클릭하는 것입니다. 이렇게 하면 Chrome에서 여러분이 인증서를 수락하려고 한다는 것을 인식하고, ShotGrid 웹 사이트가 ShotGrid 데스크톱과 통신하도록 허용합니다.                    참고: 웹 브라우저와 ShotGrid 데스크톱 간에 연결이 이루어지도록 할 수 있는 방법은 이것뿐입니다. 신뢰 설정은 두 응용프로그램 간 트래픽 흐름을 가능하도록 할 뿐, 인터넷 상의 다른 모든 서버에 대한 신뢰를 의미하는 것은 아닙니다. 아쉽게도 이 프로세스는 문제가 있는 모든 컴퓨터마다 반복해야 합니다. 이렇게 해도 문제가 해결되지 않거나 모든 사용자들에게 알려주기에는 너무 복잡한 방법이라고 생각되는 경우 다음 단계를 살펴보시기 바랍니다.                        참고: 이 단계 해결 방법은 ERR_SSL_SERVER_CERT_BAD_FORMAT 오류에는 적용되지 않으며, 아래 설명에 따라 인증서를 다시 생성해야 합니다.    모든 플랫폼에서 NET::ERR_CERT_COMMON_NAME_INVALID 및 ERR_SSL_SERVER_CERT_BAD_FORMAT 해결Chrome은 자체 서명 인증서에 관한 보안을 정기적으로 업그레이드하며, 이 업데이트로 인해 종종 브라우저 통합이 끊어집니다. 불행히도 이런 종류의 문제는 인증서의 certificate_path를 다시 생성하는 방법으로만 해결할 수 있습니다.인증서를 다시 생성하려면 ShotGrid 데스크톱의 사용자 메뉴에 있는 고급(Advanced) 섹션에서 인증서 재생성(Regenerate Certificates) 옵션을 선택해야 합니다. (이 옵션이 보이지 않으면 tk-desktop 엔진을 업데이트하여 잠금 해제합니다.)인증서 재생성을 확인하고 나면 인증서를 처음 생성했을 때처럼 일련의 대화상자가 나타납니다. Windows 및 macOS에서는 Windows 인증서 저장소 또는 macOS 키체인을 업데이트하라는 메시지가 두 번 나타납니다. 한 번은 이전 인증서를 제거하라는 메시지가 나타나고, 새 인증서를 등록하라는 메시지가 한 번 더 나타납니다. Linux에서는 등록이 자동으로 이루어집니다. 등록이 끝나면 ShotGrid 데스크톱을 다시 시작합니다.ShotGrid 데스크톱이 다시 시작되어 실행되면 주소 표시줄에 chrome://restart를 입력해 Chrome을 다시 시작함으로써 Chrome이 완전히 종료되고 인증서 캐시가 지워지도록 하는 것이 좋습니다.컴퓨터가 인터넷에 연결되어 있지 않아 업데이트를 다운로드할 수 없다면 support@shotgunsoftware.com에 문의하시기 바랍니다.Windows에서 NET::ERR_CERT_AUTHORITY_INVALID 해결경우에 따라 Windows가 인증서를 성공적으로 가져왔다고 보고하는데 인증서가 필요한 응용프로그램에 이를 사용할 수 없을 때가 있습니다. 이는 Windows에서 인증서 대화상자로 이동하여 확인할 수 있습니다. 대화상자에 액세스하려면 Windows 키를 누르고 인터넷 옵션을 입력합니다. 인터넷 속성 대화상자에서 내용 탭으로 이동한 다음 인증서 버튼을 클릭합니다. 마지막으로 신뢰할 수 있는 루트 인증 기관을 클릭하고 localhost를 찾습니다.해당 항목이 없으면 Windows 도메인 또는 로컬 컴퓨터에 그룹 정책 문제가 있다는 의미일 수 있습니다. 이 문제가 있으면 지원 팀에 문의하는 것이 좋습니다.이 경우, 조직의 Windows 컴퓨터 관리자에게 연락하여 Windows로 하여금 자체 서명 인증서를 신뢰하지 않도록 지시하는 그룹 정책이 설정되어 있지 않은지 문의해 보십시오.그룹 정책 문제 조사컴퓨터가 도메인에 존재한다면 관리자는 이 StackExchange 게시글에 나와 있는 단계대로 수행하면 됩니다.컴퓨터가 도메인에 존재하는 것이 아니라면 컴퓨터가 관리자에 의해 여전히 잠겨 있을 가능성이 있습니다. 다음 단계를 수행하려면 Windows 관리자 계정이 필요합니다.Windows 키를 클릭하고 mmc를 입력한 다음 Enter 키를 누릅니다. 그러면 Microsoft 관리 콘솔이 실행됩니다. 이 응용프로그램에서 파일 메뉴를 클릭하고 스냅인 추가/제거를 선택합니다. 그러면 스냅인 추가/제거 대화상자가 나타납니다. 왼쪽에서 그룹 정책 개체 편집기를 찾아 추가 &amp;gt;를 클릭합니다. 새 대화상자가 나타나면 마침을 클릭해 무시하면 됩니다. 끝으로 스냅인 추가/제거 대화상자에서 확인을 클릭합니다.마지막으로 메인 대화상자 왼쪽에서 로컬 컴퓨터 정책/컴퓨터 구성/Windows 설정/보안 설정/공개 키 정책으로 이동합니다. 가운데 패널에서 인증서 경로 유효성 검사 설정을 선택한 다음 두 번 클릭합니다.다음 대화상자에서 이 정책 설정 정의가 선택 해제되어 있는지 확인합니다. 선택되어 있으면 사용자의 신뢰할 수 있는 루트 CA를 사용하여 인증서를 확인하도록 허용(권장)이 선택되어 있는지 확인합니다. 마치면 확인을 클릭하여 설정을 저장합니다.이때 모든 Chrome 창을 닫고 Chrome을 다시 시작해야 합니다. 위에서처럼 chrome://restart를 사용하여 다시 시작하는 것이 좋습니다. 이렇게 해야 변경 사항이 제대로 적용됩니다. 이제 인증서 목록을 찾으면 localhost 인증서가 보여야 합니다.이렇게 변경한 후에도 브라우저 통합을 사용할 때 문제가 계속 발생하거나 첫 번째 단계에서 설정이 올바르게 되어 있다면 지원 팀에 문의하시기 바랍니다.다른 OS에서 문제 해결다른 OS에서 ShotGrid 데스크톱 통합과 관련한 문제가 발생한다면 지원 팀에 연락해 도움을 받고, 이 게시글도 업데이트하도록 해 주십시오.",
    "url": "/95518180/",
    "relUrl": "/95518180/"
  },
  "12": {
    "id": "12",
    "title": "Firefox에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다.",
    "content": "Firefox에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다.개요간혹 ShotGrid의 액션 메뉴에 사용 가능한 툴킷 응용프로그램 목록이 표시되지 않거나, ShotGrid 데스크톱이 실행 중인데도 로컬 파일 링크를 사용하면 오류가 발생할 수 있습니다.이 문서는 Firefox에서 ShotGrid 데스크톱의 브라우저 통합 문제를 해결하고, 원하는 기능들이 제대로 작동하도록 하는 데 도움을 주기 위한 안내서입니다. Chrome의 경우 별도의 안내서가 있습니다.문제 진단ShotGrid 데스크톱이 실행 중입니까?예, 알고 있습니다. 이미 확인하셨을 것이라 생각했지만 다시 한번 확인했습니다. :)방화벽 소프트웨어를 사용 중입니까?방화벽 소프트웨어가 localhost 또는 포트 9000 접속을 차단 중이지 않은지 확인하십시오.Firefox가 인증서를 거부합니까?https://localhost:9000으로 이동하여 Firefox가 인증서를 수락하는지 확인할 수 있습니다. 이 주소는 ShotGrid 웹 사이트가 로컬 파일 링크를 수행하고 툴킷 응용프로그램을 실행하기 위해 액세스하려고 시도하는 주소입니다. 보통 다음 메시지가 나타나야 합니다.이와 달리 다음 두 메시지 중 하나가 표시된다면 인증서 등록 프로세스에 문제가 발생했다는 의미입니다.“연결이 안전하지 않음” 문제를 해결하는 방법인증서가 수락되도록 Firefox 브라우저에 예외를 추가해야 합니다. https://localhost:9000을 막 방문한 경우라면 예외를 추가하는 가장 쉬운 방법은 고급(Advanced)을 클릭하고 예외 추가(Add Exception) 버튼을 클릭하는 것입니다. 대화상자가 나타납니다.**인증서 가져오기(Get Certificate)를 클릭한 다음 **보안 예외 확인(Confirm Security Exception)을 클릭합니다. 인증서를 신뢰할 수 없다는 메시지는 무시해도 됩니다. 인증서가 인증 기관이 아닌 ShotGrid 데스크톱에 의해 생성된 경우에 보통 발생하는 일입니다.이제 ShotGrid 사이트에서 로컬 파일 링크에 액세스하고 툴킷 응용프로그램을 실행할 수 있습니다. 예외를 추가한 뒤에도 계속 문제가 발생하면 support@shotgunsoftware.com으로 문의하십시오.“보안 연결 실패” 문제를 해결하는 방법메뉴 열기(Open Menu) 버튼을 클릭하고 기본 설정(Preferences)을 선택해야 합니다. 그 다음 왼쪽에서 고급(Advanced)을 선택하고, 인증서(Certificates) 그리고 끝으로 인증서 보기(View Certificates)를 선택합니다.서버(Servers) 섹션에서 아무 항목이나 클릭하고 localhost를 입력하거나 그냥 이름이 localhost:9000인 항목이 나올 때까지 스크롤합니다. 이를 삭제합니다. 그런 다음, 기관(Authorities) 탭으로 이동해 localhost를 다시 입력합니다. 역시 그 아래 localhost 항목이 있는 Autodesk 섹션이 나올 때까지 스크롤해도 됩니다. localhost 항목을 제거하면 됩니다. 다 마치면 확인(OK)을 클릭해 Firefox를 다시 시작합니다. Firefox가 다시 시작되면 https://localhost:9000으로 이동합니다. 이제 다음 메시지가 나타나야 합니다.이때 위에 설명된 단계에 따라 예외를 추가해야 합니다.이 화면이 아닌 다른 화면이 표시된 경우 support@shotgunsoftware.com으로 문의하십시오.",
    "url": "/d4936105/",
    "relUrl": "/d4936105/"
  },
  "13": {
    "id": "13",
    "title": "ShotGrid in the Cloud",
    "content": "ShotGrid in the CloudWhat is ShotGrid in the Cloud?ShotGrid Cloud is our default offering, hosted on AWS and built on top of Autodesk’s Cloud technology platform. ShotGrid Cloud is the latest generation of our hosted service and is completely cloud based.Further ReadingAdministration documentation can be found here.",
    "url": "/af35baf6/",
    "relUrl": "/af35baf6/"
  },
  "14": {
    "id": "14",
    "title": "Community Shared Integrations",
    "content": "Community Shared IntegrationsHere are projects that people in the Toolkit community have been gracious enough to share. They aren’t written by us at ShotGrid and we can’t vouch for them, but we’ll definitely answer any questions we can about them. If you have a project you want added to the list, please visit our support site for help.Engines            Integration      Engine      Information                        tk-katana      Project URL: https://github.com/robblau/tk-katana  Project Contributor:  Lightchaser Animation  Project Maintainer:   Project Description: A ShotGrid Engine for Foundry’s Katana                    tk-unreal      Project URL: https://docs.unrealengine.com/en-US/Engine/Content/UsingUnrealEnginewithAutodeskShotgun/index.html  Project Contributor:  Epic Games  Project Maintainer:  Project Description: A ShotGrid Engine for  Unreal Engine                    tk-substancepainter      Project URL:  https://github.com/diegogarciahuerta/tk-substancepainter  Project Contributor:  Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for Adobe’s Substance Painter                    tk-substancedesigner      Project URL:  https://github.com/diegogarciahuerta/tk-substancedesigner    Project Contributor:  Factor64    Project Maintainer: Diego Garcia Huerta    Project Description: A ShotGrid Engine for Adobe’s Substance Designer    More info:  ShotGrid Community Forums                    tk-modo      Project URL: https://github.com/tremolo/tk-modo    Project Contributor: Lutz Pälike and  Walking The Dog    Project Maintainer:    Project Description: A ShotGrid Engine for Foundry’s Modo                    tk-clarisse      Project URL:  https://github.com/diegogarciahuerta/tk-clarisse  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Clarisse iFX, a fully interactive CG toolset for set-dressing, look development, lighting and rendering.                    tk-natron      Project URL:  https://github.com/diegogarciahuerta/tk-natron  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Natron, a free and open-source node-based software application.                    tk-harmony      Project URL:  https://github.com/diegogarciahuerta/tk-harmony  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Toon Boom Harmony, industry leading production animation software.                    tk-cinema      Project URL:  https://github.com/mikedatsik/tk-cinema  Project Contributor: Mykhailo Datsyk  Project Maintainer: Mykhailo Datsyk  Project Description: A ShotGrid Engine for  Maxon Cinema 4D, a designer-friendly toolset for modeling, animation, and rendering.  More Information:  ShotGrid Community Forums                    tk-krita      Project URL:  https://github.com/diegogarciahuerta/tk-krita  Project Contributor: Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Krita, a free and open-source raster graphics editor designed primarily for digital painting and 2D animation.  More Information: ShotGrid Community Forums                    tk-blender      Project URL:  https://github.com/diegogarciahuerta/tk-blender  Project Contributor: Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Blender, a free and open-source 3D computer graphics software toolset used for creating animated films, visual effects, art, 3D printed models, motion graphics, interactive 3D applications, virtual reality and computer games.  More Information: ShotGrid Community Forums      Apps            Integration      Engine      Information                        tk-maya-playblast      Project URL:  https://github.com/basestudio/tk-maya-playblast    Project Contributor: BASE Studio    Project Maintainer:    Project Description: App to publish playblasts from Maya. See https://goo.gl/5oJTv0                    tk-multi-renderfarm      Project URL: https://github.com/baitstudio/tk-multi-renderfarm    Project Contributor: Bait Studio    Project Maintainer:    Project Description: App to submit work to the farm. See https://goo.gl/ew6mkD                    tk-shotgun-publishrenders      Project URL: https://github.com/janimation/tk-shotgun-publishrenders    Project Contributor:    Project Maintainer:  Dave Sisk    Project Description: This app searches the directory structure of a project to find existing published files or file sequences, then registers them in ShotGrid as published files if the published file objects don’t already exist.                    nuke-getShotgunData      Project URL: https://github.com/RicardoMusch/nuke-getShotgunData    Project Contributor:  Ricardo Musch    Project Maintainer: Ricardo Musch    Project Description: Getting ShotGrid data into nuke text nodes can be a bit of a pain. This node can be used to pipe that info into slates, burn-ins, or anywhere else.                    sb-shotgun-schema-introspection      Project URL: https://github.com/scottb08/sb-shotgun-schema-introspection    Project Contributor:  Scott Ballard    Project Maintainer: Scott Ballard    Project Description: This is a simple Toolkit app that allows ShotGrid and Toolkit developers to quickly navigate and inspect the ShotGrid entities, fields and the underlying schema.                    foto-multi-namingconvention      Project URL: https://github.com/scottb08/foto-multi-namingconvention    Project Contributor:  Griffith Observatory    Project Maintainer: Scott Ballard    Project Description: This is a simple Toolkit app that allows ShotGrid and Toolkit developers to quickly navigate and inspect the ShotGrid entities, fields and the underlying schema.                    tk-cpenv      Project URL: https://github.com/cpenv/tk-cpenv    Project Contributor:  Dan Bradham    Project Maintainer: Dan Bradham    Project Description: This app adds support for  cpenv, a tool that uses modules to manage software plugins, project dependencies and environment variables.    More Information: ShotGrid Community Forums                    rtm-tk-hiero-shotgunDropper      Project URL: https://github.com/RicardoMusch/rtm-tk-hiero-shotgunDropper  Project Contributor:  Ricardo Musch  Project Maintainer: Ricardo Musch  Project Description: This app allows you to drop Versions and playlists from ShotGrid into Hiero.  More Information: ShotGrid Community Forums      ",
    "url": "/58a557ee/",
    "relUrl": "/58a557ee/"
  },
  "15": {
    "id": "15",
    "title": "Configuration Staging and Rollout",
    "content": "Configuration Staging and RolloutThis document explains best practices for how to safely roll out changes to your production pipeline. It explains how you can create a staging sandbox, which is a copy of your production configuration, update this sandbox and do testing and then finally push your changes to the production config.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For the default setup, please see  ShotGrid Integrations Admin Guide.IntroductionThis document outlines how to manage your Toolkit configuration. Toolkit contains several utilities and tools that lets you safely manage your configuration and test upgrades and changes in a safe and sandboxed environment before rolling them out to the entire production.In this document, we’ll describe how to:  Safely upgrade the Toolkit Core API.  Upgrading your Apps and Engines.  Various ways to manage your config across multiple projects.  Go through Toolkit’s  Clone  and  Push  functionality that allows you to safely test upgrades and changes without disrupting production.  How to work with  git  source control and Toolkit.Basics of configuration managementEach Toolkit Project has one or more configurations associated with it. The configuration contains all the settings that the project needs, including file system locations (templates), engines apps, etc. In Toolkit, each project is independently configurable. This means that different projects can live side-by-side safely, and upgrading one project will not affect another.If you are working with a large number of projects, this may become cumbersome and we offer several ways to make this process easy, safe and streamlined.In ShotGrid, each project has a number of  Pipeline Configurations. When a project is first set up with Toolkit, a Pipeline Configuration called  primary  is created. The pipeline configuration entity in ShotGrid points at a location on disk where the Toolkit configuration can be found.During the course of a project, you often need to make changes to the configuration. This can be tweaks to the configuration, or perhaps you need to add additional apps or engines. We also release new app versions frequently and we recommend that you use the latest versions if possible.While it is possible to upgrade your  primary  project configuration straight away, this can be risky; since this configuration is used by everybody on the project, introducing a problem will affect everyone. A better approach is to create an isolated version of the configuration that a select group of people have access to. In this safe environment, upgrades, configuration changes and development can happen without impacting the rest of the production. Once the changes have been tested, they can be safely and confidently pushed to the primary configuration.This process is called  cloning  and means that you make a personal copy of the primary configuration that only you (and other people you invite) have access to the clone. In here you can make changes safely and once you are happy you can push these changes back to the primary configuration.Cloning your ConfigurationOnce you have set up Toolkit and configured a project, the setup will look something like this:There is a  studio  install which holds the Core API for all projects. This  studio  location also contains a  tank command and a Toolkit Python API you can use to access any of your Toolkit-enabled ShotGrid projects.In addition to this, there is a configuration folder for each project. This folder contains all the settings for that project. It also contains a  tank  command (and a Python API) which specifically operates on this configuration. When you are using this tank command or API code, you can strictly only operate on this configuration.When a new project is set up, a  Primary  configuration is created. This is the configuration that Toolkit will use by default for the project. In addition to the primary configuration, you can create additional configurations for a project. These can exist in parallel and are useful if you for example want to privately test some modifications, upgrade some apps or do development without impacting the entire team. Additional configurations are created by a process called  cloning, a process where a configuration is copied to a new location.Once you have cloned your configuration, your setup may look something like this:In addition to the studio level  tank  command and your primary project configuration  tank  command, you now have a new pipeline configuration which has its own  tank  command. If you run this  tank  command, you will operate exclusively on the configuration located in the staging sandbox. So if you want to test out some new things in Maya, you can simply navigate to your cloned sandbox, run  ./tank Shot xyz launch_maya  and the ShotGrid menu which appears in Maya will reflect the configuration inside of your staging sandbox rather than your Primary configuration.Note that the studio level  tank  command always uses the Primary config, so the only way to access a cloned configuration is by navigating to its location and using the  tank  command that is located in that folder. In ShotGrid, you can assign a specific set of users to a pipeline configuration entry, and any users that are associated with a configuration will now see menu entries appear in addition to those coming from the Primary config:Creating a Cloned ConfigurationIn order to create a staging sandbox where you can safely test your upgrades, navigate to the pipeline configurations for your project in ShotGrid and right click on the Primary configuration. An option to clone your configuration will appear:Once you click it, you’ll be presented with a dialog where you specify the path on disk where you want this new configuration to be located. If you are running a multi OS setup, make sure to put in paths for all relevant platforms.When you press ok, Toolkit will copy the configuration across and set up the clone. It will also associate your ShotGrid user with this configuration, so as soon as you have created your clone, you will see new menu items appearing inside ShotGrid.Pushing changes from your staging sandbox to PrimaryOnce you have applied the relevant updates and run any testing that you deem is necessary, you can push back your changes into the production configuration by executing the  tank push_configuration  command. This will transfer all the changes you have made in your staging sandbox to your Primary configuration.Please note that your current configuration is moved to a backup location when you run the push_configuration command. If you accidentally push or if there is a problem with the push, you can roll back simply by taking the content in the backup folder and copying into the config folder.By default, this command will copy a collection of files into the  config  folder in the target pipeline configuration. If you are using unix and would like a more atomic update, you can add a  --symlink  flag to the  push_configuration  command. This will turn the  config  folder in the target pipeline configuration into a symbolic link which makes it easier to upgrade without running the risk of having configuration mismatches in currently running sessions.Refreshing an old cloned configurationIf you have a old dev or staging sandbox set up, but it is out of date and you need to sync its contents with the latest production configuration, you do this by running the  push_configuration  command for the primary configuration:tank push_configurationWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.comStarting Toolkit for your current directory '/tmp'- Using configuration 'Primary' and Core v0.14.52- Setting the Context to Empty Context.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary') to another pipeline configuration in the project.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [324] Staging Sandbox (/my/staging/sandbox)Please type in the id of the configuration to push to (ENTER to exit): 324Hold on, pushing config...Checking if there are any apps that need downloading...Push Complete!Your old configuration has been backed up into the following folder:/my/staging/sandbox/config.bak.20140108_093218Note how we are pushing from the primary project config to the staging sandbox. We do this by running the  primary  configuration’s tank command. If you have multiple sandboxes set up, it is also possible to push data between those.Deleting a cloned configurationIf you want to delete a cloned configuration, simply delete the entry in ShotGrid and remove the folder from disk.Getting latest apps and enginesInside your staging sandbox (or in any other config), you can run the  tank updates  command in order to check if there are any app updates available. This command has got rudimentary filters that you can use if you only want to check certain areas of your configuration:----------------------------------------------------------------------Command: Updates----------------------------------------------------------------------This command will go through your current configuration and check if there areany updates available. If there are updates, you will be asked if you want toperform an upgrade. If settings has been added to the new version that you areinstalling, you may be prompted to specified values for these.Running this command with no parameters will check all environments, enginesand app. This may take a long time. You can also run the updater on a subsetof your installed apps and engines.General syntax:&amp;gt; tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:Check everything:&amp;gt; tank updatesCheck the Shot environment:&amp;gt; tank updates ShotCheck all maya apps in all environments:&amp;gt; tank updates ALL tk-mayaCheck all maya apps in the Shot environment:&amp;gt; tank updates Shot tk-mayaMake sure the loader app is up to date everywhere:&amp;gt; tank updates ALL ALL tk-multi-loaderMake sure the loader app is up to date in maya:&amp;gt; tank updates ALL tk-maya tk-multi-loaderUpgrading the Toolkit Core APIThis section explains how you can use a clone staging sandbox configuration to safely upgrade the Toolkit Core API. If you haven’t got a staging sandbox prepared yet, just follow the instructions in the previous section!If your staging sandbox was cloned from a pipeline configuration using a  shared studio Core API, you’ll want to update your sandbox to use it’s own unique Core API code. This is called “localizing” the core and can be done by navigating to your staging sandbox and running  tank localize. This command will copy the Core API from the studio install, into your sandbox, making it possible to run and test a different version of the Core API later on.The default behavior in Toolkit is to localize the core by default. If you haven’t explicitly created a shared studio core previously, it’s safe to assume your core is localized already.cd /my/staging/sandbox./tank localizeWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.comStarting Toolkit for your current directory '/my/staging/sandbox'- Using configuration 'Staging Sandbox' and Core v0.14.52- Setting the Context to Empty Context.- Running command localize...----------------------------------------------------------------------Command: Localize----------------------------------------------------------------------This will copy the Core API in /mnt/software/shotgun/studio into the Pipelineconfiguration /my/staging/sandbox.Do you want to proceed [yn]yLocalizing Core: /mnt/software/shotgun/studio/install/core -&amp;gt; /my/staging/sandbox/install/coreCopying Core Configuration Files...Localizing Apps: /mnt/software/shotgun/studio/install/apps -&amp;gt; /my/staging/sandbox/install/appsLocalizing Engines: /mnt/software/shotgun/studio/install/engines -&amp;gt; /my/staging/sandbox/install/enginesLocalizing Frameworks: /mnt/software/shotgun/studio/install/frameworks -&amp;gt; /my/staging/sandbox/install/frameworksThe Core API was successfully localized.Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.Now we are no longer sharing the Core API with the studio location but are running our own, independent version. We can now go ahead and perform a standard Core API upgrade, again using our local tank command:cd /my/staging/sandbox./tank coreToolkit will check if there is a new version available and offer you to download and install it.Once you have updated the Core API, make sure to test the installation. Launch some apps, either using the tank command in the sandbox or using the special menu entries in ShotGrid. Do a basic run-through of your pipeline and perform the tests you deem necessary.Finally, once you are happy, it is time to go ahead and update the studio version of the Core API. Note that in the typical Toolkit setup, the Core API is shared between all projects, so by running the tank core command from your studio location  tank  command, you are updating the Core API for all projects.Managing the Project LifecycleEach Toolkit project contains an independent configuration which holds all the settings for that project. If you are managing a lot of projects, this means that you need to manage a lot of configurations. For this reason, Toolkit contains a number of different tools and ways to handle configurations, both for individual projects and for the studio lifecycle and configuration evolution. This section outlines some of those best practices and shows practical steps for how to set up your config.Depending on the needs of your studio, different levels of complexity may be relevant. Toolkit offers three different approaches and we’ll explain each one of them in detail:  The most straightforward approach is to copy the config from the previous project when you set up a new project. This is good if you are a small studio and don’t have a large number of projects.  If you have a higher project turnover and if you run more than one project in parallel, the next level of integration that we recommend involves git version control. Toolkit has native support for git and once you are up and running with a git-based workflow you have a single configuration for your studio and are tracking all the changes you are making to that configuration over time. Each project can safely pull in configuration changes as and when they need to.  If you are running a large-scale facility, it may be worth considering a setup where a single configuration is directly connected to all the currently-active projects in the studio. A single change to this configuration will have an immediate impact on all the projects.In the following sections we’ll describe the different approaches in detail.Inheriting the config from your previous projectThis is the simplest approach to configuration management. For the very first time you set up a project with Toolkit, you download our default configuration. You then set up that first project to match your pipeline settings, filesystem locations, etc. When the project is running, you run commands such as tank updates to update the app versions you are running.When your second project comes around, you don’t want to start with the default config again - instead, during the project setup phase, pick the config from your first project as the starter for your new project. This means that all the changes, tweaks and improvements you did for the first project will be taken advantage of in the second project as well. For the third project, use the second project’s config etc.This is a very simple way to gradually evolve the configuration over time. Changes and improvements will flow from project to project in an ad hoc fashion. The first time you run the setup_project command, just hit enter when the setup process prompts for the configuration to use. This will download and install the default configuration.For your second project, you will be presented with a list of paths to configurations for previous projects. Choose one of these paths and enter that when the setup process prompts for a config. This will copy that configuration to the new project:Welcome to the ShotGrid Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.com- Running command setup_project...----------------------------------------------------------------------Command: Setup project----------------------------------------------------------------------Welcome to the ShotGrid Pipeline Toolkit Project Setup!Connecting to ShotGrid...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   My very first project: '/mnt/software/shotgun/first_project/config'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe ShotGrid Pipeline Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can enter the pathto this config and it will be used for the new project.You can also enter an url pointing to a git repository. Toolkit will thenclone this repository and base the config on its content.[tk-config-default]: /mnt/software/shotgun/first_project/configA studio configuration in git source controlLimitations with the first approach include the fact that the projects are not connected to each other. If you have 10 projects and you all need to update them because a critical bug fix has been released, you would have to manually go through each project and run the  tank updates  command.One way to resolve this is to create a master configuration and store it in git source control. Whenever you create a new project, simply type in the path to this git repository in the setup project dialog and Toolkit will clone it for you. Now all the projects are connected to the same “studio master” config. If you have made some good changes to a project configuration, you can commit them and push them to the studio master. Other projects can then easily pull these down. You also retain a history of all your changes via git.What is Git?The basic idea is that you set up a git repository which holds the git configuration. Whenever you run tank setup_project, you specify the git url to this repository (for example  username@someserver.com:/studio_config.git) and the setup process will clone the repository so that the new project becomes a repository connected to the main studio repository. Once they are connected you can push and pull changes, and work in branches for finer granularity.Setting up your studio config repositoryBefore you do anything else, you need to create a studio config repository. This section shows how to take an existing toolkit configuration and creating a git repository from that.First, you need to go to your git server and create a repository. This process may be different depending on your setup. If you are using something like GitHub, you would start a web browser and navigate to github.com. If you have access to the server you may do something like  git init --bare. In our example, we assume that the git repository you create is called  username@someserver.com:/studio_config.git.Now move the  config  folder of the project you want to use to seed your repo with into a  config.bak  location:cd /project_configs/studio_configmv config config.bakClone your initialized git repository into the  config  location of your project that you want to base the studio config on. Once you have run the clone command, you will have an empty  config folder  which is also a git repository:cd /project_configs/studio_configgit clone username@someserver.com:/studio_config.git configCopy all the files from your config.bak location back into the config folder. Once done, you can delete the empty config.bak folder. Your config files are now inside the git repository and we need to add them, commit them and push them to the server. But before doing that, we need to do some house keeping to handle some Toolkit system files correctly. In the  config  folder, create a  .gitignore  file and add the following lines to it:install_location.ymlpipeline_configuration.ymlNow git will ignore those two system files. We can go ahead and add the rest of the files in the configuration, commit them and push them to the studio repository.git add --allgit commit -am &quot;initial commit of our studio config!&quot;git pushCreating a new project from gitWhen you create a new project, simply specify a valid git url when the setup process prompts you to enter the path to the configuration to use. Following our example above, we would enter username@someserver.com:/studio_config.git. As part of the project setup process, Toolkit will clone this repository into the config folder of your new project configuration. This means that you can later on go into this config folder and run git commands. Note that any cloned pipeline configurations will also clone the git repository and will work seamlessly.Making changes to a projectWhenever you have made changes to your primary config, you can simply go to your config folder and then run git diff, git commit and git push. This would push your changes to the studio configuration that you cloned your project config from.Updating a project to have the latest versionAlternatively, if you have updated your studio level config with some changes and you want to pull those down to your project, just go to your config folder and run a git pull.  Important: Note that once you have done this, make sure you run a tank cache_apps to ensure that all the app versions that your changed config requires are present in the system!Advanced git usage: BranchesThe default behavior in Toolkit is a simple clone operation when a new project is created. The project will be using the git master branch. For a more advanced setup, if you for example want to keep certain configuration changes for a project private and don’t share them with other projects, you can set up a git branch after the project has been created. You then commit to this branch. The changes you want to push to the studio configuration can be merged with the local master branch for the project and then pushed.Advanced git usage: Batch deploymentSince Toolkit keeps a list of all the different configurations for a ShotGrid site via its pipeline configuration entity, it is possible to iterate over this list and execute a git pull command for each of the items, effectively running a batch update on all projects. This functionality is not currently part of Toolkit out of the box, but can be scripted using Python and the ShotGrid Python API.A global configuration using includesThe git based approach above handles independent project configurations which are connected via git: Updates are not automatically reflected across projects but will have to be pulled and pushed.For a fully centralized configuration, where the configuration truly resides in one place and where a single change immediately reflects a group of projects, you will need to make use of the  @include  functionality in the Toolkit configuration. This makes it possible to create references so that each project configuration points at a central location where the actual configuration is being kept.The  @include  syntax allows you to chain together multiple files. For example, if you have a file  /tmp/stuff.yml, which contains the following content:# paths to mayamaya_windows: 'C: Program  Files Autodesk Maya2012 bin maya.exe'maya_mac: '/Applications/Autodesk/maya2012/Maya.app'maya_linux: 'maya'# a configured toolkit appfile_manager:  allow_task_creation: true  file_extensions: []  hook_copy_file: default  hook_filter_publishes: default  hook_filter_work_files: default  hook_scene_operation: default  launch_at_startup: false  launch_change_work_area_at_startup: false  location: {name: tk-multi-workfiles, type: app_store, version: v0.4.8}  saveas_default_name: scene  saveas_prefer_version_up: false  sg_entity_type_filters: {}  sg_entity_types: [Shot, Asset]  task_extra_display_fields: []  template_publish: null  template_publish_area: null  template_work: null  template_work_area: nullAs you can see above, you can create include definitions at several different levels - in the case above, we have an app definition and three strings values. These can then be referenced from an environment file:includes: ['/tmp/stuff.yml']engines:  tk-maya:    # First all our app definitions    apps:         # normally, we would have the entire set of configuration parameters at this point.        # because we are using an include, we can reference an entire sub-section of configuration        # using the @ keyword:         tk-multi-workfiles: '@file_manager'        # alternatively, for simple values, we can use them as parameter values for apps:         tk-maya-launcher:          mac_path: '@maya_mac'          linux_path: '@maya_linux'          windows_path: '@maya_windows'          location: {name: tk-multi-launchapp, type: app_store, version: v0.2.19}    # and after the apps section follows specific configuration options for the engine    location: {name: tk-maya, type: app_store, version: v0.4.1}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    template_project: null    use_sgtk_as_menu_name: falseFurthermore, you can read in several include files, one after the other. If the same include definition exists in two different files, the most recently read file will take precedence. We could extend our example environment above:includes:     # first include a global config file which contains all the studio level app definitions    - '/studio/configurations/studio_apps.yml'    # now we can include an include containing overrides, for example based on project type.    # if the global config contains an entry named file_manager and the vfx_apps.yml contains    # the same, the vfx_apps definition will be used.    - '/studio/configurations/vfx_apps.yml'engines:  tk-maya:        apps:         tk-multi-workfiles: '@file_manager'    location: {name: tk-maya, type: app_store, version: v0.4.1}    use_sgtk_as_menu_name: falseWith the approach just shown, it is possible to have a set of studio defaults which can be overridden by project type defaults which in turn can be overridden by specific project settings. You can either do it on the app level, as shown in the example above, or an engine level, as shown in the next section.Best practices when setting up a global configThere are several ways to set up a global configuration. Our recommended best practices approach for setting this up breaks the configuration down on a per engine basis. Each environment file is completely empty and references engines (and apps) defined in separate files. This makes it easy to tweak and reconfigure things - one engine at a time.Each of these include files are in a standard form, named after the engine. For example, if you have a Maya engine, an include file would contain just the engine and its apps. Its top level entry would simply be named  maya:maya:    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.13}      tk-multi-loader2:        action_mappings:          Maya Scene: [reference, import]          Photoshop Image: [texture_node]          Rendered Image: [texture_node]        actions_hook: '{self}/tk-maya_actions.py'        entities:        - caption: Assets          entity_type: Asset          filters:          - [project, is, '{context.project}']          hierarchy: [sg_asset_type, code]        filter_publishes_hook: '{self}/filter_publishes.py'        location: {name: tk-multi-loader2, type: app_store, version: v1.0.6}        menu_name: Load        publish_filters: []        title_name: Loader      [... additional app entries here ...]    debug_logging: true    location: {name: tk-maya, type: app_store, version: v0.3.10}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: ShotGrid Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    use_sgtk_as_menu_name: false# each include file has a framworks section containing all the frameworks needed for# all apps in the fileframeworks:  tk-framework-shotgunutils_v1.x.x:    location: {name: tk-framework-shotgunutils, type: app_store, version: v1.0.8}In your studio, you most likely don’t have a single maya setup, but may have a number of different ones for different departments and types of things. We recommend that you set up a maya include file for each of these ones, organized in a file hierarchy. Each of these files has a top level  maya  entry just like the file above.Now each project will contain a number of environments. Each of these environment files will be a list of engine includes, linking that specific environment to a collection of engine and app setups. You can set up one (or several) default project configurations for your studio, all containing includes like this, thereby ensuring that the actual app and engine payload is completely contained within the include files and therefore global. If you make a change to your global include files, all projects will be affected. With this setup, your environment files will then be on the following form:includes:         - '/studio/configurations/maya/asset.yml'    - '/studio/configurations/nuke/asset.yml'    - '/studio/configurations/houdini/generic.yml'engines:  tk-maya: '@maya'  tk-nuke: '@nuke'  tk-houdini: '@houdini'# we don't need any frameworks here because there are no apps or engines definedframeworks: nullIf you wanted to break out of the above setup and start defining some project specific entries, you would simply replace  @maya  with a series of app and engine definitions in the environment file itself.Managing a global configurationManaging a global configuration is more involved than managing a normal one. Because you have effectively combined a number of projects into a single file structure, running the  tank updates  command from any project and choosing to update an app version will affect all other projects, so proceed with some caution here.Furthermore, the standard clone workflow won’t work out of the box, since what you are cloning is the project configuration, which now only contains includes.For safe testing and maintenance, we recommend storing the global configuration in source control (e.g.  git) and do updates in a separate test area with a special test project. Once the quality control passes, commit the changes and pull them down into the actual global configuration.",
    "url": "/60762324/",
    "relUrl": "/60762324/"
  },
  "16": {
    "id": "16",
    "title": "Connecting Your Studio With Your AWS VPC",
    "content": "Connecting Your Studio With Your AWS VPCYou can connect your studio networks with AWS using one of many options, described in detail in this Amazon Virtual Private Cloud Connectivity Options whitepaper.Some of the common options our clients have used include:VPN ConnectionUsing a VPN appliance - AWS-managed or client-managed - your studio can establish a secure connection between your data center (or offices) to your AWS private VPC.AWS Direct ConnectAWS Direct Connect creates a dedicated link between your studio and your AWS VPC. This will help segregate your studio’s network traffic to your private AWS VPC from general internet traffic.",
    "url": "/de0ef1a3/",
    "relUrl": "/de0ef1a3/"
  },
  "17": {
    "id": "17",
    "title": "내 컨텍스트에 태스크/단계가 누락되어 있는데 파일 이름의 일부로 존재하는 이유는 무엇입니까?",
    "content": "내 컨텍스트에 태스크/단계가 누락되어 있는데 파일 이름의 일부로 존재하는 이유는 무엇입니까?툴킷을 통해 폴더를 만들면 조회를 수행할 수 있도록 엔티티에 대해 경로를 등록합니다. 즉, 경로가 지정되고 올바른 컨텍스트를 결정할 수 있습니다.툴킷은 스키마에서 생성된 폴더에 대해서만 레지스트리를 생성하므로 templates.yml 파일에 단독으로 정의된 파일 이름이나 폴더 등은 고려하지 않습니다.스키마에 Task 폴더가 없는 경우에는 툴킷이 파일의 태스크를 알고 있어야 하지만 경로만으로는 태스크를 알 수가 없는 상황에 빠질 수 있습니다.예시아래의 기본 스키마 구조 사용 시 폴더 생성 프로세스 중에 Asset 및 Step 폴더가 등록됩니다.다음과 같은 템플릿을 사용하여 파일 경로를 생성하고assets/{sg_asset_type}/{Asset}/{Step}/work/maya/{task_name}_{name}.v{version}.{maya_extension}`경로를 생성한 컨텍스트를 찾으려고 시도하면 Asset 및 Step만 설정할 수 있으며 파일 경로에 태스크 이름이 있어도 Task는 설정할 수 없습니다.솔루션스키마에 Step 폴더는 있고 Task 폴더는 없는 것이 대부분의 워크플로우에서 좋습니다. 일반적으로는 Workfiles 앱을 사용하여 작업할 태스크를 선택한 후 파일을 선택하여 씬 파일을 엽니다. 그런 다음 열린 파일의 경로에서 찾지 않고 UI에서 선택한 태스크를 사용하여 컨텍스트를 유도합니다.그러나 다음과 같은 상황에서는 경로에서 컨텍스트를 가져오는 것이 중요할 수 있습니다.  자동 컨텍스트 전환 기능을 사용하는 경우, 이 기능은 툴킷이 사용자가 소프트웨어의 기본 열기 대화상자에서 파일을 여는지 탐지하고(Workfiles 앱을 사용하지 않고) 현재 컨텍스트를 적절하게 전환할 수 있도록 해줍니다.  지정된 파일에 대한 컨텍스트를 찾아야 하는 독립 실행형 프로세스에서 API를 사용하는 경우이러한 상황을 해결할 수 있는 솔루션은 스키마에 Task 폴더를 추가하거나 자동 컨텍스트 전환을 사용하지 않는 것입니다. 또는 API 스크립트 사용 시에는 프로세스에 이미 필요한 컨텍스트 정보가 있는지 확인하면 이 조회를 수행할 필요가 없습니다.",
    "url": "/a10dadb2/",
    "relUrl": "/a10dadb2/"
  },
  "18": {
    "id": "18",
    "title": "기여 가이드",
    "content": "기여 가이드가능한 모든 사항을 공개하려는 노력의 일환으로 Autodesk ShotGrid 팀에서는 Creative Commons 라이센스에 따라 공용 리포지토리에 개발자 문서를 올리기로 했습니다. 이 문서를 더 효율적으로 작성할 수 있는 방법을 아신다면 개선 사항과 함께 리포지토리에 대한 pull 요청을 주십시오. pull 요청을 수락하기 위해서는 다음 기여자 계약서 중 하나에 서명하여 보내 주셔야 합니다.  개인 기여 계약서  기업 기여 계약서위의 계약서 중 하나를 제출한 후에는 변경 사항 제출 방법에 대한 읽어보기의 지침을 따르면 됩니다.",
    "url": "/92b042bd/",
    "relUrl": "/92b042bd/"
  },
  "19": {
    "id": "19",
    "title": "여러 개의 저장소 루트를 사용하도록 구성을 수정하려면 어떻게 해야 합니까?",
    "content": "여러 개의 저장소 루트를 사용하도록 구성을 수정하려면 어떻게 해야 합니까?기본 구성은 단일 로컬 저장소 루트를 사용하도록 설정됩니다(즉, 모든 프로젝트 파일이 /sgtk/projects 같은 단일 루트 지점에 저장됨). 그리고 일부 프로젝트 파일을 저장할 새 저장소 루트를 추가할 수 있습니다. 보통 디스크 공간이 부족하거나 일부 미디어를 더 빠른 저장소에 저장하고 싶을 때 이렇게 하게 됩니다.그럼 이제 이름이 “secondary”인 다른 루트를 추가해 보겠습니다. 수행해야 할 단계는 다음과 같습니다.ShotGrid에서 로컬 저장소 추가  ShotGrid에서 관리자(Admin) &amp;gt; 사이트 기본 설정(Site Preferences) 페이지로 이동  파일 관리(File Management) 섹션 열기  [+] 로컬 파일 저장소 추가([+] Add Local File Storage) 클릭  해당하는 모든 플랫폼에서 이름(“secondary”) 및 저장소 루트 경로 입력. 특정 플랫폼을 사용하고 있지 않다면 그냥 비워 두어도 됩니다.  페이지 위나 아래에 있는 페이지 저장(Save Page) 버튼 클릭파이프라인 구성에 새 루트 추가툴킷은 파이프라인 구성에서 사용되는 로컬 저장소에 관한 정보를 config/core/roots.yml 파일에 캐시합니다. ShotGrid에서 지금 막 생성한 새로운 secondary 저장소 루트를 추가하려면 이 파일을 편집합니다.primary: {    linux_path: /mnt/hgfs/sgtk/projects,    mac_path: /sgtk/projects,    windows_path: 'z: sgtk projects'}secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'}                    참고: tk-core v0.18.141부터 roots.yml에 정의된 루트 이름이 SG에 정의된 로컬 저장소 이름과 일치할 필요가 없습니다. roots.yml 정의에 shotgun_storage_id: &amp;lt;id&amp;gt; 키/값 쌍을 포함하여 연결을 명시적으로 정의할 수 있습니다.예시:secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'    shotgun_storage_id: 123}저장소 ID는 현재 API 호출을 통해서만 쿼리할 수 있습니다.    새 로컬 저장소 루트를 사용하도록 스키마 수정이제 새 저장소 루트를 정의하고 툴킷에 이를 알렸으므로 앞으로 디렉토리 구조에서 어떻게 사용할 것인지 결정해야 합니다. 이 예에서는 모든 에셋 작업이 secondary 저장소에 저장되고, 모든 샷 작업이 primary 저장소에 저장된다고 가정해 보겠습니다. config/core/schema에서 다음과 같이 스키마를 설정해야 할 것입니다.config/core/schema/project.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;primary&quot;config/core/schema/secondary.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;secondary&quot;해당 필터에서 이 루트를 참조하는 모든 YAML 파일도 수정해야 합니다.예를 들어, secondary 폴더 아래 어딘가에 asset.yml이 있다면 필터를 업데이트하여 secondary 폴더 값을 기준으로 해당 프로젝트를 필터링해야 합니다.filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$secondary&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }템플릿 경로를 업데이트하여 사용할 루트 지정끝으로 config/core/templates.yml 파일에 정의되어 있는 경로를 업데이트하여1 어느 저장소 루트를 사용할지 지정하고, 필요 시 모든 경로를 업데이트해야 합니다. 템플릿 경로는 스키마의 ‘절친’이기 때문에 둘은 일치되어야 한다는 점을 기억하십시오. 템플릿 경로가 스키마에 정의되어 있는 경로와 올바로 일치되지 않도록 정의되어 있으면 오류가 발생합니다.예를 들어, 여기에서는 모든 에셋 작업을 secondary 저장소에 저장하려고 하기 때문에 maya_asset_work 템플릿 경로를 업데이트하려면 이를 다음과 같이 수정해야 합니다.maya_asset_work:    definition: '@asset_root/work/maya/{name}.v{version}.ma'    root_name: 'secondary'config/core/templates.yml 파일의 각 템플릿 경로에 대해 이와 같은 패턴을 따라야 합니다. 각각에 대해 올바른 root_name을 지정합니다(‘primary’ 또는 ‘secondary’).                    참고: 기본 저장소 루트를 사용하는 템플릿에 대한 root_name을 지정할 필요가 없습니다. 기본 루트는 roots.yml 파일에서 default: true를 지정하여 표시됩니다. roots.yml에 기본값이 명시적으로 정의되지 않은 경우 primary라는 루트를 기본값으로 간주합니다.    1 새 값을 설정하고 나면 툴킷이 이전 값을 사용하여 생성된 모든 이전 파일에 액세스할 수 없게 되기 때문에 경로를 업데이트하는 것이 반드시 이상적이라고 할 수는 없습니다. 즉, 템플릿 경로를 변경하고 나면 툴킷이 이전 작업 파일을 찾을 수 없습니다. 이것이 우려된다면 새 위치를 지정하여 새 템플릿(예: houdini_shot_publish_v2)을 생성한 다음, 새 버전을 사용하도록 앱을 업그레이드하면 됩니다. 모든 앱이 이 같은 폴백 컨셉을 처리할 수 있는 것은 아니지만 일부 앱이라도 이전 파일을 인식할 수 있게 됩니다. 게시는 항상 ShotGrid의 게시에 링크되어 있기 때문에 영향을 받지 않습니다.",
    "url": "/9ea9dd4e/",
    "relUrl": "/9ea9dd4e/"
  },
  "20": {
    "id": "20",
    "title": "API를 통해 게시물을 작성하려면 어떻게 해야 합니까?",
    "content": "API를 통해 게시물을 작성하려면 어떻게 해야 합니까?sgtk API는 ShotGrid에서 PublishedFiles 엔티티를 등록할 수 있는 편의 메서드를 제공합니다.또한 자체 API와 함께 Publish 앱도 제공합니다.Publish API는 궁극적으로 Core sgtk API 메서드를 사용하여 PublishedFile을 등록하지만 사용자 지정 가능한 컬렉션, 유효성 확인 및 게시 관련 프레임워크도 제공합니다. 이와 관련하여 Publish API 설명서와 함께 파이프라인 튜토리얼에 자체 게시 플러그인 작성 예제도 제공합니다.register_publish() API 메서드 사용로우 ShotGrid API 호출을 사용하여 ShotGrid에서 게시 레코드를 생성하는 것도 가능하지만 툴킷의 편의 메서드를 이용하는 것이 훨씬 좋습니다.게시를 생성하는 모든 툴킷 앱은 sgtk.util.register_publish()라는 API 유틸리티 메서드를 사용 중입니다.기본적으로 이 메서드는 ShotGrid에서 새로운 PublishedFile 엔티티를 생성하며, 툴킷 컨셉을 사용하여 생성을 쉽게 만들어줍니다. 여러분의 코드로 무언가를 실행하려면 다음의 행을 이용해야 할 것입니다.# Get access to the Toolkit APIimport sgtk# this is the file we want to publish.file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/foreground.v034.nk&quot;# alternatively, for file sequences, we can just use# a standard sequence token# file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/renders/v034/foreground.%04d.exr&quot;# The name for the publish should be the filename# without any version number or extensionname = &quot;foreground&quot;# initialize an API object. If you have used the Toolkit folder creation# to create the folders where the published file resides, you can use this path# to construct the API object. Alternatively you can create it from any ShotGrid# entity using the sgtk_from_entity() method.tk = sgtk.sgtk_from_path(file_to_publish)# use the file to extract the context. The context denotes the current work area in Toolkit# and will control which entity and task the publish will be linked up to. If you have used the Toolkit# folder creation to create the folders where the published file resides, you can use this path# to construct the context.ctx = tk.context_from_path(file_to_publish)# alternatively, if the file you are trying to publish is not in a location that is# recognized by toolkit, you could create a context directly from a ShotGrid entity instead:ctx = tk.context_from_entity(&quot;Shot&quot;, 123)ctx = tk.context_from_entity(&quot;Task&quot;, 123)# Finally, run the publish command.# the third parameter (file.nk) is typically the file name, without a version number.# this makes grouping inside of ShotGrid easy. The last parameter is the version number.sgtk.util.register_publish(  tk,  ctx,  file_to_publish,  name,  published_file_type=&quot;Nuke Script&quot;,  version_number=34)위에 나온 기본 항목 외에도 사용자가 직접 입력할 수 있는 여러 가지 옵션이 있습니다.전체 매개변수 목록 및 매개변수의 기능에 대한 자세한 내용은 Core API 설명서를 참조하십시오.                    팁: 코드가 툴킷 앱 내에서 실행 중인 경우 self.sgtk를 통해 sgtk 인스턴스를 가져오고 self.context를 사용하여 컨텍스트를 가져올 수 있습니다.앱 내는 아니지만 툴킷 통합이 있는 소프트웨어 내에서 실행될 경우 다음 코드를 사용하여 현재 컨텍스트 및 sgtk 인스턴스에 액세스할 수 있습니다.import sgtkcurrentEngine = sgtk.platform.current_engine()tk = currentEngine.sgtkctx = currentEngine.context    ",
    "url": "/ed4bcc20/",
    "relUrl": "/ed4bcc20/"
  },
  "21": {
    "id": "21",
    "title": "Linux에서 ShotGrid 데스크톱의 데스크톱/시작 관리자 아이콘을 어떻게 설정합니까?",
    "content": "Linux에서 ShotGrid 데스크톱의 데스크톱/시작 관리자 아이콘을 어떻게 설정합니까?현재 ShotGrid 데스크톱 설치 관리자는 단축키를 자동으로 생성하지 않고 항목을 자동으로 실행하지도 않기 때문에 설치 후에 수동으로 해주어야 합니다. 아이콘을 추가하는 과정은 간단하지만, 어느 Linux 버전을 사용 중인지에 따라 달라질 수 있습니다.ShotGrid 데스크톱 설치 관리자를 실행하고 나면 ShotGrid 데스크톱 실행 파일이 /opt/Shotgun folder에 생성됩니다. 실행 파일 이름은 ShotGrid입니다.설치 관리자와 함께 배포되는 아이콘은 없습니다. ShotGrid 데스크톱 엔진 github 리포지토리에서 다운로드하십시오.아이콘을 다운로드하고, 실행 파일(/opt/Shotgun/Shotgun)로 경로를 지정하고 나면 수동으로 필요한 데스크톱 또는 메뉴 시작 관리자를 생성하십시오. 이 프로세스는 Linux 버전에 따라 달라질 수 있지만 보통 데스크톱을 마우스 오른쪽 버튼으로 클릭한 다음 적절한 메뉴 옵션을 찾아 데스크톱 시작 관리자를 생성할 수 있습니다.",
    "url": "/d82ab5ce/",
    "relUrl": "/d82ab5ce/"
  },
  "22": {
    "id": "22",
    "title": "개발",
    "content": "개발툴킷을 사용한 개발을 기반으로 한 빠른 답변 모음입니다.  소프트웨어를 실행하기 전에 환경 변수는 어떻게 설정합니까?  내 컨텍스트에 존재하는 값이 as_template_fields()에 누락되었습니다.  Maya에서 툴킷 앱 실행을 위한 쉘프 버튼을 추가하려면 어떻게 해야 합니까?  어떻게 하면 shotgunEvents 데몬을 사용하여 다른 Toolkit Core 모듈을 로드할 수 있습니까?  API를 사용하여 툴킷 구성을 프로그래밍 방식으로 업데이트하려면 어떻게 해야 합니까?  API를 통해 게시물을 작성하려면 어떻게 해야 합니까?",
    "url": "/16654f1f/",
    "relUrl": "/16654f1f/"
  },
  "23": {
    "id": "23",
    "title": "Development",
    "content": "DevelopmentWhat is Toolkit?Toolkit is the platform that underpins our pipeline integrations. For example, If you are using the ShotGrid Panel app in Maya or launching the Publish app from ShotGrid Create, you are using tools built upon the Toolkit platform.How can I develop with Toolkit?There are a number of different ways in which you can develop with Toolkit.  Writing custom code, in what we call hooks, to expand the existing app, engine, or framework behavior.  Writing your own apps, engines or frameworks.  Or writing your own standalone scripts that make use of the API.To do any of these things it’s important to understand how to work with the Toolkit API.ShotGrid as a whole has three main API’s  ShotGrid Python API  ShotGrid REST API  ShotGrid Toolkit APIThe Toolkit API is a Python API, designed to be used alongside the ShotGrid Python API or REST API, and is not a replacement for them.Although the Toolkit API does have some wrapper methods, in general whenever you need to access data from your ShotGrid site you will use the ShotGrid Python or REST APIs instead.The Toolkit API instead focuses on the integrations and management of file paths.Some Toolkit apps and frameworks also have their own APIs.These articles will guide you through how you can develop with Toolkit.",
    "url": "/a1cfe87c/",
    "relUrl": "/a1cfe87c/"
  },
  "24": {
    "id": "24",
    "title": "Direct Connect",
    "content": "Direct ConnectAWS Direct Connect is a service from AWS that allows you to establish a dedicated connection from your on-premise data center (or offices) to AWS. Direct Connect will allow you to create a dedicated link between your network and one of the AWS Direct Connect locations.Leveraging AWS Direct Connect ensure that you will benefit from the best experience possible when using the isolation feature set, optimizing reliability and performance for all your access points across the globe.",
    "url": "/0de47d40/",
    "relUrl": "/0de47d40/"
  },
  "25": {
    "id": "25",
    "title": "ShotGrid AWS Direct Connect Onboarding",
    "content": "ShotGrid AWS Direct Connect OnboardingIntroductionAWS Direct Connect (DX) is used to establish private connectivity between AWS and an on-prem facility. DX provides a private, high bandwidth network connection between your network and AWS Virtual Private Cloud (VPC) and bypasses the public internet. AWS has established 100 Direct Connect locations globally and leverages the AWS Partner Network to extend the footprint.Review of Shogun Configuration in AWSCustomer Types  Customer already has AWS Direct Connect dedicated connection  Customer has equipment and network presence in an AWS Direct Connect location  Customer does not have equipment or presence in an AWS Direct Connect locationSetup Options  Request a dedicated Direct Connect connection through AWS Console          Provision the required connectivity yourself      Work with Direct Connect Partner to help establish a dedicated connection to AWS equipment        Request a hosted Direct Connect connection through AWS Direct Connect PartnerCriteria to Determine Setup PathIf you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console (Option 1a):  Do you already have equipment and presence in an AWS Direct Connect location?  Do you know the process for requesting a cross-connect within the Direct Connect location facility?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console and select a Partner to assist (Option 1b):  Are you planning to use AWS Direct Connect to connect to other AWS resources outside of ShotGrid?  Do you have the time and resources to complete the setup?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then you should work with an AWS Direct Connect Partner to request a hosted Direct Connect connection (Option 2):  Are you already working with an AWS Direct Connect Partner?  Do you want a Partner to facilitate the setup?  Are you looking for a port less than 1Gbps or a hosted connection?Disclaimer:  All options are valid and the criteria are just a guide to help simplify the selection process. You can still pick any option based on more specific criteria.Setup DirectionsRequest through AWS Console - Option 1 (a and b)  Create a Connection in the AWS Console  Download the LOA-CFA. The LOA is the authorization to connect to AWS and is required to establish the cross-network connection.  (Option 1a only) Request cross-connects at AWS Direct Connect locations. Find contact information here.  (Option 1b only) Reach out to an AWS Partner and share the LOA with them.  Once the dedicated connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).Request through AWS Direct Connect Partner - Option 2  Reach out to an AWS Partner. The criteria for choosing an AWS Partner are:          AWS Region      Providers      If you are already working with an AWS Direct Connect Partner        If hosted connection, accept a hosted connection. More information can be found here.  Once the hosted connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).FAQHow long should it take to set up AWS Direct Connect?Short Answer - It depends. A lot of factors go into the time it takes to set up AWS Direct Connect. The timeline can vary from a few days to a few months. Some of the factors include current infrastructure, location of equipment, providers, partners, and more. If you are looking to expedite the process, consider using an AWS Direct Connect Partner who is geographically nearby.Further questions about AWS Direct Connect?AWS Direct Connect FAQsVPNA site-to-site VPN can be used as an alternative to AWS Direct Connect. Learn more about AWS VPN here.AWS Documentation &amp;amp; Resources  What is AWS Direct Connect?  Direct Connect User Guide  re:Invent 2018 - 400 level Deep Dive on Direct Connect  AWS Direct Connect Locations  AWS Direct Connect Partners",
    "url": "/8233001e/",
    "relUrl": "/8233001e/"
  },
  "26": {
    "id": "26",
    "title": "ShotGrid 데스크톱의 브라우저 통합을 어떻게 비활성화할 수 있습니까?",
    "content": "ShotGrid 데스크톱의 브라우저 통합을 어떻게 비활성화할 수 있습니까?브라우저 통합을 비활성화하려면 다음의 간단한 두 단계를 수행하십시오.      다음 위치에서 텍스트 파일을 생성하거나 엽니다.     Windows: %APPDATA% ShotGrid preferences toolkit.ini Macosx: ~/Library/Preferences/ShotGrid/toolkit.ini Linux: ~/.ShotGrid/preferences/toolkit.ini            다음 섹션을 추가합니다.     [BrowserIntegration] enabled=0      브라우저 통합 구성 방법에 대한 자세한 내용은 관리자 안내서를 참조하십시오.대체 방법툴킷 파이프라인 구성을 인계받은 경우 대체 방법은 환경에서 tk-ShotGrid 엔진을 제거하여 어떤 액션도 로드할 수 없도록 하는 것입니다.",
    "url": "/1bb3f6ad/",
    "relUrl": "/1bb3f6ad/"
  },
  "27": {
    "id": "27",
    "title": "파일 시스템 구성",
    "content": "동적 파일 시스템 구성이 안내서에서는 툴킷 파이프라인 구성을 수정하여 프로덕션 폴더 구조와 파일 명명 규칙을 커스터마이즈하는 방법을 설명합니다.안내서 정보파이프라인 관리의 가장 어려운 점 중 하나는 생성되는 다양한 파일을 추적하는 것입니다. 툴킷 파이프라인은 ShotGrid의 데이터 및 구성된 폴더 구조를 기반으로 폴더를 만들고 올바른 위치에 표준화된 명명 규칙을 사용하여 자동으로 파일을 작성하는 방식으로 파일 시스템 관리를 자동화해 주므로 아티스트는 컨텐츠 생성에 집중할 수 있습니다. 파이프라인 구성은 기본 폴더 세트 및 파일 명명 규칙과 함께 제공되지만 프로덕션에서는 이를 커스터마이즈하는 경우가 많습니다. 이 안내서에서는 이러한 커스터마이즈에 필요한 지식을 제공합니다.기본 구성에서 에셋은 asset_type/asset/pipeline_step과 같은 폴더 구조로 관리됩니다. 이 안내서에서는 “Set”라는 커스텀 엔티티를 사용하여 각 에셋이 사용되는 프로덕션 세트별로 에셋을 추가 구성합니다. 먼저 ShotGrid에서 커스텀 엔티티를 설정한 다음 이를 사용하여 지정된 세트에 생성된 에셋을 관리합니다. 폴더 구조는 set/asset_type/asset/pipeline_step과 같은 형태입니다.일부 씬은 차고에서 진행되고 나머지 씬은 다이닝룸에서 진행하는 프로젝트를 수행한다고 가정하고 세트별로 에셋을 구성하는 방식을 설명하겠습니다. 설정을 사용하면, “렌치”, “기름통” 또는 “작업대”와 같은 에셋에 대한 파일은 “garage” 폴더에 구성되고 “접시”, “와인병” 또는 “테이블보”와 같은 에셋에 대한 파일은 “dining_room” 폴더에 구성됩니다. 예제에서 군침 도는 “필레” 에셋은 적절하게 다이닝룸에 배치됩니다.예제에서는 프로젝트에 대한 파일 명명 템플릿도 편집하여 에셋에 대한 Maya 작업 파일에 해당 이름의 세트가 포함되도록 합니다. 동적으로 생성된 파일 이름은 다이닝룸에 대한 파일과 다른 세트에서 사용된 파일로 구분됩니다.이 안내서는 다음과 같이 세 부분으로 구성됩니다.  ShotGrid에서 “Set”라는 커스텀 엔티티 만들기. 아티스트가 만드는 다이닝룸 요소와 연결하는 데 사용됩니다.  스키마 폴더 편집. 툴킷이 폴더 구조에서 현재 세트를 기반으로 동적으로 이름이 지정된 폴더를 포함할 수 있게 합니다.  에셋 작업 파일 이름 지정에 사용되는 템플릿 편집. 툴킷이 파일 이름에 연관된 세트 이름을 포함할 수 있게 합니다.필수 요건이 안내서를 사용하려면 다음이 필요합니다.  유효한 ShotGrid 사이트. 하나 이상의 에셋이 생성된 프로젝트가 있어야 합니다. 에셋에는 모델 태스크가 있어야 합니다.  ShotGrid 사이트를 에셋 관리에 사용하는 방법에 대한 기본적인 이해  ShotGrid 데스크톱이 시스템에 설치되어 있어야 함  식별된 프로젝트에 대한 복제된 파이프라인 구성이나 구성 시작하기 안내서를 완료하고 해당 연습에서 생성한 구성 복제  YAML에 대한 기본 지식  파이프라인 구성이 저장된 파일 시스템에 대해 읽기 및 쓰기 권한을 적절하게 설정합니다.  툴킷이 프로덕션 파일 시스템에 읽고 쓸 수 있도록 읽기 및 쓰기 권한을 적절하게 설정합니다.  활성 상태의 Maya 멤버쉽. Maya의 30일 체험판을 구할 수 있습니다.                    참고: 이 안내서는 tk-config-default2 파이프라인 구성을 기반으로 합니다. 이 구성을 수정한 경우 YAML 설정의 파일, 폴더 및 블록의 위치가 여기에 설명된 것과 다를 수 있습니다.    파일 스키마 및 템플릿 정보툴킷 파이프라인 구성에서 스키마 및 템플릿을 사용하면 ShotGrid 데이터를 활용하여 디스크의 프로덕션 파일을 관리할 수 있습니다. 기본 구성의 스키마에는 샷, 시퀀스, 에셋, 에셋 유형 등의 엔티티가 포함됩니다. 레벨, 에피소드, 시즌과 같은 다른 엔티티나 앞에서 설명한 세트(Set)같은 커스텀 엔티티를 추가할 수 있습니다.툴킷 플랫폼을 통해 스키마를 사용하여 동적으로 폴더 구조를 빌드할 수 있습니다. 스키마는 실제 프로덕션 파일 시스템을 빌드할 때 템플릿으로 사용되는 프로덕션 폴더 구조의 미니어쳐 버전입니다. 스키마는 동적 폴더 생성을 위한 명시적 지침으로, YAML 파일을 사용하여 동적으로 생성된 폴더의 규칙을 정의합니다. 기본 구성에는 에셋 및 샷 파이프라인에 대한 폴더 생성을 지원하는 사전 구성된 스키마가 포함됩니다. 에셋 폴더 구조(/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;) 생성을 지원하는 스키마 부분을 수정하여 새로 생성하는 Set 엔티티도 지원할 수 있습니다.템플릿을 사용하면 ShotGrid 데이터 및 스키마 구조의 정보를 사용하여 만든 파일을 동적으로 이름을 지정하고 저장할 수 있습니다. 기본 구성은 파이프라인의 요구에 맞게 편집할 수 있는 일련의 초보자용 템플릿을 제공합니다.                    참고: ShotGrid 통합의 기본 설정에는 파일 시스템 관리가 포함되지 않습니다. 프로젝트에 대한 파일 시스템 관리를 구성하려면 프로젝트에 고급 설정이 필요합니다. 첫 번째 안내서인 구성 시작하기에서 고급 설정 프로세스에 대해 설명합니다.    연습 시작스키마 및 템플릿을 커스터마이즈하면 상차림, 뜨거운 필레미뇽, Penfolds Grange Hermitage 1951 와인, 감자 그라탱, 레몬 갈릭 아스파라거스 등 다이닝룸 세트를 만들 때 생성된 파일을 동적으로 관리할 수 있습니다. 다이닝룸 세트에 사용된 에셋은 보다 쉽게 관리할 수 있도록 “Dining Room” Set 엔티티와 연결됩니다. Set는 기본 구성과 함께 제공되는 표준 엔티티 유형이 아니므로 커스텀 엔티티를 활성화한 후 스키마 및 템플릿을 확장하기 전에 Set로 지칭해야 사용할 수 있습니다.커스텀 엔티티 활성화하기1단계: 브라우저에서 ShotGrid 사이트를 엽니다. 아바타를 클릭하고 관리자(ADMIN) &amp;gt; 사이트 기본 설정(Site Preferences)으로 이동합니다. 결과 페이지에서 엔티티(Entities) 섹션을 확장합니다.ShotGrid에서 사용할 수 있는 엔티티 유형 목록이 표시됩니다. 아래 이미지에서 목록 상단에는 현재 ShotGrid 사이트에 구성된 일부 엔티티 유형이 있습니다. 이러한 엔티티 유형 아래에는 구성되지 않았거나 활성화되지 않은 몇 가지 커스텀 엔티티가 있습니다.커스텀 엔티티 유형 중 하나를 선택하고 구성하고 활성화합니다.2단계: 화살표를 선택하여 회색으로 비활성화된 커스텀 엔티티에 대한 설정을 엽니다. 예, 커스텀 엔티티 사용…(Yes, use Custom Entity…) 옆의 라디오 버튼을 선택하고 표시 이름(Display name)을 Set로 변경한 다음 창의 맨 위로 스크롤하여 변경 사항 저장(Save Changes)을 선택합니다.이렇게 하면 ShotGrid에서 해당 커스텀 엔티티가 활성화되고 표시 이름이 Set로 표시됩니다. 기본적으로 엔티티의 시스템 이름은 CustomEntity01로 유지되므로 커스텀 엔티티에 대한 별칭을 작성합니다. 이 예제에서는 CustomEntity01을 사용하지만 다른 커스텀 엔티티를 사용할 수 있습니다.                    참고: 선택한 커스텀 엔티티의 시스템 이름을 기억하십시오.    데이터 필드를 추가하여 에셋을 세트와 연결에셋 엔티티에 데이터 필드를 추가하면 에셋을 새 엔티티에 링크할 수 있습니다. 아티스트가 다이닝룸에 대해 만드는 에셋은 Dining Room Set 엔티티와 연결됩니다.3단계: 페이지 맨 위에 있는 프로젝트(Projects) 드롭다운을 선택하고 이 연습에서 사용할 프로젝트를 엽니다.4단계: 프로젝트 메뉴 막대에서 에셋(Assets)을 선택하여 에셋(Assets) 페이지로 이동합니다. 에셋(Assets) 메뉴에서 필드(Fields) &amp;gt; 에셋 필드 관리…(Manage Asset Fields…)를 선택합니다.그러면 에셋 필드 관리자가 표시됩니다.새 필드 추가(+ Add a new field)를 선택합니다.새 필드에 대한 매개변수를 선택합니다.새 필드 이름(New Field Name)에 “Set”를 입력합니다. 일반(GENERAL) 메뉴 아래 필드 유형(Field Type)에서 엔티티(Entity)를 선택하고 유형 제한(Restrict the type)을·스크롤하여 Set를 선택합니다. 다음(Next)을 선택합니다.이 안내서에서는 이를 현재 프로젝트만(Only the current project)으로 적용하고 필드 만들기(Create Field)를 선택합니다.ShotGrid이 새 필드를 구성합니다.변경 사항이 적용되면 완료(Done)를 선택할 수 있습니다.Dining Room Set 엔티티 만들기5단계: 에셋의 새 Set 필드를 선택하고 Dining Room을 입력합니다. 일치하는 항목을 찾을 수 없습니다. “Dining Room” 만들기라고 적힌 대화상자가 표시됩니다.“Dining Room” 만들기(Create “Dining Room”)를 선택합니다.Set 만들기(Create Set)를 선택합니다.에셋의 Set 필드에 Dining Room을 추가하면 Dining Room Set 엔티티와 연결이 만들어집니다.6단계: 테스트용으로 쉽게 찾을 수 있도록 필레 에셋에 대한 모델 태스크를 자신에게 할당합니다.스키마 설정이제 Set 커스텀 엔티티가 활성화되고 “Dining Room”이라는 Set 엔티티가 만들어지고 에셋 엔티티가 Dining Room Set에 링크되었습니다. ShotGrid 사이트에서 모든 부분이 준비되었으며 이제 폴더 구조를 수정할 수 있습니다. 아티스트가 태스크에 대한 작업을 시작하면 툴킷은 연결된 ShotGrid 데이터를 사용하여 파일 시스템에 만들 폴더를 결정합니다. 새 폴더가 생성되고 파이프라인 구성 스키마를 기반으로 이름이 자동으로 지정됩니다.이제 아티스트가 프로덕션 파이프라인을 단계별로 수행할 때 툴킷에서 동적으로 생성할 폴더 구조를 정의할 수 있습니다. 이 작업은 스키마를 편집하여 수행합니다.                    참고: 활성 프로덕션 구성에 영향을 주지 않도록 복제된 구성에서 구성을 테스트하는 것이 좋습니다. 복제 프로세스는 구성의 복사본을 만들어 변경 사항을 라이브 구성에 적용하기 전에 안전하게 편집할 수 있습니다. 구성 복제에 대한 자세한 내용은 구성 스테이징 및 롤아웃 문서에서 찾을 수 있습니다.    7단계: 파이프라인 구성으로 이동합니다. 스키마 폴더(&amp;lt;pipeline_configuration_root&amp;gt;/config/core/schema)로 드릴다운하고 project 폴더를 엽니다.현재 스키마는 다음과 같으며&amp;lt;project&amp;gt;/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;다음 폴더 구조를 동적으로 만들 수 있습니다.the_other_side/assets/prop/filet/model여기서는 다음과 같은 구조가 필요합니다.the_other_side/assets/Dining-Room/Prop/filet/model이렇게 하려면 다음과 같은 스키마를 설정합니다.&amp;lt;project&amp;gt;/assets/&amp;lt;CustomEntity01&amp;gt;/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;Set 엔티티는 CustomEntity01로 표시됩니다. ShotGrid에서 Set의 표시 이름으로 CustomEntity01을 제공했지만 구성에서 항상 시스템 이름으로 CustomEntity01을 참조합니다.스키마가 YAML 파일을 사용하는 방법스키마는 정적 및 동적 폴더를 포함할 수 있습니다. “assets”라는 스키마에 정적 폴더가 있는 경우 “assets”라는 프로덕션 파일 시스템의 단일 폴더에 해당합니다. 반면 프로젝트의 각 에셋에 대한 하나의 폴더를 나타내는 “asset”이라는 스키마의 동적 폴더가 있을 수 있습니다. 모든 동적 폴더에는 그 옆에 폴더와 동일한 이름을 가진 YAML 파일이 있습니다(예: asset/ 및 asset.yml). 이 파일은 스키마 폴더를 기반으로 프로덕션 폴더를 생성하는 방법에 대한 규칙을 정의합니다.Set 엔티티에 대한 새 폴더 및 YAML 파일 만들기스키마에는 ShotGrid에서 추적하는 다른 엔티티에 대한 폴더가 포함된 project 폴더가 있습니다. 새 에셋 엔티티 CustomEntity01을 추가하여 ShotGrid에서 Set의 항목을 추적할 수 있도록 합니다. 이러한 항목은 에셋이므로 에셋에서 폴더 및 YAML 파일을 편집할 수 있습니다.다시 말하지만 우리의 목표는 asset_type/asset/step 폴더 구조에서 set/asset_type/asset/step 폴더 구조로 바꾸는 것입니다. 따라서 해당 YAML 파일을 사용하여 스키마에서 세트를 나타내는 폴더를 추가하려고 합니다. 커스텀 엔티티에 대한 시스템 이름을 사용해야 하므로 CustomEntity01/ 폴더와 CustomEntity01.yml을 만듭니다.8단계: 스키마의 project/assets 폴더 내에 CustomEntity01 폴더를 추가합니다.9단계: 다음 내용으로 CustomEntity01 폴더 옆에 CustomEntity01.yml 파일을 만듭니다.type: &quot;shotgun_entity&quot;name: &quot;code&quot;entity_type: &quot;CustomEntity01&quot;filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }YAML 파일은 툴킷에서 CustomEntity01 폴더 이름을 무엇으로 지정할지에 대한 지침을 제공합니다. 여기서는 유형이 ShotGrid_entity인 폴더를 만들고 있으며 이는 ShotGrid 쿼리에 해당함을 의미합니다. entity_type 필드는 ShotGrid에서 CustomEntity01 엔티티를 쿼리함을 나타내고 name 필드는 쿼리할 엔티티에 대한 필드를 나타내며 여기서는 CustomEntity01에서 code 필드를 가져옵니다.filters 필드는 이 동적 폴더를 만들어야 하는 경우를 제한합니다.10단계: asset_type/ 및 asset_type.yml을 CustomEntity01 폴더로 이동합니다.Dining-Room/Prop/filet와 같은 폴더 구조가 필요하므로 계층에서 asset_type 폴더는 CustomEntity01 폴더 아래에 있어야 합니다. asset_type/ 및 asset_type.yml을 CustomEntity01 폴더로 이동합니다.asset.yml 파일 편집filters 필드는 지정 시간에 생성된 폴더가 있는 엔티티를 제한합니다. 현재 상태에서 asset.yml의 필터 필드는 다음과 같습니다.filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }에셋에 대한 폴더를 만들기로 결정할 때 올바른 프로젝트 폴더에 있는지 올바른 asset_type 폴더에 있는지 확인하고 싶습니다. 이제 세트 폴더를 추가했으며 세 번째 필터를 추가하려고 합니다. 이 작업을 하지 않고 다음과 같은 폴더로 끝내면 잘못됩니다.assets/Dining-Room/Prop/spoonassets/Garage/Prop/spoonassets/Classroom/Prop/spoon그렇게 되지 않도록 세 번째 필터를 추가하면 에셋의 폴더가 올바른 세트의 폴더에만 생성됩니다.11단계: asset.yml에서 filters 필드를 다음과 같이 수정합니다.filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }    - { &quot;path&quot;: &quot;sg_set&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$CustomEntity04&quot; ] }폴더 생성 테스트이제 Set 커스텀 엔티티별로 에셋을 구성하도록 스키마가 성공적으로 수정되었습니다. 이제 테스트해 보겠습니다.폴더는 툴킷 파이프라인 워크플로우의 몇 지점에서 생성됩니다.  응용프로그램 시작 관리자: 사용자가 태스크에 대한 DCC를 시작할 때마다 툴킷은 해당 태스크에 대한 디렉토리를 만듭니다(아직 없는 경우). 툴킷을 사용하여 수행하는 첫 번째 작업이 보통 DCC를 시작하는 것이기 때문에 이 방법이 디렉토리를 생성하는 가장 일반적인 방법입니다. 이 작업은 ShotGrid 또는 ShotGrid 데스크톱이나 Create 앱에서 마우스 오른쪽 버튼 클릭 메뉴를 통해 수행할 수 있습니다.  ShotGrid 메뉴: 태스크에 대해 폴더를 만드는 가장 직접적인 방법은 ShotGrid에서 태스크를 마우스 오른쪽 버튼으로 클릭하고 “폴더 만들기”(Create Folders) 메뉴 항목을 선택하는 것입니다.  툴킷 API: 툴킷 API를 통해 직접 디렉토리 생성 로직을 트리거할 수 있습니다. 툴킷 API는 커스텀 시작 관리자에 툴킷을 연결하거나, ShotGrid에서 샷이 생성될 때 샷에 대한 디렉토리를 자동으로 만들려는 워크플로우의 이벤트 트리거 등에 사용할 수 있습니다.  tank 명령: ShotGrid의 메뉴 항목과 유사하며 tank folders 터미널 명령도 태스크에 대한 폴더를 만듭니다.tank 명령을 사용하여 테스트하겠습니다.12단계: filet 에셋에서 tank folders를 실행합니다. 터미널에서 다음을 실행합니다.&amp;gt; cd &amp;lt;pipeline_configuration_root_folder&amp;gt;&amp;gt;  ./tank Asset Filet folders출력을 요약하면 다음과 같습니다.----------------------------------------------------------------------Command: Folders----------------------------------------------------------------------Creating folders, stand by...The following items were processed: - /Users/michelle/Documents/Shotgun/projects/the_other_side. . . - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/ - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/publish. . .In total, 23 folders were processed.최종 구조는 예상과 일치하며 Dining과 Room 사이에 대시가 추가될 정도로 툴킷이 스마트합니다./the_other_side/assets/Dining-Room/Prop/Filet/model파일을 읽고 쓰기 위한 툴킷 템플릿이제 폴더 구조가 설정되었으며 다음 단계는 프로덕션 파일의 이름이 적절하게 지정되고 생성 시 올바른 폴더에 들어가도록 템플릿을 편집하는 것입니다.툴킷 앱의 템플릿 사용 방법먼저 세트를 나타내는 CustomEntity01을 활성화한 다음 에셋 엔티티에 에셋과 세트 간 링크를 나타내는 링크 필드를 추가하면 ShotGrid에서 세트와 에셋을 연결할 수 있습니다. 에셋과 세트 간에 관계를 설정한 후 폴더 스키마를 설정하여 해당 연결을 사용해 모든 에셋 폴더를 연결된 세트의 폴더 내에 배치합니다. 이제 파일의 이름을 동적으로 지정하고 툴킷 앱에서 자동으로 파일을 관리할 수 있습니다.아티스트가 프로젝트의 태스크 작업을 시작하면 필수 폴더 구조가 생성됩니다. 그러 다음 아티스트가 Workfiles 앱의 파일 저장(File Save) 액션을 시작하면 자동으로 파일 이름이 지정됩니다. 툴킷의 Workfiles 앱을 통해 액세스한 템플릿은 해당 파일의 이름을 지정하는 데 사용됩니다. Nuke Write 노드 및 Houdini Mantra 노드와 같은 렌더 앱은 템플릿을 사용하여 렌더링된 파일의 이름을 지정하고 파일을 저장합니다. 게시된 파일의 경우 Publisher 앱에서 수행하는 작업입니다.Workfiles 파일 열기(File Open) 액션을 사용하여 파일이 액세스되면 앱은 템플릿을 사용하여 해당 파일을 찾아 로드합니다. Publisher, Loader 및 Nuke Studio Export 앱도 템플릿을 사용하여 파일을 찾고 관리합니다. 아티스트는 파일 이름이나 위치에 대해 걱정할 필요가 없으며 툴킷이 템플릿과 수행할 태스크를 기반으로 모두 관리합니다.템플릿은 구성 파일 /&amp;lt;pipeline_configuration_root&amp;gt;/config/core/templates.yml에 의해 관리됩니다. 마지막 두 안내서에서는 작업 환경에 관련된 설정을 관리하고 만들었습니다. 스키마 및 템플릿 설정은 config/core 폴더에 저장되며 환경에 한정되지 않습니다. 모든 템플릿은 단일 파일에 저장되고 다른 환경 구성 파일의 앱 설정 시 이 파일에서 참조됩니다. 예를 들어 template_work는 작업 파일에 사용하기 위해 templates.yml에서 템플릿을 지정하는 Workfiles 앱의 설정입니다. Workfiles가 구성된 환경 및 엔진에 따라 이 구성 설정을 사용하여 templates.yml에서 maya_shot_work 템플릿 또는 houdini_asset_work 템플릿을 지정할 수 있습니다.13단계: 파이프라인의 구성에서 config/core/templates.yml을 엽니다.이 파일은 다음 세 개의 섹션으로 나뉩니다.  키: 템플릿 작성에 사용할 토큰 세트입니다(예: {version}, {Asset}, 등). 템플릿이 실제로 사용될 때 실제 값으로 대체됩니다. 각 키에는 필요한 이름과 유형 및 기타 선택적 매개변수가 있습니다.  경로: 키를 사용하여 디스크의 폴더 및 파일에 대한 경로를 나타내는 명명된 문자열입니다. paths 섹션의 템플릿은 유효성이 검사되고 디스크에 실제로 존재해야 합니다.  문자열: 경로 섹션과 유사하지만 임의 텍스트에 대한 템플릿입니다. 경로 섹션의 항목은 유효성이 검사되고 디스크의 실제 경로와 일치해야 하며 문자열은 툴킷 워크플로우에서 참조하려는 텍스트 데이터를 저장하는 데 사용할 수 있습니다.Set 엔티티에 대한 템플릿 키 추가가장 먼저 할 일은 엔티티의 시스템 이름을 사용하여 Set 엔티티에 대한 새 키를 정의하는 것입니다.14단계: 들여쓰기에 유의하여 templates.yml의 keys 섹션에 다음 줄을 추가합니다.       CustomEntity01:           type: str템플릿 수정템플릿은 툴킷이 파일을 읽고 쓰는 위치를 정의하기 때문에 여기에서 정의한 경로와 스키마에서 정의한 폴더 구조가 일치하는 것이 중요합니다. 결국 프로덕션 파일은 여기에서 생성하는 파일 시스템으로 이동해야 합니다. 따라서 모든 에셋 관련 템플릿을 스키마에서 정의한 새 폴더 구조와 일치하도록 수정합니다.그런 다음 Maya에서 에셋 단계의 작업 파일에 대한 템플릿을 수정하여 세트도 파일 이름에 포함하도록 합니다. 기본 구성에서 문제의 템플릿은 maya_asset_work이며 이 템플릿부터 살펴보겠습니다.                    참고: Maya에서 에셋 기반 Workfiles에 대해 maya_asset_work라는 템플릿을 사용하는 것이 기본 구성의 규칙입니다. 올바른 템플릿인지 확인하려면 asset_step 환경(여기서는 GitHub)[(https://github.com/shotgunsoftware/tk-config-default2/blob/v1.2.4/env/includes/settings/tk-multi-workfiles2.yml#L217)]에서 tk-maya 엔진의 tk-multi-workfiles2에 대한 template_work 설정 값을 확인합니다.    15단계: templates.yml을 열고 maya_asset_work를 찾습니다.   maya_asset_work:        definition: '@asset_root/work/maya/{name}.v{version}.{maya_extension}'maya_asset_work의 definition 값은 @asset_root로 시작합니다. @ 기호는 @asset_root 값이 다른 곳에서 정의된 것임을 나타냅니다.                    참고: 앞의 @ 기호는 환경 구성 파일에서처럼 templates.yml에서 포함을 나타내지 않습니다.    각 통합, 각 앱 및 각 환경이 다른 설정을 사용할 수 있기 때문에 경로의 첫 번째 부분은 templates.yml 내의 다양한 지점에 사용될 수 있음을 가정할 수 있습니다. 구성은 단일 변수를 사용하여 공통 경로 루트를 저장한 다음 템플릿 내에서 해당 변수를 참조할 수 있도록 설정됩니다. 공통 루트를 참조할 수 있는 경우 경로 생성 설정의 각 인스턴스를 변경할 필요가 없습니다.기본 구성에는 세 개의 공통 루트 변수 @shot_root, @sequence_root 및 @asset_root가 있습니다. @asset_root를 수정하겠습니다. 이렇게 한 번 변경하면 모든 에셋 관련 템플릿에 영향이 미칩니다.템플릿을 파일 시스템 스키마의 경로와 일치하도록 편집16단계: templates.yml의 paths 섹션 맨 위에서 asset_root를 찾습니다. 기본 구성에서는 다음과 같습니다.asset_root: assets/{sg_asset_type}/{Asset}/{Step}스키마 수정 사항과 일치하도록 asset_root 경로에 CustomEntity01을 추가합니다.asset_root: assets/{CustomEntity01}/{sg_asset_type}/{Asset}/{Step}파일 이름에 세트 추가스키마 변경 사항을 반영하도록 파일의 폴더 구조를 변경했으며 이제 적절한 위치에서 파일을 읽고 쓸 수 있습니다. 그럼 이제 Maya 에셋 작업 파일 템플릿에 대한 파일 이름에도 세트가 포함되도록 수정하겠습니다.maya_asset_work 템플릿 정의를 다시 찾습니다. 현재 상태에서 파일 이름은 다음과 같습니다.{name}.v{version}.{maya_extension}{name} 템플릿 키는 Workfiles 앱의 파일 저장(File Save) 액션에서 사용자 입력을 나타내는 특수 키입니다. 템플릿에 어떤 사용자 입력도 포함하지 않고 대신 현재 세트 및 에셋으로만 구성되도록 수정하겠습니다.17단계: maya_asset_work 템플릿 정의를 다음과 같이 수정합니다.    maya_asset_work:        definition: '@asset_root/work/maya/{CustomEntity01}_{Asset}.v{version}.{maya_extension}'이 액션을 통해 파일 이름에 Dining-Room 엔티티의 적절한 이름을 사용할 수 있습니다. 결과는 Dining-Room_Filet.v1.mb와 같이 지정됩니다.이제 프로덕션 폴더 구조에 새 세트 폴더를 반영하고 Maya에서 에셋 태스크에 대한 작업 파일에 세트 이름을 포함하도록 templates.yml이 수정되었습니다. 변경 사항을 테스트해 보겠습니다.테스트18단계: ShotGrid 데스크톱에서 Maya를 시작합니다.Maya에서 ShotGrid &amp;gt; 파일 열기(File Open)로 이동하여 결과 대화상자에서, ShotGrid에서 Set를 지정한 에셋에 대한 태스크를 선택합니다.+새 파일(+New File)을 선택합니다.간단한 3D 객체를 만들거나 ShotGrid &amp;gt; 파일 저장(Save File)을 사용하여 파일을 저장할 수 있습니다.다 되었습니다!파일 저장(File Save) 대화상자에 새 템플릿 설정을 사용하여 미리보기: Dining-Room_scene.v001.ma(Preview: Dining-Room_scene.v001.ma)가 표시되어 있습니다.작업 영역(Work Area)에는 Workfiles가 파일을 저장하는 경로인 …/ShotGrid/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/work/maya가 표시되어 있습니다.고급 항목예제 확장이 예제에서는 단일 템플릿을 수정했지만 파일 시스템 구성을 사용하여 수행할 수 있는 작업은 훨씬 많습니다. 실제 사례에서는 동일한 파일 명명 규칙을 갖도록 모든 에셋 관련 파일을 변경합니다. 다른 엔티티(시즌, 에피소드, 레벨 등)를 기반으로 수정하고, 사용자 폴더를 만들고, 정규 표현식으로 조작된 ShotGrid 데이터를 기반으로 폴더 이름을 지정하는 등 많은 작업을 수행할 수 있습니다. 툴킷의 모든 폴더 및 스키마 옵션에 대한 자세한 내용은 파일 시스템 구성 참조를 참조하십시오.경로 캐시폴더가 생성될 때 디스크의 폴더와 ShotGrid 엔티티 간에 매핑이 만들어집니다. 이러한 매핑은 ShotGrid에 FilesystemLocation 엔티티로 저장되고 사용자 컴퓨터의 SQLite 데이터베이스에서 캐시됩니다. 경로 캐시 작동 방식과 이를 사용한 작업 방법에 대한 자세한 내용은 이 문서를 참조하십시오.추가 리소스  파일 시스템 구성 참조  툴킷 구성 소개 웨비나 동영상",
    "url": "/56b441c6/",
    "relUrl": "/56b441c6/"
  },
  "28": {
    "id": "28",
    "title": "구성 편집",
    "content": "파이프라인 구성 편집이 안내서를 통해 다음과 같은 기본 사항을 익힐 수 있습니다.  특정 툴킷 앱의 구성 설정 찾기  설정 편집  구성 설정에서 확장할 수 있는 다른 기능 살펴보기안내서 정보이 안내서에서는 기존 파이프라인 구성 내에서 설정을 프로젝트 파이프라인의 요구 사항에 맞게 편집하는 방법에 대해 설명합니다. 첫 번째 안내서인 구성 시작하기에서는 편집을 위해 파이프라인 구성을 준비하는 방법을 설명합니다. 편집 가능한 프로젝트 구성을 만드는 데 익숙하지 않다면 먼저 구성 시작하기를 전체적으로 검토하십시오.기본 구성을 확장하는 방법으로 ShotGrid 툴킷에서 파이프라인 워크플로우 내의 태스크를 커스터마이즈할 수 있습니다. 커스터마이즈의 간단한 예로, 하나 이상의 소프트웨어 패키지 내에서 툴킷 앱의 버튼을 활성화 또는 비활성화하여 사용자들이 툴킷의 기능과 상호 작용하는 방식을 변경할 수 있습니다. 툴킷은 독자적인 구성을 지원하므로 커스텀 워크플로우를 생성하고, 반복적이고 일상적인 태스크를 자동화하고, 후크를 수정하고, 툴킷 플랫폼에 커스텀 도구를 추가함으로써 더 스마트하고 빠르게 작업할 수 있습니다. 그러나 ShotGrid 소프트웨어 통합을 통해서만 액세스할 수 있으며 일상적인 작업용으로는 아직 출시되지 않았습니다.이 안내서의 연습을 통해 ShotGrid 소프트웨어 통합 내에서 구성 설정 제어 액션을 찾는 방법과 설정이 존재하는 위치, 설정을 편집하는 방법을 익힐 수 있습니다. 특히 Maya 내에서 프로젝트 작업 중에 아티스트가 새 태스크를 생성하지 못하도록 +새 태스크(+New Task) 버튼의 동작을 관리하는 Workfiles 앱의 설정을 편집해 보겠습니다.이 문서 사용이 안내서를 사용하고 파이프라인 구성에 대한 편집을 수행하려면 다음이 필요합니다.  활성 ShotGrid 사이트.  하나 이상의 에셋이 있는 프로젝트. 첫 번째 안내서에서 생성한 the_other_side 프로젝트에 에셋을 추가할 수 있습니다. 구성 시작하기 안내서에서 프로젝트의 에셋을 생성하는 방법을 익힐 수 있습니다.  식별된 프로젝트에 대한 파이프라인 구성이나 구성 시작하기 안내서를 완료하고 해당 연습에서 생성한 구성을 사용합니다.  파이프라인 구성이 저장된 파일 시스템에 대해 읽기 및 쓰기 권한을 적절하게 설정합니다.  ShotGrid 데스크톱이 시스템에 설치되어 있어야 합니다.  활성 상태의 Maya 멤버쉽. Maya의 30일 체험판은 여기에서 구할 수 있습니다.                    참고: 이 안내서는 tk-config-default2 파이프라인 구성을 기반으로 합니다. 이 구성을 수정한 경우 YAML 설정의 파일, 폴더 및 블록의 위치가 여기에 설명된 것과 다를 수 있습니다.    Workfiles 앱 정보Workfiles 앱은 ShotGrid 소프트웨어 통합에서 파일 관리를 제어하고, 작업 파일을 검색하고 열고 저장하는 기능에 대한 액세스를 제어합니다. +새 태스크(+New Task) 버튼은 사용자가 이 작업을 수행하기 위해 ShotGrid으로 이동할 필요 없이 태스크를 추가할 수 있게 해 주는 Workfiles 앱의 동작입니다. 구성은 환경별 파일로 나뉩니다. 이를 통해 파일을 생성하고, 파일에 이름을 지정하고, 파일을 저장하는 시기 또는 태스크를 실행하거나 특정 기능을 수행하는 시기를 제어하는 등 파이프라인의 여러 단계와 관련된 기능을 관리할 수 있습니다. 이러한 구성은 Workfiles 앱의 모든 기능과 연관되며 앱 또는 엔진의 설정을 수정할 때도 적용됩니다. 자세한 내용은 이 문서의 끝부분에 있는 고급 항목을 참조하십시오.구성 파일 익히기SShotGrid의 파이프라인 구성 목록을 사용하여 작업 중인 프로젝트의 파이프라인 구성이 저장된 위치를 찾을 수 있습니다. 저장된 위치를 아는 경우 5단계로 건너뛸 수 있습니다.파이프라인 구성 찾기1단계: 이 연습에서 사용하게 될 프로젝트를 관리하는 ShotGrid 사이트를 엽니다.2단계: ShotGrid 사이트의 프로젝트 페이지에서 프로젝트를 선택하여 액세스합니다.3단계: 오른쪽 상단에 있는 아바타를 선택하여 관리자(ADMIN) 메뉴를 표시하고 아래로 스크롤하여 기본 레이아웃(Default Layouts) &amp;gt; 파이프라인 구성(Pipeline Configuration) &amp;gt; 파이프라인 구성 목록(Pipeline Configuration List)을 선택합니다.4단계: 파이프라인 구성 목록(Pipeline Configuration List)이 표시되면 열 헤더 맨 오른쪽의 + 기호를 선택하여 다른 열을 추가합니다. 드롭다운 목록에서 적절한 운영 체제 경로를 선택합니다.경로가 새 필드에 표시됩니다.5단계: 터미널 또는 파일 관리자에서 프로젝트의 파이프라인 구성이 저장된 폴더를 찾아 폴더를 엽니다.툴킷 구성 루트 폴더에는 cache, config 및 install이라는 3개의 하위 폴더가 있습니다. config 폴더를 열면 몇 개의 하위 폴더와 파일이 중첩되어 있음을 확인할 수 있습니다.env 폴더는 아티스트가 작업하는 환경을 지원하는 통합 설정을 저장합니다. 환경을 통해 파이프라인의 여러 단계에서 구성을 커스터마이즈할 수 있습니다. 기본 구성이 일련의 미리 정의된 환경과 함께 제공되지만 이 구성은 파이프라인을 더 세부적으로 설정하기 위해 수정할 수 있습니다.6단계: env 폴더를 엽니다.툴킷은 YAML 파일을 사용하여 기능을 구성합니다. YAML은 툴킷 내의 파일 형식을 읽기 쉽고 간단하고 단순한 방식으로 커스터마이즈할 수 있기 때문에 YAML이 구성 언어로 선택되었습니다. YAML에 대한 자세한 내용은 여기를 참조하십시오. 구성은 식별자 엔진, 앱 및 프레임워크를 제공하는 중첩된 YAML 파일로 구성됩니다. 구성은 적용할 액션을 제어하는 특정 코드 번들로 안내하는 일종의 로드맵입니다.구성 파일 편집ShotGrid 툴킷을 통해 다양한 소프트웨어 패키지 내에 통합된 앱으로 변경할 수 있습니다. Workfiles 앱의 기능 중 하나는 +새 태스크(+New Task) 버튼으로, 사용자가 파일 열기(File Open) 대화상자에서 새 태스크를 추가할 수 있게 해 줍니다. 기본적으로 이 기능은 모든 사용자에 대해 프로젝트의 모든 진행단계에서 활성화되어 있습니다. 그러나 이 기능을 제한하고 싶은 스튜디오도 있을 수 있습니다. 특정 명명 규칙이 있거나 프로젝트의 프로덕션 관리 팀만 태스크를 생성할 수 있도록 제한하려는 경우에 그렇습니다. 이 경우 아티스트가 Maya에서 작업할 파이프라인의 모든 지점에 대해 +새 태스크(+New Task) 버튼을 비활성화하면 됩니다.Maya에서 프로젝트에 대해 +새 태스크(+New Task) 버튼 비활성화7단계: ShotGrid 데스크톱을 엽니다.8단계: 편집할 구성의 프로젝트를 선택합니다.9단계: ShotGrid 데스크톱에서 Maya를 시작합니다.ShotGrid 메뉴가 완전히 로드될 때까지 기다립니다. 인터넷 연결 속도가 느릴 경우 메뉴가 로드되는 동안 커피 한 잔 준비하는 것도 좋습니다.Maya와 ShotGrid이 완전히 로드되면 파일 열기(File Open) 대화상자가 자동으로 열립니다. ShotGrid 데스크톱에서 Maya를 실행하면 프로젝트 환경에서 Maya가 시작되고 툴킷 워크플로우의 구성이 config/env/project.yml 파일에 의해 구동됩니다. 기본 구성에서 식별되는 환경은 project, sequence, shot, shot_step, asset, asset_step입니다.10단계: 파일 열기(File Open) 대화상자의 왼쪽 창에서 에셋(Assets) 탭을 선택합니다. 검색 결과에 표시되는 폴더 내의 모든 에셋을 선택합니다.+새 태스크(+New Task) 버튼이 활성화되어 있습니다.+새 태스크(+New Task) 버튼을 제어하는 설정 찾기파이프라인 요구 사항을 충족하기 위해 툴킷 파이프라인 구성을 사용하여 사용자 환경을 커스터마이즈할 수 있습니다. 파이프라인 구성은 프로젝트 파이프라인의 요구 사항에 맞게 필요에 따라 기본 ShotGrid 통합 설정을 재정의할 수 있습니다. ShotGrid 코어 코드의 기본값과 다른 설정만 추가하여 구성을 간단하게 생성할 수 있는 구조입니다. 이 연습에서는 Workfiles 앱의 +새 태스크(+New Task) 버튼을 사용할 수 없게 할 예정이지만 그전에 이 버튼을 제어하는 구성 설정을 확인해야 합니다.11단계: 프로젝트(프로젝트 이름)(Project(프로젝트 이름)) 옆에 있는 파일 열기(File Open) 창의 오른쪽 상단에서 &amp;gt;를 선택합니다.이 참조 상자는 파일 열기(File Open) 창의 기능을 제어하는 구성 설정에 대한 상세한 정보를 보여 줍니다. 툴킷의 일부 앱에는 앱에 사용된 설정과 기본 설정을 보여 주는 참조 상자가 있습니다. 위치:(Location:) 식별자는 tk-multi-workfiles2입니다. 이 식별자는 Workfiles 앱을 만드는 코드 번들의 식별자입니다. 파이프라인 구성을 검색할 때 이 이름으로 앱의 설정이 있는 위치를 확인할 수 있습니다. ShotGrid 통합에서 사용할 수 있는 모든 구성 설정, 앱 및 엔진이 나열된 앱 및 엔진 페이지가 있습니다.이 특정 환경에 대한 설정을 찾으려면 구성(Configuration) 헤더 아래를 확인하십시오.                    참고: my_tasks_filters 설정 다음이 launch_at_startup 설정입니다. 프로젝트 환경에서 파일 열기(File Open) 설정의 기본 설정이므로 유의해야 합니다. 이는 ShotGrid 데스크톱에서 Maya가 실행되면 파일 열기(File Open) 대화상자가 자동으로 열린다는 의미입니다.    설정 allow_task_creation까지 아래로 스크롤합니다. 이 설정의 기본값은 True이므로 사용자가 Maya 프로젝트 환경에 있는 동안 새 태스크를 생성할 수 있습니다.설정을 검색할 때 다음 사항을 고려해야 합니다.  실행 중인 소프트웨어 응용프로그램  작업 중인 파일과 환경. 이 부분은 앱의 참조 상자에서 확인할 수 있습니다.  호출되는 설정. 이 부분은 앱의 참조 상자 또는 앱 및 엔진 페이지에서 확인할 수 있습니다.  확장할 YAML 파일. YAML 파일에 자세히 나와 있는 식별자와 로드맵으로 설정이 있는 위치를 확인할 수 있습니다.  확장할 YAML 파일 내의 특정 블록. 이는 로드맵에서 확인할 수 있습니다.  YAML 파일에서 사용되는 식별자 및 기호.  현재 프로젝트의 구성이 저장된 위치(가장 중요).설정은 파이프라인 구성 내의 여러 곳에서 활용될 수 있습니다. 적용할 소프트웨어 통합 및 변경할 파이프라인 프로세스에 따라 활용 방법이 결정됩니다.allow_task_creation 값을 설정할 위치 찾기12단계: 기본 Maya 창을 앞으로 가져옵니다.13단계: Maya 창의 오른쪽 상단에서 ShotGrid 메뉴 항목을 찾습니다.팁: 메뉴가 표시되지 않을 경우 일부 숨겨진 메뉴 항목을 볼 수 있는 »가 표시됩니다. »를 선택하여 ShotGrid 메뉴를 표시하거나 Maya 창을 넓히면 됩니다.14단계: 메뉴 오른쪽 상단에서 ShotGrid &amp;gt; 프로젝트 the_other_side(Project the_other_side) &amp;gt; 작업 영역 정보…(Work Area Info…)를 선택합니다.작업 영역 정보(Work Area Info) 대화상자에는 현재 작업 영역이 어떻게 돌아가는지 및 상세 정보가 표시됩니다. 여기에는 작업 중인 환경 및 설정이 위치한 환경 구성 파일의 경로도 포함됩니다.15단계: 현재 작업 영역(Your Current Work Area) 대화상자에서 아래에 있는 환경(Environment) 탭을 선택합니다.첫 번째 항목에서 사용 중인 엔진이 확인됩니다. 엔진은 특정 소프트웨어 응용프로그램 내에서 ShotGrid 도구를 통합하는 기능을 구동합니다. 여기에는 각 소프트웨어 통합에 해당하는 로직이 포함됩니다. 창에 표시된 두 번째 항목은 현재 프로젝트 환경이 위치한 경로를 보여 줍니다.마지막 두 폴더는 project.yml이고 그 다음에 config/env/이 표시됩니다. project.yml 파일은 현재 환경에 대한 설정이 있는 위치를 안내하는 로드맵의 시작입니다.16단계: 즐겨 사용하는 텍스트 편집기에서 project.yml을 엽니다.description: Apps and Engines when launching with a project only context.################################################################################includes:- ./includes/frameworks.yml- ./includes/settings/tk-3dsmaxplus.yml- ./includes/settings/tk-desktop.yml- ./includes/settings/tk-flame.yml- ./includes/settings/tk-houdini.yml- ./includes/settings/tk-mari.yml- ./includes/settings/tk-maya.yml- ./includes/settings/tk-motionbuilder.yml- ./includes/settings/tk-nuke.yml- ./includes/settings/tk-photoshopcc.yml- ./includes/settings/tk-shell.yml- ./includes/settings/tk-shotgun.yml################################################################################# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;################################################################################# reference all of the common frameworksframeworks: &quot;@frameworks&quot;project.yml 내에는 설명 아래 세 가지 섹션 includes, engines 및 frameworks가 있습니다. includes 섹션은 구성에서 다른 YAML 파일을 참조하는 파일 포인터의 목록입니다. 기본 구성의 아키텍처에서는 파일을 간단하게 유지하기 위한 또 다른 방법으로 파일 중첩 및 포인터를 활용합니다. includes를 따라가면 원하는 구성 설정을 찾을 때까지 다음 파일로 이동합니다. 이는 적절한 구성 설정을 찾을 때까지 계속해서 내부에 포개진 인형이 하나씩 열리는 러시아 마트료시카 인형과 비슷합니다.모든 엔진은 tk-&amp;lt;name of software application&amp;gt;으로 식별됩니다. Maya에서 설정을 적용하려고 하므로 찾아야 할 식별자는 tk-maya입니다.project.yml 파일의 includes: 섹션에서 ./includes/settings/tk-maya.yml 행을 찾습니다. 이 행은 settings 폴더 내의 includes 폴더에 중첩된, Maya 엔진의 설정을 제어하는 구성 tk-maya를 나타냅니다.engines: 섹션에서 tk-maya 값을 찾습니다.tk-maya: &quot;@settings.tk-maya.project&quot;이 @ 기호는 값이 포함된 파일에서 제공되었음을 나타냅니다.settings 및 project는 프로젝트의 설정임을 나타냅니다. 이는 식별하는 데 도움이 되는 기본 구성 내의 명명 규칙입니다.이 전체 행은 Maya 엔진의 구성 설정인 tk-maya를 찾기 위해 포함된 파일에서 settings.tk-maya.project 블록을 찾는다는 것을 나타냅니다.ShotGrid 툴킷은 YAML 파일에서 간단한 용어를 사용하여 설정의 이름과 설정으로 이동하는 경로를 나타냅니다. +새 태스크(+New Task) 버튼 수행 방식을 제어하는 코드 번들이 tk-multi-workfiles2로 식별되는 것은 Maya 파일 열기(File Open) 참조 상자를 볼 때 이미 알고 있습니다. 툴킷 번들은 이러한 식별자를 사용하여 YAML 파일에서 참조됩니다. ‘tk-multi-workfiles2’는 Workfiles 앱 코드 번들의 식별자이며 +새 태스크(+New Task) 버튼은 Workfiles 앱의 기능입니다.tk-maya.yml에서 Workfiles 앱 설정 찾기17단계: 파일 브라우저에서 env/includes/settings 폴더를 찾아 tk-maya.yml을 엽니다.18단계: project.yml에서 include를 따라가면서 tk-maya.yml 파일에서 settings.tk-maya.project를 찾습니다. 구체적으로는 특정 프로젝트의 프로젝트 환경에서 +새 태스크 (+New Task) 버튼을 비활성화하려고 합니다. 현재 해당 프로젝트에 대한 구성에 있으며 프로젝트 환경에 있는 동안 위치 정보를 얻었습니다.# projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;  menu_favourites:  - {app_instance: tk-multi-workfiles2, name: File Open...}  location: &quot;@engines.tk-maya.location&quot;settings.tk-maya.projects 아래에 tk-multi-workfiles2 앱 설정이 다음과 같이 나열됩니다.tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;@ 기호는 tk-multi-workfiles2 값이 포함된 파일에서 제공된 것임을 나타냅니다. tk-maya.yml의 맨 위에 있는 includes 섹션에서 다음을 확인할 수 있습니다.includes:...- ./tk-multi-workfiles2.yml현재 파일 config/env/includes/settings와 동일한 디렉토리에 있는 tk-multi-workfiles2.yml 파일에서 settings.tk-multi-workfiles2.launch_at_startup을 찾아야 합니다.19단계: tk-multi-workfiles2.yml 파일을 열고 settings.tk-multi-workfiles2.launch_at_startup을 찾습니다.# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  launch_at_startup: true  entities:allow_task_creation 설정을 나타내는 Maya 참조 상자에서 기본값은 true입니다. 가장 좋은 방법은 파이프라인 구성에 기본 설정을 반영하지 않는 것입니다. 이렇게 하면 스파스 형식이 허용되어 기본 코드와 다른 설정만 구성에 추가됩니다. 설정이 명시적으로 제공되지 않는 경우 해당 설정이 액세스하는 모든 호출이 기본값을 받습니다. 툴킷이 구성을 읽고 환경을 빌드하면 해당 환경에서 실행되는 앱, 엔진 및 프레임워크는 해당 프로젝트의 파이프라인 구성 설정을 사용하고 구성에 있는 항목을 기반으로 모든 기본 설정을 재정의합니다.20단계: tk-multi-workfiles2.yml에서 settings.tk-multi-workfiles2.launch_at_startup: 아래 allow_task_creation을 추가하고 값을 false로 설정합니다.# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  allow_task_creation: false  launch_at_startup: true  entities:참고: 툴킷 기본 구성 설정은 특정 설정을 찾기 쉽도록 알파벳순으로 구성됩니다. 이 규칙을 유지해야 구성이 복잡해질 경우에도 처리하기가 편리합니다.21단계: 파일을 저장합니다.구성 다시 로드22단계: Maya 내의 파일 열기(File Open) 대화상자에서 참조 상자를 열고 엔진 및 앱 다시 로드(Reload Engines and Apps)를 선택합니다.그러면 구성 설정이 다시 로드됩니다.변경 사항 보기23단계: 파일 열기(File Open) 대화상자로 이동하여 에셋을 선택합니다.+새 태스크(+New Task) 버튼이 표시되지 않습니다.Workfiles 앱의 구성 설정을 수정하여 프로젝트 환경의 버튼 동작을 변경했습니다. 이 프로젝트 환경의 해당 설정만 수정했기 때문에 다른 환경에서 작업을 시작하면 +새 태스크(+New Task) 버튼에 대한 설정은 여전히 활성 상태입니다. 예를 들어 실제 프로덕션에서 모든환경에 대해 지금처럼 변경할 수 있습니다.환경 변경24단계: 에셋(Assets) 검색 결과에서 폴더를 열고 작업할 에셋을 선택합니다.25단계: +새 파일(+New File)을 선택합니다.+새 파일(+New File)을 선택하여 새 에셋에 대한 작업을 시작했으며 Maya에서 asset_step 환경이 로드되었습니다. 아티스트가 에셋 태스크를 선택하고 새 파일을 생성하거나 기존 파일을 열면 asset_step 환경이 자동으로 로드되어 파이프라인의 해당 단계에 구성된 도구 및 기능이 제공됩니다.작업 중인 환경 검색26단계: Maya 메뉴 오른쪽 상단에서 ShotGrid을 선택합니다.아트, 에셋(Art, Asset)은 지금 작업 중이라는 것과 현재 환경을 알려 줍니다.27단계: 아트, 에셋((Art, Asset) &amp;gt; 작업 영역 정보…(Work Area Info…)를 선택하여 현재 작업 영역에 어떤 매개변수가 있는지 표시합니다.28단계: 아래에 있는 환경(Environment) 탭을 선택합니다.각 환경은 파이프라인 구성에서 설정이 있는 위치를 확인할 수 있도록 필요한 정보를 표시합니다. 아티스트가 새 태스크를 추가하지 않도록 하려면 아티스트가 작업하는 모든 환경에 대해 +새 태스크(+New Task) 버튼을 비활성화해야 합니다. 각 환경에 대해 위에 설명한 것과 동일한 단계를 사용하여 적절하게 구성을 편집합니다.참고: 각 환경은 독립적이며 프로젝트는 전용 구성을 사용하고 소프트웨어 통합은 프로젝트가 로드될 때 파이프라인 구성에서 해당 특정 소프트웨어의 설정만 읽습니다.지금까지 파이프라인 구성을 편집하여 앱 설정을 변경했습니다. 이제 본격적으로 ShotGrid 툴킷 환경에서 수행할 수 있는 모든 작업에 대해 알아보겠습니다. 다음은 살펴볼 몇 가지 고급 항목입니다.고급 항목이 안내서에서는 단일 엔진(tk-maya) 및 단일 환경(project)에서 앱의 구성 설정을 간단하게 변경했습니다. 툴킷은 환경별로 구성되고, 모든 소프트웨어 구현에 있어 각 환경은 고유하며, 정의된 파이프라인 지점에서 아티스트가 특정 기능을 사용할 수 있도록 프로젝트 및 태스크별로 초점을 맞추는 것에 대해 학습했습니다. 간단한 변경 사항을 일반화하면 툴킷 파이프라인 구성을 얼마든지 커스터마이즈할 수 있습니다.기타 엔진Workfiles 앱의 시스템 이름은 tk-multi-workfiles2이고 여기서 multi는 이 앱이 다중 앱임을 암시합니다. 다중 앱은 소프트웨어에 구속받지 않는 앱으로, Maya, Nuke, Houdini에서 실행하든 기타 지원되는 앱에서 실행하든 앱의 기능이 동일합니다. 모든 소프트웨어 패키지의 Workfiles에서 태스크 생성을 비활성화하려면 모든 엔진(tk-nuke, tk-houdini 등)에 대해 이 안내서의 단계를 수행합니다.기타 환경여기서는 프로젝트 환경에서 태스크 생성을 비활성화했지만 실제 스튜디오 환경에서는 아티스트가 작업 중인 모든 환경에 대해 태스크 생성을 비활성화하고 싶을 수 있습니다. 이를 위해서는 안내서의 단계를 수행하되 project.yml에서 시작하는 대신 asset_step.yml, shot_step.yml 등에서 시작합니다.커스텀 환경 생성기본 구성은 일련의 미리 정의된 파이프라인 단계(project, sequence, shot, shot_step, asset 및 asset_step)와 함께 제공됩니다. 그러나 스튜디오에서는 파이프라인 단계(asset_step_rig, asset_step_model, shot_step_anim, shot_step_light 등)마다 다른 구성 설정을 원할 수 있습니다. 툴킷은 커스텀 환경을 지원합니다. 자세한 내용은 환경 구성 참조의 “커스텀 환경” 섹션을 참조하십시오.비디오 리소스  SIGGRAPH 2018 Developer Day의 툴킷 구성 소개  기본 구성 이해 웨비나앱 구성 설정을 수정하는 방법에 대해 알아보았습니다. 이제 툴킷 구성에 앱을 추가해 보십시오.",
    "url": "/37f575b8/",
    "relUrl": "/37f575b8/"
  },
  "29": {
    "id": "29",
    "title": "VPC Endpoints",
    "content": "VPC EndpointsComing soon.",
    "url": "/8a9c5baf/",
    "relUrl": "/8a9c5baf/"
  },
  "30": {
    "id": "30",
    "title": "환경 구성 참조",
    "content": "환경 구성 참조소개툴킷 파이프라인의 핵심에는 환경 구성이 있습니다. 툴킷 파이프라인 구성 내에서 환경 구성 파일은 다양한 DCC 내에서 사용할 수 있는 툴킷 앱을 정의하고 각 설정을 커스터마이즈할 수 있는 곳입니다. 이 문서는 환경 구성 파일의 구조 및 기능을 전체적으로 소개하는 완전한 참조 자료입니다. 이 문서에서는 프로젝트 내에서 다양한 워크플로우를 구성할 수 있게 해 주는 툴킷 환경의 개념과 커스터마이즈할 수 있는 항목을 찾는 방법에 대해 설명합니다.                    참고: 이 문서는 환경 구성 파일에 대한 참조 자료로 사용될 수 있으며 툴킷 기본 사항 안내서의 파이프라인 구성 편집에서는 구성 설정 편집에 대한 단계별 예제를 확인할 수 있습니다.    환경이란?ShotGrid 툴킷 플랫폼은 스튜디오 파이프라인을 구축하는 데 일반적으로 사용되는 컨텐츠 작성 소프트웨어를 위해 완전히 커스터마이즈 가능한 통합 세트를 제공합니다. 프로젝트 구성 내에서 통합이 있는 소프트웨어 패키지, 각각 사용 가능한 툴킷 앱, 각 앱에 대한 옵션을 지정하여 스튜디오의 요구 사항에 맞게 아티스트 워크플로우를 구축할 수 있습니다.하지만 대부분의 스튜디오 파이프라인에서는 아티스트 유형별로 다른 워크플로우를 사용하는 것이 일반적입니다. 간단한 예로, 에셋 작업 중인 아티스트의 경우 텍스처 페인팅 소프트웨어(예: Mari)를 사용하게 하고 샷 작업 중인 아티스트의 경우에는 컴포지팅 소프트웨어(예: Nuke)를 사용하게 할 수 있습니다.소프트웨어 패키지뿐 아니라 동일한 툴킷 앱에 대한 설정도 아티스트별로 다르게 지정할 수 있습니다. 예를 들어 샷 아티스트와 에셋 아티스트 둘 다 Workfiles 앱을 사용할 수 있지만 샷 아티스트는 샷 엔티티, 에셋 아티스트는 에셋 엔티티와 관련된 파일로만 파일 탐색을 제한할 수 있습니다.프로젝트 내에서 이렇게 서로 다른 워크플로우를 지원하기 위해 툴킷은 환경에서 앱과 엔진 구성을 분리합니다. 각 환경에는 소프트웨어 패키지 셋트의 통합과 설정이 모두 공통적으로 포함되어 있습니다.위의 예에서 에셋 작업 중인 아티스트는 에셋 단계 환경에서 작업하고 샷 작업 중인 아티스트는 샷 단계 환경에서 작업합니다. 각 환경은 서로 독립적으로 구성되므로 한 프로젝트 내에서 각기 다른 워크플로우를 사용할 수 있습니다.툴킷의 기본 구성에 대한 참고 사항툴킷은 환경을 구성하는 방식에 있어 매우 자유롭습니다. 이 문서에서는 사용 가능한 모든 옵션을 모두 소개하므로 파이프라인 요구 사항에 가장 적합한 선택을 하는 데 필요한 지식을 얻을 수 있습니다.또한 이 문서에서는 기본 구성이라는 시작점으로 제공되는 파이프라인 구성의 선택 사항에 대해서도 설명합니다. 파이프라인을 커스터마이즈할 준비가 된 경우 첫 번째 단계는 프로젝트에 대해 편집 가능한 파이프라인 구성을 만드는 것입니다.이러한 선택 사항은 일반적인 규칙일 뿐이고 툴킷 워크플로우에 하드코딩되지 않으므로, 기본 구성은 파이프라인을 커스터마이즈한 후 사용할 수 있는 기능을 학습하기 위한 예제로 참조하거나 고유의 구성을 설정하기 위한 모범 사례로 사용하는 것이 좋습니다. 또한 새로운 툴킷 사용자를 위한 시작점으로도 좋으며 몇 가지 규칙을 알아 두면 유용합니다. 이 문서에서는 툴킷 환경 구성의 일반적인 기능과 기본 구성에 특정한 선택 사항을 구분해 두었습니다. 기본 구성의 환경 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오.파일 위치파이프라인 구성에서 config/ 디렉토리에는 커스터마이즈할 수 있는 모든 파일 및 폴더가 포함됩니다. config/에는 세 개의 하위 디렉토리(cache, core 및 env)가 있습니다. env 디렉토리에 환경 구성 파일이 있으므로 이 문서에서는 config/env의 파일을 참조합니다.기본 구성의 config/env/에는 다음 파일이 있습니다.asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.yml이러한 각 파일이 환경에 해당하며 별도 파일을 사용하면 각 환경을 별도로 구성할 수 있습니다.툴킷이 현재 환경을 결정하는 방식툴킷은 pick_environment라는 코어 후크를 사용하여 현재 컨텍스트를 기반으로 지정된 시간에 사용할 환경 파일을 결정합니다. pick_environment 후크의 반환 값은 환경 구성 파일에 해당합니다. 예를 들어 pick_environment가 shot_step을 반환하는 경우 툴킷은 config/env/shot_step.yml을 사용하여 툴킷 환경을 구성합니다.커스텀 환경위에 나열된 환경 구성 파일은 기본 구성에서 제공하는 파일입니다. 그러나 일부 스튜디오에서는 다른 환경 또는 추가 환경을 필요로 할 수 있습니다. 예를 들어 스튜디오에서 파이프라인 단계(asset_step_rig, asset_step_model, shot_step_anim, shot_step_light 등)마다 다른 구성 설정을 사용해야 할 수 있습니다. 다행히도 사용 가능한 환경을 완전히 커스터마이즈할 수 있습니다.이렇게 하려면 원하는 환경 구성 파일을 config/env 디렉토리에 추가해야 합니다. 그런 다음 pick_environment 코어 후크를 재지정하여 새 환경을 사용할 때 정의하는 로직에 추가합니다.기본 구조툴킷의 구성 파일은 YAML로 작성됩니다. 모든 번들(앱, 엔진 또는 프레임워크)의 일반적인 구성은 다음과 같은 구조로 되어 있습니다.bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: value이 구조를 보여 주는 간단한 예제가 아래에 있습니다(단일 엔진이 있고 엔진 내에 단일 앱이 정의된 환경). 다음은 이 구성에서 project.yml의 내용이 될 수 있습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4엔진 블록모든 환경 구성 파일은 engines 블록으로 시작합니다. 해당 환경에 대해 정의된 모든 엔진이 이 블록 내에 중첩됩니다.이 예에서는 하나의 엔진, tk-maya만 정의되어 있습니다. 여기에는 두 개의 설정(apps 및 location)이 나열되어 있습니다.location은 모든 번들에 필요한 특수한 설정입니다. apps 설정은 엔진에 대해 정의된 모든 앱의 목록으로, 각 앱에는 자체 설정이 있습니다. 이 예에서는 엔진에 대해 하나의 앱, tk-multi-workfiles2만 정의되어 있습니다.위치 설명자모든 툴킷 번들에는 번들의 설명자라고 불리는 location 설정이 있습니다. 설명자를 통해 툴킷은 지정된 번들의 위치를 파악하고 해당 유형에 따라 직접 액세스할지 아니면 로컬로 캐시할지 여부를 파악합니다. 툴킷 번들을 가져올 수 있는 위치는 ShotGrid 앱 스토어, git 리포지토리, 디스크의 경로 또는 ShotGrid 사이트에 업로드된 ZIP 파일 등입니다. 이러한 각 위치에 해당하는 설명자 유형이 있으며 여기에는 해당 유형과 관련된 설정이 포함됩니다. 위 예제의 tk-maya 엔진에 대한 설명자는 다음과 같습니다.    location:        type: app_store        name: tk-maya        version: v0.9.4이 예는 app_store 유형의 설명자로, 툴킷이 ShotGrid 앱 스토어에서 지정된 번들을 가져오도록 합니다. app_store 유형의 설명자에는 name 및 version 설정이 있습니다.한편, 커스텀 번들을 개발 중이고 스튜디오의 특정 워크플로우에 대한 툴킷 앱을 작성 중인 경우 디스크의 경로에서 직접 가져오고 싶을 수 있습니다. 이 경우 다음과 같이 dev 유형의 설명자를 사용합니다.    location:        type: dev        path: /path/to/appdev 설명자에는 app_store 설명자와 다른 설정이 있습니다. 다른 설정을 가져올 수 있지만 디스크에 있는 앱 위치를 가리키는 path 설정으로 간단하게 설정할 수 있습니다.사용 가능한 모든 설명자 유형 및 해당 설정에 대한 자세한 내용은 Toolkit Core API 문서의 설명자 섹션을 참조하십시오.앱 블록앱은 툴킷의 사용자 도구로, 각 앱은 서로 독립적으로 실행할 수 있습니다. 파이프라인 요구 사항에 맞게 사용할 앱을 선택할 수 있으며 엔진 블록 내의 apps 설정은 지정된 엔진에서 사용할 수 있는 앱을 정의하는 곳입니다.위 예제에서 apps 설정은 다음과 같습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8단일 앱인 tk-multi-workfiles2 앱이 정의되어 있는 것을 확인할 수 있습니다. 현재는 하나의 설정(설명자)만 정의되어 있습니다.project 환경의 tk-maya 엔진에서 다른 앱을 사용할 수 있도록 하려면 여기에 추가합니다. 엔진에 패널 tk-multi-shotgunpanel 및 앱 정보 tk-multi-about을 추가해 보겠습니다. project.yml 예제 파일은 이제 다음과 같이 표시됩니다.engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4이때 다음과 같은 몇 가지 중요 사항에 유의해야 합니다.  기본 구성에는 번들이 알파벳순으로 나열되며 이 예에서는 해당 규칙을 따릅니다.  파일이 길어지기 시작하고 있지만 아직 어떤 구성 설정도 추가하지 않은 상태입니다.  다른 엔진 및 다른 환경에서도 이와 동일한 앱을 사용할 수 있습니다. 예를 들어 다른 엔진(예: Houdini, Nuke 또는 Photoshop) 및 다른 환경(예: asset_step 또는 shot_step)에도 이 세 개의 앱(Panel 앱, About 앱, Workfiles 앱)이 모두 있을 수 있습니다. 구성에서 여러 곳에 공통 앱 설정을 정의하면 변경 시에도 여러 곳에서 수정해야 합니다.마지막 두 가지 문제점을 해결하기 위해 툴킷 구성은 includes를 지원합니다.Includesincludes는 구성에서 한 파일의 섹션을 다른 파일에서 참조할 수 있게 해 줍니다. includes를 사용하면 한 곳에서 구성 설정을 설정한 후 여러 환경에서 사용할 수 있습니다.includes는 두 부분으로 구성됩니다.  includes 목록: 키가 includes인 YAML 사전이며 값은 포함할 모든 파일의 목록입니다.  구성 설정 내의 참조: 앞에 @ 기호가 붙고, 포함된 파일에서 참조할 섹션의 이름을 가리키도록 명명됩니다.위의 예제를 구체화하기 위해 모든 엔진에 대한 위치 설명자가 있는 단일 파일이 있다고 가정합니다. 이 파일을 includes 하위 폴더에 넣고 engine_locations.yml로 지정하겠습니다.engine_locations.yml의 내용은 다음과 같습니다.config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...이 파일은 모든 엔진 위치에 대한 단일 소스 역할을 하며 모든 환경 구성에서 참조할 수 있습니다. 이 포함 파일을 사용할 경우 예제는 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationtk-maya 엔진에 대한 location 설정 값이 이제 포함된 YAML 파일의 키에 대한 참조임을 확인할 수 있습니다.                    참고: 이 예제에서와 같이 config/env/includes/engine_locations.yml 파일에 모든 엔진 위치가 있는 기본 구성의 규칙을 따릅니다.    앱 위치에 대한 두 번째 포함 파일을 추가할 수 있으며 사실 기본 구성은 이 작업을 수행합니다. 예제를 확장해 보겠습니다.config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location이제 포함된 engine_locations.yml 파일에서 tk-maya 엔진의 설명자를 가져오고 포함된 app_locations.yml 파일에서 tk-maya 엔진에 대해 정의된 각 앱의 설명자를 가져옵니다.                    참고: 기본 구성은 여기에 설명되지 않은 두 번째 중첩 수준을 사용합니다. 설명자 외에도 설정이 있는 모든 앱 또는 엔진에 includes/settings의 설정 파일(예: includes/settings/tk-maya.yml, includes/settings/tk-multi-workfiles2.yml)이 있습니다. 엔진 설정 파일에는 앱 설정 파일의 앱 설정이 포함되고 환경 구성 파일에는 엔진 설정 파일의 설정이 포함됩니다. 기본 구성의 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오. 구성 설정 수정에 대한 자세한 내용은 툴킷 기본 사항 안내서의 파이프라인 구성 편집을 참조하십시오.    스파스 구성모든 툴킷 번들에는 각 기본값이 포함된 일련의 구성 설정이 있습니다. 툴킷은 스파스 구성을 허용하므로 환경 구성 파일(및/또는 포함 파일)에 구성 설정이 명시적으로 지정되지 않은 경우에는 번들의 기본값이 사용됩니다.이 예에서는 location을 제외하고 앱에 대한 어떤 설정도 지정하지 않았습니다. 따라서 구성의 현재 상태에서 세 개의 앱은 모든 설정에 대해 기본값을 사용합니다. 그렇다면 어떤 구성 설정을 사용할 수 있는지 어떻게 알 수 있을까요?                    참고: 툴킷 구성이 스파스일 필요는 없지만 기본 구성은 스파스 구성입니다.    사용 가능한 구성 설정 확인스파스 구성의 경우 단순히 구성 파일을 보는 것만으로는 앱에 대해 사용할 수 있는 구성 설정을 바로 확인할 수 없습니다. 사용 가능한 앱 구성 설정을 확인하려면 두 가지 방법이 있습니다.  앱 설명서: 각 앱에는 고유의 설명서 페이지가 있으며 이 각 페이지마다 “구성 옵션” 섹션이 있습니다. 이 섹션에는 각각의 설명 및 기본값을 포함하여 사용 가능한 모든 앱 구성 설정이 나와 있습니다. 예를 들어 Workfiles 설명서 페이지를 참조할 수 있습니다. 앱 및 엔진 페이지에는 모든 앱 및 엔진에 대한 문서 페이지가 나열되어 있습니다.  매니페스트: 모든 툴킷 번들에는 루트 디렉토리에 info.yml  파일이 포함되어 있습니다. 이 파일을 번들의 매니페스트라고 하며 각각의 설명 및 기본값을 포함하여 번들에 대해 사용 가능한 모든 구성 설정을 정의합니다. 매니페스트는 번들의 자체 캐시(예: 파이프라인 구성 내의 install/app_store/tk-multi-workfiles2/v0.11.8/info.yml) 또는 GitHub(Workfiles용)에서 찾을 수 있습니다.구성 설정 수정기본값에서 구성을 수정하려면 파이프라인의 구성에서 적절한 환경의 적절한 블록에 추가하고 값을 설정하면 됩니다.예제로 돌아가 프로젝트 환경에서 Maya를 시작할 때 tk-multi-workfiles2가 자동으로 시작되도록 구성한다고 가정해 보겠습니다. 앱의 매니페스트에서 응용프로그램 시작 시 Workfiles UI 시작 여부를 제어하는 launch_at_startup 설정이 있고 기본값은 False임을 확인할 수 있습니다. 따라서 launch_at_startup 옵션을 추가하고 해당 옵션을 True로 설정합니다. project.yml 파일은 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationtk-multi-workfiles2에 대한 설정을 포함 파일에서 가져온 경우 해당 파일에서 설정을 변경해야 합니다.추가 리소스  툴킷 기본 사항 안내서: 파이프라인 구성 편집  툴킷 기본 사항 안내서: 앱 추가  애니메이션 파이프라인 튜토리얼  설명자 참조 설명서  웨비나: 툴킷 관리  파일 시스템 구성 참조  기본 구성 환경 구조 읽어보기",
    "url": "/487a9f2c/",
    "relUrl": "/487a9f2c/"
  },
  "31": {
    "id": "31",
    "title": "API",
    "content": "APIregisterCallbacksA global level function in all plugins that is used to tell the framework about event processing entry points in the plugin.registerCallbacks(reg)  reg: The Registrar you will interact with to tell the framework which functions to call.RegistrarThe Registrar is the object used to tell the framework how to interact with a plugin. It is passed to the registerCallbacks function.AttributesloggerSee getLogger.MethodsgetLoggerGet the python Logger object used to log messages from within the plugin.setEmails(*emails)Set the emails that should receive error and critical notices when something bad happens in this plugin or any of its callbacks.To send emails to default addresses as specified in the configuration file (default)reg.setEmails(True)To disable emails (this is not suggested as you won’t get error messages)reg.setEmails(False)To send emails to specific addresses usereg.setEmails('user1@domain.com')orreg.setEmails('user1@domain.com', 'user2@domain.com')registerCallback(sgScriptName, sgScriptKey, callback, matchEvents=None, args=None, stopOnError=True)Register a callback into the engine for this plugin.  sgScriptName: The name of the script taken from the ShotGrid  scripts page.  sgScriptKey: The application key for the script taken from a ShotGrid  script page.  callback: A function or an object with a __call__ method. See exampleCallback.  matchEvents: A filter of events you want to have passed to your callback.  args: Any object you want the framework to pass back into your callback.  stopOnError: Boolean, should an exception in this callback halt processing of events by all callbacks in this plugin. Default is True.The sgScriptName is used to identify the plugin to ShotGrid. Any name can be shared across any number of callbacks or be unique for a single callback.The sgScriptKey is used to identify the plugin to ShotGrid and should be the appropriate key for the specified sgScriptName.The specified callback object will be invoked when an event that matches your filter needs processing. Although any callable should be able to run, using a class here is not suggested. Use of a function or an instance with a __call__ method is more appropriate.The matchEvent argument is a filter that allows you to specify which events the callback being registered is interrested in. If matchEvents is not specified or None is specified, all events will be passed to the callback. Otherwise each key in the matchEvents filter is an event type while each value is a list of possible attribute names.matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],}You can have multiple event types or attribute namesmatchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],    'Shotgun_Version_Change': ['description', 'sg_status_list']}You can filter on any event type that has a given attribute namematchEvents = {    '*': ['sg_status_list'],}You can also filter on any attribute name for a given event typematchEvents = {    'Shotgun_Version_Change': ['*']}Although the following is valid and functionally equivalent to specifying nothing, it’s just really uselessmatchEvents = {    '*': ['*']}When matching against non field specific event types such as “_New” or “_Retirement”, you don’t provide a list, instead you pass None as the value.matchEvents = {    'Shotgun_Version_New': None}The args argument will not be used by the event framework itself but will simply be passed back to your callback without any modification.                    Note: The point of the args argument is for you to be able to process time consuming stuff in the registerCallbacks function and have it passed back to you at event processing time.    Another use of the args argument could be to pass in a common mutable, a dict for example, to multiple callbacks to have them share data.The stopOnError argument tells the system if an exception in this callback can cause event processing to stop for all callbacks in the plugin. By default this is True but can be switched to False. You will still get mail notifications of errors should there be any but processing of events will not stop. Being a per callback setting you can have some critical callbacks for whom this is True but others for whom this is False.CallbackAny plugin entry point registered by Registrar.registerCallback is generally a global level function that looks like this:exampleCallback(sg, logger, event, args)  sg: A ShotGrid connection instance.  logger: A Python logging.Logger object preconfigured for you.  event: A ShotGrid event to process.  args: The args argument specified at callback registration time.                    Note: Implementing a callback as a __call__ method on an object instance is possible but left as an exercise for the user.    ",
    "url": "/b04a53ae/",
    "relUrl": "/b04a53ae/"
  },
  "32": {
    "id": "32",
    "title": "Configuration",
    "content": "ConfigurationThe following guide will help you configure ShotGridEvents for your studio.Most of the configuration for ShotGridEvents is controlled by the shotgunEventDaemon.conf file. In this file, you’ll find several settings you can modify to match your needs. Most of them have defaults that will work fine for most studios, however, there are some settings that must be configured (specifically, your ShotGrid server URL, script name, and application key so the ShotGridEventDaemon can connect to your ShotGrid server).                    Note: For Windows: Windows users will need to change all the paths in the configuration file for Windows equivalents. We suggest keeping all paths, including logging, under one single location for the sake of simplicity. This documentation tends to refer to C: shotgun shotgunEvents when mentioning Windows paths.    Edit shotgunEventDaemon.confOnce you have installed ShotGridEvents, the next step is to open the shotgunEventDaemon.conf file in a text editor and modify the settings to match your studio’s needs. The defaults will be fine for most studios, however, there are some settings that have no defaults that will need to be provided by you before you can run the daemon.The items you must provide are:  your ShotGrid server URL  the Script name and Application key for connecting to ShotGrid  the full path to your plugins for the ShotGridEventDaemon to runOptionally, you can also specify an SMTP server and email-specific settings in order to setup email notification for errors. While this is optional, if you choose to set this up, you must provide all of the configuration values in the email section.There is also a section for an optional timing log which can help with troubleshooting if you ever encounter performance issues with your daemon. Enabling timing logging will populate its own separate log file with the timing information.ShotGrid SettingsUnderneath the [ShotGrid] section, replace the default tokens with the correct values for server, name, and key. These should be the same values you’d provide to a standard API script connecting to ShotGrid.Exampleserver: https://awesome.shotgunstudio.comname: ShotGridEventDaemonkey: e37d855e4824216573472846e0cb3e49c7f6f7b1Plugin SettingsYou will need to tell the ShotGridEventDaemon where to look for plugins to run. Under the [plugins] section replace the default token with the correct  value for paths.You can specify multiple locations (which may be useful if you have multiple departments or repositories using the daemon). The value here must be a full path to a readable existing directory.Examplepaths: /usr/local/shotgun/ShotGridEvents/pluginsWhen you’re first getting started, a good plugin to test with is the logArgs.py plugin located in the /usr/local/shotgun/ShotGridEvents/src/examplePlugins directory. Copy that into the plugins folder you specified and we’ll use that for testing things.Location of shotgunEventDaemon.confBy default, the daemon will look for the shotgunEventDaemon.conf file in the same directory that ShotGridEventDaemon.py is in, and in the /etc directory. If you need to put the conf file in another directory, it’s recommended you create a symlink to it from the current directory.                    Note: If for some reason the above won’t work for you, the search paths for the config file are located in the _getConfigPath() function at the bottom of the shotgunEventDaemon.py script                        Note: For Windows The /etc doesn’t exist on Windows so the configuration file should be put in the same directory as the Python files.    Testing the DaemonDaemons can be difficult to test since they run in the background. There isn’t always an obvious way to see what they’re doing. Lucky for us, the ShotGridEventDaemon has an option to run it as a foreground process. Now that we have done the minimum required setup, let’s go ahead and test the daemon and see how things go.                    Note: The default values used here may require root access (for example, to write to the/var/log directory). The examples provided use are run using sudo to accommodate this.    $ sudo ./ShotGridEventDaemon.py foregroundINFO:engine:Using ShotGrid version 3.0.8INFO:engine:Loading plugin at /usr/local/shotgun/ShotGridEvents/src/examplePlugins/logArgs.pyINFO:engine:Last event id (248429) from the ShotGrid database.You should see the lines above when you start the script (some of the details may differ obviously). If you get any errors, the script will terminate since we opted to run it in the foreground we’ll see that happen. Some common errors are displayed below if you get stuck.The logArgs.py plugin simply takes the event that occurred in ShotGrid and passes it to the logger. Not very exciting but it’s a simple way to ensure that the script is running and the plugin is working. If you’re at a busy studio, you may have already noticed a rapid stream of messages flowing by. If not, login to your ShotGrid server in your web browser and change some values or create something. You should see log statements printed out to your terminal window corresponding to the type of event you generated with your changes.                    Note: There are variables in the logArgs.py file that need to be filled in with appropriate values. ‘$DEMO_SCRIPT_NAMES$’ and ‘$DEMO_API_KEY$’ must be edited to contain the same values that were used in the shotgunEventDaemon.conf file in order for the logging to function correctly.    If you don’t see anything logged to the log file, check your log-related settings in ShotGridEventDaemon.conf to ensure that the logging value is set to log INFO level messageslogging: 20and the logArgs plugin is also configured to show INFO level messages. There is a line at the end of the registerCallbacks() method that should readreg.logger.setLevel(logging.INFO)Assuming all looks good, to stop the ShotGridEventDaemon process, simply type &amp;lt;ctrl&amp;gt;-c in the terminal and you should see the script terminate.Running the daemonAssuming all went well with your testing, we can now run the daemon as intended, in the background.$ sudo ./ShotGridEventDaemon.py startYou should see no output and control should have been returned to you in the terminal. We can make sure that things are running well in two ways. The first would be to check the running processes and see if this is one of them.$ ps -aux | grep shotgunEventDaemonkp              4029   0.0  0.0  2435492    192 s001  R+    9:37AM   0:00.00 grep shotgunEventDaemonroot            4020   0.0  0.1  2443824   4876   ??  S     9:36AM   0:00.02 /usr/bin/python ./ShotGridEventDaemon.py startWe can see by the second line returned that the daemon is running. The first line is matching the command we just ran. So we know it’s running, but to ensure that it’s working and the plugins are doing what they’re supposed to, we can look at the log files and see if there’s any output there.$ sudo tail -f /var/log/shotgunEventDaemon/shotgunEventDaemon2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.Go back to your web browser and make some changes to an entity. Then head back to the terminal and look for output. You should see something like the following2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.2011-09-09 09:45:31,228 - plugin.logArgs.logArgs - INFO - {'attribute_name': 'sg_status_list', 'event_type': 'Shotgun_Shot_Change', 'entity': {'type': 'Shot', 'name': 'bunny_010_0010', 'id': 860}, 'project': {'type': 'Project', 'name': 'Big Buck Bunny', 'id': 65}, 'meta': {'entity_id': 860, 'attribute_name': 'sg_status_list', 'entity_type': 'Shot', 'old_value': 'omt', 'new_value': 'ip', 'type': 'attribute_change'}, 'user': {'type': 'HumanUser', 'name': 'Kevin Porterfield', 'id': 35}, 'session_uuid': '450e4da2-dafa-11e0-9ba7-0023dffffeab', 'type': 'EventLogEntry', 'id': 276560}The exact details of your output will differ, but what you should see is that the plugin has done what it is supposed to do, that is, log the event to the logfile. Again, if you don’t see anything logged to the log file, check your log-related settings in ShotGridEventDaemon.conf to ensure that the loggingvalue is set to log INFO level messages and your logArgs plugin is also configured to show INFO level messages.A Note About LoggingIt should be noted that log rotation is a feature of the ShotGrid daemon. Logs are rotated at midnight every night and ten daily files are kept per plugin.Common ErrorsThe following are a few of the common errors that you can run into and how to resolve them. If you get really stuck, please visit our support site for help.Invalid path: $PLUGIN_PATHS$You need to specify the path to your plugins in the shotgunEventDaemon.conf file.Permission denied: ‘/var/log/shotgunEventDaemon’The daemon couldn’t open the log file for writing.You may need to run the daemon with sudo or as a user that has permissions to write to the log file specified by the logPath and logFile settings in shotgunEventDaemon.conf. (the default location is /var/log/shotgunEventDaemon which is usually owned by root.ImportError: No module named shotgun_api3The ShotGrid API is not installed. Make sure it is either located in the current directory or it is in a directory in your PYTHONPATH.If you have to run as sudo and you think you have the PYTHONPATH setup correctly, remember that sudo resets the environment variables. You can edit the sudoers  file to preserve the PYTHONPATH or run sudo -e(?)List of Configuration File SettingsDaemon SettingsThe following are general daemon operational settings.pidFileThe pidFile is the location where the daemon will store its process id while it is running. If this file is removed while the daemon is running, it will shut down cleanly after the next pass through the event processing loop.The directory must already exist and be writable. You can name the file whatever you like but we strongly recommend you use the default name as it matches with the process that is runningpidFile: /var/log/shotgunEventDaemon.pideventIdFileThe eventIdFile points to the location where the daemon will store the id of the last processed ShotGrid event. This will allow the daemon to pick up where it left off when it was last shutdown, thus it won’t miss any events. If you want to ignore any events since the last daemon shutdown, remove this file before starting up the daemon and the daemon will process only new events created after startup.This file keeps track of the last event id for each plugin and stores this information in pickle format.eventIdFile: /var/log/shotgunEventDaemon.idlogModeThe logging mode can be set to one of two values:  0 = all log messages in the main log file  1 = one main file for the engine, one file per pluginWhen using a value of 1, the log messages generated by the engine itself will be logged to the main log file specified by the logFile config setting. Any messages logged by a plugin will be placed in a file named plugin.&amp;lt;plugin_name&amp;gt;.logMode: 1logPathThe path where to put log files (both for the main engine and plugin log files). The name of the main log file is controlled by the logFilesetting below.logPath: /var/log/shotgunEventDaemon                    Note: The shotgunEventDaemon will have to have write permissions for this directory. In a typical setup, the daemon is set to run automatically when the machine starts up and is given root privileges at that point.    logFileThe name of the main daemon log file. Logging is configured to store up to  10 log files that rotate every night at midnight.logFile: shotgunEventDaemonloggingThe threshold level for log messages sent to the log files. This value is the default for the main dispatching engine and can be overridden on a per plugin basis. This value is simply passed to the Python logging module. The most common values are:  10: Debug  20: Info  30: Warnings  40: Error  50: Criticallogging: 20timing_logEnabling timing logging by setting this value to on will generate a separate log file with timing information which should make troubleshooting performance issues with your daemon simpler.The timing information provided for each callback invocation is as follows:  event_id The id of the event that triggered the callback  created_at The timestamp in ISO format when the event was created in ShotGrid  callback The name of the invoked callback in plugin.callback format  start The timestamp in ISO format of the start of callback processing  end The timestamp in ISO format of the end of callback processing  duration The duration in DD:HH:MM:SS.micro_second format of the callback processing time  error If the callback failed or not. The value can be False or True.  delay The duration in DD:HH:MM:SS.micro_second format of the delay between the event creation and the start of processing by the callback.conn_retry_sleepIf the connection to ShotGrid fails, this is the number of seconds to wait until the connection is re-attempted. This allows for occasional network hiccups, server restarts, application maintenance, etc.conn_retry_sleep = 60max_conn_retriesNumber of times to retry the connection before logging an error level message(which potentially sends an email if email notification is configured below).max_conn_retries = 5fetch_intervalThe number of seconds to wait before requesting new events after each batch of events is done being processed. This setting generally doesn’t need to be adjusted.fetch_interval = 5ShotGrid SettingsThe following are settings related to your ShotGrid instance.serverThe URL for the ShotGrid server to connect to.server: %(SG_ED_SITE_URL)s                    Note: There is no default value here. Set the SG_ED_SITE_URL environment variable to the URL for your ShotGrid server (ie. https://awesome.shotgunstudio.com)    nameThe ShotGrid Script name the ShotGridEventDaemon should connect with.name: %(SG_ED_SCRIPT_NAME)s                    Note: There is no default value here. Set the SG_ED_SCRIPT_NAME environment variable to the Script name for your ShotGrid server (ie. shotgunEventDaemon)    keyThe ShotGrid Application Key for the Script name specified above.key: %(SG_ED_API_KEY)s                    Note: There is no default value here. Set the SG_ED_API_KEY environment variable to the Application Key for your Script name above (ie:0123456789abcdef0123456789abcdef01234567)    use_session_uuidSets the session_uuid from every event in the ShotGrid instance to propagate in any events generated by plugins. This will allow the ShotGrid UI to display updates that occur as a result of a plugin.use_session_uuid: True  ShotGrid server v2.3+ is required for this feature.  ShotGrid API v3.0.5+ is required for this feature.                    Note: The ShotGrid UI will only show updates live for the browser session that spawned the original event. Other browser windows with the same page open will not see updates live.    Plugin SettingspathsA comma-delimited list of complete paths where the framework should look for plugins to load. Do not use relative paths.paths: /usr/local/shotgun/plugins                    Note: There is no default value here. You must set the value to the location(s) of your plugin files (ie:/usr/local/shotgun/shotgunEvents/plugins or C: shotgun shotgunEvents plugins on Windows)    Email SettingsThese are used for error reporting because we figured you wouldn’t constantly be tailing the log and would rather have an active notification system.Any error above level 40 (ERROR) will be reported via email if all of the settings are provided below.All of these values must be provided for there to be email alerts sent out.serverThe server that should be used for SMTP connections. The username and password values can be uncommented to supply credentials for the SMTP connection. If your server does not use authentication, you should comment out the settings for username and passwordserver: smtp.yourdomain.com                    Note: There is no default value here. You must replace the smtp.yourdomain.com token with the address of your SMTP server (ie. smtp.mystudio.com).    usernameIf your SMTP server requires authentication, uncomment this line and make sure you have configured the SG_ED_EMAIL_USERNAME environment variable with the username required to connect to your SMTP server.username: %(SG_ED_EMAIL_USERNAME)spasswordIf your SMTP server requires authentication, uncomment this line and make sure you have configured the SG_ED_EMAIL_PASSWORD environment variable with the password required to connect to your SMTP server.password: %(SG_ED_EMAIL_PASSWORD)sfromThe from address that should be used in emails.from: support@yourdomain.com                    Note: There is no default value here. You must replacesupport@yourdomain.com with a valid value (ie. noreply@mystudio.com).    toA comma-delimited list of email addresses to whom these alerts should be sent.to: you@yourdomain.com                    Note: There is no default value here. You must replace you@yourdomain.com with a valid value (ie. shotgun_admin@mystudio.com).    subjectAn email subject prefix that can be used by mail clients to help sort out alerts sent by the ShotGrid event framework.subject: [SG]",
    "url": "/ed5161c4/",
    "relUrl": "/ed5161c4/"
  },
  "33": {
    "id": "33",
    "title": "Example Plugins",
    "content": "Example PluginsThere is a folder of example plugins in the source code.This page includes a few more simple examples, for anyone looking to get started. You can copy/paste this code and it should run(Note: you’ll have to update the script_name, and script_key values to something specific for your installation)First, here’s a template upon which all SG event code should be written1. Code TemplateCopy / Paste this to get started on new plugins&quot;&quot;&quot;Necessary Documentation of the codeAuthor: YouTemplate Author: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    # This takes the form of:    #    matchEvents = {'Shotgun_Entity_EventType': ['list', 'of', 'field', 'names', 'you', 'need', 'sg_custom_field']}    # the 'id' is always returned, in addition to any fields specifically requested by your callback    matchEvents = {        'Shotgun_Task_Change': ['content']    }    # script_name and script_key are defined by you whenever you create a SG script    # the entry_function_call refers to the function that performs the work of the event plugin    reg.registerCallback('script_name', 'script_key', entry_function_call, matchEvents, None)# This gives you#    shotgun handle = sg#    a logger object... please use this instead of python print, especially if you respect your time and your fellow developers#    an event object... this is the metadata that describes what's happening with the particular event.#        some very good information comes from the event['meta'] object, below is the example event['meta'] data from the subject renamer plugin#              {#                &quot;type&quot;: &quot;attribute_change&quot;,#                &quot;attribute_name&quot;: &quot;subject&quot;,#                &quot;entity_type&quot;: &quot;Note&quot;,#                &quot;entity_id&quot;: 2,#                &quot;field_data_type&quot;: &quot;text&quot;,#                &quot;old_value&quot;: &quot;My Note Subject&quot;,#                &quot;new_value&quot;: &quot;2017-05 May-09 - My Note Subject&quot;#              }def entry_function_call(sg, logger, event, args):    # Now do stuff    pass   2. Note Subject RenamingWorking with New Entity EventsThis is a great one to start with  because it’s simple, but it also deals with a rather tricky aspect of catching Shotgun_Entity_New events…import timefrom pprint import pprintdef registerCallbacks(reg):    matchEvents = {        'Shotgun_Note_New': ['*'],    }    reg.registerCallback('script_name', 'script_key', Function_Name, matchEvents, None)def Function_Name(sg, logger, event, args):    # Waiting here should allow the entity to be fully created             #     and all the necessary attributes to be added to the NOTE entity    time.sleep(1)    current_date = time.strftime(&quot;%Y-%m %b-%d&quot;)    asset_id = event['meta']['entity_id']    asset_type = event['meta']['entity_type']    asset = sg.find_one(asset_type, [['id', 'is', asset_id]], ['subject'])    if asset['subject'] is None:        current_name = current_date + ' - ' + event['project']['name'] + ' - ' + event['user']['name']    else:        current_name = current_date + ' - ' + asset['subject']    # Modify ALL notes except those in 'Software Development'    if event['project'] == None:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})        return    if event['project']['id'] != 116:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})    else:        logger.info('Dates are not prepended for notes in project id 116 - Software Development')        returnNote the sleep call as the very first line of the function body. The reason for this deals with the way that new events are handled.  When a NEW entity is created in SG, it is still rather unformed - meaning that it doesn’t possess all the attributes needed to fully define that entity as you’re used to it. In fact, in this example, I can’t even guarantee that the subject attribute will be on the Note entity when SG emits the Shotgun_Note_New event.  In order to add all of the necessary attributes, SG then publishes a series of Shotgun_Note_Change events wherein SG will add every single attribute to the entity and update the values of those attributes - if required.  This means that a multiplicity of events are created, which means that if you need two different attributes to be present and you didn’t write a sleep aspect to your code, then you’d have to sift through ALL of the Shotgun_Note_Change events and the internal metadata looking for only those that have new attributes added and values set… This is a cumbersome process and will process many Shotgun_Note_Change events looking for - effectively - just one per note at time of creation.  The solution as I’ve found it is to rely on Shotgun_Entity_New and let the script sleep for a short period. At the end of the sleep, SG will have updated all the attributes required for the entity and then you can re-query that same entity for any of the fields you need2. Field Deletion WarningGenerating Notes, Working with Fields as Entities, and Entity Retirement Events&quot;&quot;&quot;Create a Note when a field is deletedAuthor: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    &quot;&quot;&quot;    fn: registerCallbacks    @brief required function. It connects to the event daemon and calls the trashedFieldWarning Function.    It runs every time a field is deleted (retired)    @param[in] reg variable that is required by shotgun event daemon plugins    @return none    &quot;&quot;&quot;    matchEvents = {        'Shotgun_DisplayColumn_Retirement': ['*']    }    reg.registerCallback('script_name', 'script_key',                         trashedFieldWarning, matchEvents, None)def CreateNote(sg, logger, event):    constants = {'note header': ':: FIELD DELETION :: '}    def GetListOfPipelineUsers():        pipeline_users = sg.find('Group', [['code', 'is', 'People_Who_Need_to_Know']], ['code', 'users', 'addressings_to',                                                                         'sg_ticket_type', 'sg_priority'])        return pipeline_users[0]['users']    def CreateToolsNote():        # Note to members of the pipeline group        # Body text = CreateNoteRequestText()        # Date Created = event['event']['created_at']        # Created By = event['user']['id']        # Project = Software Development['id']        # Subject = ':: Field Delete Warning :: ' + event['entity']['name']        note_data = {            'project': {'type': 'Project', 'id': 'ID OF PROJECT WHERE YOU WANT THE NOTE REPORTED TO'},            # ex: 'project': {'type': 'Project', 'id': 2},            'content': CreateNoteRequestText(),            'created_at': event['created_at'],            'created_by': event['user'],            'addressings_to': GetListOfPipelineUsers(),            'subject': constants['note header'] + event['meta']['display_name']        }        sg.create('Note', note_data)    def CreateNoteRequestText():        OUT = ''        # Tool Name = event['entity']['name']        # sg_assigned_to = members of the pipeline group        # Description = linked Ticket decription        # Project = decided in GUI        # sg_sg_request_ticket = event['entity']['id']        # task_template = Software task template        # Software Projects = defined in GUI        OUT = '::FIELD DELETION WARNING:: n'        OUT += ':: A Field was deleted :: n'        OUT += ':: It was called %s :: n'%event['meta']['display_name']        return OUT    logger.info('::WARNING:: A FIELD has been deleted')    CreateToolsNote()def trashedFieldWarning(sg, logger, event, args):    &quot;&quot;&quot;    fn: finalizeTasksFromShot    @brief Function to create and send a warning note, via SG, whenever a field is deleted    event['entity']['id'] yields the id of the current entity that was caught by the plugin as having been changed.    ie. this is the id of the field that was just deleted    @param[in] sg defines the Shotgun handle to access the database    @param[in] logger sets logging messages to the shotgun event daemon    @param[in] event the collection of shots that have changed    @param[in] args useless variable for this particular function    @return none    &quot;&quot;&quot;    if event['meta']['entity_type'] == 'DisplayColumn':        logger.info('This DisplayColumn was deleted %s', event['meta']['display_name'])    if event['event_type'] == 'Shotgun_DisplayColumn_Retirement':        logger.info('The incoming event call is for deleting a field from an entity. Field name: %s', event['meta']['display_name'])    # logger.info(' TEST ')    # logger.info('Deleted Field ID is #%d, and is called: %s', event['entity']['id'], event['entity']['name'])    CreateNote(sg, logger, event)This is a very simple script. There is no special logic in checking for deleted fields. If a field is deleted, then a note is created and sent to a group of people that need to know. In my department, we have the group id set to the ‘programmers’ group, and the project id of the note set to the ‘development’ project.",
    "url": "/34048d1e/",
    "relUrl": "/34048d1e/"
  },
  "34": {
    "id": "34",
    "title": "Installation",
    "content": "InstallationThe following guide will help you setup ShotGridEvents for your studio.System RequirementsThe daemon can run on any machine that has Python installed and has network access to your ShotGrid server. It does not need to run on the ShotGrid server itself. In fact, if you are using the hosted version of ShotGrid, this isn’t an option. However, you may run it on your ShotGrid server if you like. Otherwise, any server will do.  Python v2.6, v2.7 or 3.7  ShotGrid Python API          Use v3.0.37 or higher for Python v2.6 or v2.7 and use v3.1.0 or more for Python 3.7.      In either case, we strongly suggest using the most up to date Python API version and keeping this dependency updated over time.        Network access to your ShotGrid serverInstalling the ShotGrid APIAssuming Python is already installed on your machine, you now need to install the ShotGrid Python API so that the ShotGrid Event Daemon can use it to connect to your ShotGrid server. You can do this in a couple of ways:  place it in the same directory as the ShotGrid Event Daemon  place it in one of the directories specified by the PYTHONPATH environment variable.To test that the ShotGrid API is installed correctly, from your terminal window:$ python -c &quot;import shotgun_api3&quot;You should see no output. If you see something like the output below then you need to make sure your PYTHONPATH is setup correctly or that the ShotGrid API is located in the current directory.$ python -c &quot;import shotgun_api3&quot;Traceback (most recent call last):File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;ImportError: No module named shotgun_api3Installing ShotGridEventsThe location you choose to install ShotGridEvents is really up to you. Again, as long as Python and the ShotGrid API are installed on the machine, and it has network access to your ShotGrid server, it can run from anywhere. However, it makes sense to install it somehwere that is logical to your studio, something like /usr/local/shotgun/shotgunEvents seems logical so we’ll use that as the example from here on out.The source and archives are available on GitHub at https://github.com/shotgunsoftware/shotgunEvents                    Note: For Windows: You could use C: shotgun shotgunEvents if you have a Windows server but for this documentation we will be using the Linux path.    Cloning the sourceThe easiest way to grab the source if you have git installed on the machine is to simply clone the project. This way you can also easily pull in any updates that are committed to ensure you stay up to date with bug fixes and new features.$ cd /usr/local/shotgun$ git clone git://github.com/shotgunsoftware/shotgunEvents.git                    Warning: Always make sure you backup your configuration, plugins, and any modifications you make to shotgunEvents before pulling in updates from GitHub so you don’t lose anything. Or, fork the project yourself so you can maintain your own repository of changes :)    Downloading the archiveIf you don’t have git on your machine or you simply would rather download an archive of the source, you can get things rolling following these steps.  head over to https://github.com/shotgunsoftware/shotgunEvents/archives/master  download the source in the format you want  save it to your machine  extract the files to the /usr/local/shotgun directory  rename the /usr/local/shotgun/shotgunsoftware-shotgunEvents-xxxxxxx directory to /usr/local/shotgun/shotgunEventsExtracting the archive into /usr/local/shotgun.For .tar.gz archives:$ tar -zxvf shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.tar.gz -C /usr/local/shotgunFor .zip archives:$ unzip shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.zip -d /usr/local/shotgunThen you can rename the GitHub-assigned directory name to shotgunEvents:$ mv shotgunsoftware-shotgunEvents-1c0c3eb shotgunEventsNow you should now have something like this:$ ls -l /usr/local/shotgun/shotgunEventstotal 16-rw-r--r--  1 kp  wheel  1127 Sep  1 17:46 LICENSE-rw-r--r--  1 kp  wheel   268 Sep  1 17:46 README.mkddrwxr-xr-x  9 kp  wheel   306 Sep  1 17:46 docsdrwxr-xr-x  6 kp  wheel   204 Sep  1 17:46 srcInstalling RequirementsA requirements.txt file is provided at the root of the repository. You should use this to install the required packages$ pip install -r /path/to/requirements.txtWindows specificsYou will need one of the following on your Windows system:  Python with PyWin32 installed  Active PythonActive Python ships with the PyWin32 module which is required for integrating the ShotGrid Event Daemon with Windows’ Service architecture.You can then install the deamon as a service by running the following command (we are assuming that C: Python27_32 python.exe is the path to your Python executable, adjust accrodingly):&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py installOr remove it with:&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py removeStarting and stopping the service can be achieved through the normal service management tools or via the command line with:&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py start&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py stopIn most cases you will need to be sure you are running each of the commands listed as your system’s administrative user. You can do so by right clicking the cmd application and choosing “Run as Administrator”.                    Note: If you have installed the daemon on Windows in a network location or if you have configured it to read and write logs and other resources from a network location you will need to edit the service’s properties to change the user running the service from the local machine account to a domain account that has access to the network resources.    ",
    "url": "/7c203655/",
    "relUrl": "/7c203655/"
  },
  "35": {
    "id": "35",
    "title": "Plugins",
    "content": "Plugins OverviewA plugin file is any .py file in a plugin path as specified in the config file.There are some example plugins provided in the src/examplePlugins folder in your download of the code. These provide simple examples of how to build your own plugins to look for specific events generated, and act on them, changing other values on your ShotGrid instance.You do not need to restart the daemon each time you make updates to a plugin, the daemon will detect that the plugin has been updated and reload it automatically.If a plugin generates an error, it will not cause the daemon to crash. The plugin will be disabled until it is updated again (hopefully fixed). Any other plugins will continue to run and events will continue to be processed. The daemon will keep track of the last event id that the broken plugin processed successfully. When it is updated (and fixed, hopefully), the daemon will reload it and attempt to process events starting from where that plugin left off. Assuming all is well again, the daemon will catch the plugin up to the current event and then continue to process events with all plugins as normal.A ShotGrid event processing plugin has two main parts: a callback registration function and any number of callbacks.registerCallbacks functionTo be loaded by the framework, your plugin should at least implement the following function:def registerCallbacks(reg):    passThis function will be used to tell the event processing system which functions to call to process events.This function should take one argument which is a Registrar object.The Registrar has one critically important method:Registrar.registerCallback.For each of your functions that should process ShotGrid events, call Registrar.registerCallback once with the appropriate arguments.You can register as many functions as you wish and not all functions in the file need to be registered as event processing callbacks.CallbacksA callback that will be registered with the system must take four arguments:  A ShotGrid connection instance if you need to query ShotGrid for additional information.  A Python Logger object that should be used for reporting. Error and Critical messages will be sent via email to any configured user.  The ShotGrid event to be processed.  The args value passed in at callback registration time. (See Registrar.registerCallback)                    Warning: You can do whatever you want in a plugin but if any exception raises back to the framework, the plugin within which the offending callback lives (and all contained callbacks) will be deactivated until the file on disk is changed (read: fixed).    LoggingUsing the print statement in an event plugin is not recommended. It is prefered you use the standard logging module from the Python standard library. A logger object will be provided to your various functionsdef registerCallbacks(reg):    reg.setEmails('root@domain.com', 'tech@domain.com') # Optional    reg.logger.info('Info')    reg.logger.error('Error') # ERROR and above will be sent via email in default configanddef exampleCallback(sg, logger, event, args):    logger.info('Info message')If the event framework is running as a daemon this will be logged to a file otherwise it will be logged to stdout.Building Robust pluginsThe daemon runs queries against ShotGrid but has built in functionality to retry find() commands should they fail, giving the daemon itself a certain degree of robustness.https://github.com/shotgunsoftware/shotgunEvents/blob/master/src/shotgunEventDaemon.py#L456If a plugin needs network resources (be that ShotGrid or some other resource), it needs to provide its own retry mechanisms / robustness. In the case of ShotGrid access you could riff off what’s in the daemon and make a helper function or class that could provide that functionality to your plugins.The ShotGrid Python API does already do some level of retrying on network issues but should you hit a ShotGrid maintenance window that can run a few minutes, or be unlucky enough to hit a network blip, that might not be enough.https://github.com/shotgunsoftware/python-api/blob/master/shotgun_api3/shotgun.py#L1554Depending on what your plugin does, you can also register it to just keep trucking should it encounter issues while processing events. Look at the stopOnError argument of the registerCallback function:https://github.com/shotgunsoftware/shotgunEvents/wiki/API#wiki-registerCallback                    Note: The plugin won’t stop but any failed attempts won’t be retried.    ",
    "url": "/3d05c112/",
    "relUrl": "/3d05c112/"
  },
  "36": {
    "id": "36",
    "title": "Technical Details",
    "content": "Technical OverviewEvent TypesThe event types your triggers can register to be notified of are generally respect the following form Shotgun_[entity_type]_[New|Change|Retirement|Revival]. Here are a few examples of this pattern:Shotgun_Note_NewShotgun_Shot_NewShotgun_Task_ChangeShotgun_CustomEntity06_ChangeShotgun_Playlist_RetirementShotgun_Playlist_RevivalSome notable departures from this pattern are used for events that aren’t related to entity record activity but rather key points in application behavior.CRS_PlaylistShare_CreateCRS_PlaylistShare_Revoke SG_RV_Session_Validate_SuccessShotgun_Attachment_ViewShotgun_Big_QueryShotgun_NotesApp_Summary_EmailShotgun_User_FailedLoginShotgun_User_LoginShotgun_User_LogoutToolkit_App_StartupToolkit_Desktop_ProjectLaunchToolkit_Desktop_AppLaunchToolkit_Folders_CreateToolkit_Folders_Delete    This list is not exhaustive but is a good place to start. If you wish to know more about the activity and event types on your ShotGrid site, please consult a page of EventLogEntries where you can filter and search through like any other grid page of any other entity type.Event Log Entries for ThumbnailsWhen a new thumbnail is uploaded for an entity, an Event Log entry is created with `Type` == `Shotgun_&amp;lt;Entity_Type&amp;gt;_Change` (e.g. Shotgun_Shot_Change).  The ‘is_transient’ field value is set to true:    { &quot;type&quot;: &quot;attribute_change&quot;,&quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656,  &quot;is_transient&quot;: true }        When the thumbnail becomes available, a new Event Log entry is created with the ‘is_transient’ field value now set to false:    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: false }        If we update the thumbnail again, we get these new Event Log entries:    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;,  &quot;old_value&quot;: 11656, &quot;new_value&quot;: 11657,  &quot;is_transient&quot;: true }{ &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;,  &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;,  &quot;old_value&quot;: null, &quot;new_value&quot;: 11657,  &quot;is_transient&quot;: false }        Notice the ‘old_value’ field is set to null when the attachment’s thumbnail is the placeholder thumbnail.Plugin Processing OrderEach event is always processed in the same predictable order so that if any plugins or callbacks are co-dependant, you can safely organize their processing.The configuration file specifies a paths config that contains one or multiple plugin locations. The earlier the location in the list the sooner the contained plugins will be processed.Each plugin within a plugin path is then processed in ascending alphabetical order.                    Note: Internally the filenames are put in a list and sorted.    Finally, each callback registered by a plugin is called in registration order. First registered, first run.We suggested keeping any functionality that needs to share state somehow in the same plugin as one or multiple callbacks.Sharing stateMany options exist for multiple callbacks that need to share state.  Global variables. Ick. Please don’t do this.  An imported module that holds the state information. Ick, but a bit better than simple globals.  A mutable passed in the args argument when calling Registrar.registerCallback. A state object of your design or something as simple as a dict. Preferred.  Implement callbacks such as __call__ on object instances and provide some shared state object at callback object initialization. Most powerful yet most convoluted method. May be redundant compared to the args argument method above.Event BacklogsThe framework is designed to have every plugin process every single event they are interested in exactly once, without exception. To make sure this happens, the framework stores a backlog of unprocessed events for each plugin and remembers the last event each plugin was provided. Here is a description of situations in which a backlog may occur.Backlogs due to gaps in the event log entry sequenceEach event that occurs in ShotGrid (field update, entity creation, entity retirement, etc.) has a unique ID number for its event log entry. Sometimes there are gaps in the ID number sequence. These gaps can occur for many reasons, one of them being a large database transaction that has not yet been completed.Every time there is a gap in the event log sequence the “missing” event IDs are put into a backlog for later processing. This allows for the event daemon to process the events from a long database transaction once it has finished.Sometimes the gap in the event log sequence will never be filled in, such as with a failed transaction or reverted page setting modifications. In this case, after a 5 minute timeout, the system will stop waiting for the event log entry ID number and will remove it from the backlog. When this happens you will see a “Timeout elapsed on backlog event id #” message. If the first time a gap in the event sequence is seen and it is already deemed to have exceeded the timeout, the message will appear as “Event # never happened - ignoring” and it won’t be put in the backlog in the first place.Backlogs due to plugin errorsDuring normal operation, the framework is always tracking the last event that was processed by each plugin. If you have a plugin that fails for any reason it will stop processing further events. When you fix the plugin, by fixing a bug for example, the framework will start processing events at the last event stored for the fixed plugin. This is done in order to make sure the newly fixed plugin gets to process all events, including those that have occurred in the past between the failure and the fix. If the failure occurred long ago, this may mean a lot of events need to be revisited and it may take a while for the fixed plugin to catch up with the other plugins that were functioning normally.While your fixed plugin plays catch-up, the other plugins will be ignoring these events in order to make sure no single event is processed twice by the same plugins. This leads to the “Event X is too old. Last event processed is (Y)” message. This is a debug message and can be safely ignored.There is no formal way to sidestep this. The framework is designed to make sure every single plugin processes every event once and only once. However, If you are familiar with Python and its pickle data format, you can stop the daemon, open the .id file with a Python interpreter/interactive shell, decode its contents with the pickle modules and edit its contents to remove the stored id thus skipping the accrued backlog. This is unsupported and at your own risk. Please backup the .id file appropriately before you do this.",
    "url": "/af5c969c/",
    "relUrl": "/af5c969c/"
  },
  "37": {
    "id": "37",
    "title": "Writing Event-Driven Triggers",
    "content": "ShotGrid  Event FrameworkThis software was originaly developed by Patrick Boucher with support from Rodeo Fx and Oblique. It is now part of ShotGrid  Software’s open source initiative.This software is provided under the MIT License that can be found in the LICENSE file or at the Open Source Initiative website.OverviewWhen you want to access the ShotGrid  event stream, the preferred way to do so it to monitor the events table, get any new events, process them and repeat.A lot of stuff is required for this process to work successfully, stuff that may not have any direct bearing on the business rules that need to be applied.The role of the framework is to keep any tedious monitoring tasks out of the hands of the business logic implementor.The framework is a daemon process that runs on a server and monitors the ShotGrid event stream. When events are found, the daemon hands the events out to a series of registered plugins. Each plugin can process the event as it wishes.The daemon handles:  Registering plugins from one or more specified paths.  Deactivate any crashing plugins.  Reloading plugins when they change on disk.  Monitoring the ShotGrid  event stream.  Remembering the last processed event id and any backlog.  Starting from the last processed event id on daemon startup.  Catching any connection errors.  Logging information to stdout, file or email as required.  Creating a connection to ShotGrid  that will be used by the callback.  Handing off events to registered callbacks.A plugin handles:  Registering any number of callbacks into the framework.  Processing a single event when one is provided by the framework.Advantages of the framework  Only deal with a single monitoring mechanism for all scripts, not one perscript.  Minimize network and database load (only one monitor that supplies event tomany event processing plugins).",
    "url": "/0d8a11d9/",
    "relUrl": "/0d8a11d9/"
  },
  "38": {
    "id": "38",
    "title": "Features Description",
    "content": "Isolation Feature SetThis section describes in detail each of the Isolation Features.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup section.In This Section  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media Replication",
    "url": "/82f8da29/",
    "relUrl": "/82f8da29/"
  },
  "39": {
    "id": "39",
    "title": "Filesystem Configuration Reference",
    "content": "File System Configuration ReferenceThis document is a complete reference of the file system centric configurations in the ShotGrid Pipeline Toolkit. It outlines how the template system works and which options are available. It also shows all the different parameters you can include in the folder creation configuration.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For details, see  ShotGrid Integrations Admin Guide.IntroductionThis document explains how to configure the part of Toolkit’s configuration related to your file system, including examples. Toolkit handles a lot of files and directories, and you can leverage Toolkit’s configuration as a way of expressing how paths are put together and what they mean. The file system is typically accessed in two different and completely separate ways:      Folder Creation:  After an object has been created in ShotGrid, folders on disk need to be created before work can begin. This can be as simple as having a folder on disk representing the Shot, or can be more complex-for example setting up a user specific work sandbox so that each user that works on the shot will work in a separate area on disk.          Toolkit automates folder creation when you launch an application (for example you launch Maya for shot BECH_0010), Toolkit ensures that folders exist prior to launching Maya. If folders do not exist, they are created on the fly. Folders can also be created using API methods, using the  tank command in the shell  and via the  Create Folders menu in ShotGrid. A special set of configuration files drives this folder creation process and this is outlined in  Part 1  of the document below.            Opening and Saving Work:  While working, files need to be opened from and saved into standardized locations on disk. These file locations typically exist within the folder structure created prior to work beginning.          Once a folder structure has been established, we can use that structure to identify key locations on disk. These locations are called  Templates. For example, you can define a template called  maya_shot_publish  to refer to published Maya files for Shots.  Toolkit apps  will then use this template-a publish app may use it to control where it should be writing its files, while a  Workfiles App  may use the template to understand where to open files from. Inside Toolkit’s environment configuration, you can control which templates each app uses. All the key file locations used by Toolkit are therefore defined in a single template file and are easy to overview.      Part 1 - Folder Creation SyntaxThe folder configuration maps entities in ShotGrid to locations on disk. Rather than using a single configuration file, the configuration is in the form of a “mini file system” which acts as a template for each unit that is configured-this is called the  schema configuration. Folders and files will be copied across from this “mini file system” to their target location when Toolkit’s folder creation executes. It is possible to create dynamic behavior. For example, a folder can represent a Shot in ShotGrid, and you can control the naming of that folder. More specifically, you can pull the name of that folder from several ShotGrid fields and then perform character conversions before the folder is created.The above image shows a schema configuration. When you run the Toolkit folder creation, a connection is established between an entity in ShotGrid and a folder on disk. Toolkit uses this folder schema configuration to generate a series of folders on disk and each of these folders are registered as a  Filesystem Location  entity in ShotGrid. One way to think about this is that ShotGrid data (e.g., Shot and Asset names) and the configuration is “baked” out into actual folders on disk and in ShotGrid. Configurations always start with a folder named “project”. This will always represent the connected project in ShotGrid and will be replaced with the Toolkit name for the project. Below this level are static folders. The folder creator will automatically create the  sequencesfolder, for example.Digging further inside the sequences folder, there is a  sequence  folder and a  sequence.yml  file. Whenever Toolkit detects a YAML file with the same name as a folder, it will read the contents of the YAML file and add the desired dynamic behavior. In this case, the  sequence.yml  file contains the structure underneath the project folder, which consists of three types of items:  Normal folders and files:  these are simply copied across to the target location.  A folder with a YAML file  (having the same name as the folder): this represents dynamic content. For example, there may be a  shot  and  shot.yml  and when folders are created, this  shot  folder is the template used to generate a number of folders-one folder per shot.  A file named name.symlink.yml  which will generate a symbolic link as folders are being processed.  Symbolic links are covered later in this document.The dynamic configuration setup expressed in the YAML files currently supports the following modes:      ShotGrid Query folders:  Dynamic folder names based on a ShotGrid Database Query. For example, this mode can be used to create a folder for every Shot in a project.        ShotGrid List Field folders:  Dynamic folder names based on a ShotGrid List Field. For example, this mode can be used to create a folder for every value in the ShotGrid List field “Asset Type”, found on the Asset Entity in ShotGrid.        Deferred folders:  Only executed when a second folder creation pass is requested via the create folders method of the Toolkit API, usually when an application (such as Maya) is launched. Typically, this method is executed by Toolkit’s various application launchers just prior to starting up an application.        Current User Folders:  A special folder, which represents the current user.  Let’s dive deeper into these modes.ShotGrid Query FoldersFor a dynamic folder which corresponds to a ShotGrid query, use the following syntax in your YAML file:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: shotgun_entity&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: Asset&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: code&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]   Set the value of dynamic content  type  field to be  shotgun_entity.  The  entity_type  field should be set to the ShotGrid entity from which we want to pull data from (e.g., “Asset”, “Shot”, “Sequence”, “CustomEntity02”, etc).      The  name  field is the name that should be given to each folder based on the data in ShotGrid.          You can use a single field, like in the example above (e.g.,  name: code).      You can use multiple fields in brackets (e.g.,  name:  &quot;{asset_type}_{code}&quot;).      If you want to include fields from other linked entities, you can use the standard ShotGrid dot syntax (e.g.,  name: &quot;{sg_sequence.Sequence.code}_{code}&quot;).        The  filters  field is a ShotGrid Query. It follows the  ShotGrid API syntax  relatively closely. It is a list of dictionaries, and each dictionary needs to have the keys  path,  relation, and  values. Valid values for $syntax are any ancestor folder that has a corresponding ShotGrid entity (e.g.,  &quot;$project&quot;  for the Project and  &quot;$sequence&quot;  if you have a sequence.yml higher up the directory hierarchy). For ShotGrid entity links, you can use the $syntax (e.g.,  { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }) to refer to a parent folder in the configuration-this is explained more in depth in the  examples below.Multiple foldersInclude a slash in your name definition in order to create an expression which creates multiple folders at once:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: shotgun_entity&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: Asset&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;{sg_asset_type}/{code}&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] When creating a file system template (see for a Part 2 of this document for details) for this kind of path, the  _last_folder will represent the ShotGrid entity. The example above could for example be expressed with the following templateasset_step_folder: assets/{asset_type}/{Asset}/{Step}{asset_type}  and  {Asset}  are both defined as string template keys and the  {Asset}  token will be used in context calculations when determining the context for a given path.Create With Parent FolderIn ShotGrid, there is nesting within ShotGrid data structures. This nesting can be referred to as a Parent to Child relationship, and vice versa. For instance, Sequences are typically parents to Shots in the file system, and likewise, Shots are typically Children to Sequences.                    Note: This filesystem nesting relationship is independent from the  ShotGrid Hierarchy, and there is no connection between the two. They are configured completely independently.    A shotgun_entity type folder supports an optional flag to control whether the folder creation process tries to recurse down into it when a parent is created, so that the child will also be created. Flags are settings that can only have certain fixed values, in this case “true” or “false”. To add this flag, use this example:&amp;lt;a name=&quot;recurse down from parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# recurse down from parent foldercreate_with_parent: true As mentioned, this setting is optional and set to false by default. If you set it to true, Toolkit create folders for any child entity it finds. To continue with our example, if you want Shots to be created whenever their parent Sequence is created, set  create_with_parent  to  true  for the Shot.                    Note: the default setting is  false, meaning that if you create folders for a Sequence, shot folders will not be created automatically. Also, you will need to add this flag to make it true. There will not be a flag in the shotgun_entity folder specifying false since false is the default behavior.    Optional fieldsTypically, when you define the folder name (e.g.,  {code}_{sg_extra_field}), Toolkit requires all fields to have values in ShotGrid. For example, if the  sg_extra_field  is blank, an error message will be generated. If you have a field that is sometimes populated and sometimes not, you can mark it as optional. This means that Toolkit will include the field if it has a value, and exclude it if the value is blank-without error.You define optional fields using square brackets, like:  {code}[_{sg_extra_field}]. This will generate the following folder names:  If the  code  is BECH_0010 and the  sg_extra_field  is extra, the folder name will be  BECH_0010_extra.  If the  code  is BECH_0010 and the  sg_extra_field  is blank, the folder name will be  BECH_0010.                    Note: optional fields can only be used to define part of the name of a folder in your schema. An entire folder can not be optional.    Regular expression token matchingToolkit supports the extraction of parts of a ShotGrid field name using regular expressions. This makes it possible to create simple expressions where a value in ShotGrid can drive the folder creation. For example, if all assets in ShotGrid are named with a three letter prefix followed by an underscore (e.g  AAT_Boulder7), this can split into two filesystem folder levels, e.g.  AAT/Boulder7:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: shotgun_entity&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: Asset&amp;lt;a name=&quot;Extract parts of the name using regular expressions&quot;&amp;gt;&amp;lt;/a&amp;gt;# Extract parts of the name using regular expressionsname: &quot;{code:^([^_]+)}/{code^[^_]+_(.*)}&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]The syntax is similar to the  subset  tokens in the Template system; Simply add a colon after the ShotGrid field name, then followed by a regular expression. Any groups (e.g. sections surrounded by  ()s) defined in the regular expression will be used to extract values. If there are multiple groups in the regex, these will be concatenated together. For example, the following expression would extract the intials for the user who created an object:  {created_by.HumanUser.code:^([A-Z])[a-z]* ([A-Z])[a-z]*}ExamplesBelow are a collection of examples showing how to use the filters syntax.To  find all shots which belong to the current project and are in progress, use the syntax below. Note that the ShotGrid Shot entity has a link field called project which connects a shot to a project. We want to make sure that we only create folders for the shots that are associated with the current project. Since there is a project level higher up in the configuration file system, we can refer to this via the $syntax and Toolkit will automatically create to this ShotGrid entity link reference. Remember, valid values for $syntax are any ancestor folder that has a corresponding ShotGrid entity (e.g.,  &quot;$project&quot;  for the Project and  &quot;$sequence&quot;  if you have a sequence.yml higher up the directory hierarchy).entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;status&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;ip&quot; ] }If you have a Sequence folder higher up the tree and want to  create folders for all Shots which belong to that Sequence, you can create the following filters:entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] }To  find all assets  use this syntax:entity_type: Assetfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]ShotGrid List Field FoldersShotGrid list field  folders are useful if you want to create one folder for every asset type in ShotGrid, for instance. Asset types are list fields in ShotGrid, and this folder config type makes it possible to define a layer in the file system that reflects those asset type listings.                    Note: once folders have been created on disk, we strongly advise not to change the value (e.g., the asset type) on the associated data.    When you want a dynamic folder which corresponds to all the items in a ShotGrid list field, use the following syntax in your YAML file:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_list_field&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Asset&quot;&amp;lt;a name=&quot;only create for values which are used in this project.&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create for values which are used in this project.&amp;lt;a name=&quot;this is optional and will be set to false if not specified.&quot;&amp;gt;&amp;lt;/a&amp;gt;# this is optional and will be set to false if not specified.skip_unused: false&amp;lt;a name=&quot;by default, list fields are only created if they are needed by a child entity node&quot;&amp;gt;&amp;lt;/a&amp;gt;# by default, list fields are only created if they are needed by a child entity node&amp;lt;a name=&quot;by setting the create_with_parent parameter to true you ensure that list field&quot;&amp;gt;&amp;lt;/a&amp;gt;# by setting the create_with_parent parameter to true you ensure that list field&amp;lt;a name=&quot;nodes are always created&quot;&amp;gt;&amp;lt;/a&amp;gt;# nodes are always createdcreate_with_parent: false&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namefield_name: &quot;{sg_asset_type}_type&quot;  Set value of dynamic content  type  field to be  shotgun_list_field.  The  entity_type  field should be set to the ShotGrid entity from which we want to pull data (for instance, “Asset”, “Sequence”, “Shot”, etc.).      The  field_name  field should be set to the ShotGrid field from which the data is pulled from and must be a  list type field. You can use expressions if you want to add static text alongside the dynamic content.field_name: &quot;{sg_asset_type}_type&quot;  This example expression includes text as well as a template key.    The optional  skip_unused  parameter will prevent the creation of directories for list type field values which are not used (as covered under the  Optional Fields  section above).                    Note: setting this to True may negatively affect folder creation performance. Also, the culling algorithm is currently crude and does not work in scenarios where complex filters have been applied to the associated entity.      The optional  create_with_parent  parameter forces the creation of the list_field node, even if there isn’t a child entity level node that is currently being processed (see  Create With Parent Folder  section above).Pipeline Step FolderThe Pipeline Step folder represents a  Pipeline Step  in ShotGrid. Pipeline Steps are also referred to as Steps.&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_step&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name. This field needs to come from a step entity.&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder name. This field needs to come from a step entity.name: &quot;short_name&quot;You can use name expressions here, just like you can with the  ShotGrid entity described above. The node will look at its parent, grandparent, etc., until a ShotGrid entity folder configuration is found. This entity folder will be associated with the Step and the type of the entity will be used to determine which Steps to create.                    Note: If you want to create a top level folder with Pipeline Steps, just use the ShotGrid entity node and set the associated type to step.    By default, the Step folder will try to create all the relevant Steps for a particular entity automatically. For example, if the folder creation is triggered for a shot which has five Steps (Layout, Animation, FX, Lighting, Compositing), Step folders will automatically be created for those five Steps (Layout, Animation, FX, Lighting, Compositing).You can, however, turn this off by using the following syntax:&amp;lt;a name=&quot;recurse down from parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# recurse down from parent foldercreate_with_parent: falseAdding this setting to the configuration means that no Step folders will be created when a Shot folder is created. Instead, Step folders will be created only when you run the folder creation on a Task. This can be useful if you want to configure user sandboxes and other structures which are created just before work starts.Different file system layouts for different pipeline stepsImagine you want to have one folder structure for Lighting and Comp and one for everything else. If you want to have different file system layouts for different Pipeline Steps, you can achieve this by adding a  filter  clause to your config. This filter allows you to scope which Pipeline Steps will be covered by a particular Step’s configuration. In our example, you can create two configuration files:  step_lightcomp.yml  and  step.yml. In the first one, you would add the following filter:filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ] The above syntax will only be used when Step folders of the type  Light  or  Comp  are being created. For the other file, we want to create a rule for everything else:filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;not_in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ]Now you can define separate sub structures in each of these folders.Advanced: Specifying a parentAs part of the folder creation, Toolkit needs to associate a Pipeline Step with an entity (e.g., “Shot”, “Asset”, etc). Toolkit does this by default by looking up the folder tree and picking the first ShotGrid entity folder it finds. For example, if you have the hierarchy  Sequence &amp;gt; Shot &amp;gt; Step, the Step folder will automatically be associated with the Shot, which is typically what you want.However, if you have a hierarchy with entities below your primary entity, for example  Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Step, Toolkit will, by default, associate the Step with the Department level, which is not desired. In this case, we need to explicitly tell Toolkit where to look. We can do this by adding the following to the Step configuration:associated_entity_type: ShotShotGrid Task FolderThe Task folder represents a  Task  in ShotGrid. By default, the Task folder will not will not be created with its parent. For example, if the folder creation is triggered for a Shot which has a Task node associated, the Task folders will not be created automatically. Instead, Task folders will only be created when the folder creation is executed for the Task (e.g., launching a Task from ShotGrid).&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_task&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name. This field needs to come from a task entity.&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder name. This field needs to come from a task entity.name: &quot;content&quot; You can, however, turn on creation so that Tasks are created with their parent entity by using the following syntax:&amp;lt;a name=&quot;recurse down from parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# recurse down from parent foldercreate_with_parent: trueSimilar to a Step, you can also optionally supply a  filter  parameter if you want to filter which Tasks your folder configuration should operate on.Once again, you can use name expressions, just like you can with the  ShotGrid entity described above, where static text can be used alongside dynamic content so that you can create a name that has both dynamic and static context.name: &quot;task_{content}&quot;The node will look at its parent, grandparent etc., until a ShotGrid entity folder configuration is found. This entity folder will be associated with the task and will be used to determine which task folders to create.Advanced: Specifying a parentAs part of the folder creation, Toolkit needs to associate a Task with an entity (e.g., a Shot, an Asset, etc.). Toolkit does this by default by looking up the folder tree and picking the first ShotGrid entity folder it finds. For example, if you have the hierarchy  Sequence &amp;gt; Shot &amp;gt; Task, the Task folder will automatically be associated with the Shot, which is typically what you want.However, if you have a hierarchy with entities below your primary entity (e.g., below Shot), like  Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Task,  Toolkit would by default associate the Task with the department level, which is not desired. In this case, we need to explicitly tell Toolkit where to look, similarly to how we updated this with Steps in the  previous section. We can do this by adding the following to the Task configuration:associated_entity_type: ShotWorkspaces and Deferred Folder CreationDeferred folder creation means that creation will only be executed when a second folder creation pass is requested via the optional  engine  parameter in the create folders method of the Toolkit API. Typically, this method is executed by Toolkit’s various application launchers just prior to starting up an application. Most folder types support a deferred flag, which is  false  by default. To make deferred folder creation  true, you can add this flag:&amp;lt;a name=&quot;only create this folder when tk.create_filesystem_structure is&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create this folder when tk.create_filesystem_structure is&amp;lt;a name=&quot;called with tk-maya, tk-nuke or any-custom-string.&quot;&amp;gt;&amp;lt;/a&amp;gt;# called with tk-maya, tk-nuke or any-custom-string.defer_creation: [&quot;tk-maya&quot;, &quot;tk-nuke&quot;, &quot;any-custom-string]&amp;lt;a  name=&quot;create this folder when any application launches, but not when normal folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# create this folder when any application launches, but not when normal folder&amp;lt;a name=&quot;creation runs&quot;&amp;gt;&amp;lt;/a&amp;gt;# creation runsdefer_creation: trueThis flag makes it possible to split the folder creation in half-one part that runs in a first “global” pass and a second pass that runs at a later point. Typically, the second pass is associated with the engine launching (although it does not happen automatically since the default is  false) and allows for a user to create folders just before engine startup. This allows for two primary workflows:  Workspaces:  Application specific folder setups. Folders can be created just before an application launches.  A common workflow for this is to have a Pipeline Step that might require Houdini, Maya, and another Engine, depending on what the shot requires and how an Artist chooses to tackle it. The Artist can create maya/, houdini/, and other directories for that Pipeline Step initially, but if the Artist on a given shot only ever works in Maya, empty folders for Houdini and any other Engine are unnecessary. So, if you defer the folder creation to happen at the time of the launch of individual engines, then if an Artist never uses Houdini, the houdini/ folder will not be created for that shot.  User folders:  A user folder is created just before application launch. The user folder config construct (described above) is deferred by default.  This can happen so that instead of basing a user folder on the assigned user in ShotGrid, you can create a folder for the current user whenever they launch an Engine. For instance, if you start working on a shot, and you launch Maya, a username folder will be created for you (based on your username in ShotGrid), and you will not interfere with anyone else’s work.Tip: If you prefer a normal, static folder to be created when an application (like Maya) launches, just create a config YAML file named the same as the folder and add the following:&amp;lt;a name=&quot;type of content&quot;&amp;gt;&amp;lt;/a&amp;gt;# type of contenttype: &quot;static&quot;&amp;lt;a name=&quot;only create this folder for maya&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create this folder for mayadefer_creation: &quot;tk-maya&quot;:::yaml&amp;lt;a name=&quot;type of content&quot;&amp;gt;&amp;lt;/a&amp;gt;# type of contenttype: &quot;static&quot;&amp;lt;a name=&quot;only create this folder when tk.create_filesystem_structure is&quot;&amp;gt;&amp;lt;/a&amp;gt;# only create this folder when tk.create_filesystem_structure is&amp;lt;a name=&quot;called with any-custom-string.&quot;&amp;gt;&amp;lt;/a&amp;gt;# called with any-custom-string.defer_creation: &quot;any-custom-string&quot; Current User FolderThe current user folder is a special construct that lets you set up work areas for different users. A common scenario is if you have multiple artists from a department working on the same shot. User folders can be used so that artists can store their workfiles in their own directories and be able to filter just for their files in the  Workfiles App. In this case, the configuration file needs to include the following options:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;user_workspace&quot;name: &quot;login&quot;  Set value of  type  field to be  user_workspace.  The  name  field is the name that should be given to a user folder. It must consist of a combination of fields fetched from People in ShotGrid (HumanUser  in ShotGrid).  You can use a single field, like in the example above (e.g.,  name: login).  You can use multiple fields in brackets (e.g.,  name: &quot;{firstname}_{lastname}&quot;).  If you want to include fields from other linked entities, you can use the standard ShotGrid dot syntax (e.g.,  name: &quot;{sg_group.Group.code}_{login}&quot;).The current user folder is created as a deferred folder by default, meaning that it will only be executed when a second folder creation pass is requested via the optional  engine  parameter in the create folders method of the Toolkit API.Static foldersStatic folders (and files) are the most simple type. You can drop them into the configuration structure, and they will automatically get copied across when the folder creation process executes.  Here are some examples of static folders  (https://github.com/shotgunsoftware/tk-config-default/tree/master/core/schema/project) in the default configuration (note that static folders do not have a corresponding YAML file).Often, you will not need to go beyond this for static folders; however, Toolkit does support some more advanced functionality for static folders. It is possible to define dynamic conditions to determine if a static folder should get created. For example, you may want to have special static folders that only get created for Pipeline Steps of the Editorial type. In this case, you need to add a YAML configuration file next to the static folder and give it the same name, with the extension “yml”. Then, use the following syntax:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;static&quot;&amp;lt;a name=&quot;pick one of the ShotGrid folders that are above this folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# pick one of the ShotGrid folders that are above this folder&amp;lt;a name=&quot;in the folder hierarchy. In this case it is a parent folder&quot;&amp;gt;&amp;lt;/a&amp;gt;# in the folder hierarchy. In this case it is a parent folder&amp;lt;a name=&quot;named step that we want to look at when deciding if this&quot;&amp;gt;&amp;lt;/a&amp;gt;# named step that we want to look at when deciding if this&amp;lt;a name=&quot;static folder should be created or not.&quot;&amp;gt;&amp;lt;/a&amp;gt;# static folder should be created or not.constrain_by_entity: &quot;$step&quot;&amp;lt;a name=&quot;we can now define constraints for this step. Constraints are simple&quot;&amp;gt;&amp;lt;/a&amp;gt;# we can now define constraints for this step. Constraints are simple&amp;lt;a name=&quot;ShotGrid queries, following the same syntax as the other ShotGrid filters&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid queries, following the same syntax as the other ShotGrid filters&amp;lt;a name=&quot;shown in previous sections.&quot;&amp;gt;&amp;lt;/a&amp;gt;# shown in previous sections.#&amp;lt;a name=&quot;In our example, if the parent step matches the constraints given&quot;&amp;gt;&amp;lt;/a&amp;gt;# In our example, if the parent step matches the constraints given&amp;lt;a name=&quot;in the filter below, the static folder will be created. If not,&quot;&amp;gt;&amp;lt;/a&amp;gt;# in the filter below, the static folder will be created. If not,&amp;lt;a name=&quot;it (and its children) will be ignored by the folder creation process.&quot;&amp;gt;&amp;lt;/a&amp;gt;# it (and its children) will be ignored by the folder creation process.constraints:    - { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;edit&quot; ] } By default, static folders will automatically get created together with their parent folder. There may be cases where this is not desirable, and in those cases you can add a special flag to indicate that the static folder should not be created together with its parent:&amp;lt;a name=&quot;do not recurse down automatically&quot;&amp;gt;&amp;lt;/a&amp;gt;# do not recurse down automaticallycreate_with_parent: false Symbolic LinksYou can create symbolic links (symlink) as part of the dynamic folder creation. If you want to create a symbolic link with the name  artwork, create a file in your schema configuration named  artwork.symlink.yml. This will be identified by the system as a symbolic link request and will not be copied across, but will instead be processed.The  artwork.symlink.yml  file must, at the very least, contain a  target  key:&amp;lt;a name=&quot;Example of a .symlink.yml file&quot;&amp;gt;&amp;lt;/a&amp;gt;# Example of a .symlink.yml file&amp;lt;a name=&quot;A target parameter is required.&quot;&amp;gt;&amp;lt;/a&amp;gt;# A target parameter is required.target: &quot;../Stuff/$Project/$Shot&quot;&amp;lt;a name=&quot;Additional parameters will be passed to the hook as metadata&quot;&amp;gt;&amp;lt;/a&amp;gt;# Additional parameters will be passed to the hook as metadata&amp;lt;a name=&quot;so you can for example include permission hints or other stuff&quot;&amp;gt;&amp;lt;/a&amp;gt;# so you can for example include permission hints or other stuff&amp;lt;a name=&quot;that you may need for advanced customization&quot;&amp;gt;&amp;lt;/a&amp;gt;# that you may need for advanced customizationadditional_param1: abcadditional_param2: def If the target parameter contains  $EntityType  tokens such as  $Asset,  $Shot, or  $Project, these will attempt to be resolved with the name of the folder representing that entity (Asset, Shot, Project, etc.). Toolkit will look up the filesystem tree for these values and if they are not defined higher up in the tree, an error will be reported.List fields, such as asset type on assets, are expressed with a syntax that includes the entity type, e.g.  $Asset.sg_asset_type. For example:&amp;lt;a name=&quot;Example of a .symlink.yml file&quot;&amp;gt;&amp;lt;/a&amp;gt;# Example of a .symlink.yml file&amp;lt;a name=&quot;A target parameter is required.&quot;&amp;gt;&amp;lt;/a&amp;gt;# A target parameter is required.target: &quot;../renders/$Project/$Asset.sg_asset_type/$Asset&quot;Symlink creation happens (like all input/output, or I/O) inside the folder processing hook. A special  symlinkaction is passed from the system into the hook, and you will get the name of the symlink, the fully resolved target, and all the YAML metadata contained within the definition file along with this request. For our  artworkexample above, we create the folder under the Shot like this: {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  }Ignoring files and foldersFiles that are placed in the schema scaffold will be copied across into the target area as part of the folder creation. This copy process is handled by a core hook, so for example, permissions handling can be customized for a project or studio.                    Note: There are more details on this kind of handling in the  Customizing I/O and Permissions sectionCustomizing I/O and Permissions section under Simple Customization. We have a  process_folder_creation core hook  (https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71) that handles a lot of folder setup. You can add chmod calls into this hook (and/or set permissions as you mkdir), thereby setting permissions for the folders you are creating.    Sometimes it can be useful to exclude certain files and folders from being copied across as part of the folder creation. For example, if you store your folder creation configs in Git or SVN, you will have  .git  and  .svnfolders that you will not want to copy to each Shot or Asset folder. If there are files which you do not want to have copied, a file named  ignore_files  can be placed in the  config/core/schema  folder inside the project configuration. This file should contain glob-style patterns to define files not to copy. Each pattern should be on a separate line:&amp;lt;a name=&quot;This is a good example of a standard ignore_files file&quot;&amp;gt;&amp;lt;/a&amp;gt;# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time.DS_Store           # no mac temp files to be copied across at folder creation time You can also use wildcards. For example, if you need to exclude all files with the TMP extension, just add a *.tmp line to the file.&amp;lt;a name=&quot;This is a good example of a standard ignore_files file&quot;&amp;gt;&amp;lt;/a&amp;gt;# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time*.tmp           # no files with tmp extension to be copied across at folder creation timeCustomizing I/O and PermissionsShot and Asset folders often need to be created with special permissions and parameters. Sometimes this is as simple as setting permission bits during the folder creation, and sometimes it may be as complex as sending a remote request to a special folder creation server that will create the folders with the appropriate credentials, groups, and permissions.It is also common that folders on different levels in the file system tree need to have different permissions; a work area folder is typically writeable for everybody, whereas a shot folder may have much stricter permissions.Toolkit allows for customization of the folder creation via a single hook. This is a core hook and it is named  process_folder_creation.py. As the folder creation API call is traversing the folder configuration and deciding which folders should be created, it builds up a list of items that could be created. These items can be both files and folders. As the final step of the folder creation, this list is passed to a hook to handle the actual folder processing. You can examine the default  process_folder_creation core hook here(https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71).Data passed to the hookThe folder creation hook is executed just once for each folder creation request. All the folder creation data is passed in a list to the hook and the hook typically loops over this and creates the folders according to the parameters passed from the Core API.The data in the list is always a depth first recursion, starting with the top level folders and files and then traversing deeper and deeper. Here is an example of what the data passed to the hook may look like:[ {'action': 'entity_folder',  'entity': {'id': 88, 'name': 'Chasing the Light', 'type': 'Project'},  'metadata': {'root_name': 'primary', 'type': 'project'},  'path': '/mnt/projects/chasing_the_light'}, {'action': 'folder',  'metadata': {'type': 'static'},  'path': '/mnt/projects/chasing_the_light/sequences'}, {'action': 'entity_folder',  'entity': {'id': 32, 'name': 'aa2', 'type': 'Sequence'},  'metadata': {'entity_type': 'Sequence',               'filters': [{'path': 'project',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04c90&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2'}, {'action': 'entity_folder',  'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'}, {'action': 'copy',  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'source_path': '/mnt/software/tank/chasing_the_light/config/core/schema/project/sequences/sequence/shot/sgtk_overrides.yml',  'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/sgtk_overrides.yml'}, {'action': 'create_file',  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'content': 'foo bar',  'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/automatic_content.txt'}, {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  },]The data is a list of dictionaries. Each dictionary has a key called  action. This key denotes the type of I/O item that is requested. If you are implementing the folder creation hook, you need to add support for the following different actions:  entity_folder: A folder on disk which is associated with a ShotGrid entity.  folder: A folder on disk.  copy: A file that needs to be copied from a source location to a target location.  create_file:- A file that needs to be created on disk.  symlink: A symbolic link should be created.Each of the actions have a different set of dictionary keys. For example, the  entity_folder  action has an  entity key  which contains the details of the entity that it is connected to. The  create_file  has a  source_path  and a  target_path  key which inform the hook which file to copy and where.All  actions  also have a key called  metadata. This key represents the YAML configuration data that comes from the associated configuration file in the schema setup. You can see in the example above how the  metadata  key for a ShotGrid folder contains all the filter and naming information that is set up within the schema configuration. For example, here is the metadata for the Shot folder in the example above:{'action': 'entity_folder',  'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} …which corresponds to the  shot.yml  schema configuration file:&amp;lt;a name=&quot;Copyright (c) 2013 ShotGrid Software Inc.&quot;&amp;gt;&amp;lt;/a&amp;gt;# Copyright (c) 2013 ShotGrid Software Inc.#&amp;lt;a name=&quot;CONFIDENTIAL AND PROPRIETARY&quot;&amp;gt;&amp;lt;/a&amp;gt;# CONFIDENTIAL AND PROPRIETARY#&amp;lt;a name=&quot;This work is provided _AS IS_ and subject to the ShotGrid Pipeline Toolkit&quot;&amp;gt;&amp;lt;/a&amp;gt;# This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit&amp;lt;a name=&quot;Source Code License included in this distribution package. See LICENSE.&quot;&amp;gt;&amp;lt;/a&amp;gt;# Source Code License included in this distribution package. See LICENSE.&amp;lt;a name=&quot;By accessing, using, copying or modifying this work you indicate your&quot;&amp;gt;&amp;lt;/a&amp;gt;# By accessing, using, copying or modifying this work you indicate your&amp;lt;a name=&quot;agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights&quot;&amp;gt;&amp;lt;/a&amp;gt;# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights&amp;lt;a name=&quot;not expressly granted therein are reserved by ShotGrid Software Inc.&quot;&amp;gt;&amp;lt;/a&amp;gt;# not expressly granted therein are reserved by ShotGrid Software Inc.&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing&quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing&amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ] Note that the dynamic token  $sequence  has been resolved into an actual object at runtime.Passing your own folder creation directives to the hookIn addition to the various configuration directives required by Toolkit, you can also define your own configuration items as part of the schema configuration. These are passed into the hook via the  metadata  key described above, and can be used to drive folder creation.For example, if you had the following structure in your schema setup:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of itemsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]&amp;lt;a name=&quot;user settings&quot;&amp;gt;&amp;lt;/a&amp;gt;# user settingsstudio_permissions_level: &quot;admin&quot; …the data passed via the folder creation hook would be:{'action': 'entity_folder',  'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},  'metadata': {'entity_type': 'Shot',               'filters': [{'path': 'sg_sequence',                            'relation': 'is',                            'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],               'name': 'code',               'type': 'shotgun_entity',               'studio_permissions_level': 'admin'},  'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} Now the special parameter  studio_permissions_level  is passed into the hook and you can use that, for example, to control file permissions. You can also pass arbitrarily complex data structures using this method. A typical usecase for this would be to control permissions at a very detailed level.Adding custom configuration to static foldersTypically, when you create a folder inside the folder schema configuration, and it does not have a corresponding YAML file, Toolkit will assume that it is a static folder and will simply create it.If you would like to associate custom configuration metadata with a static folder, you have to create a YAML configuration file with the  static  type. For example, let’s say you have a static  assets  folder just under the project root and would like to group together assets and add custom configuration metadata. To achieve this, create the following  assets.yml  file:type: staticstudio_permissions_level: &quot;admin&quot;The configuration data passed to the hook will then contain the following:{'action': 'folder', 'metadata': {'studio_permissions_level': 'admin', 'type': 'static'}, 'path': '/mnt/projects/chasing_the_light/assets'},Again, arbitrarily complex data can be passed from the YAML configuration file into the hook in this way.Simple customization of how folders are createdA simple folder creation hook could look something like this:class ProcessFolderCreation(Hook):    def execute(self, items, preview_mode, **kwargs):        &quot;&quot;&quot; The default implementation creates folders recursively using open permissions. This hook should return a list of created items. Items is a list of dictionaries. Each dictionary can be of the following type: Standard Folder --------------- This represents a standard folder in the file system which is not associated with anything in ShotGrid. It contains the following keys: * &quot;action&quot;: &quot;folder&quot; * &quot;metadata&quot;: The configuration yaml data for this item * &quot;path&quot;: path on disk to the item Entity Folder ------------- This represents a folder in the file system which is associated with a ShotGrid entity. It contains the following keys: * &quot;action&quot;: &quot;entity_folder&quot; * &quot;metadata&quot;: The configuration yaml data for this item * &quot;path&quot;: path on disk to the item * &quot;entity&quot;: ShotGrid entity link dict with keys type, id and name. File Copy --------- This represents a file copy operation which should be carried out. It contains the following keys: * &quot;action&quot;: &quot;copy&quot; * &quot;metadata&quot;: The configuration yaml data associated with the directory level on which this object exists. * &quot;source_path&quot;: location of the file that should be copied * &quot;target_path&quot;: target location to where the file should be copied. File Creation ------------- This is similar to the file copy, but instead of a source path, a chunk of data is specified. It contains the following keys: * &quot;action&quot;: &quot;create_file&quot; * &quot;metadata&quot;: The configuration yaml data associated with the directory level on which this object exists. * &quot;content&quot;: file content * &quot;target_path&quot;: target location to where the file should be copied. &quot;&quot;&quot;        # set the umask so that we get true permissions        old_umask = os.umask(0)        folders = []        try:            # loop through our list of items            for i in items:                action = i.get(&quot;action&quot;)                if action == &quot;entity_folder&quot; or action == &quot;folder&quot;:                    # folder creation                    path = i.get(&quot;path&quot;)                    if not os.path.exists(path):                        if not preview_mode:                            # create the folder using open permissions                            os.makedirs(path, 0777)                        folders.append(path)                elif action == &quot;copy&quot;:                    # a file copy                    source_path = i.get(&quot;source_path&quot;)                    target_path = i.get(&quot;target_path&quot;)                    if not os.path.exists(target_path):                        if not preview_mode:                            # do a standard file copy                            shutil.copy(source_path, target_path)                            # set permissions to open                            os.chmod(target_path, 0666)                        folders.append(target_path)                elif action == &quot;create_file&quot;:                    # create a new file based on content                    path = i.get(&quot;path&quot;)                    parent_folder = os.path.dirname(path)                    content = i.get(&quot;content&quot;)                    if not os.path.exists(parent_folder) and not preview_mode:                        os.makedirs(parent_folder, 0777)                    if not os.path.exists(path):                        if not preview_mode:                            # create the file                            fp = open(path, &quot;wb&quot;)                            fp.write(content)                            fp.close()                            # and set permissions to open                            os.chmod(path, 0666)                        folders.append(path)                else:                    raise Exception(&quot;Unknown folder hook action '%s'&quot; % action)        finally:            # reset umask            os.umask(old_umask)        return folders Part 2 - Configuring File System TemplatesThe Toolkit templates file is one of the hubs of the Toolkit configuration. There is always one of these files per project and it resides inside the  config/core  folder inside your pipeline configuration.This file contains definitions for  templates  and their  keys.A  key  is a dynamic field we defined. It can be a name, a version number, a screen resolution, a shot name etc. Keys are configured with types, so we can define that a key should be a string or an int for example. They are also formatted, so we can define that a string should only contain alpha numeric characters, or that all integers should be padded with eight zeroes.A  template  is a dynamic path. An example of a template is  shots/{shot}/publish/{name}.{version}.ma. This template could for represent maya publishes for a shot - the bracketed fields are keys.The templates file is divided into three sections: keys, paths and strings.The Keys SectionKeys define what values are acceptable for fields. In the template config file keys are defined in the form:key_name:   type: key_type   option: option_value   option: option_value Key type is either  str,  int, or  sequence. Str keys are keys whose values are strings, int keys are keys whose values are integers, and sequence keys are keys whose values are sequences of integers.In addition to specifying the type, you can also specify additional options. The following options exist:      default: default_value  - Value used if no value was supplied. This can happen if you are using the Toolkit API and trying to resolve a set of field values into a path for example.        choices: [choice1, choice2, etc]  - An enumeration of possible values for this key.        exclusions: [bad1, bad2, etc]  - An enumeration of forbidden values for this key. If key is of type sequence, frame spec values cannot be invalidated with this setting.        length: 12  - This key needs to be of an exact length.        alias: new_name  - Provides a name which will be used by templates using this key rather than the key_name. For example if you have two concepts of a version number, one is four zero padded because that is how the client wants it, and one is three zero padded because that how it is handled internally - in this case you really want both keys named “version” but this is not really possible since key names need to be unique. In this case you can create an alias. See one of the examples below for more information.        filter_by: alphanumeric  - Only works for keys of type string. If this option is specified, only strings containing alphanumeric values (typically a-z, A-Z and 0-9 for ascii strings but may include other characters if your input data is unicode) will be considered valid values.        filter_by: alpha  - Only works for keys of type string. If this option is specified, only strings containing alpha values (typically a-z, A-Z for ascii strings but may include other characters if your input data is unicode) will be considered valid values.        filter_by: '^[0-9]{4}_[a-z]{3}$'  - Only works for keys of type string. You can define a regular expression as a validation mask. The above example would for example require the key to have four digits, then an underscore and finally three lower case letters.        format_spec: &quot;04&quot;  - For keys of type int and sequence, this setting means that the int or sequence number will be zero or space padded. Specifying “04” like in the example will result in a four digit long zero padded number (e.g. 0003). Specifying “03” would result in three digit long zero padded number (e.g. 042), etc. Specifying “3” would result in three digit long space padded number (e.g. “ 3”). For keys of type timestamp, the format_spec follows the  strftime and strptime convention.        strict_matching: true  - Only works for keys of type type int. This settings means that the field will only match numbers that have been properly formatted. For example, given “003” and strict_matching set to true, we would match “002”, “12345” and “042”, but not “00003” or “2”. If you need the matching to be less strict, set strict_matching to false. The default behavior is to strictly match.        shotgun_entity_type  - When used in conjunction with the  shotgun_field_name  option, will cause contexts to query ShotGrid directly for values. This allows using values from fields not seen in the folder structure to be used in file names.        shotgun_field_name  - Only used in conjunction with  shotgun_entity_type.        abstract  - Denotes that the field is abstract. Abstract fields are used when a pattern is needed to describe a path - for example image sequences (%04d) or stereo (%V). Abstract fields require a default value.        subset  and  subset_format  - Extracts a subset of the given input string and makes that the key value, allowing you to create for example an initials key from a full username or a key that holds the three first letters of every shot name.  For technical details about template keys, see the  API reference.Example - An alphanumeric nameA name that defaults to “comp” and that is alphanumeric:name:    type: str    default: &quot;comp&quot;    filter_by: alphanumericnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{version}.nk Example - Version numberA version number that would match numbers such as 002, 102, 034, 12341version:    type: int    format_spec: &quot;03&quot; A version number that would match numbers such as 002, 102, 034, 12341, but also 0002, 2 and 0102version:    type: int    format_spec: &quot;03&quot;    strict_matching: false Example - A stereo eyeA typical stereo eye setup. The eye field is either L or R, but when used in software, it is often referred to in a generic, abstract fashion as %V. Since %V does not really refer to a file name but rather a collection of files, we set the  abstract  flag. Abstract fields need to have a default value that is pulled in whenever the abstract representation is being requested.eye:    type: str    choices: [&quot;L&quot;, &quot;R&quot;, &quot;%V&quot;]    default: &quot;%V&quot;    abstract: truenuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{eye}_v{version}.{SEQ}.exrExample - Image sequencesImage sequences are abstract by definition and they have a default value set to %0Xd unless otherwise specified. The below sequence spec would identify frame numbers such as 0001, 1234 and 12345.SEQ:    type: sequence    format_spec: &quot;04&quot;nuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{channel}_{eye}_v{version}.{SEQ}.exr Example - Two fields both named version via an aliasTwo definitions of version number that can both be used by code that expects a key which is named “version”. This is useful if you have two Toolkit apps that both need a  version  field but you want these version field to be formatted differently.nuke_version:    type: int    format_spec: &quot;03&quot;    alias: versionmaya_version:    type: int    format_spec: &quot;04&quot;    alias: version&amp;lt;a name=&quot;nuke versions are using numbers on the form 003, 004, 005&quot;&amp;gt;&amp;lt;/a&amp;gt;# nuke versions are using numbers on the form 003, 004, 005&amp;lt;a name=&quot;the nuke publish app requires a field called {version}&quot;&amp;gt;&amp;lt;/a&amp;gt;# the nuke publish app requires a field called {version}&amp;lt;a name=&quot;however {nuke_version} is a valid replacement for {version}&quot;&amp;gt;&amp;lt;/a&amp;gt;# however {nuke_version} is a valid replacement for {version}&amp;lt;a name=&quot;because it has an alias defined&quot;&amp;gt;&amp;lt;/a&amp;gt;# because it has an alias definednuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{nuke_version}.nk&amp;lt;a name=&quot;maya versions are using numbers on the form 0004, 0005, 0006&quot;&amp;gt;&amp;lt;/a&amp;gt;# maya versions are using numbers on the form 0004, 0005, 0006maya_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{maya_version}.ma Example - TimestampA timestamp that defaults to the current local time and is formatted as YYYY-MM-DD-HH-MM-SS.now:    type: timestamp    format_spec: &quot;%Y-%m-%d-%H-%M-%S&quot;    default: now A timestamp that defaults to the current utc time and is formatted as YYYY.MM.DD.year_month_day:    type: timestamp    format_spec: &quot;%Y.%m.%d&quot;    default: utc_now A timestamp that defaults to 9:00:00 and is formatted as HH-MM-SS.nine_am_time:    type: timestamp    format_spec: &quot;%H-%M-%S&quot;    default: &quot;09-00-00&quot; Example - ShotGrid mappingsThis is useful when you would like to to add ShotGrid fields to a file name, for example. Let’s say we would like to include the user name in a file name- we’d use the following definition:current_user_name:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: loginnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{current_user_name}_{name}.v{version}.nkWhen a Toolkit app populates all the context fields (via the  context.as_template_fields()  method, it will populate the higher level fields  Shot,  Sequence  and  Step  automatically. It will also scan through all fields which have  shotgun_entity_type  defined (like our  current_user_name  field above). If the ShotGrid Entity is defined in the context, it will be able to automatically resolve the value. The current user is always tracked in the context, and in the above example, it would also be possible to pull data from fields on Shot, Sequence and Step since these are defined as part of the higher level path and therefore part of the context. However, trying to refer to an Asset entity in a field wouldn’t work in the above example since Toolkit would have no way of knowing which asset in ShotGrid to pull the data from.Example - String field with two valid valuesOften times a studio will have a project that needs to save out ASCII and Binary Maya files. In this scenario, a string value with two valid values looks like:maya_file_extension:    type: str    choices: [&quot;ma&quot;, &quot;mb&quot;]                     Note: the default apps use either  .ma  or  .mb  based on what’s configured in the  templates.yml. So, for example, if you want to change the work files app to save  .mb  instead of  .ma  in a project, you can change these three templates (for Shots):    maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.ma'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.ma'If  you  instead  end  them  with  .mb,  then  the  apps  will  save  out  as  Maya  binary:maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.mb'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.mb'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.mb' Check out  The Paths Section  below for more details.Example - Disallowing a valueA string field for which the value “assets” is not allowed. This is useful if you for example have two a folder which contains folders for all the sequences for a project alongside with a single “assets” folder where all the assets are kept:project |--- sequence1 |--- sequence2 |--- sequence3  --- assets In order for Toolkit to correctly understand that the assets folder is not just another sequence, we can define that “assets” is not a valid value for the sequence template.sequence:    type: str    exclusions: [&quot;assets&quot;] The exclusions field above allows us to define two templates that both correctly resolves:sequence_work_area: {sequence}/{shot}/workasset_work_area: assets/{asset}/work Example - Subsets of stringsThe following example extends a previous example and shows how to prefix filenames with a user’s initials.user_initials:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: login    subset: '([A-Z])[a-z]*  ([A-Z])[a-z]*'    subset_format: '{0}{1}'nuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{user_initials}_{name}.v{version}.nk The Paths SectionThe Paths section specifies where work will be saved. All paths consist of at least a name and a definition, where the definition is a combination of key names in brackets interspersed with non-key values representing a path. For example, a definition for a shot work file might look like:shot_work: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma With Sequence, Shot, Step and version being keys defined in the same template file.                    Note: If a string key’s name matches the entity type of a dynamic schema folder that has an associated ShotGrid entity, then that folder name will be substituted in for the token. For example, if you are using a {Sequence} template key of type ‘string’ like the above snippet, and in your schema, you have a dynamic folder named ‘sequence’, and in its corresponding  sequence.yml  file, it’s defined to be of type  shotgun_entity, and is connected to the ‘Sequence’ entity type in ShotGrid. Toolkit will recognize that your template key corresponds to this dynamic folder’s entity type (in that they are both Sequence). So, Toolkit will take the resulting folder name (i.e., the name of the specific sequence in question), and substitutes that in for the template key.    This form is required if any optional attributes need to be defined. Currently, the only optional attribute is  root_name, which can be used to specify a project root for a path in a project that has multiple roots.  Multiple roots  are used when you’d like to add a new storage root to store some of your project files.root_name: name_of_project_rootFor example, it may look like this:shot_work:  definition: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma  root_name: primary You need to use the above format if you want to use another storage root than the primary one. In this example, using this simple format implies that you are using the primary root for all entries.The Strings SectionStrings are similar to paths in that they must include a name and definition, which can be supplied in the simple form:string_name: string_definitionString definitions are templates consisting of key names and other values which together resolve to a string rather than a file system path. An example might the name used in ShotGrid for a publish:maya_publish_sg_name: &quot;Maya  publish,  {name},  v{version}&quot;With name and version as key names defined in the same file.Using Optional Keys in TemplatesOptional keys in templates are useful for a number of reasons. One common case is when  {SEQ}  is optional for rendered images. In this example, there can be a set of exrs that that are comprised of frame numbers, like  /path/to/render/shot.101.exr  (and 102, 103, etc), while you are also able to use the same template for quicktime movies, like  /path/to/render/shot.qt. Another more common case is when you are rendering stereo images. If you are in a studio where the convention is:  left eye: file.LFT.exr, right eye: file.RGT.exr, stereo image: file.exr?, you can make  {eye}  optional.Optional sections can be defined using square brackets:shot_work: sequences/{Shot}/work/{Shot}.[v{version}.]ma The optional section must contain at least one key. If the path is resolved with no value for the key(s) in an optional section, the path will resolve as if that section did not exist in the definition. The example above can be thought of as two templates baked into a single definition:shot_work: sequences/{Shot}/work/{Shot}.v{version}.mashot_work: sequences/{Shot}/work/{Shot}.ma As you pass in a dictionary of fields, Toolkit will choose the right version of the template depending on the values:&amp;gt;&amp;gt;&amp;gt; template = tk.templates[&quot;shot_work&quot;]&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;, &quot;version&quot;: 12}/project/sequences/ABC_123/work/ABC_123.v12.ma&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;}/project/sequences/ABC_123/work/ABC_123.ma Advanced questions and troubleshootingHow can I add a new entity type to my file structure?Let’s say you have been working on feature animations and shorts on your ShotGrid site, and now you have been awarded episodic work. Let’s walk through how you can incorporate an episodic workflow to Toolkit. The first thing to do is to set up your hierarchy in ShotGrid for episodic work following the instructions  here.                    Note: see the  Create with parent folder section above  to revisit nesting relationships in Toolkit (which is completely independent from the project hierarchy in ShotGrid).    Additional Reference:  How does the Episode entity work?  Customizing an entity’s hierarchyShotGrid fields required for the Episode &amp;gt; Sequence &amp;gt; Shot hierarchyYou can choose to use any Custom Entity for Episode (Site Preferences &amp;gt; Entities), or you can use the official Episode entity that was made available in ShotGrid 7.0.7.0. If you signed up for ShotGrid pre-7.0.7.0 (before 2017), the “TV Show” template uses CustomEntity02 for Episodes. If you decide to use another entity that is not CustomEntity02 or the official Episode entity, no worries! ShotGrid and Toolkit are flexible. Let’s walk through both cases.For the purpose of this exercise, we will use Episode (CustomEntity02) and the official Episode entity as examples of how to incorporate Episodes with the project hierarchy update (you can use either/or). First, the way to properly set up our Project’s  Episode &amp;gt; Sequence &amp;gt; Shot  hierarchy is to ensure the following fields are in ShotGrid:Episodea)  Using the official Episode entity:  the “Episode” entity may be the entity used when creating a TV Show project from the Project Template.ORb)  Using a custom entity:  CustomEntity02  may be the custom entity used when creating a TV Show project from the Project Template.  As noted previously, you can enable another custom entity and use it instead of  CustomEntity02—just make sure to replace all  CustomEntity02’s with the specific one that you have enabled.SequenceA single entity link called Episode (sg_episode) that links to the Episode entity is required.Using the official  Episode  EntityUsing  CustomEntity02ShotA single entity field called Sequence (sg_sequence) that links to the Sequence entity. This should already exist as part of the TV Show Project Template in ShotGrid.Using the official  Episode  EntityUsing  CustomEntity02Toolkit schema definitionLet’s assume a hierarchy as follows (where the folders in  {}s are dynamically named based on their name in ShotGrid):- {project_name} - shots episode.yml - {episode_name} sequence.yml - {sequence_name} shot.yml - {shot_name} ... …EpisodesIn your  config/core/schema/project/shots  folder, create a folder named  episode  with a corresponding  episode.yml  file in the same directory with the following content:Using the official  Episode  Entity&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Episode&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]Using  CustomEntity02&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;CustomEntity02&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] This tells Toolkit to create folders for every Episode in this project.SequenceIn your  config/core/schema/project/shots/episode  folder, create a folder named  sequence  with a corresponding  sequence.yml  file in the same directory with the following content:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Sequence&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_episode&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$episode&quot; ] } ]` This tells Toolkit to create folders for every Sequence that is linked to the Episode above it in the directory tree.ShotsIn your  config/core/schema/project/shots/episode/sequence  folder, create a folder named  shot  with a corresponding  shot.yml  file in the same directory with the following content:&amp;lt;a name=&quot;the type of dynamic content&quot;&amp;gt;&amp;lt;/a&amp;gt;# the type of dynamic contenttype: &quot;shotgun_entity&quot;&amp;lt;a name=&quot;the ShotGrid field to use for the folder name&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid field to use for the folder namename: &quot;code&quot;&amp;lt;a name=&quot;the ShotGrid entity type to connect to&quot;&amp;gt;&amp;lt;/a&amp;gt;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;&amp;lt;a name=&quot;ShotGrid filters to apply when getting the list of items&quot;&amp;gt;&amp;lt;/a&amp;gt;# ShotGrid filters to apply when getting the list of items&amp;lt;a name=&quot;this should be a list of dicts, each dict containing &quot;&amp;gt;&amp;lt;/a&amp;gt;# this should be a list of dicts, each dict containing &amp;lt;a name=&quot;three fields: path, relation and values&quot;&amp;gt;&amp;lt;/a&amp;gt;# three fields: path, relation and values&amp;lt;a name=&quot;(this is std ShotGrid API syntax)&quot;&amp;gt;&amp;lt;/a&amp;gt;# (this is std ShotGrid API syntax)&amp;lt;a name=&quot;any values starting with $ are resolved into path objects&quot;&amp;gt;&amp;lt;/a&amp;gt;# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]` This tells Toolkit to create folders for every Shot that is linked to the Sequence above it in the directory tree.After you’ve done this, your schema should reflect the following:Toolkit template definitionsIn order to tell Toolkit that you are using Episodes in your schema, you need to create a new key in the  keys section  at the top to define it:Using the official  Episode  Entitykeys:    ...    Episode:        type: str    ... Then, in your template paths below, update the  shot_root  template, as well as any other template paths that are in the shot hierarchy, to match your episodic hierarchy by inserting  {Episode}  in the proper place to specify the episode in the directory structure:...    paths:        shot_root: shots/{Episode}/{Sequence}/{Shot}/{Step}        … Using  CustomEntity02keys:    ...    CustomEntity02:        type: str    ...Then, in your template paths below, update the  shot_root  template, as well as any other template paths that are in the shot hierarchy, to match your episodic hierarchy by inserting  {CustomEntity02}  in the proper place to specify the episode in the directory structure:...    paths:        shot_root: shots/{CustomEntity02}/{Sequence}/{Shot}/{Step}        … That’s all you need for the basic  Episode &amp;gt; Sequence &amp;gt; Shot  workflow!How can I set up a branch in my structure?This relates to  Different file system layouts for different Pipeline Steps, more specifically, if you are looking to add a branch to your structure. For example, you can have one structure for “Pipeline Step A” and another for all other Pipeline Steps.Let’s say you are adding another kind of  Asset Type  to your Pipeline, and that new Asset Type is a Vehicle. You want to change the file structure for Vehicles so that it has different folders for different Pipeline Steps; for example, “geoprep” and “lookdev”, with additional folders inside each of those Pipeline Step folders. In parallel to this update, the way that you create Assets currently should remain the same. Let’s walk through how to update your pipeline to accommodate this new flow.Step 1: Modify the schemaFirst, modify your schema to reflect the way your folder structure will look with the new Asset Type.  Start by creating a new branch in the schema for this new Asset Type: vehicle.  At the same level as  asset/  and  asset.yml, add an  asset_vehicle/  folder and  asset_vehicle.yml.  These YAML files also have a filter setting in them. Modify the filter in your  asset.yml  so that it applies to all assets  except for  vehicle, and then modify  asset_vehicle.yml  to apply  only to  assets of type vehicle.  Here is an example of what those filters look like.      Now that you have two folders to represent  asset  and  asset_vehicles, add all the folders underneath  asset_vehicle  that you expect to be created for those assets (e.g.,  geoprep,  lookdev, etc.).    If you are saving and publishing files for these assets, you’ll want to create templates, in  core/templates.yml, that describe the file paths for saved and publish files. For example, in addition to  maya_asset_work, you may create a template called  maya_asset_work_vehicle, and its definition will be the templated path where you want to save Maya work files for vehicle assets.Step 2: Create a new environment fileAt this point, you have a directory structure for the new Asset Type, and you have templates that describe where to save and publish files in the new directory structure. Now, you need to tell Toolkit when to use these new templates. To do this, create a new environment file.  Create a copy of  env/asset_step.yml  called  env/asset_vehicle_step.yml. These two files will be identical, except  env/asset_vehicle_step.yml  will use your new templates. Replace any instances of  maya_asset_work  with  maya_asset_work_vehicle. Do the same for any other vehicle templates you’ve created.  Finally, you’ll need to teach Toolkit when to pick your new environment. To do this, modify the  pick_environment  core hook to return  asset_vehicle  or  asset_vehicle_step  when the asset in context is of type  vehicle  . Now, when you are working with an Asset of this new type (vehicle), Toolkit will know to use its environment configuration, and to therefore save and publish files to its alternate file system structure.How can I create a custom Pipeline Step using a custom entity?In ShotGrid 7.0.6.0,  managing Pipeline Steps via the Admin menu  was introduced. With this feature, you can easily add custom fields to Pipeline Steps.  Pro Tip: In most cases, utilizing custom fields on Pipeline Steps helps keep your pipeline more organized than creating a custom entity to manage those Pipeline Steps.However, in more advanced cases, it may be useful to have an alternative Pipeline Step. For instance, you might like to have the flexibility of different naming conventions and structures for production versus pipeline in the area of Pipeline Steps, as well as flexibility in naming and structuring them independently. While typically ShotGrid’s built-in Pipeline Steps are used for scheduling purposes, you may want to use another  Custom Entity  to structure the file system and group individual tasks together in the pipeline. You can accomplish this by creating a custom link field from a Task to a custom entity. This is then used by the system to group tasks together, via the step node.In the folder configuration, add two special options to tell it to use your custom step setup rather than ShotGrid’s built-in Pipeline Step:entity_type: &quot;CustomNonProjectEntity05&quot;task_link_field: &quot;sg_task_type&quot;",
    "url": "/82ff76f7/",
    "relUrl": "/82ff76f7/"
  },
  "40": {
    "id": "40",
    "title": "Python API에서 SSL: CERTIFICATE_VERIFY_FAILED 문제 수정",
    "content": "Python API에서 SSL: CERTIFICATE_VERIFY_FAILED 문제 수정Python API는 ShotGrid에서 사용하는 다양한 웹 서비스에 연결하기 위해 사용자 시스템에 있고 API와 함께 번들로 제공되는 인증서 목록을 사용합니다. 그러나 새 인증서 인증 기관이 릴리즈되어 Python API 또는 OS와 함께 번들로 제공되지 않을 수 있습니다.Python API는 최신 인증서 사본을 제공하지만 2019년 2월 21일부터 최신 API 버전을 사용하는 경우에도 API에서 Amazon S3 업로드에 대해 해당 인증서를 사용하지 못하도록 하는 버그가 있습니다. 자세한 내용은 이 AWS 블로그 게시물을 참조하십시오. 다음 솔루션을 통해 상황을 일시적으로 해결할 수 있습니다.                    참고: 이 방법은 임시적인 해결 방법이며 장기적 솔루션을 찾고 있는 중입니다.    기본 솔루션필요한 CA 인증서를 Windows 인증서 저장소에 추가합니다. Windows 7 사용자가 이 솔루션을 사용하려면 먼저 PowerShell 3.0으로 업그레이드하거나 certutil을 사용하여 필요한 인증서를 추가해야 할 수 있습니다.      시작을 마우스 오른쪽 버튼으로 클릭한 다음 Windows PowerShell(관리자) 항목을 마우스 왼쪽 버튼으로 클릭하여 승격된 PowerShell을 시작합니다.        PowerShell 창에 다음 명령을 붙여넣은 후 Return 키를 눌러 실행합니다.     $cert_url = &quot;https://www.amazontrust.com/repository/SFSRootCAG2.cer&quot; $cert_file = New-TemporaryFile Invoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullName Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root            추가된 인증서에 포함된 자세한 지문 925A8F8D2C6D04E0665F596AFF22D863E8256F3F가 표시되면 작업이 완료된 것이며 PowerShell을 닫을 수 있습니다.  대체 솔루션Python API만 사용 중인 경우      Python API v3.0.39로 업그레이드합니다.        a. ShotGrid_API_CACERTS를 /path/to/shotgun_api3/lib/httplib2/cacerts.txt로 설정합니다.    또는    b. 스크립트를 업데이트하고 Shotgun 개체를 인스턴스화할 때 ca_certs=/path/to/shotgun_api3/lib/httplib2/cacerts.txt를 설정합니다.  툴킷을 사용 중인 경우      툴킷 배포 방법에 따라 tank core 명령을 통해 최신 버전의 툴킷 API로 업그레이드하거나 파이프라인 구성의 core/core_api.yml 파일을 업데이트하는 방법으로 업그레이드합니다.        https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem에서 최신 인증서 목록을 다운로드합니다.        ShotGrid_API_CACERTS를 이 파일을 저장한 위치로 설정합니다. 하지만 툴킷은 Python API에서처럼 연결을 만들 때 ca_certs 매개변수 지정을 허용하지 않습니다.  Python API 또는 툴킷을 업데이트할 수 없는 경우      https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem에서 최신 인증서 목록을 다운로드합니다.        SSL_CERT_FILE 환경 변수를 이 파일을 저장한 위치로 설정합니다.  ",
    "url": "/c593f0aa/",
    "relUrl": "/c593f0aa/"
  },
  "41": {
    "id": "41",
    "title": "Getting Started",
    "content": "Getting StartedShotGrid 툴킷은 스튜디오 파이프라인 생성을 위해 매우 세부적인 사항까지 커스터마이즈할 수 있는 일련의 도구를 제공합니다. 이 도구를 통해 아티스트는 컨텐츠 생성 소프트웨어를 종료하지 않고도 ShotGrid의 정보에 액세스하고 아티스트 간에 작업을 공유할 수 있습니다. 이 안내서는 실습을 통해 커스텀 툴킷 파이프라인 설정을 시작할 수 있도록 디자인되었습니다. ShotGrid 데스크톱 앱을 사용하여 편집 가능한 프로젝트 구성을 생성하고, 기존 앱에서 설정을 수정하고, 다른 아티스트 환경에 툴킷 앱을 추가하여 커스텀 파이프라인을 디자인할 수 있습니다. 각 안내서는 이전 안내서를 토대로 작성되지만 어디서나 이동할 수 있는 지침이 포함되어 있습니다.",
    "url": "/3c5b69aa/",
    "relUrl": "/3c5b69aa/"
  },
  "42": {
    "id": "42",
    "title": "Getting Started",
    "content": "Isolation Feature Set - Getting StartedWant to learn more about the isolation features? See About the Isolation Feature Set for more details about what is in store for you. The Isolation feature set is available only to Super Awesome clients. Before starting, make sure to upgrade your subscription to Super Awesome.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup sectionIn This Section  About the Isolation Feature Set  Client Responsibilities  Onboarding Process  Planning Your Setup",
    "url": "/0f6d8a60/",
    "relUrl": "/0f6d8a60/"
  },
  "43": {
    "id": "43",
    "title": "Houdini ShotGrid 통합이 시작되지 않는 이유는 무엇일까요?",
    "content": "Houdini ShotGrid 통합이 시작되지 않는 이유는 무엇일까요?여기서는 Houdini에서 ShotGrid 통합을 시작할 수 없는 가장 일반적인 원인을 살펴봅니다. 이 경우, Houdini는 ShotGrid 데스크톱, ShotGrid 웹 사이트 또는 tank 명령으로 오류 없이 시작됩니다. 하지만 Houdini가 시작된 후에 ShotGrid 메뉴 또는 쉘프가 나타나지 않습니다.원인은 ShotGrid이 재정의된 HOUDINI_PATH 환경 변수를 사용하여 시작 스크립트 경로를 전달하기 때문인 경우가 많습니다.ShotGrid에서 Houdini가 시작되면 시작 앱 로직에서는 ShotGrid 부트스트랩 스크립트 경로를 HOUDINI_PATH 환경 변수에 추가합니다. 그러나 Houdini에 houdini.env 파일이 있는 경우 문제가 발생할 수 있습니다.이 파일을 통해 사용자는 Houdini가 로드될 때 제공되는 환경 변수를 설정할 수 있지만 파일에 정의된 모든 값이 현재 세션의 기존 환경 변수를 덮어씁니다.이 문제를 해결하려면 기존의 HOUDINI_PATH 환경 변수를 해당 변수에 대한 새 정의에 포함해야 합니다.예를 들어 houdini.env 파일에 다음과 같은 내용이 이미 있는 경우HOUDINI_PATH = /example/of/an/existing/path;&amp;amp;파일에 정의된 경로 끝에 $HOUDINI_PATH;를 추가하고 저장해야 합니다.HOUDINI_PATH = /example/of/an/existing/path;$HOUDINI_PATH;&amp;amp;그러면 Houdini가 시작될 때 ShotGrid 설정 값을 유지할 수 있습니다.                    주의: Windows에서 $HOUDINI_PATH에 문제가 발생하는 경우가 있습니다. 간혹 ShotGrid 통합을 여러 번 부트스트랩하며 다음과 같은 오류가 발생합니다.툴킷 부트스트랩에 필요한 변수가 누락되어 있음: TANK_CONTEXT이 오류가 발생하면 대신 %HOUDINI_PATH%를 사용해야 합니다.    그래도 문제가 해결되지 않으면 문제를 진단할 수 있도록 당사 지원 팀에 문의해 주십시오.",
    "url": "/eecfb05b/",
    "relUrl": "/eecfb05b/"
  },
  "44": {
    "id": "44",
    "title": "개요",
    "content": "",
    "url": "/",
    "relUrl": "/"
  },
  "45": {
    "id": "45",
    "title": "Windows에서 ShotGrid 데스크톱을 자동으로 설치하려면 어떻게 해야 합니까?",
    "content": "Windows에서 ShotGrid 데스크톱을 자동으로 설치하려면 어떻게 해야 합니까?ShotGrid 데스크톱 설치 프로그램을 자동으로 실행하려면 다음 방법으로 ShotGrid 데스크톱 설치 프로그램을 실행하십시오.ShotgunInstaller_Current.exe /S설치 폴더를 지정하고 싶다면 /D 인자를 사용하여 실행하면 됩니다.ShotgunInstaller_Current.exe /S /D=X: path to install folder.                    참고: /D 인자는 마지막 인자여야 하며, 경로에 공백이 있다고 하더라도 &quot;를 사용해서는 안 됩니다.    ",
    "url": "/3a27b3da/",
    "relUrl": "/3a27b3da/"
  },
  "46": {
    "id": "46",
    "title": "앱 추가",
    "content": "앱 추가이 안내서를 마치면 툴킷의 구성 관리 도구를 간단히 익히고 다음과 같은 작업을 수행하는 방법을 익힐 수 있습니다.  활성 파이프라인 구성의 복사본을 안전하게 생성  앱을 구성에 추가  특정 환경에서 앱을 사용하는 데 필요한 설정 추가  활성 구성에 변경 사항 다시 적용안내서 정보이 안내서에서는 ShotGrid 툴킷 앱을 기존 파이프라인 구성에 추가하는 방법을 살펴보고 구성 관리 도구에 대해 간단히 알아보겠습니다.여기서 추가할 앱은 ShotGrid Python 콘솔 앱입니다. Maya에는 자체 Python 콘솔이 있지만 이 툴킷 앱에는 Maya 콘솔에 없는 일부 기능이 있습니다.이 안내서에서는 파이프라인 구성 편집안내서에서 생성한 파이프라인 구성을 활용합니다. 이 안내서를 완료하지 않았다면 기존 파이프라인 구성을 사용하여 앱을 추가할 수 있습니다.이 문서 사용이 안내서를 사용하고 툴킷 앱을 설치하려면 다음이 필요합니다.  유효한 ShotGrid 사이트.  지정한 프로젝트에 대한 파이프라인 구성. 또는 구성 시작하기 안내서의 연습에서 생성한 구성을 사용하십시오.  파이프라인 구성이 저장된 파일 시스템에 대해 읽기 및 쓰기 권한을 적절하게 설정합니다.  ShotGrid 데스크톱이 시스템에 설치되어 있어야 합니다.  활성 상태의 Maya 멤버쉽. 여기에서 Maya 30일 체험판을 다운로드하십시오.                    참고: 이 안내서는 tk-config-default2 파이프라인 구성을 기반으로 합니다. 이 구성을 수정한 경우 YAML 설정의 파일, 폴더 및 블록의 위치가 여기에 설명된 것과 다를 수 있습니다.    ShotGrid 툴킷 앱 정보Toolkit 앱의 작동 방식파이프라인 구성에서 참조하는 앱은 다양한 위치에서 가져온 것일 수 있습니다. 기본 구성에서 표준인 앱은 ShotGrid 앱 스토어에서 가져온 것입니다. 파이프라인 구성의 파일은 툴킷에 “주소록에서 Python 콘솔 앱의 주소를 찾아줄래?”라고 묻는 것처럼 ShotGrid 통합이 앱에 액세스하는 방법을 지정합니다. 파이프라인 구성 파일은 툴킷에 특정 앱에 활용되는 코드의 번들을 찾는 위치를 알려줍니다.기본 구성에서 툴킷 앱의 “주소”는 config/env/includes/app_locations.yml 파일에 나열되어 있으며 코드를 찾는 위치를 지정합니다. 이러한 “주소”를 설명자라고 합니다. ShotGrid 통합은 앱에 대한 코드 번들을 찾는 위치뿐 아니라 앱을 사용하는 환경도 알아야 합니다.다음은 앱 설치 방법과 ShotGrid 통합에 앱을 사용하는 위치를 알리는 방법에 대한 개념적인 개요입니다. 여기서는 구성을 확장하고 툴킷에 설명자를 조회하도록 요청하고 ShotGrid에 앱을 사용하는 위치를 알리는 단계를 간략하게 설명합니다. 이 안내서에서는 다음 단계를 자세히 살펴봅니다.  추가하려는 앱의 설명자를 결정합니다.  앱 설명자를 추가하려는 활성 파이프라인 구성의 복사본을 생성합니다.  앱의 설명자가 구성에 존재하는지 확인하고, 존재하지 않는 경우 추가합니다.  들여쓰기에 탭이 아니라 공백을 사용하여 YAML 파일의 서식을 올바르게 지정합니다.  앱이 사용되는 환경을 결정합니다.  이러한 환경 내에서 ShotGrid이 앱을 사용할 수 있도록 허용하는 설정을 추가합니다.  새 구성을 테스트합니다.  확장된 구성을 라이브로 적용합니다.Python 콘솔 앱에 대한 위치 설명자 찾기1단계: 앱 및 엔진 페이지를 열고 Maya에서 ShotGrid Python 콘솔에 대한 정보를 찾습니다. 제목을 선택합니다.그러면 주소록에 필요한 항목이 모두 포함된 앱 관련 정보가 표시됩니다.시스템 이름이 주 식별자이며 tk-multi-pythonconsole입니다. 또한 최신 버전: v1.1.2도 필요합니다.Maya의 프로젝트 환경에서 Python 콘솔 앱이 없음을 확인2단계: Maya를 실행하고 ShotGrid 메뉴 ShotGrid &amp;gt; 프로젝트 the_other_side(Project the_other_side)를 선택하면 프로젝트 환경에 해당 프로젝트에 사용할 수 있는 앱 목록이 표시됩니다.구성 확장프로덕션 단계에 적용된 구성을 편집하려면 복사본을 먼저 생성한 후 편집해야 합니다. 그러면 라이브 구성에 영향을 미치지 않고 편집한 구성을 라이브로 적용하기 전에 테스트할 수 있는 안전한 공간이 만들어집니다. 스테이징 샌드박스를 생성하면 현재 프로덕션에서 사용되는 파이프라인 구성의 복사본을 시험해 볼 수 있습니다. 샌드박스에서 구성의 복사본을 변경한 후 변경 사항을 프로덕션에 라이브로 적용하기 전에 테스트해 볼 수 있습니다.파이프라인 구성을 복제하면 새 구성을 라이브 프로덕션에 적용하기 전에 복사본을 시험해 볼 수 있는 샌드박스를 구축하여 복사본 생성 프로세스를 자동화할 수 있습니다.앱을 추가하려는 파이프라인 구성 복제파이프라인 구성 목록으로 이동합니다.3단계: ShotGrid을 열고 오른쪽 위에서 관리자(Admin) 메뉴(아바타) &amp;gt; 기본 레이아웃(Default Layouts) &amp;gt; 파이프라인 구성(Pipeline Configuration) &amp;gt; 파이프라인 구성 목록(Pipeline Configuration List)을 선택합니다.이렇게 하면 ShotGrid 사이트의 파이프라인 구성이 모두 포함된 상세 목록이 표시됩니다.4단계: 파이프라인 구성 목록이 표시되면 열 헤더의 맨 오른쪽에 있는 + 기호를 선택하고 프로젝트(Projects) 열을 추가합니다.프로젝트 구성의 위치 리뷰5단계: 또한, 운영 체제에 적합한 경로(Path) 필드를 추가합니다.그러면 구성 파일의 경로가 표시됩니다.6단계: 기본(Primary) 행 항목 옆에 있는 빈 공간을 마우스 오른쪽 버튼으로 클릭하고 상황에 맞는 메뉴에서 이 구성 복제…(Clone this Configuration…)를 선택합니다.7단계: 구성 목록의 구성과 디렉토리의 파일의 이름을 각각 “Primary Clone Config 2”와 “the_other_side_clone2”로 지정합니다. 확인(OK)을 선택합니다.구성에 포함된 모든 파일 및 폴더가 복사되고 앱에 대한 캐시가 생성될 때까지 기다립니다. 이제 앱을 사용할 수 있으므로 입에서 살살 녹는 크로아상과 함께 에스프레소를 마시면서 여유를 즐기십시오.완료되면 구성 목록에 복제된 구성 관련 정보가 업데이트되고 새 구성이 로컬 구성 폴더에 추가됩니다.                    참고: 사용자 제한(User Restrictions)에 사용자 이름이 추가되었습니다. 구성을 만든 작업자만 새 구성에 액세스할 수 있도록 자동으로 제한이 적용됩니다. 이 구성을 편집 및 테스트하고, 사용하게 하려는 작업자가 있으면 직접 추가할 수 있습니다. 또한 ShotGrid은 유연성과 제어 기능을 지원합니다.    복제된 구성을 프로젝트와 연결8단계: ShotGrid 데스크톱을 열고 복제된 구성을 생성한 프로젝트를 선택합니다. 오른쪽 위에 있는 아래쪽 화살표를 선택하여 이 프로젝트와 연결된 구성을 표시하고 방금 생성한 Primary Clone Config 2를 선택합니다.ShotGrid 데스크톱이 이제 이 프로젝트에 대해 복제된 구성을 사용합니다.파이프라인 구성 편집9단계: 파일 시스템에서 복제된 구성을 생성할 때 지정한 경로에서 해당 구성을 찾습니다. config/env/includes/app_locations.yml 파일을 봅니다.app_locations.yml 파일이 기본 구성의 주소록이며 앱의 설명자가 이 파일에 나열되어 있습니다. 이 파일에 앱의 위치가 지정되며 이 파일을 사용하여 앱에 대한 설정을 생성할 수 있습니다.사용하려는 앱이 이 주소록에서 참조되지 않을 경우 툴킷에 앱을 찾을 위치를 알려야 합니다.툴킷에 앱을 찾을 위치 알리기10단계: 파일에서 pythonconsole을 검색합니다. 프로젝트에 기본 구성을 사용한 경우 Python 콘솔 앱에 대한 설명자가 이 파일에 나열되어 있는 것을 볼 수 있습니다. 이 설명자는 이 과정을 시작할 때 살펴본 Maya 앱의 목록에 있는 설명과 일치해야 합니다. 버전이 Maya 앱 목록에서 확인한 항목과 일치하는지 확인합니다.apps.tk-multi-pythonconsole.location:	type: app_store	name: tk-multi-pythonconsole	version: v1.1.2                    참고: 다른 구성을 사용하는 경우 파일에 설명자를 추가해야 할 수 있습니다.    모든 앱과 엔진에는 설명자가 있습니다. Core API 문서의 설명자 섹션에서 설명자의 작동 방식과 type:을 설정하는 방법을 확인할 수 있습니다.툴킷에 설명자를 사용하도록 지시이제 Maya의 프로젝트 환경에 있는 동안 툴킷에 설명자를 사용하여 Python 콘솔 앱을 찾아 사용하도록 지시해야 합니다.11단계: 복제된 구성에서 config/env/project.yml 파일을 열고 tk-maya 엔진에 대한 설정을 찾습니다.# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;@settings를 사용하는 tk-maya: “@settings.tk-maya.project” 행은 설정이 포함된 파일에 있음을 나타냅니다. tk-maya는 Maya 엔진을 나타내고 project는 환경을 나타냅니다.YAML 파일ShotGrid 툴킷 파이프라인 구성은 YAML 파일에서 단순한 용어를 사용하여 앱과 엔진의 위치와 해당 설정을 식별합니다.이 블록에서  settings는 기본 구성에 대해 설정 폴더의 참조로 선택된 항목입니다.  project는 기본 구성에 대해 프로젝트 환경의 참조로 선택된 항목입니다.  tk-maya는 Maya에 대한 툴킷 엔진의 식별자입니다.  @은 설정 값을 포함된 파일에서 가져온다는 것을 나타내는 데 사용되는 툴킷 용어입니다.YAML 파일은 ShotGrid 통합으로 통하는 창입니다. 이 파일을 사용하면 파이프라인의 요구사항을 충족하는 작업 환경을 더욱 손쉽게 구성할 수 있습니다.구성이 툴킷 번들을 참조하는 방식ShotGrid 통합의 코드는 앱, 엔진 및 프레임워크에 대한 번들로 구성됩니다. 번들은 툴킷의 YAML 파일에서 tk-maya, tk-multi-pythonconsole 등과 같은 식별자로 참조됩니다. YAML에서 각 번들에 해당하는 블록에는 식별된 번들의 액세스 및 활용 방식을 제어하는 설정이 포함됩니다.Python 콘솔에 대한 설정을 추가할 위치기본 구성의 이 블록에서 ‘tk-maya.project’는 프로젝트 환경에서 Maya 엔진을 나타내는 식별자입니다. 여기서 목표는 Python 콘솔 앱 코드 번들을 프로젝트 환경의 Maya 엔진에 추가하는 것입니다. 사용된 용어를 보면 tk-maya.yml은 프로젝트 환경의 설정이 위치한 YAML 파일의 이름입니다. tk-maya.yml 파일에서 apps에 대한 settings.tk-maya.project를 찾습니다.13단계: 파일을 찾기 위해 엔진 위에 있는 includes 섹션에서 tk-maya.yml을 찾습니다../includes/settings/tk-maya.yml14단계: 복제된 구성에서 텍스트 편집기로 config/env/includes/settings/tk-maya.yml을 열고 settings.tk-maya.project를 검색합니다.15단계: 다음 아래에 위치 설명자를 추가합니다.settings.tk-maya.project:  apps:위치 설명자를 추가하는 방법에 대한 가이드로 about 앱인 tk-multi-about:을 사용한 후 파일을 저장합니다.                    참고: YAML 파일의 서식이 탭이 아니라 공백을 사용하여 올바르게 지정되었는지 확인하십시오.    # projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-pythonconsole:      location: &quot;@apps.tk-multi-pythonconsole.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;Screening Room, ShotGrid 패널 및 Workfiles2 앱의 위치 식별자가 포함된 다른 파일에 나열되어 있고 About 앱과 다르게 액세스되는 것을 알 수 있습니다. 이러한 앱에는 추가 설정이 있으므로 정리를 위해 포함된 설정 폴더로 분리되었습니다.                    참고: Python 콘솔 앱은 기본 구성에 이미 있지만, 사용 중인 구성에 이전에 추가한 적이 없는 앱을 추가할 경우 또는 앱의 버전을 변경하고 중앙 집중식 구성을 사용하는 경우에는 추가 단계를 수행해야 합니다. 터미널을 열고 복제된 구성이 저장된 위치를 찾습니다. 복제된 구성의 루트 폴더에서 다음 명령을 실행합니다.Linux 또는 Mac:./tank cache_appsWindows:tank.bat cache_apps이렇게 하면 앱, 엔진 및 프레임워크에 대해 구성을 스캔하고 모두 다운로드되었는지 확인합니다.    Maya에서 변경 사항 보기16단계: ShotGrid 데스크톱을 열고 작업하는 프로젝트를 선택한 후 복제된 구성을 사용하고 있는지 확인합니다.프로젝트 이름 아래, 생성된 복제본의 이름에 파란색 막대가 표시됩니다.                    참고: 기본 항목을 사용하는 경우 파란색 막대가 없고 구성 이름이 표시되지 않습니다.    17단계: 데스크톱에서 Maya를 실행하고 ShotGrid &amp;gt; 프로젝트(Project) &amp;gt; … 메뉴를 선택합니다.다음에 해당하는 경우:  방금 편집한 복제된 구성을 사용합니다.  복제된 구성이 올바르게 확장되었습니다.  확장된 파일을 저장했습니다.  복제된 구성과 프로젝트를 연결했습니다.  ShotGrid 데스크톱에서 Maya를 다시 실행했습니다.Python 콘솔 앱을 Maya에서 사용할 수 있습니다.변경 사항을 프로덕션에 적용Python 콘솔 앱이 올바르게 추가된 것을 확인하고 나면 변경 사항을 라이브로 적용할 수 있습니다.18단계: 터미널을 열고 복제된 구성이 저장된 위치를 찾습니다. 복제된 구성의 루트 폴더에서 다음 명령을 실행합니다.Linux 또는 Mac:./tank push_configurationWindows:tank.bat push_configuration프롬프트에 따라 변경 사항을 적용하려는 구성인 프로젝트 기본 구성의 ID를 입력합니다.$ lscache		config		install		tank		tank.bat$ ./tank push_configurationWelcome to the Shotgun Pipeline Toolkit!For documentation, see https://support.shotgunsoftware.comStarting Toolkit for your current path'/Users/michelle/Documents/Shotgun/configs/the_other_side_clone2'- The path is not associated with any Shotgun object.- Falling back on default project settings.- Running as user 'Michelle'- Using configuration 'Primary Clone Config 2' and Core v0.18.159- Setting the Context to Project the_other_side.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary Clone Config 2') to another pipeline configuration in the project.By default, the data will be copied to the target config folder. If pass a--symlink parameter, it will create a symlink instead.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [1] Primary (/Users/michelle/Documents/Shotgun/configs/the_other_side)Please type in the id of the configuration to push to (ENTER to exit):복제된 구성을 적용할 수 있는 사용 가능한 파이프라인 구성 목록이 표시됩니다. 구성을 업데이트하려는 프로젝트에 대한 기본 파이프라인 구성의 ID를 입력합니다.                    참고: 이 안내서의 3단계에서 확인한 ShotGrid의 파이프라인 구성(Pipeline Configuration) 페이지에서 파이프라인 구성의 ID를 찾을 수도 있습니다. 프로젝트 ID를 찾으려면 구성 목록(Configuration List)으로 이동하고 ID 열을 추가하십시오.    ID를 입력하면 ShotGrid에서 다음 작업을 수행합니다.  기본 구성 백업  복제된 구성 복사  복제본을 그대로 둔 상태로 복제된 구성의 복사본을 프로젝트와 연결  기본 구성이 저장된 위치 표시  다운로드하고 캐시해야 할 앱이 있는지 여부 확인Please type in the id of the configuration to push to (ENTER to exit): 1Hold on, pushing config…Your old configuration has been backed up into the following folder:/Users/michelle/Documents/Shotgun/configs/the_other_side/config.bak.20190118_111627Checking if there are any apps that need downloading…Push Complete!기본 구성에서 수행한 변경 사항 표시19단계: ShotGrid 데스크톱의 오른쪽 위에 있는 화살표를 클릭하고 구성(CONFIGURATION) 목록에서 기본(Primary)을 선택합니다.20단계: 데스크톱에서 Maya를 실행하고 ShotGrid &amp;gt; 프로젝트(Project) &amp;gt; … 메뉴에서 ShotGrid Python 콘솔…(ShotGrid Python Console…)을 찾습니다.Python 콘솔 앱이 선택한 프로젝트의 프로젝트 환경에 추가되었습니다. 두 번째 안내서인 “구성 편집“에서 각 환경은 서로 독립적이고, 프로젝트마다 전용 구성이 있으며, 프로젝트가 로드될 때 소프트웨어 통합이 파이프라인 구성에서 설정을 수집한다는 것을 살펴봤습니다. 환경에서 Python 콘솔을 사용할 수 있으려면 app_locations.yml 파일에서 위치 설명자를 찾는 지침이 환경에 제공되어야 합니다. 이 점을 고려해 볼 때 파이프라인에서 Python 콘솔 앱을 사용할 수 있게 할 위치에 “여기서 Python 콘솔 앱 사용”과 같은 설정을 지정해야 합니다.고급 항목ShotGrid 개발자 커뮤니티툴킷의 놀라운 특징 중 하나는 모든 작업자가 툴킷 앱을 작성할 수 있다는 점입니다. 앱을 전용 앱으로 사용할 수도 있지만, ShotGrid 도구에 추가할 수 있도록 ShotGrid 커뮤니티에서 공유할 수도 있습니다. 뛰어난 앱을 만들었으며, 이 앱을 ShotGrid 커뮤니티 페이지에서 공유하고 싶다면 support@shotgunsoftware.com으로 이메일을 보내 주시기 바랍니다.표준 툴킷 앱과 ShotGrid 커뮤니티에서 생성된 앱에 대한 활발한 논의가 ShotGrid-dev Google 그룹에서 진행되고 있습니다. ShotGrid 커뮤니티에 새로운 정보 제공 사례가 늘어남에 따라 이러한 기술 및 도구 기반은 끊임없이 확장되고 있습니다.구성을 확장하는 방법 연구프로젝트에 사용할 구성을 선택할 때 Python 콘솔 앱을 ShotGrid 데스크톱 드롭다운에서 찾을 수 있다는 것을 아셨을 것입니다.파이프라인 구성에 추가하려는 앱을 사용하고 있는 환경이 있다면 간단한 탐색 작업을 거쳐 앱을 구성에 추가하는 데 필요한 정보를 찾을 수 있습니다. 환경의 구성 파일에서 앱이 사용되는 위치를 파악하면 앱 위치 설명자와 설정을 추가하는 방법을 확인할 수 있습니다.데스크톱 앱은 프로젝트 환경에서 열리므로 project.yml 파일에서 tk-desktop을 찾습니다.config/env/project.yml을 엽니다.                    참고: 엔진 블록에서 tk-desktop은 포함된 컨텐츠를 가리킵니다.includes:  - ./includes/settings/tk-desktop.ymlengines:  tk-desktop: &quot;@settings.tk-desktop.project&quot;includes:의 경로를 따라 config/env/includes/settings/tk-desktop.yml을 열고 settings.tk-desktop.project 블록을 찾습니다. 해당 블록에서 다음을 확인할 수 있습니다.apps:  tk-multi-pythonconsole:  location: &quot;@apps.tk-multi-pythonconsole.location&quot;이러한 블록은 프로젝트 단계에서 Python 콘솔 앱을 데스크톱 엔진에 추가합니다.includes의 경로를 ../includes/app_locations.yml까지 따라가 apps.tk-multi-pythonconsole.location을 검색하여 다음을 확인합니다.# pythonconsoleapps.tk-multi-pythonconsole.location:  type: app_store  name: tk-multi-pythonconsole  version: v1.1.2    모든 앱, 엔진 및 프레임워크에는 툴킷에 특정 번들에 액세스하는 위치를 알리는 데 사용되는 위치 설명자가 있습니다. 대부분의 앱 설명자는 app_locations.yml 파일에 있지만, Python 콘솔 앱에서 확인한 것처럼 원하는 위치에서 참조되지 않을 수도 있습니다. 모든 표준 앱 및 엔진이 앱 및 엔진 페이지에 정리되어 있습니다.Shotgun에서 지원하는 적합한 소프트웨어 통합에 앱을 추가할 수도 있고, 자신만의 전용 응용프로그램을 자체 툴킷 도구에 추가할 수도 있습니다. 지원되는 모든 소프트웨어 응용프로그램도 통합의 앱 및 엔진 페이지에 정리되어 있습니다.원하는 앱을 찾을 수 없는 경우 직접 작성할 수 있습니다. 다른 Shotgun 사용자도 동일한 기능을 필요로 할 수 있으므로 새로 만든 앱을 공유하는 것도 Shotgun 커뮤니티에 기여하는 한 가지 방법입니다.다음 안내서에서는 스튜디오의 구조에 따라 프로덕션 폴더 구조를 커스터마이즈하는 방법을 알아봅니다.",
    "url": "/4d147fb2/",
    "relUrl": "/4d147fb2/"
  },
  "47": {
    "id": "47",
    "title": "ShotGrid Integrations Admin Guide",
    "content": "ShotGrid Integrations Admin GuideIntroductionThis document serves as a guide for administrators of ShotGrid integrations. It’s one of three: user, admin, and developer. Our  User Guide  is intended for artists who will be the end users of ShotGrid integrations in their daily workflow, and our  Developer Guide  is technical documentation for those writing Python code to extend the functionality. This document falls between those two: it’s intended for those who are implementing ShotGrid integrations for a studio, managing software versions, and making storage decisions for published files.Standard Pipeline ConfigurationsAt the heart of any Toolkit setup is the Pipeline Configuration, a set of YAML files that manage everything from installed apps to software versions, and in some cases, even hold the templates for setting up your production directory structure and file names. The Pipeline Configuration is highly customizable, but we offer two starting points.The Basic ConfigOur out-of-the-box integrations are designed to run without the need to set up or modify any configuration files. When you use our out-of-the-box integrations, there’s nothing to administer, but Toolkit uses an implied Pipeline Configuration under the hood, and we call this Pipeline Configuration the Basic Config. The Basic Config makes three Toolkit apps – The Panel, Publisher, and Loader – available in all supported software packages, and looks to your Software Entities in ShotGrid to determine which software packages to display in ShotGrid Desktop. The Basic Config does not include filesystem location support. When you use out-of-the-box integrations on a project, your copy of the Basic Config is auto-updated whenever you launch Desktop, so you’ll always have the latest version of our integrations. You can  subscribe to release notes here, and  see the Basic Config in Github here.The Default ConfigThis is the default starting point for our Advanced project setup. It includes  filesystem location support  and a wider array of Toolkit apps and engines.You can  see the Default Config in Github here. For a detailed description of the Default Config’s structure, see the  config/env/README.md  file in your Pipeline Configuration, or  view it here in Github.If you’re familiar with the old structure of the Default Config, take a look at the  Default Config Update FAQ.                    Note: Looking for the old config structure? With the v1.1 release of Integrations, we reorganized the structure of the Default Config to help maximize efficiency and readability, and to make it match the Basic Config’s structure more closely You can still base projects on the legacy Default Config. Just choose ‘Legacy Default’ when prompted to select a configuration in the Desktop Set Up Project Wizard.    The PublisherThe Publisher is designed to ease the transition between the out-of-the-box workflow and the full pipeline configuration. In the out-of-the-box setup, files are published in place, which avoids the need to define templates or filesystem schema. Once a project has gone through the advanced setup and has a full Pipeline Configuration, the same publish plugins will recognize the introduction of templates to the app settings and begin copying files to their designated publish location prior to publishing. Studios can therefore introduce template-based settings on a per-environment or per-DCC basis as needed for projects with full configurations. The Default Config comes fully configured for template-based workflows and is a good reference to see how templates can be configured for the Publish app. See the  tk-multi-publish2.yml file  in the Default Config in Github for more info.For details on writing plugins for the Publisher, see the  Publisher section of our Developer Guide.Configuring software launchesIt’s simple to rely on ShotGrid’s auto-detection of host applications on your system: just launch ShotGrid Desktop, choose a project, and Desktop will display launchers for all supported software packages that it finds in standard application directories. But we also offer robust tools for more fine-grained management of the software in your studio. You can restrict application visibility to specific projects, groups, or even individual users. You can specify Versions, deactivate a given software package across your site, and group software packages together. All of this is managed through Software entities in ShotGrid.When you create a new ShotGrid site, it will have a set of default Software entities—one for each supported host application. You can modify these and add your own to manage the software that shows up in Desktop exactly how you want it.To see your Software entities in ShotGrid, open the Admin menu by clicking on the profile icon in the upper right corner of the screen, and choose  Software.The Software entity has the following fields:  Software Name:  The display name of the Software in Desktop.  Thumbnail:  Uploaded image file for Desktop icon.  Status:  Controls whether or not the Software is available.  Engine:  The name of the integration for the content creation tool.  Products:  For Software packages that include variants (e.g., Houdini vs. Houdini FX), you can specify a comma separated list here. Valid only in auto-detect mode, not manual mode.  Versions:  Specific versions of the software to display. You can specify a comma separated list here. Valid only in auto-detect mode, not manual mode.  Group:  Entities with the same value for the  Group  field will be grouped under a single icon in Desktop and a single menu in ShotGrid. For example, you could create an FX group that includes Houdini and Nuke.  Group Default: When one member of a group has  Group Default  checked, clicking the icon or menu item for the group will launch this software.  Projects:  A way to restrict software to certain projects.  User Restrictions:  A way to restrict software to certain users or groups.  Linux/Mac/Windows Path:  Use these fields to explicitly specify an OS-specific path to software.  Linux/Mac/Windows Args:  Commandline args to append to the command when launching the Software.We can learn a lot about how these fields work together by demonstrating some ways of using them.Example: Grouping versions of the same application, auto-detectSay you have three versions of Maya on your filesystem: Maya 2016, Maya 2017, and Maya 2018. You want to make all of these available to your artists, but you want them to be grouped under a single icon in Desktop.If these three versions of Maya are installed in the standard location on your filesystem, then this will all happen automatically. When you select a project in Desktop, it will scan the standard applications directory on the local machine, and will find the three versions. Since you already have a Maya software entity in ShotGrid, with no specific versions or paths specified, it will display all versions it finds in Desktop.A few things to note here:  When ShotGrid auto-detects your software, a single Software entity generates the menu items for all versions.  None of the Path fields have values specified. The Software entity is in auto-detect mode, so the App is assumed to be in the standard location.These will show up in Desktop as you see here: one icon for Maya, with a drop-down listing all the available versions. If you click on the icon itself, you’ll launch the latest version of Maya.Example: Grouping versions of the same application, manual modeIt’s perfectly fine to store Maya in a non-standard location in your studio. You’ll just need to create your own Software entities, and specify paths to let ShotGrid know where to find your software. Your setup may look like this:Some notes here:  Unlike in auto-detect mode, here you have a Software entity for each version of a given software package.  In order to group them together, use the  Group  and  Group Default  fields. Software entities that share the same value for  Group  will be grouped in Desktop in a dropdown under a single icon, which uses the  Group  value as its name.  When you click on that icon itself, you’ll launch the software within the group with  Group Defaultchecked.  When you specify a value for  any  of Linux Path, Mac Path, or Windows Path on a Software entity, that entity will shift to Manual mode.  Unlike auto-detect mode, where the software  would  show up in Desktop when a path field is empty, in manual mode, a software package will  only  show up on a given operating system if a path is specified for it and the file exists at the specified path.  In this example, none of the three Maya versions would show up in Desktop on Windows because no  Windows Path  has been specified.Example: Restrict by users or groupsNow, say with that last example that we’re not ready to make Maya 2018 available to all users just yet. But we do want TDs, Devs, and our QA engineer, Tessa Tester, to be able to access it. We can achieve this with the  User Restrictions  field. Here’s an example:We made a couple changes from the last example:  The group default is now Maya 2017. We want that to be the production version, so with that box checked, clicking the icon for Maya will now go to this version.  We’ve added a few values to the  User Restrictions  field: It can take both users and groups, and we’ve added our Dev and TD groups, as well as the user Tessa Tester. Now, only those people will see Maya 2018 in Desktop.Example: Restrict software versions by projectSometimes you want to do more complex version management across projects in your studio. You may have a project in a crunch to deliver, which you want to lock off from new versions of software, while at the same time, its sequel may just be starting up and able to evaluate newer versions. In this case, you may have your Software entities set up like this:A few important things to note:  We’ve removed the  Group  and  Group Default  values here, as only one Maya version will ever show up in Desktop for a given environment.  We’ve set the  Software Name  for all three versions to “Maya”. This way, on every project, users will have an icon with the same name, but it will point to different versions depending on what’s configured here.  We’ve set Maya 2016’s  Status  field to  Disabled. We are no longer using this version in our studio, and this field toggles global visibility across all projects.  We’ve specified values for  Projects  for Maya 2017 and Maya 2018. This  Projects  field acts as a restriction. Maya 2017 will  only  show up in the Chicken Planet project, and Maya 2018 will only show up in Chicken Planet II.  Note that once you’ve specified a value for  Projects  for a Software entity, that Software will only show up in the projects you’ve specified. So, if you have other projects in your studio in addition to the Chicken Planet series, you’ll need to specify software for them explicitly.Example: Add your own SoftwareThere are several reasons you might add a new software entity in addition to those that ShotGrid Desktop has auto-detected on your system:  You want to make an application for which there is no engine available to your users through Desktop.  You have in-house software, or third-party software that we don’t have an integration for, for which you’ve written your own engine.  Your software doesn’t live in a standard location, so you want to point ShotGrid to it manually. (This case was described in the “Grouping versions of the same Application, Manual mode” example above.)In these cases, you can add your own Software entities. You’ll need to have a value for the  Software Namefield. If you’re using an in-house engine for your software, specify the engine name in the  Engine  field. Some studios may want to include apps in Desktop that don’t have ShotGrid integrations, as a convenience for artists. Your artists can launch the app straight from Desktop. You can even use all of the settings above to manage versions and usage restrictions. In this case, leave the  Engine  field empty, but you’ll need to specify a value for at least one of  Mac Path,  Linux Path, and  Windows Path.Configuring published file path resolutionWhen you publish a file, the Publisher creates a PublishedFile entity in ShotGrid, which includes a  File/Link  field called  Path. Later on, a different user may try to load this file into their own work session using the Loader. The Loader uses complex logic to resolve a valid local path to the PublishedFile across operating systems.The way in which the Loader attempts to resolve the publish data into a path depends on whether the the publish is associated with a local file link or a  file://  URL.Resolving local file linksLocal file links are generated automatically at publish time if the path you are publishing matches any local storage defined in the ShotGrid Site Preferences. If the publish is a local file link, its local operating system representation will be used. Read more about local file links  here.If a local storage doesn’t define a path for the operating system you are currently using, you can use an environment variable to specify your local storage root. The name of the environment variable should take the form of  SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;. So, if you wanted to define a path on a Mac for a storage root called “Renders”, you’d create a  SHOTGUN_PATH_MAC_RENDERS  environment variable. Let’s go deeper with that example:  Say your ShotGrid site has a storage root called “Renders”, with the following paths specified:  Linux path:  /studio/renders/  Windows path:  S: renders       Mac path:  &amp;lt;blank&amp;gt;        You are on a Mac.    You want to load a publish with the path  /studio/renders/sq100/sh001/bg/bg.001.exr  into your session.The Loader can parse the path and deduce that  /studio/renders/  is the storage root part of it, but no storage root is defined for Mac. So, it will look for a  SHOTGUN_PATH_MAC_RENDERS  environment variable, and if it finds one, it will replace  /studio/renders  in the path with its value.Note:  If you define a  SHOTGUN_PATH_MAC_RENDERS  environment variable, and the local storage Renders  _does_have Mac path set, the local storage value will be used and a warning will be logged.Note:  If no storage can be resolved for the current operating system, a  PublishPathNotDefinedError  is raised.Resolving file URLsThe Loader also supports the resolution of  file://  URLs. At publish time, if the path you are publishing does not match any of your site’s local storages, the path is saved as a  file://  URL. Contrary to local file links, these paths are not stored in a multi-OS representation, but are just defined for the operating system where they were created.If you are trying to resolve a  file://  URL on a different operating system from the one where where the URL was created, the Loader will attempt to resolve it into a valid path using a series of approaches:  First, it will look for the three environment variables  SHOTGUN_PATH_WINDOWS,  SHOTGUN_PATH_MAC, and  SHOTGUN_PATH_LINUX. If these are defined, the method will attempt to translate the path this way. For example, if you are trying to resolve  file:///prod/proj_x/assets/bush/file.txt  on Windows, you could set up  SHOTGUN_PATH_WINDOWS=P: prod  and  SHOTGUN_PATH_LINUX=/prod  in order to hint the way the path should be resolved.  If you want to use more than one set of environment variables, in order to represent multiple storages, this is possible by extending the above variable name syntax with a suffix:  If you have a storage for renders, you could for example define  SHOTGUN_PATH_LINUX_RENDERS,  SHOTGUN_PATH_MAC_RENDERS, and  SHOTGUN_PATH_WINDOWS_RENDERS  in order to provide a translation mechanism for all  file://  URLs published that refer to data inside your render storage.  Then, if you also have a storage for editorial data, you could define  SHOTGUN_PATH_LINUX_EDITORIAL,  SHOTGUN_PATH_MAC_EDITORIAL, and  SHOTGUN_PATH_WINDOWS_EDITORIAL, in order to provide a translation mechanism for your editorial storage roots.Once you have standardized on these environment variables, you could consider converting them into a ShotGrid local storage. Once they are defined in the ShotGrid preferences, they will be automatically picked up and no environment variables will be needed.  In addition to the above, all local storages defined in the ShotGrid preferences will be handled the same way.  If a local storage has been defined, but an operating system is missing, this can be supplied via an environment variable. For example, if there is a local storage named  Renders  that is defined on Linux and Windows, you can extend to support mac by creating an environment variable named  SHOTGUN_PATH_MAC_RENDERS. The general syntax for this is  SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;.  If no root matches, the file path will be returned as is.Here’s an example:Say you’ve published the file  /projects/some/file.txt  on Linux, and a ShotGrid publish with the URL  file:///projects/some/file.txt  was generated. In your studio, the Linux path  /projects  equates to  Q: projects  on Windows, and hence you expect the full path to be translated to  Q: projects some file.txt.All of the following setups would handle this:  A general environment-based override:  SHOTGUN_PATH_LINUX=/projects  SHOTGUN_PATH_WINDOWS=Q: projects      SHOTGUN_PATH_MAC=/projects        A ShotGrid local storage called “Projects”, set up with:    Linux Path:  /projects  Windows Path:  Q: projects      Mac Path:  /projects        A ShotGrid local storage called “Projects”, augmented with an environment variable:    Linux Path:  /projects  Windows Path:`  Mac Path:/projects`  SHOTGUN_PATH_WINDOWS_PROJECTS=Q: projectsNote:  If you have a local storage  Renders  defined in ShotGrid with  Linux path  set, and also a  SHOTGUN_PATH_LINUX_RENDERS  environment variable defined, the storage will take precedence, the environment variable will be ignored, and a warning will be logged. Generally speaking, local storage definitions always take precedence over environment variables.Advanced configurationFor information on the underlying method that performs the resolution of PublishedFile paths, take a look at our  developer reference docs.If you are using Advanced Project Setup, you can add support beyond local file links and  file://  URLs by customizing the  resolve_publish  core hook. Possible customizations include:  Publishes with associated uploaded files could be automatically downloaded into an appropriate cache location by the core hook and the path would be be returned.  Custom URL schemes (such as  perforce://) could be resolved into local paths.Browser IntegrationBrowser integration for ShotGrid Toolkit refers to access to Toolkit apps and launchers by way of right-click context menus in the ShotGrid web application. These menus, an example of which is shown above, contain actions configured for various entity types. In the case where you have multiple pipeline configurations for a project, the actions are organized by pipeline configuration. Browser integration allows you to launch content creation software like Maya or Nuke that is aware of your ShotGrid context, right from the browser.A Brief History of Browser IntegrationOver the years, ShotGrid Toolkit’s browser integration has taken several forms. As technologies and security requirements have progressed, so has the approach to implementing browser integration.Java Applet (deprecated)The first implementation consisted of a Java applet that provided access to the local desktop from the ShotGrid web application. As Java applets became recognized as an exploitable security risk, they fell out of favor, necessitating its deprecation.Browser Plugin (deprecated)Replacing the deprecated Java applet was a browser plugin making use of NPAPI to access the local desktop from the ShotGrid web application. As NPAPI also became known as a security risk, the major web browsers began blocking its use. This necessitated deprecating the browser plugin.Websockets v1 via ShotGrid Desktop (legacy)Hosting a websocket server within the ShotGrid Desktop app was, and still is, the approach to communicating with the local desktop from the ShotGrid web application. The first implementation of this websocket server’s RPC API made use of the same underlying technology developed for the Java applet and browser plugin before it. When the server received a request from ShotGrid, the tank command from the associated project’s pipeline configuration was used to get the list of commands to show in the action menu.Websockets v2 via ShotGrid DesktopThe second iteration of the websocket server’s RPC API changes the underlying mechanism used to get, cache, and execute Toolkit actions. This implementation addresses a number of performance issues related to the earlier browser integration implementations, improves the visual organization of the action menus, and adds support for  out-of-the-box ShotGrid Integrations, which work without explicitly configuring Toolkit. This is the current implementation of browser integration.ConfigurationTo control what actions are presented to the user for each entity type, you modify YAML environment files in your project’s pipeline configuration. There are a few things to understand and consider when first attempting customization.Which engine configuration?The Toolkit engine that manages Toolkit actions within the ShotGrid web app is  tk-shotgun, so it’s this engine’s configuration that controls what shows up in the action menus.In the above example from  tk-config-basic, there are two apps configured that will result in a number of engine commands turned into menu actions. Toolkit apps will register commands that are to be included in the action menu, including launcher commands for each software package found on the local system that correspond to the list of  Software entities  in the ShotGrid site. The result is the list of menu actions shown here:The browser integration code found installations of Houdini, Maya, Nuke, and Photoshop on the user’s system, which resulted in menu actions for launching each of those integrations. Note that in a given environment configuration file, the  engine  for a Software entity needs to be present in order for that Software’s launcher to show up for entities of that environment. So, in this example, the  tk-houdini,  tk-maya,  tk-nuke, and  tk-photoshopcc  engines must all be present in the file from which this snippet was taken. If you wanted to remove, for example, Maya from the list of launchers on this entity, you could just remove the  tk-maya  engine block from the environment config file.In addition to these launchers, the Publish app’s “Publish…” command is included in the menu.Which YML file?You can take one of two paths: making use of the primary environment configuration (config/env/*.yml), as controlled by the config’s  pick_environment.py core hook, or the legacy approach employed by  tk-config-default, which uses  config/env/shotgun_&amp;lt;entity_type&amp;gt;.yml  files.In the case where the standard environment files are used, browser integration uses the  pick_environmentcore hook to determine which environment configuration file to use for a given entity’s action menu. In the simplest case, the environment corresponds to the entity type. For example, if you right-click on a Shot, the resulting action menu will be configured by the  tk-shotgun  block in  config/env/shot.yml. You can customize the  pick_environment  hook to use more complex logic. Should there be no  tk-shotgun  engine configured in the standard environment file, a fallback occurs if a  shotgun_&amp;lt;entity_type&amp;gt;.yml  file exists. This allows browser integration to work with legacy configurations that make use of the entity-specific environment files.Tip: Removing Software from the Browser Launchers with tk-config-default2Updating the configuration for launching software from the ShotGrid browser varies from tk-config-default to tk-config-default2.With tk-config-default2, updates should be applied to config/env/includes/settings/tk-shotgun.yml, whereas in tk-config-default, they were done in config/env/shotgun_task.yml.As an example, let’s remove Mari from the list of options when launching from an Asset through the browser.First, navigate to  config/env/asset.yml  and notice how the  tk-shotgun  engine engine block is pointing to  @settings.tk-shotgun.asset. The  @  symbol signifies that the value for the configuration is coming from an included file. This means you’ll need to go to your  env/includes/settings/tk-shotgun.yml  to make the update.While in your  env/includes/settings/tk-shotgun.yml, notice how each block is per Entity. So, for instance, Asset first:&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;To remove Mari from the list of options on an Asset in the browser, remove the Mari line (tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;):&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;Then, follow the same instructions for each entity (like Shot) from which you’d like to remove the ability to launch a particular software in the ShotGrid browser. Note that once you save the file, you may need to wait a minute and hard-refresh the browser for it to take effect.CachingBrowser integration has a robust caching mechanism, which allows menu actions to be shown to the user as quickly as possible. This is necessary because the process of bootstrapping Toolkit and getting a list of engine commands can be time consuming.When is the cache invalidated?The websocket server’s RPC API looks at two things to determine whether the cached data is still valid: YAML file modification times, and the contents of the site’s Software entities. If one of the environment YAML files in a given config has been modified since the cache data was written, the requisite data is recached and fresh data returned to the ShotGrid web application. Similarly, if any field on any Software entity in ShotGrid has been modified since the data was cached, Toolkit is bootstrapped and new data is cached.Where is the cache file on disk?The cache file location is dependent upon the operating system.`OS X: ~/Library/Caches/Shotgun/&amp;lt;site_name&amp;gt;/site.basic.desktop/tk-desktopWindows: %APPDATA% Shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopLinux: ~/.shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopHook MethodsA  browser_integration.py  hook is included in  tk-framework-desktopserver, which provides the following hook methods:  get_cache_key: This method determines the cache entry’s key for the given configuration URI, project entity, and entity type. The default implementation combines the configuration URI and entity type.  get_site_state_data: This method can be used to include additional queried data from ShotGrid into the hash that’s used to test the validity of cached data. By default, the state of all Software entities that exist on the site are used, but if additional data should be included in the hash, that can be implemented in this hook method.  process_commands: This method provides a place to customize or alter the commands that are to be returned to the ShotGrid web application. The data structure provided to the method is a list of dictionaries, with each dictionary representing a single menu action. Data can be altered, filtered out, or added into the list as is necessary and will be reflected in the menu requesting Toolkit actions immediately.LogsLogs for browser integration can be found in Toolkit’s  standard log location. The relevant log files are  tk-desktop.log  and  tk-shotgun.log. In addition, if you are using Google Chrome, some relevant log output is sometimes available in the developer console within the browser.TroubleshootingThe complex nature of communicating from a web application with the local desktop means that there are possible points of failure along the way. Below are a few such situations and some suggestions of first steps to take when you encounter them.“Open or install ShotGrid Desktop…” shown in the action menuThis likely means one of three things:      ShotGrid Desktop is not currently running on the local machine. It seems obvious, but it is definitely worth double checking.        Chrome or the Python websocket server has refused the connection, resulting in the ShotGrid web application being unable to communicate with ShotGrid Desktop. This situation is most likely related to the self-signed certificates that allow the connection to proceed when requested. Regenerating these certificates from scratch often resolves the issue, and can be triggered from ShotGrid Desktop, as shown below.    ShotGrid Desktop’s websocket server failed to start on launch. This situation is likely limited to situations where a bad release of the websocket server has gone out to the public, which should be exceedingly rare. In this situation, logging will be present in  tk-desktop.log  explaining the error, which can be  sent to ShotGrid’s support team.No actions are shown in the action menuThis is indicative of a configuration problem if actions were expected for this entity type. Some possible issues:      The  tk-shotgun  engine is configured in the correct environment YAML file, but there are no apps present in that configuration. In this case, it’s likely that the intention was for no actions to be present for this entity type.        The  tk-shotgun  engine is configured in the correct environment YML file, and apps are present, but actions still do not appear in the menu. This is likely due to apps failing to initialize. In this case, there will be information in  tk-shotgun.log and tk-desktop.log  describing the problems.        The environment that corresponds to this entity type does not contain configuration for  tk-shotgun. The end result here is the same as #1 on this list. In this case, you can look at the pipeline configuration’s  pick_environment  hook to determine which environment is being loaded for this entity type, and the configuration of  tk-shotgun  can be verified there.        There is an empty list of menu actions cached on disk. To force the cache to be regenerated, there are a few options:          Update the modification time of a YAML file in your project’s configuration. This will trigger a recache of menu actions when they are next requested by ShotGrid. Worth noting is that this will trigger a recache for  all  users working in the project.      Update the value of a field in any of the Software entities on your ShotGrid site. The behavior here is the same as the above option concerning YAML file modification time, but will invalidate cached data for all users in  all  projects on your ShotGrid site. Software entities are non-project entities, which means they’re shared across all projects. If data in any of the Software entities is altered, all projects are impacted.      The cache file can be deleted on the host suffering from the problem. It is typically safe to remove the cache, and since it is stored locally on each host, it will only cause data to be recached from scratch on that one system. The cache is stored in the following SQLite file within your ShotGrid cache location:  &amp;lt;site-name&amp;gt;/site.basic.desktop/tk-desktop/shotgun_engine_commands_v1.sqlite      “Toolkit: Retrieving actions…” is never replaced with menu actionsThere are a few possibilities for this one:      The websocket server has not yet finished caching actions. If this is the first time actions are being retrieved after a significant update to the project’s config, the process can take some time to complete. Wait longer, and observe the contents of  tk-desktop.log  to see if processing is still occurring.        The websocket server has failed to respond and never will. This situation should be rare, but if it becomes obvious that there is no additional processing occurring as a result of the request for actions, as seen in  tk-desktop.log,  contact ShotGrid support, providing relevant log data.        The user is working in more than one ShotGrid site. With ShotGrid Desktop authenticated against a single site, requesting menu actions from a second ShotGrid site results in the user being queried about restarting ShotGrid Desktop and logging into the new site. If that request is ignored, the second site will never receive a list of menu actions.  Toolkit Configuration FileIf your studio is using a proxy server, if you want to pre-populate the initial login screen with some values, or if you want to tweak how the browser-based application launcher integrates with ShotGrid Desktop, there is a special configuration file called  toolkit.ini. ShotGrid Desktop does not require this file in order to run; it’s only needed if you need to configure its behavior. Toolkit looks for the file in multiple locations, in the following order:  An environment variable named  SGTK_PREFERENCES_LOCATION  that points to a file path.  Inside the ShotGrid Toolkit preferences folder: (Note that this file does not exist by default in these locations; you must create it.)          Windows:  %APPDATA% Shotgun Preferences toolkit.ini      macOS:  ~/Library/Preferences/Shotgun/toolkit.ini      Linux:  ~/.shotgun/preferences/toolkit.ini      The  SGTK_PREFERENCES_LOCATION  environment variable option allows you to store your configuration file somewhere else on your computer or on your network. Please note that  toolkit.ini  is the current standard file name. If you were using  config.ini, check below in the  “Legacy Locations”  section.You can see a documented example of a configuration file  here.Please note that this example file is called  config.ini  but it can be just renamed to  toolkit.iniPlease also note that you can use environment variables as well as hard coded values in this file, so that you could, for example, pick up the default user name to suggest to a user via the USERNAME variable that exists on Windows.Legacy Locations (DEPRECATED)Although  toolkit.ini  is the current standard file name, we previously used a  config.ini  file for same purpose. The contents of  toolkit.ini  and  config.ini  are the same. The  config.ini  will be searched for using the following deprecated locations:  An environment variable named  SGTK_DESKTOP_CONFIG_LOCATION  that points to a file.  In the following paths:          Windows:  %APPDATA% Shotgun desktop config config.ini      macOS:  ~/Library/Caches/Shotgun/desktop/config/config.ini      Linux:  ~/shotgun/desktop/config/config.ini      Proxy ConfigurationIf your studio is accessing the internet through a proxy, you’ll need to tell Toolkit to use this proxy when it accesses the Internet. Do so by specifying your proxy as the value of the  http_proxy  setting:http_proxy: &amp;lt;proxy_server_address&amp;gt;Running ShotGrid Desktop with a locally hosted siteIf your ShotGrid site URL does not end with  shotgunstudio.com or shotgrid.autodesk.com, it means that you are running a local ShotGrid site. In this case, it is possible that your site has not yet been fully prepared for ShotGrid integrations and the ShotGrid team may need to go in and do some small adjustments before you can get going! In this case,  please submit a ticket  and we’ll help sort you out.Connecting to the app store with a locally hosted siteIf you are using a local ShotGrid site with access to the Internet through a proxy, you might want to set an HTTP proxy for accessing the app store, but not the local ShotGrid website. To do this, simply add the following line to  toolkit.ini:app_store_http_proxy: &amp;lt;proxy_server_address&amp;gt;where  &amp;lt;proxy_server_address&amp;gt;  is a string that follows the convention documented  in our developer docs.If you need to override this setting on a per-project basis, you can do so in  config/core/shotgun.yml  in your project’s Pipeline Configuration.Offline Usage ScenariosIn general use, ShotGrid Desktop automatically checks for updates for the Desktop app itself, the tk-desktop engine, and the basic configuration at launch time. However, there are cases where you might want to run integrations while offline or on machines that are completely disconnected from the Internet. The following section describes how to address each of these scenarios.ShotGrid CreateThe approaches to resolving offline usage scenarios outlined in this document also apply to the integration features provided by  ShotGrid Create. The various environment variables used to tailor the behavior of ShotGrid Toolkit, such as  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS, apply when using ShotGrid Create in the same ways as ShotGrid Desktop.Running integrations while offlineScenario: I want to run ShotGrid integrations, but I am not connected to the Internet. We have a local ShotGrid install.Solution  If you can temporarily connect to the internet, just download ShotGrid Desktop. It comes prepackaged with a set of  integrations, and pre-bundled with all the apps and engines needed for the ShotGrid integrations for all supported DCCs. When you start it up, it will automatically try to look for upgrades, but if it cannot connect to the ShotGrid App Store, it will simply run the most recent version that exists locally.Good to know  Some Toolkit operations (such as registering a Publish) require access to your ShotGrid site. So, this solution only works for locally hosted sites.  Updates are downloaded to your local machine.  If you switch between being connected and disconnected, Desktop, as well as in-app integrations like those inside Maya and Nuke, will download upgrades at startup whenever they are connected.Managing updates via manual downloadScenario: Our artist workstations are disconnected from the internet, so we cannot use the auto-updates in Desktop. We still want to get updates, but we have to download them via a single online machine and manually transfer them to artists or into a centralized location.Solution  Run ShotGrid Desktop on a workstation connected to the internet. When it starts up, the latest upgrades are automatically downloaded at launch time.  Option 1: Shared Desktop bundle  Copy the  bundle cache  to a shared location where all machines can access it.  Set the  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS  environment variable on offline machines to point to this location.  When Desktop starts up on offline machines, they will pick up the latest upgrades that are available in the bundle cache.  Option 2: Local deployment  Distribute the updated bundle cache to the correct bundle cache location on each local machine.Good to know  With Option 1, the Toolkit code will be loaded from the location defined in  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS. If this location is on a shared storage, make sure that it is performant enough to load many small files.  For Windows setups, this is often not the case. Here we would instead recommend Option 2.Locking off updatesWhile Desktop’s auto-updates are handy for making sure you always have the latest, sometimes you’ll want to freeze a project, or even your whole site, locking it to a specific version and preventing any updates.Freezing updates for a single projectScenario: My project is about to wrap and I would like to freeze it so that no ShotGrid integration updates are automatically downloaded.Solution  Determine the version you want to lock your project to.  You can find the integration releases here.  In ShotGrid, create a Pipeline Configuration entity for the project you want to lock down, with the following fields populated (In this example, we are locking down the config to use v1.0.36 of the integrations):  Name:  Primary  Project: The project you want to lock down  Plugin ids:  basic.*      Descriptor:  sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36    Anyone starting ShotGrid Desktop on the project will now always use v1.0.36. Any new users starting to work on the project will also get v1.0.36.Good to know  Updates are downloaded to your local machine.  The next time a user launches Desktop while connected to the Internet,  v1.0.36  of the basic config, and all of its related code, will be downloaded to their machine.  basic.*  means that all plugins in the basic configuration will pick up this override. If, for example, you wanted to freeze the Nuke and Maya integrations only, you could specify  basic.maya, basic.nuke.  To test, you can create a duplicate of this Pipeline Configuration entity, and add your username to the  User Restrictions  field. This will restrict the entity such that it’s only available to you and won’t impact other users. You can then launch Maya or some other software from this duplicate configuration and confirm that it’s running the expected integrations versions.Known issues  The Flame integration is namespaced  basic.flame, and so is implied to be part of  basic.*. However, the Flame integration isn’t actually included in the basic config. So, if you are using Flame for a project and implement this override, the Flame integration will stop working.  The solution would be to create an additional Pipeline Configuration override specifically for flame:  Name:  Primary  Project: The project you want to lock down (or None for all projects)  Plugin ids:  basic.flame  Descriptor:  sgtk:descriptor:app_store?name=tk-config-flamepluginFreezing updates for your siteScenario: I don’t want any updates. I want full control over what is being downloaded and used in all projects in my studio.Solution  Follow the steps in the above example, but leave the  Project  field blank. With no override in the  Project  field, this Pipeline Configuration entity will apply to all projects, including the “site” project, i.e., the site configuration that is used by Desktop outside of any project.Good to know  This is the workflow to use if you want to “lock down the site config”. This would lock down everything, and you can then proceed with the advanced project setup via the Desktop menu.  If you lock down your entire site to use, for example,  v1.2.3, you can still lock down an individual project to use another config.Known issues  Flame would be affected by this. See the ‘Known Issues’ section of the above scenario for a solution.Freezing updates for all but one projectScenario: I’d like to lock down all projects in our site, except for our test project, which we still want to allow to auto-update.Solution  Freeze updates for your site as described in the above section.  Configure the exception project’s Pipeline Configuration entity to have the following field values:  Name:  Primary  Project: The project you want  not  to lock down  Plugin ids:  basic.*  Descriptor:  sgtk:descriptor:app_store?name=tk-config-basicGood to know  Note that you’ve omitted the version number from the Descriptor field for the project. This will mean that the project is tracking the latest release of the basic config.Safely Upgrading a locked off site  Scenario: We’re locked down to v1.0.0, and we’d like to upgrade to v2.0.0, but first I want to test out the new version before deploying it to the studio.*Solution  Duplicate the Pipeline Configuration entity in ShotGrid by right-clicking on it and selecting “Duplicate Selected”.  Name the cloned config “update test”, and assign yourself to the User Restrictions field.  You will now begin to use this Pipeline Configuration.  Change the descriptor to point to the version you wish to test.  You can invite any users you want to partake in testing by adding them to the User Restrictions field.  Once you are happy with testing, simply update the main Pipeline Configuration to use that version.  Once users restart Desktop or DCCs, the update will be picked up.Taking over a Pipeline ConfigurationWithout setting up any configurations, you get a basic set of ShotGrid integrations out-of-the-box, and this document covers the kinds of administration you can do with these out-of-the-box integrations. This basic setup is built on top of ShotGrid’s Toolkit platform, which supports much richer customization. Within Desktop, the Toolkit Project Setup Wizard will lead you through the process of creating a full, customizable Pipeline Configuration for your project.Each section below explains in detail each of the steps of the Wizard with examples and suggestions of sensible default values in case you are not sure how to set things up.Launching the setup wizard from DesktopOnce you have navigated to a project there will be an “Advanced Project Setup…” menu item in the user menu in the bottom right hand of Desktop. Click on this menu item to launch the Toolkit Setup Wizard.Select a configuration typeWhen you start configuring a new project, the first thing to decide is  which configuration template to use. A configuration template is essentially the complete project configuration with all settings, file system templates, apps and logic needed to run the project.  If this is your very first project, head over to the ShotGrid defaults to get you started.  If you already have configured projects and configurations for previous projects, you can easily reuse these by basing your new project on an existing project  For advanced workflows, you can use external configurations or configs stored in git repositories.Default configuration templatesThis is the place to go if you want to start from scratch. The default configuration contain all the latest apps and engines set up with a default file structure and file naming convention.Once you have installed the default configuration, you can manually tweak the configuration files and customize it to fit the specific needs of your pipeline. Once you have got a project up and running, you can base your next project on this configuration.The Default ConfigurationThis is the default Toolkit VFX configuration and usually a great starting point when you start setting things up. It comes with 3dsmax, Flame, Houdini, Nuke, Mari, Maya, Motionbuilder, and Photoshop set up and contains a simple, straight forward folder setup on disk.The configuration contains a number of different pieces:  A file system setup  A set of templates to identify key locations on disk  A set of preconfigured engines and apps which are chained together into a workflow.File System OverviewThe standard config handles Assets and Shots in ShotGrid. It breaks things down per Pipeline Step. A pipeline step is similar to a department. Each pipeline step contains work and publish areas for the various supported applications. The Shot structure looks like this:Applications and workflowsThe config contains the following components:  Maya, Mari, Nuke, 3dsmax, Flame, Houdini, Photoshop, and Motionbuilder support  ShotGrid Application Launchers  Publishing, Snapshotting, and Version Control  A Nuke custom Write Node  ShotGrid integration  A number of other tools and utilitiesIn addition to the apps above, you can easily install additional apps and engines once the config has been installed.Basing your new project on an existing projectThis is a quick and convenient way to get up and running with a new project with all the defaults and settings that you had in a previous project. Toolkit will simply copy across the configuration from your old setup to the new project. This is a simple and pragmatic way to evolve your configuration - each new project is based on an older project.For more ways and documentation on how to evolve and maintain your pipeline configuration, see here:Managing your project configurationUsing a configuration template from gitUse this option if you want to keep your project’s configuration connected to source control. Specify a url to a remote git or github repository and the setup process will clone it for you. Note that this is not just github, but works with any git repository. Just make sure that the path to the repository ends with  .git, and Toolkit will try to process it as a git setup. Because your project configuration is a git repository, you can commit and push any changes you make to your master repository and beyond that to other projects. Using a github based configuration makes it easy to keep multiple Toolkit projects in sync. You can read more about it here:Managing your project configurationPlease note that if you are running on Windows, you need to have git installed on your machine and accessible in your  PATH. On Linux and Mac OS X, it is usually installed by default.Browsing for a configuration templateUse this option if you have a configuration on disk, either as a folder or zipped up as a zip file. This can be useful if someone has emailed a configuration to you or if you keep a master config on disk which you are basing all your projects on. This is usually an expert option and we recommend either using a config from another project or one of our app store default configs.Setting up a storageEach Toolkit project writes all its files and data to one or more shared storage locations on disk. For example, a configuration may require one storage where it keeps textures, one where it keeps renders and one where it stores scene files. Normally, these storages are controlled from within the ShotGrid Site Preferences, under the  File Management  tab.The Toolkit Setup wizard will ask you to map each storage root required by the configuration to a local storage in ShotGrid.The required root is listed on the left with its description (as defined in the configuration’s  roots.yml  file). On the right, a list of existing ShotGrid local storages is listed. You must select a storage for each required root and enter a path for the current OS if one does not already exist in ShotGrid.You can also add paths for other operating systems that have not been defined. Existing paths are locked to ensure you don’t accidentally affect other projects that may be relying on that storage path. The mapping page in the wizard will ensure that you’ve mapped each required root and that each mapping is valid.You can create a new local storage in the wizard as well by selecting the  +New  item at the end of the storage selection list. You will be prompted for a local storage name and path for the current OS.Once the project is being set up, Toolkit will create a folder for each new project in each of the storage locations. For example, if your primary storage location is  /mnt/projects, a project called  The Edwardian Cry  would end up in  /mnt/projects/the_edwardian_cry. And if the config is using more than just the primary storage, each of the storages would end up with an  the_edwardian_cry  folder.Your primary storage location is typically something like  /mnt/projects  or    studio projects  and is typically a location where you are already storing project data, grouped by projects. It is almost always on a shared network storage.Choosing a project folder nameNow it is time to choose a disk name for your project. This folder will be created in all the different storages which are needed by the configuration. You can see a quick preview in the UI - for most configurations this will only preview the primary storage, but if you are using a multi root config, additional storages will show up too. Toolkit will suggest a default project name based on the name in ShotGrid. Feel free to adjust it in order to create what is right for your setup.Selecting a configuration locationLastly, please decide where to put your configuration files on disk. Toolkit will suggest a location based on previous projects, so that they all end up in the same place on disk.The configuration normally resides on a shared storage or disk, so that it can be accessed by all users in the studio who needs it. If you are planning on using more than one operating system for this project, make sure to enter all the necessary paths. All paths should represent the same location on disk. Often, the path can be the same on Mac OS X and Linux but will be different on Windows.If this is your first project, you typically want to identify a shared area on disk where you store all your future pipeline configurations. This is typically a location where you store software or software settings shared across the studio. This could be something like  /mnt/software/shotgun. It may vary depending on your studio network and file naming conventions.When you set up your first configuration, set it up with paths for all the platforms you use in your studio. This will make it easier later on to create an environment which is accessible from all machines. As a hypothetical example, if your project name is  Golden Circle  you may type in the following three paths:linux:   /mnt/software/shotgun/golden_circlemacosx:  /servers/production/software/shotgun/golden_circlewindows:   prod software shotgun golden_circleWhat can I do once I have a configuration?Once you are up and running with your first configuration, please navigate to our ‘next steps’ documentation to learn more about how to configure and adjust Toolkit to better suite your studio needs:Beyond your first projectYou can also learn more in our  Advanced Project Setup documentation.Advanced functionalitySilent installsIf you are on a Windows network, you can use the argument “/S” to force the .exe ShotGrid Desktop installer to do a silent install. Then you can push a copy of the shortcut to the executable to the startup folder.",
    "url": "/8085533c/",
    "relUrl": "/8085533c/"
  },
  "48": {
    "id": "48",
    "title": "통합",
    "content": "RV 통합RV는 서로 다른 기능 세트를 가진 여러 ShotGrid 통합(ShotGrid Integration, RV용 Screening Room 및 ShotGrid Review)을 비롯해 Nuke 및 Maya를 위한 통합 도구가 함께 제공됩니다.앞쪽의 두 문서에서는 Nuke 및 Maya 통합의 설치 및 워크플로우에 대해 설명하며, 뒤쪽의 두 문서에서는 선택에 도움을 주기 위해 다양한 ShotGrid 통합에 대해 설명합니다.",
    "url": "/268002fe/",
    "relUrl": "/268002fe/"
  },
  "49": {
    "id": "49",
    "title": "Knowledge",
    "content": "Generic KnowledgeIn This Section  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/540597cc/",
    "relUrl": "/540597cc/"
  },
  "50": {
    "id": "50",
    "title": "Learn",
    "content": "ShotGrid Isolation - LearnThis section will host a learning curriculum for ShotGrid Isolation features n the near future.",
    "url": "/da5a2d10/",
    "relUrl": "/da5a2d10/"
  },
  "51": {
    "id": "51",
    "title": "Maya에서 툴킷 앱 실행을 위한 선반 버튼을 추가하려면 어떻게 해야 합니까?",
    "content": "Maya에서 툴킷 앱 실행을 위한 쉘프 버튼을 추가하려면 어떻게 해야 합니까?Maya에서 툴킷 앱을 실행하기 위한 선반 버튼을 Maya에 추가하는 작업은 정말 간단합니다. 다음은 Loader 앱을 여는 커스텀 쉘프 버튼을 추가하는 방법을 보여 주는 예입니다.                    참고: 이 예는 툴킷이 현재 Maya 세션에서 활성화되어 있다고 가정한 것입니다. 이 예제 코드는 툴킷을 부트스트랩하지 않습니다.    Maya에서 스크립트 편집기를 열고 다음 Python 코드를 붙여 넣습니다. import maya.cmds as cmds# Define the name of the app command we want to run.# If your not sure on the actual name you can print the current_engine.commands to get a full list, see below.tk_app = &quot;Publish...&quot;try:    import sgtk    # get the current engine (e.g. tk-maya)    current_engine = sgtk.platform.current_engine()    if not current_engine:        cmds.error(&quot;ShotGrid integration is not available!&quot;)    # find the current instance of the app.    # You can print current_engine.commands to list all available commands.    command = current_engine.commands.get(tk_app)    if not app:        cmds.error(&quot;The Toolkit app '%s' is not available!&quot; % tk_app)    # now we have the command we need to call the registered callback    command['callback']()except Exception, e:    msg = &quot;Unable to launch Toolkit app '%s': %s&quot; % (tk_app, e)    cmds.confirmDialog(title=&quot;Toolkit Error&quot;, icon=&quot;critical&quot;, message=msg)    cmds.error(msg)이 코드를 선택하고 커스텀 쉘프로 끌어다 놓습니다. 커스텀 쉘프 버튼으로 작업하는 방법에 대한 자세한 정보는 Maya 설명서를 참조하십시오.이 코드 예를 사용하면 위쪽에 있는 tk_app 및 call_func 값을 수정하여 Maya에서 활성화되어 있는 툴킷 앱을 실행할 수 있을 것입니다.",
    "url": "/dba779a5/",
    "relUrl": "/dba779a5/"
  },
  "52": {
    "id": "52",
    "title": "Media Isolation",
    "content": "Media IsolationMedia Isolation allows your studio to retain ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid is stored in your studio’s private S3 Bucket. Access to the media is provided to the ShotGrid services only, using AWS AssumeRole keyless Security Token Service.Client-Owned S3 BucketStoring media and attachments in an S3 bucket that you own means that you remain the legal owner of these artifacts, allowing you to comply with your company’s security and legal policies. Your studio retains control of asset storage and access, access that you can revoke at will.More about AccessWhen using ShotGrid to upload and download media it is transferred directly to / from AWS S3 without transiting through Autodesk infrastructure. ShotGrid will only access media in two situations:  The ShotGrid Transcoding service will get read/write access once, soon after upload, when transcoding the media. See Ephemeral Transcoding for details.  When the ShotGrid service generates S3 Links to your sources and transcoded media.This is rendered possible by leveraging AWS AssumeRole keyless Security Token Service. When setting up Media Isolation, an AWS Role allowing ShotGrid to access your media for the action listed above is created, and the ShotGrid service is allowed to assume that role.ShotGrid Support staff do not have access to your S3 Bucket under any circumstances.CostsWhen activating Media Isolation the following costs, previously covered by Autodesk, become the responsibility of the client:  S3 Costs. All the S3 storage costs will be assumed by the customer. See Media Isolation for more details about how to reduce costs.  S3 Bandwidth. Bandwidth out of the S3 bucket will be assumed by the customer.What Media Isolation is not providingActivating Media Isolation doesn’t guarantee that the access to your ShotGrid site or media takes place within a closed network.",
    "url": "/a3c0e676/",
    "relUrl": "/a3c0e676/"
  },
  "53": {
    "id": "53",
    "title": "Media Replication",
    "content": "Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.Pre-requisitesMedia Isolation is required in order to elect Media Replication.Configuration by usersWhen using Media Replication, each user can customize which region data is read from. A user can either specify the region to use, or use automatic mode. In automatic mode ShotGrid selects the replica determined by the user’s IP address using IP ranges specified in the Isolation Preferences.How it worksShotGrid can be configured to read from up to two different buckets. Using the AWS S3 Replication feature, you can configure replication between buckets in different regions, and then consume media from the region closest to your users. It is important to underline that media is always uploaded to the main bucket.Following AWS service level agreement, S3 guarantees the replication of 99.99% of the object within 15 minutes.Replication DelayA small amount of time, typically under 15 minutes, is required before replication happens. The replication time depends on the size of the object to replicate. In order to alleviate that replication delay, ShotGrid will, for a small period of time, generate links from to object in the source bucket instead of the replica. The duration of this transitional state in configurable in the Isolation Preferences.CostsActivating the Media Replication feature can increase your AWS costs considerabibly. Before activating, be aware that:  Your S3 cost linked to ShotGrid usage will more or less double, because the media is now stored in two regions.  You will be charged for the transfer cost between the source and the destination region. See AWS S3 CRR and the destination region for more details.Next StepsSee Media Replication Setup for setup instructions.",
    "url": "/0221297e/",
    "relUrl": "/0221297e/"
  },
  "54": {
    "id": "54",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic Isolation using AWS PrivateLink for Amazon S3                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS regionYou will need to deploy a VPC with the required VPC endpoint. We provide a private VPC CloudFormation templates as starting points. This template create the necessary VPC, subnets and VPC endpoint.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc-s3-privatelink.yml  Click Next  Set a stack name. Eg. ShotGrid-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used.    Simply add an com.amazonaws.us-west-2.s3 Interface VPC Endpoint to your existing VPC. Make sure the associated security group allow traffic from your site network.Add the VPC to your S3 bucket policyIn order for the S3 VPC endpoint to communicate with your S3 bucket your bucket policy must allow access from the S3 endpoint’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 VPC endpointUse the endpoint URL to list objects in your bucket using AWS CLI. In the following example, replace the VPC endpoint ID vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com and bucket name my-bucket with appropriate information.    aws s3 --endpoint-url https://bucket.vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com ls s3://my-bucket/Configure your test site to use your S3 VPC endpoint  Navigate to the Site Preferences menu within ShotGrid and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Web Traffic Isolation to activate the Web Traffic Isolation feature.See Media Replication to activate the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/2ab85e3e/",
    "relUrl": "/2ab85e3e/"
  },
  "55": {
    "id": "55",
    "title": "Media Traffic Isolation - S3 Proxy",
    "content": "                    Deprecated: The preferred way is to use S3 Private Link instead of a S3 proxy, see Media Traffic Isolation    Media Traffic Isolation using an S3 proxy (DEPRECATED)                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS region                    Disclaimer: Before starting, decide whether your S3 proxy will be privately accessible within your VPC or publicly accessible via the Internet and choose the relevant templates in the following instructions.    You will need to deploy a VPC with the required VPC endpoints. We provide both private VPC and public VPC CloudFormation templates as starting points. These template create the necessary VPCs, subnets and VPC endpoints.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private VPC (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc.yml      Public VPC:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-public-vpc.yml        Click Next  Set a stack name. Eg. shotgun-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used when configuring Media Isolation.    Set up S3 proxyYou will need to deploy an S3 proxy in your VPC to forward traffic to the S3 VPC endpoint. We provide both private and public S3 proxy CloudFormation templates as starting points for this purpose. These will create the necessary Elastic Container Service (ECS) cluster and other resources to run the S3 proxy on AWS Fargate behind an AWS Application Load Balancer (ALB).Make the Docker image available from a private AWS ECR repository  Create a new Elastic Container Registry (ECR) repository  Name the repository s3-proxy  Upload the s3-proxy Docker image to the newly created ECR repository          Install Docker on your workstation      Follow the docker login instructions shown by clicking the View push commands button      Run the following commands, substituting the ECR endpoint in the example for yours:        docker pull quay.io/shotgun/s3-proxy:1.0.6docker tag quay.io/shotgun/s3-proxy:1.0.6 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6docker push 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6                    Create S3 proxy CloudFormation stackCreate a new stack in AWS Console using either the private or public CloudFormation template.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private S3 proxy (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy.yml      Public S3 proxy:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy-public.yml        Click Next  Set a stack name up to 32 characters in length. Eg. shotgun-s3-proxy  Set the parameters that do not have default values with those used when creating the ECR repository, VPC and S3 bucket previously  Click Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  Click NextConfigure HTTPSShotGrid requires that the S3 proxy be accessed via HTTPS, therefore the AWS ALB handling requests for your newly created S3 proxy stack must be configured to accept HTTPS requests.  Create a DNS entry pointing to your S3 proxy, depending upon whether public or private          Private S3 proxy (default):                  Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and make a note of the DNS name          Add a DNS CNAME record pointing to the DNS name of the ALBEg. s3-proxy.mystudio.com. 300 IN CNAME s3proxy-12R1MXX0MFFAV-2025360147.us-east-1.elb.amazonaws.com.                    Public S3 proxy:                  Go to the AWS Global Accelerator dashboard and make a note of the DNS name associated with your S3 proxy’s accelerator          Add a DNS CNAME record pointing to the DNS name of the Global AcceleratorEg. s3-proxy.mystudio.com. 300 IN CNAME a48a2a8de7cfd28d3.awsglobalaccelerator.com.                      Obtain an SSL certificate for your chosen URL, we recommend using AWS Certificate Manager (ACM) for this  Configure HTTPS for the S3 proxy by adding a new HTTPS listener to the AWS ALB          Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and click on the Listeners tab      Click Add listener      Select HTTPS from the Protocol dropdown menu      Click Add action -&amp;gt; Forward to…      Select your S3 proxy’s target group from the Target group dropdown menu      Select the Security policy you’d like to use. Eg. TLS-1-2-Ext-2018-06 (See AWS documentation for more information)      Select the SSL certificate you’d like to use from ACM or import a new certificate      Click Save      Add S3 proxy VPC to S3 bucket policyIn order for the S3 proxy to communicate with your S3 bucket your bucket policy must allow access from the S3 proxy’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 proxyTry to access your S3 proxy using the ping route. Eg. https://s3-proxy.mystudio.com/pingConfigure your test site to use the S3 proxy  Navigate to the Site Preferences menu within ShotGrid and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Web Traffic Isolation to activate the Web Traffic Isolation feature.See Media Replication to activate the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/85124db5/",
    "relUrl": "/85124db5/"
  },
  "56": {
    "id": "56",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic IsolationCommunication between your client systems and S3 bucket targets a number of AWS network endpoints and data traverses the open Internet by default. Media Traffic Isolation allows you to limit the number of network endpoints used to transfer data to and from your S3 bucket and optionally restrict access to your AWS VPC or a defined set of public address scopes.ConfigurationAn S3 Proxy component is deployed within your VPC; which is then used as the endpoint for all S3 communication. It can also be made publicly available using AWS Global Accelerator.How it worksShotGrid can be configured to use an S3 Proxy address to communicate with your S3 bucket. Deploying the S3 Proxy component within your VPC makes it possible to isolate traffic from the public Internet completely, or to allow more tightly controlled access from the Internet to your media.Secure communicationYou are responsible for supplying and renewing SSL certificates for the S3 Proxy component.CostsActivating the Media Traffic Isolation feature will increase your AWS costs. Before activating, be aware that:  There are costs associated with running the S3 Proxy component. See AWS Fargate Pricing for more details.  If you choose to make your S3 Proxy publicly accessible, there are also additional costs associated with AWS Global Accelerator. See AWS Global Accelerator Pricing for more details.Next StepsSee Media Traffic Isolation for setup instructions.",
    "url": "/58919eae/",
    "relUrl": "/58919eae/"
  },
  "57": {
    "id": "57",
    "title": "SG 데스크톱에서 Nuke/Maya 등을 실행했는데 ShotGrid 메뉴에 해당 항목이 없습니다",
    "content": "SG 데스크톱에서 Nuke/Maya 등을 실행했는데 ShotGrid 메뉴에 해당 항목이 없습니다ShotGrid 메뉴에 표시되는 액션은 상황에 맞게 구성됩니다. 즉, 사용 가능한 액션 목록은 상황에 따라 다를 수 있습니다.잘못된 상황에 있기 때문에 앱이 표시되지 않을 수 있습니다.예시ShotGrid 데스크톱에서 응용프로그램을 실행하면 기본적으로 프로젝트 환경으로 이동합니다. 이 환경은 config/env/project.yml에 있는 파이프라인 구성의 구성 파일에 의해 관리됩니다. 대부분의 사용자 작업이 이 환경에서 수행되지 않을 것이므로 이 환경에는 작업에 사용하는 앱이 대부분 구성되어 있지 않습니다.기본 Maya 프로젝트 액션:ShotGrid Workfiles 앱을 사용하여 작업할 에셋, 샷 또는 태스크를 선택할 수 있습니다. 이렇게 하면 적합한 새 환경이 로드되고 ShotGrid 메뉴에 더 많은 앱과 메뉴 항목이 활성화됩니다.기본 Maya 에셋 태스크 액션올바른 환경에 있는데도 액션이 표시되지 않을 경우 다음 단계는 관련 로그에 오류가 있는지 확인하는 것입니다.전체 출력을 얻으려면 디버그 로깅을 활성화해야 합니다.",
    "url": "/901110e2/",
    "relUrl": "/901110e2/"
  },
  "58": {
    "id": "58",
    "title": "Migration",
    "content": "MigrationOnce everything is configured and properly tested with the migration test site, it’s now time to migrate your production site to use the isolation features.Test migrationAsk the ShotGrid team to start the migration process in support ticket/slack.  ShotGrid will clone your production site database to your migration test site.  You will do a first sync of the media from ShotGrid’s S3 bucket to your bucket. ShotGrid will provide the exact instructions.  You can now test your site to be sure your existing media is available.Final migrationThe second test is to definitly migrate your site to use your own S3 bucket.  You will do a second sync of the media from ShotGrid’s S3 bucket to your bucket.  ShotGrid will reconfigure your hosted site with media isolation. Some media will be missing until the final media sync is completed.  You will do a final media sync.",
    "url": "/09699c82/",
    "relUrl": "/09699c82/"
  },
  "59": {
    "id": "59",
    "title": "파이프라인 구성을 새 위치로 이동하려면 어떻게 해야 합니까?",
    "content": "파이프라인 구성을 새 위치로 이동하려면 어떻게 해야 합니까?                    참고: 이 문서의 내용은 중앙 집중식 구성 설정에만 적용됩니다. 분산 구성은 개별 클라이언트 시스템에 로컬로 캐시되고 툴킷에서 자동으로 관리됩니다.    파이프라인 구성을 새 위치로 옮길 수 있는 가장 쉬운 방법은 tank move_configuration 명령을 사용하는 것입니다. 이렇게 하면 파일을 이동하고, ShotGrid을 업데이트하고, 새 위치를 가리키도록 구성 파일을 업데이트하는 작업이 모두 이루어집니다. 이 명령은 단일 운영 체제의 위치만 옮기거나 이전에는 특정 운영 체제를 사용하지 않았지만 이제 운영 체제를 추가하고 싶은 경우에도 유용합니다. 이동하거나 추가해야 하는 항목과 그렇지 않은 항목은 툴킷이 감지하여 진행할 작업을 미리 보여 주기 때문에 진행하기 전에 확인할 수 있습니다.  tank move_configuration 명령 사용  수동으로 파이프라인 구성 이동                    주의: 현지화된 코어가 있는 구성을 옮기려고 하고, 이 파이프라인 구성에 포함된 Toolkit Core를 사용 중인 다른 프로젝트가 있는 경우에는(즉, 다른 구성에서 공유 코어로 사용) 해당 프로젝트의 구성 파일을 이 파이프라인 구성의 새 위치를 가리키도록 수동으로 업데이트해야 합니다. 이 파일의 위치는 다음과 같습니다.  /path/to/pipeline_configuration/install/core/core_Darwin.cfg  /path/to/pipeline_configuration/install/core/core_Linux.cfg  /path/to/pipeline_configuration/install/core/core_Windows.cfg    tank move_configuration 명령 사용:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://toolkit.shotgunsoftware.com    Starting Toolkit for your current path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Syntax: move_configuration linux_path windows_path mac_path    This will move the location of the given pipeline configuration.    You can also use this command to add a new platform to the pipeline    configuration.    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    You typically need to quote your paths, like this:    &amp;gt; tank move_configuration &quot;/linux_root/my_config&quot; &quot;p: configs my_config&quot;    &quot;/mac_root/my_config&quot;    If you want to leave a platform blank, just just empty quotes. For example, if    you want a configuration which only works on windows, do like this:    &amp;gt; tank move_configuration &quot;&quot; &quot;p: configs my_config&quot; &quot;&quot;예시:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration &quot;/mnt/hgfs/sgtk/software/shotgun/scarlet_new&quot; &quot;z: sgtk software shotgun scarlet_new&quot; &quot;/sgtk/software/shotgun/scarlet_new&quot;    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://toolkit.shotgunsoftware.com    Starting toolkit for path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    New Paths    --------------------------------------------------------------    New Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet_new'    New Windows Path: 'z: sgtk software shotgun scarlet_new'    New Mac Path:     '/sgtk/software/shotgun/scarlet_new'    The configuration will be moved to reflect the specified path changes.    Note for advanced users: If your configuration is localized and you have other    projects which are linked to the core API embedded in this configuration,    these links must be manually updated after the move operation.    Are you sure you want to move your configuration? [Yes/No] yes    Copying '/sgtk/software/shotgun/scarlet' -&amp;gt; '/sgtk/software/shotgun/scarlet_new'    Copying /sgtk/software/shotgun/scarlet/cache...    Copying /sgtk/software/shotgun/scarlet/config...    Copying /sgtk/software/shotgun/scarlet/config/core...    Copying /sgtk/software/shotgun/scarlet/config/core/hooks...    Copying /sgtk/software/shotgun/scarlet/config/core/schema...    Copying /sgtk/software/shotgun/scarlet/config/env...    Copying /sgtk/software/shotgun/scarlet/config/env/includes...    Copying /sgtk/software/shotgun/scarlet/config/hooks...    Copying /sgtk/software/shotgun/scarlet/config/icons...    Copying /sgtk/software/shotgun/scarlet/install...    Copying /sgtk/software/shotgun/scarlet/install/apps...    Copying /sgtk/software/shotgun/scarlet/install/apps/app_store...    Copying /sgtk/software/shotgun/scarlet/install/core...    Copying /sgtk/software/shotgun/scarlet/install/core/python...    Copying /sgtk/software/shotgun/scarlet/install/core.backup...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143244...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143940...    Copying /sgtk/software/shotgun/scarlet/install/engines...    Copying /sgtk/software/shotgun/scarlet/install/engines/app_store...    Copying /sgtk/software/shotgun/scarlet/install/frameworks...    Copying /sgtk/software/shotgun/scarlet/install/frameworks/app_store...    Updating cached locations in /sgtk/software/shotgun/scarlet_new/config/core/install_location.yml...    Updating ShotGrid Configuration Record...    Deleting original configuration files...    All done! Your configuration has been successfully moved.수동으로 파이프라인 구성 이동                    중요: 아직 파이프라인 구성을 옮기지 않았다면 위의 기본 제공 tank 명령을 사용하여 이를 자동으로 처리하는 것이 가장 좋습니다.    이미 수동 이동을 시작했는데 중간에 막혀 버렸다면 툴킷이 이제 새 위치에 있는 파이프라인 구성을 통해 계속 작동하도록 하기 위해 변경해야 하는 사항들이 있습니다.      파이프라인 구성 파일을 새 위치로 이동     $ mv /sgtk/software/shotgun/scarlet /mnt/newserver/sgtk/software/shotgun/scarlet_new            툴킷이 파이프라인 구성의 위치를 파악하는 데 도움을 주도록 install_location.yml을 편집:     $ vi /mnt/newserver/sgtk/software/shotgun/scarlet_new/config/core/install_location.yml        해당하는 모든 플랫폼에서 이 파일의 경로가 새 파이프라인 구성 위치를 가리키도록 업데이트합니다. 플랫폼을 사용하고 있지 않다면 빈 문자열 ''을 입력합니다.     # ShotGrid Pipeline Toolkit configuration file # This file was automatically created by setup_project # This file reflects the paths in the primary pipeline # configuration defined for this project. Windows: 'Y: sgtk software shotgun scarlet_new' Darwin: '/mnt/newserver/sgtk/software/shotgun/scarlet_new' Linux: '' # End of file.            ShotGrid에서 이 프로젝트에 대한 해당 파이프라인 구성 엔티티를 찾아 Linux 경로, Mac 경로 및 Windows 경로 필드 값이 위에서 변경한 사항과 일치하도록 수정합니다.  이제 파이프라인 구성이 새 위치에서 기대한 대로 작동할 것입니다.                    참고: SG 데스크톱을 사용 중인 경우 프로젝트에서 나와 프로젝트 아이콘을 다시 클릭해서 파이프라인 구성을 새 위치에서 다시 로드해야 합니다.    ",
    "url": "/18e34e3c/",
    "relUrl": "/18e34e3c/"
  },
  "60": {
    "id": "60",
    "title": "내 프로젝트 디렉토리를 새 로컬 저장소 루트로 어떻게 옮깁니까?",
    "content": "내 프로젝트 디렉토리를 새 로컬 저장소 루트로 어떻게 옮깁니까?                    주의: 프로젝트 위치를 이동하면 ShotGrid 툴킷을 넘어 확장해도 중간 프로젝트에 많은 영향을 미칠 수 있습니다. 가볍게 처리해서는 안 됩니다.    간혹 프로젝트 파일(씬 파일, 렌더 등)을 새 루트 저장소 위치로 옮겨야 할 때가 있습니다(예: /mnt/smalldrive에서 /mnt/bigdrive/foo로). 이동은 단일 루트 구성을 사용 중이든 다중 루트 구성을 사용 중이든 상관없이 가능합니다. 이름이 “asset_storage”인 저장소를 옮기는 예를 살펴보겠습니다.  이전 위치에서 새 위치로 프로젝트 파일을 복사(또는 이동)합니다.  ShotGrid에서 관리자(Admin) &amp;gt; 사이트 기본 설정(Site Preferences) 페이지로 이동해 파일 관리(File Management) 섹션을 엽니다.   각 플랫폼의 경로와 함께 이름이 “primary”인 로컬 파일 저장소를 프로젝트 파일의 새 저장소로 업데이트합니다. 특정 플랫폼을 사용하고 있지 않다면 그냥 비워 두십시오.  페이지 위나 아래에 있는 “변경 사항 저장(Save Changes)” 버튼을 클릭합니다.  지금 막 ShotGrid에 저장한 새로운 경로 값과 일치하도록 프로젝트 구성의 config/core/roots.yml 파일을 업데이트합니다.툴킷이 게시 경로를 저장소 루트의 상대 경로로 저장합니다. 이전 저장소 루트도 마찬가지로 경로가 다음과 같이 확장되었습니다.[asset_storage]/assets/Character/betty =&amp;gt; /mnt/smalldrive/assets/Character/betty새 저장소 루트 정의의 경우에는 이제 경로가 다음과 같이 확장됩니다.[asset-storage]/assets/Character/betty =&amp;gt; /mnt/bigdrive/foo/assets/Character/betty그리고 ShotGrid 또는 툴킷에서 어떤 다른 게시 정보를 업데이트하는 일은 신경 쓸 필요가 없습니다!                    경고: 위 단계에서는 기존 저장소 루트 경로를 재지정한다고 가정합니다. 대신 기존 경로를 삭제하거나 새 경로를 만드는 경우 모든 폴더를 다시 등록하고 PublishedFiles 엔티티를 다시 게시해야 합니다.    참조어떤 씬 파일에 이전 경로를 가리키는 참조가 있는 경우에는 직접 해당 참조를 업데이트하거나 참조가 올바로 해석되도록 심볼릭 링크를 만들어야 합니다.버전ShotGrid에 이 변경 사항의 영향을 받는 영상 경로 또는 프레임 경로 필드에 정보를 저장하는 버전 엔티티가 있는 경우 이 필드는 미디어에 대한 절대 경로를 포함하고 있는 문자열 필드이기 때문에 해당 버전 역시 새 위치를 가리키도록 업데이트되어야 합니다.",
    "url": "/9aaa493a/",
    "relUrl": "/9aaa493a/"
  },
  "61": {
    "id": "61",
    "title": "NUKE_PATH 환경 변수를 설정하면 Nuke 통합이 시작되지 않는 이유가 무엇입니까?",
    "content": "NUKE_PATH 환경 변수를 설정하면 Nuke 통합이 시작되지 않는 이유가 무엇입니까?통합은 Nuke 시작 프로세스 중에 부트스트랩 스크립트가 실행되도록 Nuke 시작 시 NUKE_PATH 환경 변수를 설정합니다.before_launch_app.py 후크를 실행하기 전에 특별히 NUKE_PATH를 정의하는 tk-multi-launchapp입니다.os.environ['NUKE_PATH'] = &quot;/my/custom/path&quot; 등을 사용하여 시작 프로세스 중에 이 환경 변수를 설정하면 환경 변수에서 시작 스크립트 경로를 제거하기 때문에 ShotGrid 통합을 시작할 수도 없습니다.경로를 툴킷 부트스트랩으로 유지하는 동안에는 경로를 NUKE_PATH 환경 변수에 추가하거나 접두사로 붙이는 다음 함수를 tank.util에 사용하십시오.tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)아니면, prepend_path_to_env_var()을 사용하여 경로를 접두사로 붙여도 됩니다.",
    "url": "/fc2af72c/",
    "relUrl": "/fc2af72c/"
  },
  "62": {
    "id": "62",
    "title": "Disabling auto updates and offline usage",
    "content": "Disabling auto updates and offline usageAuto updatesWhat parts auto update?By default ShotGrid Desktop will automatically check for updates, and install them to the local machine if it finds any.It checks for updates on two components:  tk-framework-desktopstartup - A frame work which aids the launch of ShotGrid Desktop.  tk-config-basic - The default site config.The configuration acts as a manifest for the versions of the apps, engines, frameworks, and core version that should be used by ShotGrid Desktop.By updating the config, you are potentially updating any of these components as well.Any updates that are found are downloaded and stored in the user’s local cache, rather than modifying the original ShotGrid Desktop installed files.ShotGrid Create as an application has it’s own update mechanism separate from ShotGrid Desktop which is not covered here.However the integration features provided in ShotGrid Create work in a similar way, and will also auto update tk-config-basic into the same user cache.What doesn’t auto update?If you have taken over a site configuration, then it won’t check for newer tk-config-basic updates but more on that further down.Also any projects that aren’t using the default site configuration (I.e. a project where the Toolkit advanced setup wizard has been run on it.), will not have their configuration auto updated.What if I can’t or don’t want to auto update?There are scenarios where you might want to run integrations in an environment where there is no connection to the internet or just have control when updates roll out.                    Note: If possible we recommend that you continue to allow auto updates to avoid missing out on new features and bug fixes.    The following sections describes how to address each of these scenarios.  Offline Usage Scenarios  Disabling auto updatesRunning the integrations offline.Initial SetupIf your studio has restricted internet access or no internet access then you will need to ensure that you have all the required parts cached locally.You will still need one machine that can connect to the internet in order to download ShotGrid Create or ShotGrid Desktop.ShotGrid Create and ShotGrid Desktop come prepackaged with all the dependencies required to run the basic integrations.When you start either of them up, it will automatically try to look for updates, but if it cannot connect to the ShotGrid App Store, it will simply run the most recent version that exists locally.It is recommended that you follow the “Managing updates” steps bellow after installing ShotGrid Desktop, as the components bundled with the installer may not be the latest.                    Note: Depending on your network setup, it can sometimes get stuck looking for updates online even though it won’t be able to access them. In this situation you can set the environment variable SHOTGUN_DISABLE_APPSTORE_ACCESS to &quot;1&quot; to stop it from trying.                        Note: You will still need to be able to connect to your ShotGrid site. When we say offline we are talking about not being able to connect to our app store to download updates.    Managing updatesTo update the tk-framework-desktopstartup component, you will need to download the latest version, and set the environment variableSGTK_DESKTOP_STARTUP_LOCATION to point to its location on disk.For the tk-config-basic component it’s a bit more tricky, due to all its dependencies.  Run ShotGrid Desktop on a workstation connected to the internet. When it starts up, the latest upgrades will be automatically downloaded.(Ensure SHOTGUN_DISABLE_APPSTORE_ACCESS is not set on this machine.)  Copy the bundle cache to a shared location where all machines can access it.  Set the SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS environment variable on offline machines to point to this location.  When Desktop starts up on offline machines, they will pick up the latest upgrades that are available in the bundle cache.                    Warning: Depending on your network setup, it can sometimes get stuck looking for updates online even though it won’t be able to access them. In this situation you can set the environment variable SHOTGUN_DISABLE_APPSTORE_ACCESS to &quot;1&quot; to stop it from trying.    CREATE does come with it’s own bundled config, however it doesn’t seem to have the engines, or atleast doesn’t share them when launching Maya for example.Disabling auto updatesDisabling updates for a single project  Determine the version you want to lock your project to. You can find the integration releases here.  In ShotGrid, create a Pipeline Configuration entity for the project you want to lock down, with the following fields populated (In this example, we are locking down the config to use v1.0.36 of the integrations):          Name: Primary      Project: The project you want to lock down      Plugin ids: basic.*      Descriptor: sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36          Anyone starting ShotGrid Desktop on the project will now always use v1.0.36. Any new users starting to work on the project will also get v1.0.36.Good to know  The next time a user launches Desktop while connected to the Internet, v1.0.36 of the basic config, and all of its related code, will be downloaded to their machine.  basic.* means that all plugins in the basic configuration will pick up this override. If, for example, you wanted to freeze the Nuke and Maya integrations only, you could specify basic.maya, basic.nuke.  To test, you can create a duplicate of this Pipeline Configuration entity, and add your username to the User Restrictions field. This will restrict the entity such that it’s only available to you and won’t impact other users. You can then launch Maya or some other software from this duplicate configuration and confirm that it’s running the expected integrations versions.Known issues  The Flame integration is namespaced basic.flame, and so is implied to be part of basic.*. However, the Flame integration isn’t actually included in the basic config. So, if you are using Flame for a project and implement this override, the Flame integration will stop working.The solution would be to create an additional Pipeline Configuration override specifically for flame:          Name: Primary      Project: The project you want to lock down (or None for all projects)      Plugin ids: basic.flame      Descriptor: sgtk:descriptor:app_store?name=tk-config-flameplugin      Disabling updates for all projectsTo disable updates for all your projects, you can follow the steps in the above example, but leave the Project field blank.With no override in the Project field, this Pipeline Configuration entity will apply to all projects, including the “site” project, i.e., the site configuration that is used by Desktop outside of any project.Good to knowIf you lock down your entire site to use, for example, v1.2.3, you can still lock down an individual project to use another config (see “Disabling updates for all but one project” bellow).Known issuesFlame would be affected by this. See the ‘Known Issues’ section of the above scenario for a solution.Disabling updates for all but one projectIf you have disabled updates on all projects as mentioned in the example above, but would like to enable updates on a specific projectYou can  Disabling updates for your site as described in the above section.  Configure the exception project’s Pipeline Configuration entity to have the following field values:          Name: Primary      Project: The project you want not to lock down      Plugin ids: basic.*      Descriptor: sgtk:descriptor:app_store?name=tk-config-basic        Good to knowNote that you’ve omitted the version number from the Descriptor field for the project. This will mean that the project is tracking the latest release of the basic config.UpgradingScenario: We’re locked down to v1.0.0, and we’d like to upgrade to v2.0.0, but first I want to test out the new version before deploying it to the studio.*SolutionDuplicate the Pipeline Configuration entity in ShotGrid by right-clicking on it and selecting “Duplicate Selected”.Name the cloned config “update test”, and assign yourself to the User Restrictions field.You will now begin to use this Pipeline Configuration.Change the descriptor to point to the version you wish to test.You can invite any users you want to partake in testing by adding them to the User Restrictions field.Once you are happy with testing, simply update the main Pipeline Configuration to use that version.Once users restart Desktop or DCCs, the update will be picked up.",
    "url": "/c186b05d/",
    "relUrl": "/c186b05d/"
  },
  "63": {
    "id": "63",
    "title": "Onboarding Process",
    "content": "Onboarding ProcessLeveraging the isolation features requires adopters to become AWS users. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering.Autodesk and Amazon will provide dedicated resources during the onboarding process to help you on this journey.To start the on-boarding process for any of the Isolation features, please open a ShotGrid Support ticket, before proceeding with your setupOnboarding Process OverviewDuring the onboarding process, you’ll have direct access to Autodesk and AWS Leaders who will support you during the implementation.Tech Briefing:  Overview meeting of all of our offerings, where we underline the advantages and disadvantages of each.Tech Deep Dive:  OPTIONAL. Deeper technical dive into isolation features. This meeting can be combined with the Tech Briefing.Kickoff Meeting:	AWS and ShotGrid Leaders review the setup process with the you.Setup / Test / Validation:	Iterative installation process where you connect your AWS resources to ShotGrid, and activate the isolation features.Training: OPTIONAL. Help sessions, if needed, as you ramp up on the AWS/ShotGrid technologies required to securely set-up the isolation features for your site.Onboarding ResourcesShotGrid Community: The ShotGrid Isolation Community forum can be used to ask questions that can be answered by either ShotGrid Experts or other isolation features users. This should be your first stop when asking general questions about isolation features, during setup and beyond.Private Slack Channel: During the onboarding, you will be given access to a dedicated Autodesk Slack Channel. Your ShotGrid and AWS Leaders will be available for quick feedback, answers, and ad-hoc meetings to help you progress as fast as possible with your ShotGrid Isolation setup. This channel will be available only for the onboarding period.ShotGrid Support: A ShotGrid Support ticket will be used to track your onboarding at a higher level. Once your ShotGrid Isolation setup is complete, follow-up support tickets can be opened with the support team as needed.Next StepsOnce the onboarding process is started, you can start thinking about your setup",
    "url": "/f66c5afa/",
    "relUrl": "/f66c5afa/"
  },
  "64": {
    "id": "64",
    "title": "Other Integrations",
    "content": "Other IntegrationsWith ShotGrid’s API, you can integrate with a number of third party packages. However, there are a few with which ShotGrid integrates right out-of-the-box.CinesyncCinesync allows you to have simultaneous synced playback between multiple locations. ShotGrid’s integration allows you to create a Playlist of Versions, play it in Cinesync, and send your Notes made during the session right back into ShotGrid.For more information, please see http://www.cinesync.com/manual/latest.DeadlineThe ShotGrid+Deadline integration allows you to automatically submit rendered Versions to ShotGrid complete with thumbnail, links to frames, and other metadata.For more information, please see http://www.thinkboxsoftware.com/deadline-5-shotgunevent.RushMuch like the Deadline integration, the ShotGrid+Rush integration allows you to automatically submit rendered Versions to ShotGrid complete with thumbnail, links to frames, and other metadata.For more information, please see http://seriss.com/rush-current/index.html.Subversion (SVN)ShotGrid a light but flexible integration, which we use internally, that allows us to track revisions and link them to tickets and releases in ShotGrid. We also provide links to Trac to integrate with an external web SVN repository viewer. This is all done by adding a post-commit hook to SVN, a ShotGrid API script that takes some ENV variables from the commit and then creates a Revision entity in ShotGrid with various fields filled in. It can be modified to match your studio’s needs and can be used for a local or hosted installation since it’s just using the API. For more information, please see https://subversion.apache.org/docs.",
    "url": "/f0ee6c48/",
    "relUrl": "/f0ee6c48/"
  },
  "65": {
    "id": "65",
    "title": "성능 문제 해결",
    "content": "성능 문제 해결툴킷 사용 시 속도가 느려지는 문제가 발생할 수 있습니다. 이러한 문제의 원인으로는 서버 속도, 인터넷 연결 등의 클라이언트 측 인프라 문제부터 툴킷 또는 ShotGrid 구성 시 성능이 고려되지 않은 구성 관련 문제, 그리고 최적화를 추가적으로 적용할 코드 영역까지 다양할 수 있습니다.다음은 확인해야 할 사항의 목록으로, 아래에서 자세히 살펴보겠습니다.  앱, 엔진, 프레임워크, 코어 및 ShotGrid 데스크톱이 최신 상태인지 확인합니다.  일반적인 사용 중에 디버그 로깅이 활성화되지 않은 것을 확인합니다.  필요한 폴더만 생성하며, 폴더가 실제로 필요할 때만 생성되도록 제한합니다. 너무 많은 폴더를 스키마에 추가하면 속도가 느려집니다.  서버에 사용자 캐시를 저장하면 속도가 느려질 수 있습니다. 로컬 드라이브 위치를 가리키도록 ShotGrid_HOME 환경 변수를 설정하여 사용자의 ShotGrid 캐시를 리디렉션할 수 있습니다.  아티스트에게 필요하지 않은 컨텐츠는 필터링하여 제외하도록 Workfiles 및 Loader 앱을 구성합니다. 엔티티 목록을 아티스트의 현재 태스크와 관련이 있는 항목으로 간결하게 유지하려면 상태를 기준으로 필터링해 보십시오.  커스텀 후크가 있는지 그리고 이러한 커스텀 후크로 인해 오버헤드가 증가하지는 않는지 확인하십시오.아래 목록에는 모범 사례와 속도 저하 문제가 발생하는 일반적인 사례가 정리되어 있습니다. 전체 사례가 수록된 완전한 목록은 아니며 새로운 패턴이 발견되는 대로 목록에 추가하겠습니다. 이 안내서가 문제 원인을 파악하는 데 도움이 되지 않을 경우 언제든지 지원 티켓을 제출해 주십시오. ShotGrid 팀이 도와드리겠습니다.목차:  일반적인 모범 사례          캐시 위치      최신 버전 유지      중앙 집중식 구성과 분산 구성 비교      디버깅        소프트웨어의 시작 속도가 느림          진단      문제가 시작 전에 발생합니까? 아니면 시작 후에 발생합니까?      로그 확인      소프트웨어의 실행 속도가 느려지는 일반적인 원인        File Open, File Save 또는 Loader 앱의 속도가 느립니까?  폴더 생성 속도가 느림          입출력량 문제 해결      폴더 등록      일반적인 모범 사례캐시 위치ShotGrid 툴킷은 사용자의 홈 디렉토리에 데이터를 캐시합니다. 이 캐시에는 여러 가지 SQLite 데이터베이스와 캐시된 앱 및 구성이 포함될 수 있습니다. 대개 사용자의 홈 디렉토리는 시스템의 로컬 하드 드라이브에 저장되지만, 스튜디오에서 이를 네트워크 저장소로 리디렉션하는 경우가 많습니다. 이렇게 되면 성능에 영향을 미칠 수 있습니다. 특히, 브라우저 통합 및 폴더 생성/조회 등에 사용되는 SQLite 데이터베이스에 주로 영향을 미칩니다.사용자 디렉토리가 서버 위치에 저장되는 경우 ShotGrid_HOME 환경 변수를 사용하여 ShotGrid 툴킷 캐시의 경로를 변경하는 것이 좋습니다. ShotGrid_HOME 환경 변수는 툴킷이 번들 캐시, 썸네일, 그리고 데이터의 빠른 조회에 사용되는 SQLite 데이터베이스 등과 같은 다양한 데이터를 캐시하는 위치를 설정하는 데 사용됩니다.디버깅ShotGrid 툴킷에서 디버그 로깅을 활성화할 수 있습니다. 그러면 다양한 프로세스에 대한 출력을 더욱 상세하게 얻을 수 있습니다. 문제를 진단하는 데 아주 유용한 기능이지만, 디버그 설정은 일상적인 사용 중에는 활성화되도록 설계되지 않았습니다. 로깅 출력이 늘어나면 성능에 상당한 영향을 미칠 수 있습니다.성능 문제가 발생하면, 특히 특정 시스템 또는 사용자에 국한되어 성능 문제가 발생하는 경우 먼저 디버그 로깅이 활성화되지 않은 것을 확인하십시오.최신 버전 유지성능 문제가 발생하면 코어, 앱, 엔진 및 프레임워크가 최신 상태인지 확인하십시오. 최신 버전에서는 이미 수정 사항 또는 최적화 기능이 제공되었을 수 있습니다.중앙 집중식 구성과 분산 구성 비교고급 툴킷 구성은 중앙 집중식 구성과 분산 구성이라는 두 가지 방법으로 설정할 수 있습니다. 주된 차이점은 중앙 집중식 구성의 경우 일반적으로 모든 사용자가 액세스할 수 있는 스튜디오의 네트워크 저장소에 저장되며, 분산 구성의 경우 대개 클라우드에 저장되고 사용자별로 로컬로 캐시된다는 점입니다.이러한 차이점은 성능 이외의 측면에도 영향을 미치지만 성능 차원에서도 각기 다른 장단점을 가집니다. 다음 표에는 성능 측면의 장단점이 정리되어 있습니다.                   장점      단점                  중앙 집중식 구성      - 초기 설정 프로세스가 완료되면 필요한 모든 항목이 이미 다운로드되어 모든 사용자가 이용할 수 있게 준비됩니다.      - 중앙 집중식 구성은 일반적으로 네트워크 저장소에 유지되므로 일반적인 툴킷 사용 중에 성능 저하가 나타날 수 있습니다.                     - 이후에 업데이트할 때는 중앙의 위치에 한 번만 다운로드하면 됩니다.      - 툴킷 구성에는 작은 파일이 많이 포함되므로 이러한 작은 파일에 대한 메타데이터 작업 처리가 상당히 느려지고 서버에 부담을 줄 수 있습니다. 또한, 구성을 빠르게 읽어올 수 없으므로 툴킷 사용을 통한 읽기 작업이든 일반적인 서버 사용을 통한 읽기 작업이든 읽기 작업이 과도하게 많은 경우 툴킷의 성능에 영향을 미칠 수 있습니다.              분산 구성      - 캐시된 앱, 엔진, 프레임워크 및 코어가 로컬로 캐시된 다른 구성과 공유할 수 있는 방식으로 저장됩니다. 즉, 여러 프로젝트가 동일한 종속 항목을 공유하는 경우 이러한 프로젝트를 이후에 로드할 때 캐시가 더 빨라질 수 있습니다.      - 분산 구성은 사용자별로 로컬에 캐시되어야 합니다. 보통, 이 과정에서 구성과 함께 필요한 모든 앱, 엔진, 프레임워크 및 코어가 다운로드됩니다.                     - 이러한 항목은 사용자의 로컬 하드 드라이브에 있는 캐시에 저장되며, 따라서 일반적으로 서버 속도보다 빠릅니다. 즉, 초기 캐시 후 성능이 중앙 집중식 구성보다 빠릅니다.      - 이 프로세스는 백그라운드에서 원활히 수행될 수 있지만, 이러한 항목을 다운로드해야 하는 초기 부담이 여전히 존재합니다.                            - 구성이 종속 항목의 새 버전을 가리키도록 업데이트될 때마다 구성과 새 종속 항목이 모두 캐시되어야 합니다.      요약하자면 저장 장치의 속도는 느리지만 인터넷 연결 속도가 괜찮다면 분산 구성이 가장 좋은 선택이 될 수 있고, 서버 저장 장치 성능은 좋지만 인터넷 속도는 좋지 않을 경우에는 중앙 집중식 구성이 적합할 수 있습니다.                    참고: 분산 구성을 사용하고 싶지만 시스템별로 종속 항목을 다운로드하는 것이 염려된다면 번들 캐시를 중앙 집중화하여 모든 사용자가 공유하도록 할 수 있습니다.    분산 구성을 사용하는 경우 사용자는 캐시에 없는 항목만 다운로드하면 되며, 한 사용자가 다운로드한 항목을 다른 사용자도 활용할 수 있게 됩니다. 이렇게 하려면 각 시스템에서 공유 위치를 가리키도록 ShotGrid_BUNDLE_CACHE_PATH 환경 변수를 설정하면 됩니다.소프트웨어의 시작 속도가 느림Maya, Nuke, Houdini 등의 소프트웨어를 시작할 때 ShotGrid 없이 시작할 때보다 시간이 오래 걸리는 것을 알아차리셨을 것입니다. ShotGrid 없이 시작하는 경우보다 시간이 약간 더 오래 걸리는 것은 당연하겠지만, 용납할 수 없을 정도로 오래 걸리는 경우도 있을 수 있습니다. 소프트웨어에 따라 다르지만 대개 1분 안에 시작되어야 합니다. 소프트웨어를 시작하는 데는 많은 프로세스가 관련되기 때문에 이 문제를 진단하는 것은 더 어려울 수 있습니다.진단먼저, 이 문제가 어떠한 상황에서 발생하는지 파악해야 합니다.  ShotGrid 없이 시작할 때도 속도가 느립니까? - 뻔한 이야기일 수 있지만 ShotGrid과 함께 시작할 때만 문제가 발생하는지 확인하는 것이 좋습니다.  시작 방법에 상관없이 동일하게 속도가 느립니까? 즉, SG 데스크톱에서 시작할 때나, 브라우저 통합을 사용하여 SG 사이트에서 시작할 때 느린 속도에 차이가 없습니까? - ShotGrid 사이트에서 시작할 때는 속도가 느리지만 SG 데스크톱에서 시작할 때는 속도가 느리지 않은 경우 브라우저 통합 문제이거나 디스크에 폴더를 생성하는 것과 관련한 문제가 있음을 나타낼 수 있습니다. 프로젝트 이외의 컨텍스트에서 시작하는 경우 디스크에 추가로 폴더를 생성해 보면 시간이 어디서 많이 걸리는지 확인할 수 있습니다. 소프트웨어가 시작될 때마다 필요한 폴더가 존재하는지 확인한다는 사실도 주목해야 합니다.  모든 프로젝트에서 이 문제가 발생합니까? - 그렇지 않다면 구성이 설정된 방식과 관련하여 문제가 있을 가능성이 큽니다.  하루 중 특정 시간에만 이 문제가 발생합니까? - 그렇다면 하루 중 특정 시간에 서버 사용량이 많은 경우와 같이 인프라에 대한 수요가 높다는 것을 나타낼 수 있습니다.  모든 시스템/OS에서 이 문제가 발생합니까? - 특정 시스템에서만 속도가 느린 경우 툴킷 외부에 문제의 원인이 있을 가능성이 있습니다. 이 경우, 먼저 해당 시스템에서 툴킷 캐시를 지우는 것이 좋습니다. OS마다 제공되는 소프트웨어 버전 및 Python 패키지가 다르며, 특정 빌드에서 성능 문제가 발생하는 경우가 있을 수 있습니다. 특히, Samba(SMB) 공유를 사용하는 Windows에서 성능 문제를 확인했습니다. 이러한 문제에 대한 수정 사항은 없지만, Windows를 사용하는 경우 유의하시기 바랍니다.문제가 특정 OS, Python 패키지 또는 소프트웨어 버전으로 국한된다고 판단되는 경우 ShotGrid 지원 팀에서 추가적인 조사를 진행할 수 있도록 알려주시기 바랍니다.  모든 사용자에게 이 문제가 발생합니까? - 위와 마찬가지로 동일한 시스템의 다른 사용자에게는 이 문제가 발생하지 않을 수 있습니다. 이 경우, 사용자의 로컬 ShotGrid 캐시를 먼저 지우십시오. 또한, 정상적으로 프로덕션 환경에서 사용할 때 디버그 로깅이 활성화되지 않은 것을 확인하십시오. 활성화할 경우 성능에 영향을 미치게 됩니다.  느린 시작 문제가 특정 앱/소프트웨어에만 국한됩니까? 아니면 모든 앱/소프트웨어가 비정상적으로 느리게 시작됩니까? - 특정 소프트웨어만 느리게 시작되는 경우 구성 문제가 있을 수 있습니다. 성능에 영향을 미칠 수 있는 커스텀 후크가 시작 전이나 후에 실행되도록 설정되었는지 확인하는 것이 좋습니다. 시작에 사용되는 일반 후크는 before_app_launch.py, app_launch.py이며 코어 후크는 engine_init.py입니다. 최신 버전의 소프트웨어가 출시될 때 ShotGrid 통합이 갑자기 훨씬 더 느리게 시작되는 등의 문제가 발생할 수도 있습니다. 이러한 경우 지원 팀에 문의하여 이에 대해 알고 있는지, 그리고 알려진 수정 사항이 있는지 확인해야 합니다. 이때 현재 사용 중인 소프트웨어의 버전 번호(해당하는 경우 패치/서비스 팩 포함)와 현재 실행 중인 tk 엔진 및 코어의 버전을 알려 주십시오.문제가 시작 전에 발생합니까? 아니면 시작 후에 발생합니까?위의 방법으로 문제의 원인이 좁혀지지 않을 경우 다음 단계로 시작 프로세스가 언제 느려지는지 파악해야 합니다. 툴킷을 통해 소프트웨어를 시작하는 경우 대개 두 단계 프로세스로 간추릴 수 있습니다.첫 번째 단계에서는 소프트웨어를 시작하는 데 필요한 정보를 수집하고 컨텍스트에서 폴더를 자동으로 생성한 후 소프트웨어를 실제로 시작하는 등의 초기 작업을 수행합니다. 소프트웨어가 시작된 후 두 번째 단계에서는 툴킷 통합을 시작합니다.일반적으로, 성능 문제가 프로세스의 첫 번째 단계에서 발생하는지 아니면 두 번째 단계에서 발생하는지는 로그를 확인하지 않고도 알 수 있습니다.  소프트웨어의 시작 화면이 시작하는 데 오래 걸리는 경우 첫 번째 단계에 문제가 있을 가능성이 큽니다.  소프트웨어가 시작 과정의 초반에는 상대적으로 속도가 빨랐다가 초기화가 완료되고 ShotGrid 메뉴가 표시된 후 느려지는지 확인하십시오. 이 경우 두 번째 단계에 문제가 있는 것입니다.이를 파악하고 나면 로그에서 무엇을 확인해야 할지 알 수 있습니다.로그 확인이제 이 문제가 시작의 첫 번째 단계에서 발생했는지 아니면 두 번째 단계에서 발생했는지 파악되었을 것이므로 이에 따라 로그에서 확인할 부분을 결정할 수 있습니다. 로그는 엔진별로 나뉘어 있으므로 문제가 시작 전 단계에서 발생한 경우 SG 데스크톱에서 시작했는지 아니면 SG 사이트에서 시작했는지에 따라 각각 tk-desktop.log 또는 tk-ShotGrid.log를 확인해야 합니다.다음으로 수행해야 하는 작업은 디버그 로깅을 활성화하는 것입니다.                    참고: 위에서 설명한 대로 디버그 로깅이 이미 활성화된 경우 이것이 속도 저하 문제의 원인이 될 수 있으므로 디버그 로깅이 활성화되지 않은 상태에서도 테스트해야 합니다.    디버그 로깅을 활성화하고 나면 기존 로그를 지운 후 시작 프로세스를 다시 실행해야 합니다. 그런 후에는 로그의 타임스탬프를 조사하여 시간이 갑자기 건너뛴 부분을 확인할 수 있습니다.예를 들어, 다음은 폴더 생성 중에 시간이 5초 이후로 건너뛴 행을 보여줍니다.2019-05-01 11:27:56,835 [82801 DEBUG sgtk.core.path_cache] Path cache syncing not necessary - local folders already up to date!2019-05-01 11:28:01,847 [82801 INFO sgtk.env.asset.tk-shotgun.tk-shotgun-folders] 1 Asset processed - Processed 66 folders on disk.시간이 건너뛴 부분을 찾고 나면 해당 로그 행에서 폴더를 생성 중이었는지 아니면 ShotGrid에 연결 중이었는지와 같이 해당 단계에서 어떠한 작업이 수행 중이었는지 확인할 수 있습니다.로그를 읽는 것이 어렵거나 내용이 이해되지 않는 경우에는 지원 팀에 문의하여 도움을 받으십시오.소프트웨어의 실행 속도가 느려지는 일반적인 원인            인터넷 속도가 느림      툴킷 사용의 거의 모든 부분에서 ShotGrid 사이트에 연결하고 통신해야 하므로 인터넷 속도가 느릴 경우 영향을 받을 수 있습니다. 이 경우, 소프트웨어를 시작할 때뿐 아니라 다른 경우에도 속도 문제가 나타날 수 있습니다. 그러나, 연결 속도가 아닌 안정성에 문제가 있다면 프로세스 전반에 걸쳐 ShotGrid 통신이 꽤 많이 필요하기 때문에 시작 단계에서 성능 문제가 나타날 가능성이 더 큽니다.              서버 액세스가 느림      이 경우 시작 시간에 확실히 영향을 미칠 수 있습니다. 중앙 집중식 구성(구성이 중앙 서버에 저장됨)을 사용하는 경우 구성 파일을 읽을 때마다 많은 입출력이 발생할 수 있습니다. 또한, 소프트웨어를 시작하면 시작 컨텍스트에 대해 폴더 생성 작업이 트리거됩니다. 즉, 폴더가 생성되었는지 확인하고 생성되지 않은 경우 폴더가 새로 만들어집니다.              폴더 생성      위에 설명한 대로 폴더 생성은 속도 저하 문제를 일으키는 일반적인 원인이 될 수 있습니다. 자세한 내용은 아래에서 폴더 생성과 관련한 성능 문제 해결 단원을 참조하십시오.      File Open, File Save 또는 Loader 앱의 속도가 느립니까?가장 먼저 문제가 있는 앱에서 어느 부분이 느려지는지 확인해야 합니다.  앱을 시작할 때 속도가 느립니까? 아니면 탭을 탐색할 때 속도가 느립니까?          앱이 너무 많은 정보를 표시하도록 구성되어 있는 것일 수 있습니다. 이 경우 목록에서 불필요한 엔티티를 필터링하여 제외하도록 내 태스크(My Tasks) 탭 및 기타 탭을 구성할 수 있습니다. 예를 들어, 대기 중(hld) 또는 최종(fin)과 같은 특정 상태의 태스크를 필터링하여 제외할 수 있습니다. 이렇게 하면 성능이 향상되고 아티스트는 중요한 정보만 볼 수 있게 됩니다. Loader 앱 및 Workfiles 앱에서 모두 필터링이 가능합니다. 단, Workfiles에는 현재 필터링에 대한 특정 섹션이 없으며, 계층 설정을 통해 필터링을 적용할 수 있습니다.      File Open 앱에서는 계층의 하위 항목이 확장될 때까지 하위 항목의 로드를 유예하도록 구성할 수 있습니다. 현재, 기본 구성 설정이지만 이전 구성을 사용하는 경우에는 이 설정을 사용하도록 전환할 수 있습니다.      디버그 로깅이 활성화되지 않은 것을 확인하십시오. 활성화되어 있으면 추가 입출력이 많이 발생하며, 이에 따라 속도가 느려질 수 있습니다. 이 앱은 많은 디버깅 출력을 포함합니다.        새 파일을 열거나 저장하거나 생성할 때 속도가 느립니까?          씬 작업 또는 액션 후크를 인계받았는지 확인하고 이러한 기능과 관련하여 속도를 저하시킬 수 있는 커스텀 동작이 있는지 확인합니다.      파일을 만들거나 저장할 때 Workfiles는 컨텍스트에 필요한 모든 폴더가 생성되었는지 확인합니다. 폴더 생성은 성능 문제가 흔히 발생하는 부분입니다.      폴더 생성 속도가 느림폴더 생성은 여러 가지 부분으로 구성되기 때문에 문제가 발생하는 경우 프로세스 속도 저하가 나타날 수 있습니다.폴더 생성 과정은 다음과 같습니다.  로컬 경로 캐시를 동기화합니다.  구성 스키마를 읽어옵니다.  특정 컨텍스트에 따라 만들어야 하는 경로 목록을 생성합니다.  로컬로 저장된 경로 레지스트리와 비교하여 경로를 확인합니다.  아직 등록되지 않은 경우 SG 사이트와 로컬 모두에 새 경로를 등록하려고 시도합니다.  폴더의 등록 여부에 상관없이 폴더가 실제로 디스크에 있는지 확인하고 없는 경우 폴더를 생성합니다.정리하면, 폴더 생성 시 로컬 데이터베이스에 기록하고 SG 사이트와 통신하는 외에도 디스크에서 상당한 양의 입출력이 발생할 수 있습니다.입출력량 문제 해결저장 장치가 대량의 작은 읽기-쓰기 작업을 처리하기에 느리거나 비효율적일 가능성이 있으므로 인프라를 개선하기 위해 수행하는 작업이라면 무엇이든 폴더 생성 속도를 높이는 데 도움이 됩니다. 하지만, 최대한 부담을 줄이기 위해 툴킷 구성 측면에서 수행할 수 있는 단계가 있습니다.첫 번째 단계는 해당 컨텍스트와 작업 환경에 중요한 폴더만 생성되도록 폴더를 제한하는 것입니다. 예를 들어, Maya의 샷에 대한 태스크를 진행하는 경우 해당하는 샷과 소프트웨어에 대한 폴더만 확인하고 생성하는 것이 바람직합니다.기본적으로, 작업물을 저장하고 게시하는 데 필요한 최소한의 폴더만 생성하는 것이 좋습니다.상위 폴더와 동시에 생성스키마 폴더에 적용될 수 있는 create_with_parent 설정이 있습니다.이 설정을 True로 설정하면 폴더와 상위 폴더가 동시에 생성됩니다. 이 설정을 True로 설정하면 대량 폴더에 대해 확인 및 생성 작업이 수행되지 않도록 주의해야 합니다.예시시퀀스/샷 폴더 계층이 있고 샷 폴더를 상위 폴더인 시퀀스 폴더와 함께 생성하도록 설정한 경우 시퀀스 폴더가 생성될 때마다 연결된 모든 샷에 대해 확인 작업이 수행되고 이에 대한 폴더가 생성됩니다.때로는 이러한 동작이 편리할 수 있지만 이로 인해 더 많은 폴더가 확인 작업을 거쳐 동시에 생성되는 문제가 발생합니다. 이러한 경우, 샷에 대한 태스크의 작업 파일에 새 파일을 생성하려고 하면 샷의 상위 폴더인 시퀀스 폴더의 생성 작업이 트리거되고, 이에 따라 현재 작업하는 샷만이 아니라 모든 하위 폴더인 샷 폴더가 생성됩니다.                    참고: 단계 스키마 폴더에 대한 설정은 기본적으로 true로 설정됩니다.    생성 유예defer_creation 설정을 사용하면 특정 엔진이 실행 중일 때에만 폴더 생성이 발생하도록 제한하여 폴더가 생성되는 경우를 세부적으로 조정할 수 있습니다. 커스텀 이름을 사용하여 sgtk API를 통해 이에 대한 생성 작업을 트리거할 수도 있습니다.예시게시 단계에서만 생성해야 하는 폴더가 여러 개 있을 수 있습니다. 이 경우, maya_publish의 유예 키워드로 커스텀을 설정한 후 API를 사용하여 이 키워드를 엔진 이름으로 사용하여 폴더를 만들 수 있습니다.스키마 내 폴더는 다음과 같습니다.# the type of dynamic contenttype: &quot;static&quot;# defer creation and only create this folder when Photoshop startsdefer_creation: &quot;publish&quot;그런 다음, 다음과 같은 스크립트를 사용하여 폴더를 만듭니다.sgtk.create_filesystem_structure(entity[&quot;type&quot;], entity[&quot;id&quot;], engine=&quot;publish&quot;)확장된 예시폴더를 유예하는 방법에서 더 나아가 프로젝트의 루트에 동적이 아닌 폴더가 여러 개 있는 경우 일반적으로 한 번만 생성하면 됩니다. 예를 들어, 기본 구성 스키마의 루트에 있는 “editorial” 및 “reference” 폴더는 프로젝트 시작 시 한 번만 생성하면 되지만, 기본적으로 폴더 생성 작업 시 항상 이 폴더의 존재 여부를 확인합니다.이 폴더에 대해 yml 파일을 생성하여 이를 제한할 수 있습니다. 이 yml 파일에서는 폴더 생성이 특정 엔진에서 실행되거나 유예 키워드가 전달되는 경우에만 폴더가 생성되도록 유예 키워드를 설정할 수 있습니다. 유예 키워드를 tk-shell로 설정한 후 tank folders와 같은 tank 명령을 통해 폴더 생성을 실행할 수 있습니다.그러면 폴더 생성이 tank 명령을 통해 실행되는 경우에만 폴더가 생성됩니다. 이 작업은 툴킷 관리자가 처음으로 프로젝트를 설정할 때 수행할 수 있습니다. 또는, 위의 예시와 같은 커스텀 키워드를 사용하여 폴더 생성을 실행하는 간단한 스크립트를 작성할 수도 있습니다.폴더 등록향후 컨텍스트를 조회할 때 경로가 사용될 수 있도록 폴더 생성 프로세스 중에 폴더가 등록됩니다. 위에서 설명한 대로 이 프로세스 부분을 실행하기 위해서는 레지스트리가 저장된 중앙 위치인 ShotGrid 사이트와의 통신이 필요합니다. 하지만, 도구에서 더욱 신속하게 조회할 수 있도록 이러한 레지스트리는 로컬로도 캐시됩니다.SQLite 데이터베이스로컬 경로 캐시에서는 데이터를 저장하기 위해 SQLite 데이터베이스를 사용합니다. 데이터베이스가 네트워크 저장소에 저장되는 경우 데이터베이스 읽기 및 쓰기 관련 성능이 심각한 영향을 받을 수 있습니다.초기 동기화많은 폴더가 등록된 프로젝트에 대해 로컬 캐시를 처음부터 생성해야 하는 경우가 있을 수 있습니다(예: 이미 진행 중인 프로젝트에 새 사용자가 참여하는 경우). 이 프로세스는 아주 긴 시간이 걸릴 수 있지만, 다행인 점은 이러한 현상이 해당 프로젝트에 대해 한 번만 발생한다는 것입니다.후속 동기화에서는 로컬 캐시와 사이트 레지스트리 사이의 차이점만 가져옵니다. 사용자의 프로젝트 작업 빈도가 낮고 세션 간에 많은 폴더가 생성되는 경우 모든 항목이 캐시되는 동안 대기하는 시간이 길어질 수 있습니다.사용자가 이러한 문제에 사용하는 것으로 확인된 한 가지 방법은 최신 버전의 로컬 캐시를 사용자 시스템으로 전송하는 것입니다.                    참고: 이 방법은 프로젝트에 대해 과도하게 많은 폴더가 생성되는 경우에만 사용해야 합니다.    이 업데이트 프로세스는 코어 후크 cache_location.py를 사용하여 자동으로 수행될 수 있습니다. 위치를 변경하는 대신 이 후크를 사용하여 캐시 위치를 설정할 수 있으며, 이 후크를 사용하여 비용이 많이 드는 전체 동기화를 수행할 필요 없이 중앙 위치의 path_cache.db 파일을 사용자의 기본 위치로 복사할 수 있습니다.이렇게 중앙에 저장된 경로 캐시는 작업자의 캐시에서 수동으로 복사하거나 정기적으로 이러한 캐시를 전송하는 스크립트를 작성하여 주기적으로 업데이트할 수 있습니다.                    경고: cache_location.py 후크를 사용하여 캐시의 위치를 설정할 수 있지만, 모든 사용자에 대해 단일 위치를 가리키도록 설정하지 않아야 합니다. 그러면 하나 이상의 프로세스에서 동시에 데이터베이스를 편집하려고 할 때 데이터베이스 잠금이 발생할 수 있습니다.    ",
    "url": "/396dd133/",
    "relUrl": "/396dd133/"
  },
  "66": {
    "id": "66",
    "title": "Pipeline Integrations",
    "content": "Pipeline Integrations여기서는 툴킷 개발자가 시작할 수 있는 안내서, 튜토리얼, 동영상 및 기타 컨텐츠를 확인할 수 있습니다.",
    "url": "/e058fbea/",
    "relUrl": "/e058fbea/"
  },
  "67": {
    "id": "67",
    "title": "Pipeline Integrations",
    "content": "Pipeline IntegrationsHere you’ll find reference documentation for components of the Toolkit platform",
    "url": "/162eaa4b/",
    "relUrl": "/162eaa4b/"
  },
  "68": {
    "id": "68",
    "title": "파이프라인 튜토리얼",
    "content": "파이프라인 튜토리얼이 튜토리얼에서는 애니메이션이나 시각 효과 프로덕션을 위한 단순하면서도 전형적인 파이프라인을 빌드하는 방법을 다룹니다. 이 튜토리얼을 수행하면 에셋을 모델링에서부터 모양 개발, 그리고 프로덕션 씬으로 푸시하는 데 필요한 모든 부분을 제공하는 파이프라인을 빌드하게 됩니다.이 파이프라인에서 다루는 대부분의 워크플로우는 ShotGrid의 기본 제공 통합에서 기본적으로 작동합니다. 이 튜토리얼은 스튜디오에서 커스텀 솔루션을 많이 빌드하는 파이프라인 부분에 대해 툴킷 플랫폼을 사용하여 아티스트 워크플로우를 커스터마이즈하는 프로세스를 안내합니다.다음은 이 튜토리얼에서 빌드할 파이프라인의 개략적인 뷰입니다.    파이프라인 개요파이프라인 개요편의상 사용되는 DCC(디지털 컨텐츠 생성) 소프트웨어는 최소로 유지되며 Maya 및 Nuke로 제한됩니다. 마찬가지 이유로 파이프라인 단계 간에 전달되는 데이터는 Maya ascii 파일, Alembic 캐시 및 렌더링된 이미지 시퀀스로 제한됩니다.                    참고: 이 튜토리얼에 설명된 간단한 파이프라인은 프로덕션에서 테스트되지 않았으므로 ShotGrid 기반 파이프라인을 빌드하는 방법에 대한 예제로만 사용해야 합니다.    필수 요건      작업 중인 ShotGrid 프로젝트 - 이 튜토리얼에서는 프로덕션 데이터 트래킹 및 관리를 위해 ShotGrid을 사용하는 환경이라고 가정합니다.        ShotGrid 통합 이해 - ShotGrid은 통합 기능을 통해 수동 구성이 필요 없는 몇 가지 간단한 프로덕션 워크플로우를 제공합니다. 이 튜토리얼에 설명된 수동 구성 및 커스터마이제이션에 대해 자세히 알아보기 전에 이러한 워크플로우의 기능 및 범위를 이해해야 합니다. ShotGrid 통합에 대한 자세한 정보는 여기를 참조하십시오.        Maya 및 Nuke 환경 - 이 튜토리얼은 Nuke와 Maya를 사용하여 간단한 파이프라인을 빌드하도록 설계되었습니다. ShotGrid에서 제공하는 통합을 커스터마이즈하기 위해서는 이러한 패키지를 기본적으로 이해하고 있어야 합니다.        Python 실무 지식 - 이 튜토리얼에서는 Python으로 작성된 “후크”를 통해 ShotGrid 통합 기능을 수정해야 합니다.        YAML 사용 경험 - 빌드할 파이프라인의 대부분의 구성은 YAML 파일을 수정하여 처리됩니다.  추가 리소스      ShotGrid 지원 사이트        ShotGrid 통합                  사용자 안내서                    관리자 안내서                    개발자 안내서            프로젝트 작성 및 설정이 튜토리얼에서는 ShotGrid에 새 프로젝트를 만들고 프로덕션을 위해 시작할 준비가 된 것처럼 구성해야 합니다. 여기에는 필요한 모든 ShotGrid 엔티티가 제대로 배치되고 링크되어 있는지 확인하는 것도 포함됩니다. 이 튜토리얼에서는 에셋, 시퀀스, 샷 및 태스크 엔티티가 필요하며 새 프로젝트에서 기본값으로 사용할 수 있어야 합니다. 다음을 만듭니다.      두 개의 에셋:                  주전자 캐릭터                    테이블 소품                  하나의 시퀀스        만든 시퀀스에 링크된 하나의 샷        파이프라인 단계별 태스크  다음은 구성된 프로젝트 엔티티가 ShotGrid에서 어떻게 표시되는지 보여 주는 일부 스크린샷입니다.    주전자 및 테이블 에셋    시퀀스에 링크된 샷    태스크소프트웨어 시작 관리자다음으로, ShotGrid 데스크톱에서 Maya 및 Nuke를 시작할 수 있는지 확인해야 합니다. 이러한 각 패키지는 데스크톱에서 해당 아이콘을 클릭하여 시작할 수 있습니다. 각 패키지의 적절한 버전이 시작되는지 확인합니다.응용프로그램이 데스크톱에 표시되지 않거나 예상한 버전이 시작되지 않을 경우 소프트웨어 엔티티를 통해 ShotGrid에서의 시작을 수동으로 구성해야 할 수 있습니다.    ShotGrid에 정의된 기본 소프트웨어 엔티티소프트웨어 엔티티는 프로덕션에 사용할 DCC 패키지를 구동하는 데 사용됩니다. 기본적으로 통합은 표준 설치 위치에서 이러한 패키지를 검색하고 데스크톱을 통해 시작할 수 있도록 합니다. 둘 이상의 버전을 설치하거나 표준 위치가 아닌 곳에 설치한 경우 아티스트의 시작 환경을 조정하기 위해 ShotGrid의 해당 소프트웨어 엔티티 항목을 업데이트해야 할 수도 있습니다.소프트웨어 엔티티 및 적절한 구성 방법에 대한 자세한 정보는 통합 관리자 안내서를 참조하십시오. 예상한 방식으로 DCC가 시작되면 다음 섹션으로 진행할 수 있습니다.구성구성은 프로젝트에 대한 아티스트 워크플로우를 정의합니다. 여기에는 아티스트가 시작하는 DCC 내에 포함할 ShotGrid 통합, 프로젝트의 폴더 구조 정의 방법 및 아티스트가 데이터를 공유할 때 만든 파일 및 폴더에 대한 명명 규칙 지정이 포함됩니다.기본적으로 모든 새 프로젝트는 다양한 기성 소프트웨어 패키지를 사용하여 아티스트 간에 공유 파일에 대한 기본 워크플로우를 제공하는 기본 ShotGrid 통합을 사용하도록 구성됩니다. 다음 섹션에서는 프로젝트의 파이프라인 구성을 인계받고 스튜디오에 맞게 커스터마이즈하는 방법에 대해 설명합니다.프로젝트 구성 인계받기ShotGrid 데스크톱(데스크톱)을 사용하여 프로젝트의 구성을 인계받습니다. 데스크톱 내에서 마우스 오른쪽 버튼을 클릭하거나 오른쪽 하단의 사용자 아이콘을 클릭하면 팝업 메뉴가 표시됩니다. 고급 프로젝트 설정…(Advanced project setup…) 옵션을 선택하고 마법사를 수행하여 프로젝트 구성을 로컬로 설치합니다. 아래 이미지는 필요한 단계를 보여 줍니다. 통합 관리자 안내서에 설명된 파이프라인 구성 가져오기 단계를 수행할 수도 있습니다.    데스크톱 팝업 메뉴에서 고급 프로젝트 설정…(Advanced project setup…)을 선택합니다    ShotGrid 기본값(ShotGrid Default) 구성 유형을 선택합니다.    기본값 구성(Default configuration)을 선택합니다.이번에 처음으로 ShotGrid 프로젝트를 설정하는 경우 프로젝트 데이터의 저장소 위치를 정의하라는 메시지가 표시될 수도 있습니다.  아니면 기존 저장소 위치를 선택할 수 있습니다.    새 저장소를 만듭니다.    새 저장소 이름을 지정합니다.  이 저장소는 사이트 전체 수준의 저장소이며 프로젝트별 저장소가 아닙니다.    사용할 운영 체제에서 이 저장소에 액세스할 수 있는 경로를 설정합니다.사이트 기본 설정(Site Preferences)의 파일 관리(File Management) 섹션에서 ShotGrid 사이트에 대한 저장소를 보고 편집할 수 있습니다.  이러한 설정에 대한 자세한 내용은 여기에서 확인할 수 있습니다.저장소 위치를 선택했으므로 이제 해당 위치에서 새 프로젝트에 대한 디렉토리 이름을 선택합니다.    프로젝트의 파일을 저장할 폴더 이름을 입력합니다.이 튜토리얼에서는 중앙 집중식 구성을 사용합니다.  분산 설정(Distributed Setup) 옵션은 다른 혜택을 제공할 수 있는 대체 옵션을 제공하며 빠른 공유 저장소가 없는 스튜디오의 경우 자주 사용하는 옵션이 될 수 있습니다.  다른 구성 설정의 장단점에 대한 자세한 내용은 툴킷 관리 프리젠테이션에서 확인할 수 있습니다.사이트 전체 수준의 저장소와 달리 구성은 프로젝트별로 다르므로 여기서 선택하는 디렉토리는 구성을 저장하는 데 직접 사용됩니다.    현재 운영 체제에 대해 선택하는 구성 경로를 기록합니다.위 화면에서 선택하는 폴더가 구성이 설치될 위치입니다. 이 튜토리얼에서는 이 폴더의 구성 컨텐츠를 살펴보고 수정합니다.위 화면에서 설정 실행(Run Setup)을 클릭하면 데스크톱에서 구성에 필요한 모든 구성 요소를 다운로드하고 설치하기 시작합니다. 설치 프로세스를 완료하는 데 몇 분 정도 걸릴 수 있습니다. 설치가 완료되면 전체 프로젝트 구성의 로컬 사본이 생기고 이를 다음 단계에서 수정합니다.데스크톱 설치 튜토리얼에서 지정한 구성 위치는 ShotGrid에서 해당 프로젝트에 대한 파이프라인 구성(Pipeline Configurations) 페이지에 기록됩니다.    ShotGrid에서 파이프라인 구성 엔티티 복제다음 섹션을 위한 준비로 이 폴더의 컨텐츠를 숙지합니다.구성 편성간단한 파이프라인 빌드 프로세스를 시작하기 전에 파이프라인 구성 편성 및 작동 방식을 이해해야 합니다. 다음 그래프에서 구성의 주요 구성 요소 및 해당 용도를 중점적으로 설명합니다. 구성 및 관리에 대한 자세한 정보는 툴킷 관리 문서를 참조하십시오.    프로젝트 스키마이 튜토리얼에서 빌드할 간단한 파이프라인은 기본 구성에서 제공되는 프로젝트 스키마를 사용합니다. config/core/schema 폴더를 검색하면 툴킷 앱에서 디스크에 파일을 작성할 때 생성되는 구조에 대해 파악할 수 있습니다. 프로젝트 디렉토리 구조 구성에 대한 자세한 정보는 파일 시스템 구성 참조 설명서를 참조하십시오.템플릿또한 이 튜토리얼에서는 기본 파이프라인 구성에 정의된 템플릿을 사용합니다. config/core/templates.yml 파일을 열고 디스크상의 경로에 입력 및 출력 파일을 매핑하기 위해 앱에서 가장 많이 사용되는 템플릿을 가져올 수 있습니다. 템플릿 지정 시스템에 대한 자세한 정보는 파일 시스템 구성 참조 설명서를 참조하십시오.후크이 튜토리얼의 대부분에는 아티스트 워크플로우를 커스터마이즈하기 위한 앱 후크 수정 작업이 포함됩니다. 이 커스터마이제이션에 대해 자세히 알아보기 전에 후크가 무엇인지, 어떻게 작동하는지, 어디에 있는지에 대한 기본적인 이해가 필요합니다. 관리 및 구성 설명서의 후크 섹션을 참조하십시오.튜토리얼을 진행하면서 툴킷 앱 중 하나에서 정의된 후크를 “인계”받으라는 요청을 받게 됩니다. 앱 후크를 인계받는 프로세스는 간단합니다. 해당 요청을 받을 때마다 다음 단계를 수행하기만 하면 됩니다.      구성의 설치 폴더에서 재지정할 후크가 포함된 앱을 찾습니다. 해당 앱의 hooks 하위 디렉토리를 검색하여 재지정할 후크 파일을 찾습니다.        구성의 최상위 수준 hooks 디렉토리에 후크를 복사하고 필요한 경우 이름을 바꿉니다.      파일이 구성의 hooks 폴더에 있기만 하면 코드를 변경하고 커스터마이즈할 수 있습니다. 해당 앱을 이 새 위치로 지정하려면 추가 단계가 필요합니다. 이 단계는 튜토리얼의 후반부에 나옵니다.파이프라인 빌드이제 파이프라인을 빌드할 준비가 되었습니다. ShotGrid에서 프로젝트를 설정하고 데스크톱을 통해 Maya &amp;amp; Nuke를 시작할 수 있으며 프로젝트 구성을 제어했습니다. 또한 구성의 기본 구조를 이해하고 아티스트 워크플로우를 구체화할 준비가 되었습니다.다음 섹션에서는 각 파이프라인 단계를 수행하면서 기본 제공 기능을 중점적으로 설명하고 ShotGrid 통합을 커스터마이즈하는 프로세스를 안내합니다. 이 섹션을 마칠 때쯤에는 완벽한 기능을 갖춘 간단한 전체 프로덕션 파이프라인을 갖게 됩니다. 또한 아티스트가 프로덕션에서 작업할 때 수행하는 단계도 파악할 수 있습니다.                    참고: 이 튜토리얼의 모든 코드 및 구성은 tk-config-default2 리포지토리의 pipeline_tutorial 분기에서 찾을 수 있습니다. 파일이 있을 위치, 코드를 추가할 위치 등의 힌트가 필요한 경우 이 분기를 활용하십시오.    모델링 워크플로우간단한 파이프라인의 첫 번째 단계는 모델링입니다. 이 섹션에서는 프로젝트의 주전자 에셋에 대한 첫 번째 반복을 만듭니다. 이를 프로젝트의 폴더 구조로 디스크에 저장한 다음 게시합니다.먼저 ShotGrid 데스크톱에서 Maya를 시작합니다.Maya가 완전히 로드되면 파일 열기(File Open) 대화상자가 나타납니다. 이 대화상자를 사용하여 프로젝트 내의 기존 Maya 파일을 찾을 수 있습니다. 또한 ShotGrid 통합에서 인식하는 새 파일을 만들 수 있습니다.에셋(Assets) 탭을 선택하고 주전자의 모델링 태스크로 드릴다운합니다. 이 태스크에 대한 아티스트 작업 파일이 아직 없으므로 + 새 파일(+ New File) 버튼을 클릭합니다.    이 버튼을 클릭하여 비어 있는 새 Maya 세션을 만들고 현재 작업 중인 컨텍스트를 주전자 에셋의 모델 태스크로 설정합니다.                    참고: 이 튜토리얼에서 언제든지 Maya 또는 Nuke의 ShotGrid 메뉴를 통해 ShotGrid 패널을 시작할 수 있습니다. 이 패널에서는 DCC를 종료하지 않고 프로젝트 데이터에 뷰를 제공합니다. 현재 작업 중인 컨텍스트와 해당 컨텍스트 내의 최근 액티비티가 표시됩니다. 또한 패널로 직접 피드백에 대한 노트를 추가할 수 있습니다. 자세한 정보는 ShotGrid 패널 설명서를 참조하십시오.    다음으로, 주전자를 모델링하거나 제공된 주전자를 다운로드하여 가져옵니다.    주전자 모델이 만족스러우면 ShotGrid &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 선택합니다. 이 대화상자에 지정된 이름, 버전 및 유형으로 파일을 저장할지 묻는 메시지가 표시됩니다.    대화상자에 전체 저장 경로를 지정하라는 메시지는 표시되지 않는데 이는 앱이 maya_asset_work 템플릿으로 저장하도록 구성되었기 때문입니다. 이 템플릿은 기본적으로 다음과 같이 정의됩니다.@asset_root/work/maya/{name}.v{version}.{maya_extension}토큰화된 필드, {name}, {version} 및 {maya_extension}은 모두 앱에서 전체 경로를 입력해야 하는 필드입니다. 템플릿의 @asset_root 부분은 다음으로 정의됩니다.assets/{sg_asset_type}/{Asset}/{Step}여기서 토큰화된 필드는 위에서 새 파일을 만들 때 설정한 현재 작업 중인 컨텍스트에 따라 툴킷 플랫폼에 의해 자동으로 추정될 수 있습니다.또한 대화상자 하단에서 작성될 파일 이름 및 경로의 미리보기를 확인합니다. 프로젝트 구성을 인계받을 때 정의한 기본 저장소 및 프로젝트 폴더가 템플릿 경로의 루트를 구성합니다.저장(Save) 버튼을 클릭하여 주전자 모델을 저장합니다.이때 주의해야 할 중요한 점은 방금 완료한 단계가 아티스트가 파이프라인 전체에서 작업 파일을 열고 저장할 때 수행할 단계와 동일하다는 점입니다. 파일 열기(File Open) 및 파일 저장(File Save) 대화상자는 Workfiles 앱의 일부입니다. 이 “다중” 앱은 ShotGrid 통합에서 지원하는 모든 DCC에서 실행되며 모든 아티스트에 대해 일관된 워크플로우를 제공합니다.다음 단계는 주전자를 약간 변경하는 것입니다. 뚜껑 지오메트리가 나중에 리깅할 수 있도록 모델의 나머지 부분과 분리되는지 확인합니다.    작업이 만족스러우면 ShotGrid &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 다시 실행합니다. 이번 대화상자에서는 기본적으로 버전 번호가 2로 설정됩니다. 파일 버전 자동 증분을 사용하면 아티스트가 수행한 전체 작업 내역을 관리할 수 있습니다. 저장(Save) 버튼을 클릭합니다.    주전자 모델을 버전 2로 저장하고 나면 튜토리얼의 이번 섹션에서 마지막 단계를 진행할 준비가 된 것입니다.이제 주전자 모델이 준비되면 서페이스 처리 및 리깅할 수 있도록 게시해야 합니다. 게시하려면 ShotGrid &amp;gt; 게시…(Publish…) 메뉴 액션을 클릭합니다. Publish 앱 대화상자가 표시됩니다.    대화상자에 게시될 항목의 트리가 표시됩니다. 트리에서 일부는 게시할 항목을 나타내고 일부는 게시 작업 중 수행할 액션을 나타냅니다.대화상자의 왼쪽에 현재 Maya 세션을 나타내는 항목이 표시됩니다. 그 아래에 ShotGrid에 게시(Publish to ShotGrid) 하위 액션이 표시됩니다. 모든 세션 지오메트리(All Session Geometry)를 나타내는 추가 항목이 현재 세션의 하위 항목으로 표시됩니다. 여기에도 ShotGrid에 게시(Publish to ShotGrid) 하위 액션이 있습니다.                    참고: 모든 세션 지오메트리(All Session Geometry) 항목이 표시되지 않으면 Maya에서 Alembic 내보내기 플러그인이 활성화되어 있는지 확인합니다.    트리 왼쪽의 항목을 클릭하여 Publish 앱을 탐색합니다. 수행할 항목을 선택하면 게시되는 항목에 대한 설명을 입력할 수 있습니다. 오른쪽의 카메라 아이콘을 클릭하여 항목과 관련된 스크린샷을 찍을 수 있습니다.준비가 되었으면 오른쪽 하단에 있는게시(Publish) 버튼을 클릭하여 현재 작업 파일과 주전자 지오메트리를 게시합니다. 완료되면 ShotGrid에서 주전자 에셋을 검색하여 게시가 성공적으로 완료되었는지 확인할 수 있습니다.    위 이미지에서 주전자 모델이 포함되어 있는 게시된 Alembic 파일을 볼 수 있습니다. Maya 세션 파일에 대한 게시도 볼 수 있습니다. 이러한 게시는 Publish 앱의 트리 뷰에 있는 항목에 해당됩니다.파일 저장(File Save) 대화상자 사용 시 만든 작업 파일과 마찬가지로 이러한 두 게시의 출력 경로는 템플릿으로 구동됩니다. 다음과 같이 표시됩니다(나중에 앱에서 이 템플릿이 구성된 위치를 확인할 수 있음).Maya 세션 게시:@asset_root/publish/maya/{name}.v{version}.{maya_extension}이 템플릿은 기본적으로 작업 파일 템플릿과 매우 유사하며 유일한 차이점은 publish 폴더에 있다는 것입니다.에셋 게시:@asset_root/publish/caches/{name}.v{version}.abc이 템플릿은 Maya 세션 게시 템플릿과 유사하지만 파일이 caches 폴더에 작성됩니다.File Save 대화상자와 달리, 게시할 때는 이름, 버전 또는 파일 확장자 값을 제공할 필요가 없습니다. 왜냐하면 기본적으로 게시자가 작업 파일 경로에서 이러한 값을 가져오기 때문입니다. 후드에서 작업 템플릿을 통해 이러한 값을 추출한 다음 게시 템플릿에 적용합니다. 이 개념은 템플릿을 사용하여 한 파이프라인 단계의 출력을 다른 파이프라인 단계의 입력에 연결하는 방법 및 툴킷 플랫폼과 관련하여 중요한 개념입니다. 자세한 정보는 이후 섹션에서 다룹니다.디스크에서 파일을 찾아 올바른 위치에 만들어졌는지 확인합니다.축하합니다! 주전자의 첫 번째 게시된 반복을 성공적으로 만들었습니다. 학습한 내용을 활용하여 테이블 소품의 모델링 태스크에서 테이블 모델을 게시할 수 있는지 확인합니다. 결과는 다음과 같아야 합니다.    다음 단계는 서페이스 처리 워크플로우입니다.서페이스 처리 워크플로우이 섹션은 모델링 섹션에서 배운 내용을 기반으로 합니다. Loader 앱을 사용하여 이전 섹션에서 만든 주전자 모델을 로드하는 방법을 배우게 됩니다. 또한 Publish 앱을 커스터마이즈하여 주전자 셰이더를 게시하는 방법도 배우게 됩니다.데스크톱에서 Maya를 실행하여 시작합니다. 이전 섹션의 작업 후에 계속 Maya가 열려 있는 경우 Maya를 다시 시작할 필요가 없습니다. Maya가 열려 있으면 ShotGrid &amp;gt; 파일 열기…(File Open…) 메뉴 항목을 사용하여 Workfiles 앱을 엽니다. 모델링 섹션에서와 마찬가지로 에셋(Assets) 탭을 사용하여 주전자 에셋의 태스크로 드릴다운합니다. 이때 서페이스 처리 태스크를 선택하고 + 새 파일(+ New File)을 클릭합니다.    이제 주전자의 서페이스 처리 태스크에서 작업하게 됩니다. 올바른 프로덕션 컨텍스트에 있는지 쉽게 확인하는 방법은 ShotGrid 메뉴의 첫 번째 항목을 확인하는 것입니다.    다음으로 주전자 모델을 새 서페이스 처리 작업 파일로 로드해야 합니다. 이렇게 하려면 Maya의 ShotGrid &amp;gt; 로드…(Load…) 메뉴 항목을 통해 Loader 앱을 시작합니다.    Loader 앱의 레이아웃은 Workfiles 앱과 유사하지만 지금은 작업 파일을 여는 대신 게시된 파일을 검색하여 로드합니다.에셋(Assets) 탭에서 주전자 캐릭터를 찾아 이전 섹션에서 만든 주전자 게시를 표시합니다. Maya 씬 및 Alembic 캐시 게시를 볼 수 있습니다. Alembic 캐시 게시를 선택하면 대화상자 오른쪽에 상세 정보가 표시됩니다. 그런 다음 Alembic 캐시 게시의 액션(Actions) 메뉴에서 참조 만들기(Create Reference) 항목을 클릭합니다. 기본적으로 추가 액션을 수행할 수 있게 로더가 계속 열려 있지만 로더를 닫고 계속 진행할 수 있습니다. 모델링 태스크에서 주전자 게시를 가리키는 참조가 생성된 것을 Maya에서 볼 수 있습니다.    다음으로, 주전자에 간단한 절차 셰이더를 추가합니다.    파이프라인을 빌드할 때 셰이더 관리는 시간이 오래 걸리는 복잡한 태스크일 수 있습니다. 이는 특히 스튜디오에만 해당되는 경우가 많습니다. 왜냐하면 제공되는 Maya 통합에서 셰이더 또는 텍스처 관리 기본 기능을 처리하지 않기 때문입니다.계속하기 전에 ShotGrid &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 사용하여 현재 세션을 저장합니다.커스텀 셰이더 게시이 간단한 파이프라인의 목적에 맞게 게시자 앱을 커스터마이즈하여 서페이스 처리 단계에서 추가 게시 항목으로 Maya 셰이더 네트워크를 내보냅니다. 튜토리얼 후반에서 다운스트림 참조 시 셰이더를 Alembic 지오메트리 캐시에 다시 연결할 수 있는 빠르고 간편한 솔루션을 만듭니다.                    참고: 추가할 커스터마이즈는 확실히 매우 간단하고 쉽습니다. 보다 강력한 솔루션을 위해 외부 이미지를 텍스처 맵으로 사용하는 에셋 관리 측면뿐만 아니라 서페이스 처리된 캐릭터의 대체 표현을 고려해야 할 수 있습니다. 이 예제는 실제 솔루션을 빌드하기 위한 시작점만 제공합니다.                        참고: 게시자 플러그인을 작성하는 방법에 대한 전체 상세 정보는 여기에서 확인할 수 있습니다.    Maya 컬렉터 재지정먼저 Publish 앱의 컬렉션 로직을 수정해야 합니다. 게시자는 앱에 게시하고 표시할 “수집” 항목에 대한 로직을 정의하는 컬렉터 후크로 구성됩니다. 프로젝트 구성 내의 다음 파일에서 구성된 앱의 설정을 찾을 수 있습니다.env/includes/settings/tk-multi-publish2.yml이 파일은 모든 아티스트 환경 내에서 Publish 앱이 사용되는 방법을 정의합니다. 파일을 열고 Maya 섹션, 특히 에셋 단계에 대한 구성을 검색합니다. 다음과 같이 표시됩니다.    컬렉터 설정은 게시자의 컬렉션 로직이 존재하는 후크를 정의합니다. 기본적으로 이 값은 다음과 같습니다.collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;이 정의에는 두 개의 파일이 포함되어 있습니다. 후크 설정에 여러 파일이 나열된 경우 상속을 의미합니다. 첫 번째 파일에는 설치된 Publish 앱의 후크 폴더로 평가할 {self} 토큰이 포함되어 있습니다. 두 번째 파일에는 현재 엔진(이 경우 설치된 Maya 엔진)의 후크 폴더로 평가할 {engine} 토큰이 포함되어 있습니다. 요약하면, 이 값은 Maya 고유의 컬렉터에 Publish 앱의 컬렉터가 상속됨을 의미합니다. 앱의 컬렉터 후크는 실행 중인 DCC에 관계없이 유용한 로직을 갖기 때문에 이러한 형태가 게시자 구성의 일반적인 패턴입니다. DCC 고유 로직은 해당 기본 로직으로부터 상속받고 기본 로직을 확장하여 현재 세션에 해당되는 항목을 수집합니다.                    참고: 에셋 단계 환경에 대한 컬렉터 설정만 변경하므로 다른 컨텍스트(예: 샷 단계)에서 작업 중인 아티스트는 변경 사항을 볼 수 없습니다. 아티스트는 제공되는 기본 Maya 컬렉터를 계속 사용합니다.    구성 섹션에서 후크를 인계받는 방법을 배웠습니다. 구성에 Maya 엔진의 컬렉터 후크를 인계받아 커스터마이제이션 프로세스를 시작합니다.    위의 이미지는 이 작업을 수행하는 방법을 보여 줍니다. 먼저 프로젝트 구성의 hooks 폴더에 폴더 구조를 만듭니다. 나중에 다른 DCC에 대해 동일한 후크를 재지정할 수 있으므로 이렇게 하면 컬렉터 플러그인에 약간의 네임스페이스를 제공합니다. 다음으로, install 폴더에서 Maya 엔진의 컬렉터 후크를 새 후크 폴더 구조로 복사합니다. 이제 구성에 다음 경로를 가진 Maya 컬렉터 사본이 생겼습니다.config/hooks/tk-multi-publish2/maya/collector.py다음으로, 새 후크 위치를 가리키도록 publish2 설정 파일을 업데이트합니다. 이제 컬렉터 설정은 다음 값을 갖습니다.collector: &quot;{self}/collector.py:{config}/tk-multi-publish2/maya/collector.py&quot;{config} 토큰을 확인합니다. 이제 경로가 프로젝트 구성에서 hooks 폴더로 해석됩니다. 새 컬렉터 사본이 앱 자체에서 정의되는 컬렉터에서 상속됩니다.                    참고: 이때 게시했으면 게시 로직은 새 위치에서 간단하게 복사하고 참조한 컬렉터와 정확히 동일합니다.    이제 원하는 IDE 또는 텍스트 편집기에서 컬렉터 사본을 연 다음 process_current_session 메서드를 찾습니다. 이 메서드는 현재 DCC 세션에서 모든 게시 항목 수집을 담당합니다. 새 게시 유형을 수집하게 되므로 이 메서드의 하단으로 이동하여 다음 줄을 추가합니다.self._collect_meshes(item)이 줄은 현재 세션에 있는 모든 메쉬를 수집하기 위해 추가할 새 메서드입니다. 이 메서드는 나중에 만들 예정인 셰이더 게시 플러그인이 작동할 수 있는 메쉬 항목을 만듭니다. 전달되는 항목은 메쉬 항목의 상위가 될 세션 항목입니다.                    참고: 이 메서드는 기존 게시 플러그인을 수정하는 매우 직접적인 접근 방법입니다. 게시자 구조 및 움직이는 모든 부분에 대한 자세한 정보는 개발자 문서를 참조하십시오.    이제 파일 하단에 아래 새 메서드 정의를 추가합니다.    def _collect_meshes(self, parent_item):       &quot;&quot;&quot;       Collect mesh definitions and create publish items for them.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;mesh.png&quot;       )       # iterate over all top-level transforms and create mesh items       # for any mesh.       for object in cmds.ls(assemblies=True):           if not cmds.ls(object, dag=True, type=&quot;mesh&quot;):               # ignore non-meshes               continue           # create a new item parented to the supplied session item. We           # define an item type (maya.session.mesh) that will be           # used by an associated shader publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name (the group name). In the future, other publish           # plugins might attach to these mesh items to publish other things           mesh_item = parent_item.create_item(               &quot;maya.session.mesh&quot;,               &quot;Mesh&quot;,               object           )           # set the icon for the item           mesh_item.set_icon_from_path(icon_path)           # finally, add information to the mesh item that can be used           # by the publish plugin to identify and export it properly           mesh_item.properties[&quot;object&quot;] = object코드가 주석 처리되어 있으며 수행할 작업에 대한 정보를 제공합니다. 요점은 이제 현재 세션에서 최상위 수준 메쉬에 대한 메쉬 항목을 수집하는 로직을 추가한 것입니다. 그러나 이때 게시자를 실행하면 항목 트리에서 어떤 메쉬 항목도 볼 수 없습니다. 왜냐하면 작동하도록 정의된 게시 플러그인이 없기 때문입니다. 다음으로, 메쉬 항목을 연결하고 다운스트림을 사용하기 위해 해당 항목 게시를 처리할 새 셰이더 게시 플러그인을 작성합니다.                    참고: 위 코드에는 메쉬 항목에 대한 아이콘을 설정하는 호출이 있습니다. 이 작업을 위해 다음과 같이 지정된 경로로 구성에 아이콘을 추가해야 합니다.    config/hooks/tk-multi-publish2/icons/mesh.png셰이더 게시 플러그인 만들기다음 단계에서는 메쉬의 셰이더를 디스크로 내보내 게시할 수 있는 게시 플러그인에 새로 수집한 메쉬 항목을 연결합니다. 이렇게 하려면 새 게시 플러그인을 만들어야 합니다. 이 후크의 소스 코드에 대한 이 링크를 따라 이동하고 이를 hooks/tk-multi-publish2/maya 폴더에 저장하고 이름을 publish_shader_network.py로 지정합니다.                    참고: 이 플러그인은 툴킷 플랫폼 및 게시 코드를 처음 사용하는 경우 사용할 코드 집합입니다. 지금은 걱정할 필요가 없습니다. 이 튜토리얼을 진행하면서 진행되는 상황을 이해하고 게시자 기능을 사용하게 됩니다. 지금은 파일을 생성하고 그 용도가 셰이더 네트워크를 디스크에 기록하는 것이라는 점만 알아 두시면 됩니다.    셰이더를 게시하기 전의 마지막 단계는 새 셰이더 게시 플러그인에서 정의한 템플릿 및 구성을 추가하는 것입니다. settings 속성에서 플러그인에 의해 정의된 설정을 다음과 같이 볼 수 있습니다.    @property    def settings(self):       &quot;”” … &quot;””       # inherit the settings from the base publish plugin       plugin_settings = super(MayaShaderPublishPlugin, self).settings or {}       # settings specific to this class       shader_publish_settings = {           &quot;Publish Template&quot;: {               &quot;type&quot;: &quot;template&quot;,               &quot;default&quot;: None,               &quot;description&quot;: &quot;Template path for published shader networks. &quot;                              &quot;Should correspond to a template defined in &quot;                              &quot;templates.yml.&quot;,           }       }       # update the base settings       plugin_settings.update(shader_publish_settings)       return plugin_settings이 메서드는 플러그인에 대한 구성 인터페이스를 정의합니다. “게시 템플릿(Publish Template)” 설정에는 디스크에 셰이더 네트워크를 작성하는 플러그인이 필요합니다. 새 게시 플러그인을 게시자 구성에 추가하고 템플릿 설정을 포함합니다. 이는 컬렉터를 인계받기 전에 수정한 구성 블록과 동일합니다. 해당 내용은 다음 파일에 정의되어 있습니다.env/includes/settings/tk-multi-publish2.yml이제 구성은 다음과 같습니다.    마지막으로, 구성에 새 maya_shader_network_publish 템플릿을 정의해야 합니다. 다음 파일을 편집하여 추가합니다.config/core/templates.yml에셋 관련 Maya 템플릿이 정의된 섹션을 찾아 새 템플릿 정의를 추가합니다. 정의는 다음과 같습니다.    모든 것이 정의되었습니다. 셰이더를 게시할 메쉬를 찾기 위해 Publish 앱의 컬렉터 후크를 재지정했습니다. 수집한 셰이더 항목에 연결할 새 게시 플러그인을 구현하고 디스크에 셰이더 네트워크를 작성할 새 게시 템플릿을 정의하고 구성했습니다.                    참고: 구성을 커스터마이즈하는 동안 Maya를 닫아도 괜찮습니다. 간단히 Maya를 다시 시작하고 파일 열기(File Open) 대화상자를 사용하여 서페이스 처리 작업 파일을 열 수 있습니다. 아래의 다시 로드 단계는 건너뛸 수 있습니다.    ShotGrid 통합 다시 로드커스터마이제이션을 시도하려면 Maya 세션에서 통합을 다시 로드해야 합니다. 이렇게 하려면 ShotGrid &amp;gt; [태스크 이름(Task Name)] &amp;gt; 작업 영역 정보…(Work Area Info…) 메뉴 액션을 클릭합니다.    현재 컨텍스트에 대한 정보를 제공하는 Work Area Info 앱이 시작됩니다. 구성을 변경할 때 통합을 다시 로드할 수 있는 유용한 버튼도 있습니다. 버튼을 클릭하여 앱 및 엔진을 다시 로드한 다음 대화상자를 닫습니다.    셰이더 네트워크 게시이제 프로젝트 구성 변경 결과를 보겠습니다. ShotGrid 메뉴에서 Publish 앱을 시작합니다. 다음과 같이 Publish Shaders 플러그인이 연결된 수집된 주전자 메쉬 항목이 표시됩니다.    작업 설명을 입력하고 게시된 파일과 연결할 서페이스 처리된 주전자의 썸네일을 캡처합니다. 마지막으로, 게시(Publish)를 클릭하여 주전자 셰이더를 디스크로 내보내고 파일을 ShotGrid의 게시로 등록합니다. 완료되면 세션 게시 플러그인이 자동으로 작업 파일을 다음 사용 가능한 버전으로 저장했는지 확인합니다. 지금까지가 ShotGrid 통합에서 지원되는 모든 DCC 내의 기본 동작입니다.이제 ShotGrid에서 주전자 에셋을 검색하여 모두 예상대로 작동되는지 확인할 수 있습니다.    축하합니다! 성공적으로 파이프라인을 커스터마이즈하고 주전자에 대한 셰이더를 게시했습니다. 학습한 내용을 활용하여 테이블 소품의 서페이스 처리 태스크에서 셰이더를 게시할 수 있는지 확인합니다. 결과는 다음과 같아야 합니다.    다음 단계는 리깅 워크플로우입니다.리깅 워크플로우이제는 ShotGrid에서 제공하는 Workfile 및 Publish 앱을 사용하여 작업 파일을 열거나 만들고 저장하고 게시하는 것이 어렵지 않을 것입니다. 또한 Loader 앱을 사용하여 업스트림에서 게시를 로드하기도 했습니다. 학습한 내용을 활용하여 다음 태스크를 완료합니다.      ShotGrid 데스크톱에서 Maya 시작        주전자 에셋의 리깅 단계에서 새 작업 파일 만들기        모델링 단계에서 주전자 alembic 캐시 게시 로드(참조)        주전자 뚜껑을 리깅하여 열고 닫기(간단하게 유지)        주전자 리그 저장 및 게시  ShotGrid에 다음과 같이 나타납니다.    다음으로, 아티스트가 해당 워크플로우에서 업스트림 변경을 처리하는 방법을 알아보겠습니다. 모델링 작업 파일을 열고 주전자 모델을 약간 변경합니다. 그런 다음 업데이트된 작업을 게시합니다. 결과는 다음과 같습니다.    주전자의 리깅 단계에서 작업 파일을 다시 엽니다(ShotGrid &amp;gt; 파일 열기…(File Open…)). 이제 ShotGrid &amp;gt; 씬 분할…(Scene Breakdown…) 메뉴 액션을 시작합니다. 작업 파일에 참조한 모든 업스트림 게시를 보여 주는 Breakdown 앱이 시작됩니다. 이 경우 업스트림 주전자 모델만 있습니다. 다음과 같이 표시됩니다.    앱은 각 참조에 대해 두 개의 표시기 중 하나를 표시합니다. 초록색 체크 표시는 참조된 게시가 최신 버전임을 나타내고 빨간색 “x”는 사용 가능한 최신 게시물이 있음을 나타냅니다. 이 경우에는 사용 가능한 최신 게시물이 있음을 확인할 수 있습니다.이제 참조된 주전자 Alembic 캐시 항목을 선택한 다음(또는 하단의 모든 빨간색 항목 선택(Select All Red) 버튼 클릭) 선택 항목 업데이트(Update Selected)를 클릭합니다.앱에서 Maya 참조가 주전자 Alembic 캐시의 최신 반복으로 업데이트됩니다. 이제 파일에 새 모델이 표시됩니다.    새 모델에 고려해야 하는 리깅 설정을 조정한 다음 변경 사항을 게시합니다.다음 섹션에서는 샷 컨텍스트에서 작업합니다. 다음 단계는 샷 레이아웃입니다.레이아웃 워크플로우이 섹션에서는 프로젝트에 대해 만든 샷에서 작업을 시작합니다. 이전 섹션에서 만든 에셋을 로드하고 샷을 실행해 봅니다. 그런 다음 게시자를 다시 커스터마이즈하고 이번에는 샷 카메라를 게시합니다.이전 섹션에서 학습한 내용을 활용하여 다음 태스크를 완료합니다.      ShotGrid 데스크톱에서 Maya 시작        샷의 레이아웃 단계에서 새 작업 파일 만들기(힌트: Loader에서 샷(Shots) 탭 사용)        주전자의 리깅 단계에서 주전자 게시 로드(참조)        테이블의 모델 단계에서 테이블 게시 로드(참조)  이제 테이블에 주전자가 있는 간단한 씬을 실행합니다. 씬에 camMain이라는 카메라를 추가하고 몇 프레임에 애니메이션을 적용하여 샷의 카메라 이동을 만듭니다.    샷 레이아웃이 만족스러우면 ShotGrid &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 통해 파일을 저장합니다. 이때 계속 진행하여 게시하면 게시할 수 있는 항목으로 전체 Maya 세션만 표시됩니다.파이프라인에 추가하여 많은 유연성을 제공하는 쉬운 커스터마이제이션은 다른 패키지에 쉽게 가져올 수 있는 파일 형식으로 독립 실행형 카메라를 게시하는 기능입니다. 이렇게 하면 일반적으로 레이아웃에 카메라를 한 번 생성한 다음 애니메이션, 조명 및 합성 등의 다른 모든 파이프라인 단계를 수행하고 직접 사용할 수 있습니다.카메라 수집셰이더 게시에서와 같이 첫 번째 단계는 컬렉터 후크를 커스터마이즈하는 것입니다. 이미 Maya에 대한 컬렉터 후크를 인계받고 에셋 단계에 구성했습니다. 이제 샷 파이프라인 단계에 대한 구성을 업데이트해야 합니다. 이렇게 하려면 게시자의 구성 파일을 수정하고 Maya 샷 단계 컬렉터 설정을 편집합니다.    이제 샷 컨텍스트 내의 태스크에서 작업할 때 커스텀 컬렉터 로직이 실행됩니다. 다음 단계에서는 커스텀 카메라 컬렉션 로직을 추가합니다.커스텀 컬렉터 후크를 열고 서페이스 처리 섹션에서 메쉬를 수집하는 호출을 추가한 process_current_session 메서드의 하단에 다음 메서드 호출을 추가합니다.self._collect_cameras(item)다음으로 파일 하단에 다음과 같이 메서드 자체를 추가합니다.    def _collect_cameras(self, parent_item):       &quot;&quot;&quot;       Creates items for each camera in the session.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;camera.png&quot;       )       # iterate over each camera and create an item for it       for camera_shape in cmds.ls(cameras=True):           # try to determine the camera display name           try:               camera_name = cmds.listRelatives(camera_shape, parent=True)[0]           except Exception:               # could not determine the name, just use the shape               camera_name = camera_shape           # create a new item parented to the supplied session item. We           # define an item type (maya.session.camera) that will be           # used by an associated camera publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name. In the future, other publish plugins might attach to           # these camera items to perform other actions           cam_item = parent_item.create_item(               &quot;maya.session.camera&quot;,               &quot;Camera&quot;,               camera_name           )           # set the icon for the item           cam_item.set_icon_from_path(icon_path)           # store the camera name so that any attached plugin knows which           # camera this item represents!           cam_item.properties[&quot;camera_name&quot;] = camera_name           cam_item.properties[&quot;camera_shape&quot;] = camera_shape다시 한 번 언급하지만 코드가 주석 처리되어 있으며 수행할 작업에 대한 정보를 제공합니다. 현재 세션의 모든 카메라에 대한 카메라 항목을 수집하는 로직을 추가했습니다. 이전과 마찬가지로, 이때 게시자를 실행하면 항목 트리에서 어떤 카메라 항목도 볼 수 없습니다. 왜냐하면 작동하도록 정의된 게시 플러그인이 없기 때문입니다. 다음으로, 이러한 항목을 연결하고 다운스트림을 사용하기 위해 해당 항목 게시를 처리할 카메라 게시 플러그인을 작성합니다.                    참고: 위 코드에는 카메라 항목에 대한 아이콘을 설정하는 호출이 있습니다. 이 작업을 위해 다음과 같이 지정된 경로로 구성에 아이콘을 추가해야 합니다.    config/hooks/tk-multi-publish2/icons/camera.png커스텀 카메라 게시 플러그인다음 단계에서는 메쉬의 셰이더를 디스크로 내보내 게시할 수 있는 게시 플러그인에 새로 수집한 메쉬 항목을 연결합니다. 이렇게 하려면 새 게시 플러그인을 만들어야 합니다. 이 후크의 소스 코드에 대한 이 링크를 따라 이동하고 이를 hooks/tk-multi-publish2/maya 폴더에 저장하고 이름을 publish_camera.py로 지정합니다.카메라 게시 구성마지막으로, 샷 단계에 대한 Publish 앱의 구성을 업데이트해야 합니다. 설정 파일을 편집하여 새 플러그인을 추가합니다.env/includes/settings/tk-multi-publish2.yml이제 구성은 다음과 같습니다.    새 플러그인의 settings 메서드에서 정의한 대로 파일에 추가된 두 개의 설정을 확인할 수 있습니다. 셰이더 플러그인과 마찬가지로 카메라 파일이 작성될 위치를 정의하는 게시 템플릿(Publish Template) 설정이 있습니다. 카메라 설정은 플러그인이 작동해야 할 카메라를 구동하는 카메라 문자열의 목록입니다. 즉, 일부 유형의 카메라 명명 규칙이 있고 이 설정을 사용하면 사용자가 규칙과 일치하지 않는 카메라의 항목을 게시할 수 없습니다. 위의 이미지에서는 camMain 카메라만 게시할 수 있도록 제공됩니다. 추가한 플러그인의 구현은 cam* 같이 와일드카드 패턴으로도 작동합니다.변경 사항을 테스트하기 전 마지막 단계는 새 카메라 게시 템플릿에 대한 정의를 추가하는 것입니다. config/core/templates.yml 파일을 편집하고 Maya 샷 템플릿 섹션에 템플릿 정의를 추가합니다.    이제 새 플러그인을 사용하여 카메라를 게시할 수 있습니다. Work Area Info 앱을 사용하여 통합을 다시 로드한 다음 게시자를 시작합니다.    이미지에서 볼 수 있듯이, 새 카메라 항목이 수집되고 게시 플러그인이 연결됩니다. 계속 진행하여 게시(Publish)를 클릭하여 디스크에 카메라를 작성하고 ShotGrid에 등록합니다.                    참고: Alembic 내보내기와 유사하게 카메라 게시 플러그인을 사용하려면 FBX 내보내기 플러그인을 로드해야 합니다.  카메라 게시 플러그인 항목이 표시되지 않으면 FBX 플러그인이 로드되었는지 확인하고 게시자를 다시 시작합니다.    ShotGrid에 다음과 같이 나타납니다.    이제 완료되었습니다. 다음 단계는 애니메이션입니다.애니메이션 워크플로우지금까지는 커스텀 파일 유형/컨텐츠를 디스크에 작성하고 다른 파이프라인 단계에서 공유하기 위해 Publish 앱만 커스터마이즈했습니다. 이 섹션에서는 Loader 앱의 구성을 커스터마이즈하여 커스텀 게시를 가져오거나 참조할 수 있도록 하는 작업을 완료합니다.이전 섹션에서 학습한 내용을 활용하여 다음 태스크를 완료합니다.      ShotGrid 데스크톱에서 Maya 시작        샷의 애니메이션 단계에서 새 작업 파일 만들기        샷의 레이아웃 단계에서 Maya 세션 게시 로드(참조)                      참고: 레이아웃 세션 게시 파일에 카메라가 포함되었음을 확인할 수 있습니다. 강력한 파이프라인에서 별도의 카메라 게시 파일이 하나의 실제 카메라 정의가 될 수 있도록 세션 게시에서 카메라를 명시적으로 숨기거나 제외할 수 있습니다. 계속 진행하여 참조로 포함된 카메라를 삭제하거나 숨깁니다.    커스텀 카메라 로더 액션카메라 게시를 가져오거나 참조하도록 Loader 앱을 커스터마이즈하려면 앱의 설정 파일을 편집해야 합니다. 구성에서 파일 경로는 다음과 같습니다.config/env/includes/settings/tk-multi-loader2.ymlMaya에 대해 앱이 구성된 섹션을 찾고 action_mappings 설정의 액션 목록에 다음 줄을 추가합니다.FBX Camera: [reference, import]커스텀 카메라 게시 플러그인에서, 디스크에 카메라를 작성하는 데는 Maya의 FBXExport mel 명령이 사용되었으며 ShotGrid에 파일을 등록하는 데 사용된 게시 유형은 FBX Camera입니다. 설정에 추가한 줄은 FBX Camera 유형의 게시에 대해 reference 및 import 액션을 표시하도록 로더에 지시합니다. 이러한 액션은 Loader 앱의 tk-maya-actions.py 후크에 정의되어 있습니다. 이러한 액션은 Maya가 참조하거나 가져올 수 있는 모든 파일 유형을 처리하는 방식으로 구현됩니다. 커스텀 플러그인에 의해 생성된 .fbx 파일은 이 범주에 해당하므로 이 작업이 게시된 카메라를 로드하는 데 필요한 유일한 변경 사항입니다.이제 앱 설정은 다음과 같습니다.    이제 Work Area Info 앱을 통해 통합을 다시 로드하고 새 설정을 선택한 다음 레이아웃에서 게시된 카메라를 찾습니다.    새 게시 유형별로 필터링한 다음 카메라에 대한 참조를 만듭니다. 로더를 닫고 새 참조 카메라를 사용하여 이전 섹션에서 만든 카메라 모션을 다시 재생할 수 있습니다.다음으로, 주전자 모델이 무언가를 수행하는 애니메이션을 적용합니다(간단하게 유지).    애니메이션이 만족스러우면 이전 섹션에서와 같이 작업 파일을 저장하고 게시합니다.다음 단계는 조명입니다.조명 워크플로우이 섹션에서는 이전 섹션에서 게시한 모든 것을 함께 가져와 샷을 렌더링합니다. 이렇게 하려면 주전자 에셋의 서페이스 처리 단계에서 게시한 셰이더를 로드하도록 Loader 앱을 커스터마이즈합니다.먼저, 이전 섹션에서 학습한 내용을 활용하여 다음 태스크를 완료합니다.      ShotGrid 데스크톱에서 Maya 시작        샷의 조명 단계에서 새 작업 파일 만들기        샷의 애니메이션 단계에서 Maya 세션 게시 로드(참조)        샷의 레이아웃 단계에서 카메라 게시 로드(참조)  커스텀 셰이더 로더 액션서페이스 처리 단계에서 게시한 셰이더를 로드하려면 이전 섹션에서 언급한 tk-maya-actions.py 후크를 인계받아야 합니다. 해당 후크를 설치 위치에서 구성으로 복사합니다.    이 후크는 지정된 게시에 대해 수행할 수 있는 액션 목록 생성을 담당합니다. Loader 앱은 제공된 통합에서 지원되는 각 DCC에 대해 이 후크와 다른 버전을 정의합니다.서페이스 처리 워크플로우 섹션에서 게시된 셰이더는 바로 Maya 파일이므로 내보낸 카메라와 같이 기존 로직을 변경하지 않고 로더에서 참조할 수 있습니다. 유일하게 변경해야 할 사항은 셰이더가 파일에 참조된 후 적절한 메쉬에 셰이더를 연결하도록 액션 후크에 새 로직을 추가하는 것입니다.액션 후크의 마지막에(클래스 외부) 다음 메서드를 추가합니다.    def _hookup_shaders(reference_node):       &quot;&quot;&quot;       Reconnects published shaders to the corresponding mesh.       :return:       &quot;&quot;&quot;       # find all shader hookup script nodes and extract the mesh object info       hookup_prefix = &quot;SHADER_HOOKUP_&quot;       shader_hookups = {}       for node in cmds.ls(type=&quot;script&quot;):           node_parts = node.split(&quot;:&quot;)           node_base = node_parts[-1]           node_namespace = &quot;:&quot;.join(node_parts[:-1])           if not node_base.startswith(hookup_prefix):               continue           obj_pattern = node_base.replace(hookup_prefix, &quot;&quot;) + &quot; d*&quot;           obj_pattern = &quot;^&quot; + obj_pattern + &quot;$&quot;           shader = cmds.scriptNode(node, query=True, beforeScript=True)           shader_hookups[obj_pattern] = node_namespace + &quot;:&quot; + shader       # if the object name matches an object in the file, connect the shaders       for node in (cmds.ls(references=True, transforms=True) or []):           for (obj_pattern, shader) in shader_hookups.iteritems():               # get rid of namespacing               node_base = node.split(&quot;:&quot;)[-1]               if re.match(obj_pattern, node_base, re.IGNORECASE):                   # assign the shader to the object                   cmds.select(node, replace=True)                   cmds.hyperShade(assign=shader)이제 셰이더 연결 로직을 호출하기 위해 _create_reference 메서드 마지막에 다음 두 줄을 추가합니다.    reference_node = cmds.referenceQuery(path, referenceNode=True)    _hookup_shaders(reference_node)&amp;lt;/td&amp;gt;코드는 새 참조가 만들어질 때마다 실행되므로 셰이더가 이미 파일에 있는 경우 새 지오메트리 참조 시 셰이더를 할당해야 합니다. 마찬가지로, 셰이더를 참조하고 지오메트리가 이미 존재할 때 작동합니다.                    참고: 이 연결 로직은 매우 억지스럽고 프로덕션에서 바로 사용할 수 있는 파이프라인을 구현할 때 고려해야 할 네임스페이스 및 기타 Maya와 관련된 미묘한 문제를 적절하게 처리하지 못합니다.    마지막으로, 다음 파일을 편집하여 샷의 로더 설정을 새 후크로 지정합니다.config/env/includes/settings/tk-multi-loader2.yml또한 Maya 셰이더 네트워크 게시 유형을 참조 액션과 연결합니다. 이제 로더 설정은 다음과 같습니다.    이제 Work Area Info 앱을 통해 통합을 다시 로드하여 새 설정을 선택한 다음 서페이스 처리에서 게시된 셰이더를 검색합니다.주전자 셰이더 네트워크 게시에 대한 참조를 만듭니다.    이제 테이블 셰이더 네트워크를 로드합니다. Maya에서 하드웨어 렌더링을 켜면 셰이더가 애니메이션 단계에서 자동으로 메쉬 참조에 연결해야 합니다.    이제 씬에 약간의 조명을 추가합니다(간단하게 유지).    Maya 렌더 게시디스크에 샷을 렌더링합니다.                        참고: 여기에서 볼 수 있듯이 주전자 및 테이블 에셋 둘 다 서페이스 처리에 문제가 있습니다. 이 튜토리얼에서는 의도된 예술적 선택이었다고 가정합니다. 이러한 문제를 해결하려면 언제든지 이러한 에셋의 서페이스 처리 작업 파일을 로드하고 셰이더를 조정하여 다시 게시할 수 있습니다. 이 경우, 조명 작업 파일의 참조를 업데이트하고 다시 렌더링해야 합니다. 단계를 진행하면 참조를 다시 로드한 후 Breakdown 앱이 업데이트된 셰이더를 다시 연결하지 않는다는 사실을 알 수 있습니다. 셰이더 참조를 연결하도록 로더를 수정한 경험을 기반으로 필요한 로직을 추가하도록 Breakdown 앱의 씬 작업 후크를 업데이트할 수 있어야 합니다. 힌트: 이 파일의 업데이트 메서드를 참조하십시오.    제공된 ShotGrid 통합은 파일에 정의된 렌더 레이어를 확인하여 이미지 시퀀스를 수집합니다. 렌더가 완료되면 게시자를 시작합니다. 렌더링된 시퀀스가 트리의 항목으로 표시됩니다.    계속 진행하여 세션 및 렌더링된 이미지 파일 시퀀스를 게시합니다. ShotGrid에 다음과 같이 나타납니다.    다음 단계는 합성입니다.합성 워크플로우이 마지막 튜토리얼 섹션에서는 Nuke에서 제공하는 기본 통합의 일부를 소개합니다. 이전 섹션에서 확인한 앱 외에도 ShotGrid 인식 쓰기 노드와 리뷰를 위해 다른 작업자에게 빠르게 렌더를 보낼 수 있는 앱에 대해 알아봅니다.다음 단계를 수행하여 작업 파일을 준비합니다.      ShotGrid 데스크톱에서 Nuke를 시작합니다.        Maya에서와 마찬가지로, ShotGrid &amp;gt; 파일 열기…(File Open…) 메뉴 액션을 사용하여 샷의 합성 단계에서 새 작업 파일을 만듭니다.  Loader 앱을 통해 이전 섹션에서 렌더링 및 게시된 이미지 시퀀스를 로드합니다.    Image 및 Rendered Image 게시 유형(유형은 파일 확장자에 따라 다름)에 정의된 액션은 읽기 노드 만들기(Create Read Node)입니다. 이 액션을 클릭하여 Nuke 세션에 새 Read 노드를 만듭니다.Nuke 프로젝트 설정 출력 형식이 렌더링된 이미지와 일치하는지 확인합니다. 배경으로 사용할 균일 색상을 만들고 읽기 노드와 병합합니다. 합성을 볼 뷰어를 연결합니다.    합성에 만족하면 ShotGrid &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 사용하여 작업 파일을 저장합니다.다음으로, Nuke의 왼쪽 메뉴에 있는 ShotGrid 로고를 클릭합니다. 해당 메뉴에서 ShotGrid 인식 쓰기 노드 중 하나를 클릭합니다.    ShotGrid Write Node 앱에서는 기본 제공 Nuke Write node의 맨 위에 현재 ShotGrid 컨텍스트를 기반으로 출력 경로를 자동으로 평가하는 레이어를 제공합니다.    디스크로 이미지 프레임을 렌더링합니다. 이제 Nuke 세션을 게시하여 렌더링된 이미지와 작업 파일을 연결할 수 있습니다. 기본적으로 게시자는 렌더링된 프레임을 수집하고 플러그인을 연결하여 ShotGrid으로 프레임을 등록합니다. 두 번째 플러그인은 백그라운드에서 실행되는 리뷰 제출이라는 통합 방식으로 리뷰할 프레임을 업로드합니다. 이 앱은 Nuke를 사용하여 업로드되어 리뷰에 사용할 수 있는 Quicktime을 생성합니다.    또 다른 유용한 통합은 Quick Review 앱입니다. 이 앱은 Quicktime을 빠르게 생성하고 리뷰를 위해 ShotGrid에 업로드하는 출력 노드입니다. 이 앱은 ShotGrid Write Node 옆의 왼쪽 메뉴에서 찾을 수 있습니다.    빠른 리뷰 노드를 만든 다음 Upload 버튼을 클릭하여 디스크로 입력을 렌더링하고 Quicktime을 생성하고 리뷰를 위해 결과를 ShotGrid에 업로드합니다. 프레임을 제출하기 전에 몇 가지 표준 옵션이 제공됩니다.    업로드된 Quicktime을 모두 보려면 ShotGrid의 미디어(Media) 탭을 확인합니다.    ShotGrid의 미디어 리뷰에 대한 자세한 정보는 공식 설명서를 참조하십시오.결론축하합니다. 모두 완료했습니다. 이 튜토리얼이 ShotGrid 통합을 사용하여 고유한 커스텀 파이프라인을 빌드하는 시작점이 되었기를 바랍니다. 기본 통합을 확장하여 스튜디오의 특정 요구 사항을 충족하는 방법을 이해할 수 있어야 합니다.shotgun-dev Google 그룹에서 다른 스튜디오에서는 툴킷을 어떻게 사용하는지 질문하고 배울 수 있습니다.  최신 게시물을 보려면 등록하십시오.기본 통합에서 제공되지 않는 기능이나 워크플로우가 있으면 언제든 자체 앱을 작성할 수 있습니다. 첫 번째 앱 작성을 시작하려면 이 문서를 참조하십시오.언제나처럼 이 튜토리얼에 대한 추가 질문이나 ShotGrid 또는 툴킷 플랫폼에 대한 일반적인 질문이 있으면 언제든지 티켓을 제출해 주십시오.",
    "url": "/cb8926fc/",
    "relUrl": "/cb8926fc/"
  },
  "69": {
    "id": "69",
    "title": "Planning Your Setup",
    "content": "Planning Your SetupPick your optionsPick which features you want to activate  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media ReplicationAWS Account CreationBefore going further, you will require an AWS Account. If you don’t already have an AWS Account, create your AWS Account.Choose an AWS RegionChoose an AWS Region for your AWS S3 bucket and VPC. Which region to use? You should chose the a region that is the closest possible to your studio.If your company is located in different locations, consider enabling the media replication feature to reduce latency and improve performancePlan the VPC IP rangesPlan your AWS VPC and subnets IP ranges.IP Range Example            Region      VPC      Subnet 1      Subnet 2      Subnet 3                  ap-southeast-2      10.1.0.0/16      10.1.0.0/24      10.1.1.0/24      10.1.2.0/24      Plan how you will privately access your AWS VPCIf you plan to activate any of the Traffic Isolation feature, you will need a way to connect your AWS VPC and your network infrastructure. The main options are:  AWS Direct Connect  Other VPN solutionWe highly recommand you to leverage Direct Connect. Direct Connect guarantees the lowest latency possible to the ShotGrid services, a consistent network experience, and allow you to leverage the optimization AWS is relying on to guarantee an optimal performance across the globe.Next StepWith your plan layed down, you are ready to start implementing the AWS building blocks that will allow you to activate the isolation features. To avoid disruption on your production site, you will first materialize and test your setup on your Migration Test Site",
    "url": "/7897b2e2/",
    "relUrl": "/7897b2e2/"
  },
  "70": {
    "id": "70",
    "title": "Private Link",
    "content": "Private LinkAWS PrivateLink is an AWS service that connects different AWS VPCs without going through the public internet.In conjunction with AWS Direct Connect, PrivateLink helps create a dedicated connection between your studio and ShotGrid’s infrastructure.",
    "url": "/9da985a7/",
    "relUrl": "/9da985a7/"
  },
  "71": {
    "id": "71",
    "title": "Python 3 Porting Best Practices",
    "content": "Python 3 Porting Best PracticesWhy the move to Python 3?There are a few compelling reasons to make the leap to Python 3.  Perhaps the most dramatic is the Python 2 end of life, which occurred on January 1, 20201. With the sunsetting of Python 2, all support for Python 2 ceases, meaning that even new security vulnerabilities found in Python 2 will not be addressed.For CY2020, the VFX reference platform makes the switch as well, targeting Python version 3.7.x.  As a practical matter for many of us, all of this will mean we don’t have much choice in when to add support for Python 3 – as DCCs (digital content creation applications) that we develop for begin to move to Python 3 interpreters, it will become a necessity to support them.Things to Consider Before StartingWhen considering moving to support Python 3, it’s good to look at the requirements and application of your codebase to set expectations.  Obviously, any host applications your code runs in will help drive this decision.  Knowing whether you need to support many different Python interpreter versions and, if so, which ones, will be important information as you decide on the porting process that makes sense for you.Next, take an audit of what libraries your code depends on.  If any of these libraries do not have Python 3 compatible versions, you’ll need to find an alternative library, or fork the library to provide compatibility yourself. Both of these options could potentially be costly decisions and are important to consider early on.  Additionally, even libraries that do offer Python 3 compatible versions may not be drop-in replacements, and some libraries choose to fork for Python 3 support rather than maintain compatibility for both Python 2 and 3 as a single source.  We’ll discuss this in more depth in the “Porting Options” section below.Finally, it’s worth noting that while it is possible to continue to support Python versions older than 2.5 and Python 3 simultaneously2, this will make your life much harder.  Since Python 2.5 is very old and not used in modern DCC versions, this guide will work under the assumption that Python 2.5 and earlier will not be targeted.  If you do need to support older versions of Python, a branching approach as described in the “Porting Options” section below may be your best option.What’s Different in Python 3Python 3 comes with some slight syntax changes, changes to builtin functions, new features, and small behavior changes.  There are many great guides that enumerate these specific changes and provide examples.  Rather than dive into specifics here, the goal of this guide will be to describe the porting process from a higher-level perspective, with a few small deep dives where compatibility may be more complicated than just matching syntax.Porting OptionsFor most of us, porting our code to only support Python 3 is not yet an option.  Many DCCs still require Python 2 support, and this is unlikely to change overnight.  This means that in the real world, it will be a necessity to be able to support both Python 2 and 3.There are two major approaches to supporting Python 2 and 3 simultaneously.  We’ll discuss both of them briefly:BranchingIn this approach, a new Python 3 compatible branch of your code is maintained in parallel with the current (Python 2 compatible) branch.  This has the advantage of letting you write cleaner, easier to read Python 3 code, and allows you to fully leverage new features without needing branching logic to maintain Python 2 support.  It also means that when the time comes to drop support for Python 2, you’ll be left with a cleaner, more modern starting point in your Python 3 branch.  The obvious downside here is that maintaining two branches can be unwieldy and mean more work, especially if the Python 3 and Python 2 code starts to diverge as the Python 3 branch can leverage new features that can significantly change how your code looks (e.g. asyncio.)Cross-CompatibilityIn this approach, a single branch is maintained that uses the subset of syntax and builtins that are compatible with both Python 2 and 3.  This allows for a graceful transition from Python 2 to 3 without maintaining multiple branches of your code.  There are a few popular libraries designed to help with this approach, and it’s a commonly-used solution to the problem of transition from Python 2 to 3.  In addition to the reduced complexity compared to maintaining multiple branches, this approach also means you don’t need to change your code distribution mechanisms or worry about using the correct (Python 2 or 3) version of your code at import time.The two most commonly used libraries for this approach are future and six.futureThe future module is probably the most popular choice for Python 2 + 3 compatibility.  It backports many Python 3 libraries to Python 2, and aims to allow you to move your codebase to a pure Python 3 syntax.  Because it backports modules and works by shadowing builtins, it is slightly more invasive than six.  Given the variety of DCCs and unknown client code in VFX environments, future may be too invasive and in an environment like this may pose a greater risk of causing problems down the road.  For this reason, we will focus on using six instead.sixThe six module does not attempt to backport Python 3 modules, or allow you to write pure Python 3 syntax, but instead unifies renamed modules and changed interfaces inside the six.moves namespace.  This allows you to update imports and use six’s helper functions to write code that is both Python 2 and 3 compatible.Testing and LintingBlackThe porting process requires an examination of the entire python codebase, and introduces a fair amount of noise in the revision control history.  This makes it a good opportunity to take care of any other housekeeping that may have similar impacts.  We took this opportunity to apply black to our code.  This is not strictly necessary or directly related to Python 3 compatibility (unless your code is mixing tabs and spaces3), but given the reasons identified above, we decided this was a good opportunity to modernize our code formatting.TestsTest coverage was incredibly valuable during the porting process since it allowed us to quickly find problems that still needed to be addressed, and verify that large sections of code were working as expected without as much manual intervention.  In many cases, we found it worthwhile to increase test coverage as part of the porting process to ensure that Python 2/3 specific cases (e.g. unicode handling) were being addressed correctly.  This being said, we recognize that in many cases the realities of production mean that test coverage is sparse, and that adding tests to code that has little or no coverage may be too time consuming to be worthwhile as part of a project like adding Python 3 compatibility.  For those in this situation, there may still be some value in using coverage measurement tools and some more basic testing code during the porting process, as these tools can provide fast feedback on what code has been covered and what may still need attention.Porting ProcedureAutomated Porting using modernizepython-modernize is a tool that can be very useful for automatically generating Python 3 compatible code.  modernize usually produces runnable code with minimal human intervention, and because of this can be a great tool to get most of the way to Python 3 compatibility very quickly.  Of course, as an automated tool it does come with the drawbacks one would expect.  It frequently produces less readable and less efficient code (e.g. wrapping all iterables in a list() instantiation.)  In some cases, modernize can even introduce regressions that might be difficult to spot.  There are also some areas where you’ll find modernize is not much help at all, like when dealing with bytes and text.  Since these decisions require a bit more understanding of context, you’ll likely have to spend some time manually addressing the handling of strings in your code even if you do rely on modernize for the bulk of the compatibility work.The alternative to using an automated tool like modernize, of course, is to go through code manually to fix incompatibilities.  This can be tedious, but in our experience generally produces nicer looking code.For our process we went with a hybrid approach, using modernize with a select set of fixers, and doing some of the work manually.  We also broke the process into two stages; first doing a pure syntax compatibility and code formatting pass, and then doing a more manual Python 3 port.  Our process was as follows:In a branch:  Run modernize with the except, numliterals, and print fixers  python-modernize --no-diffs --nobackups -f except -f numliterals -f print -w .  Make sure the resulting code is Python 3 syntax compliant by compiling it with Python 3.  The goal here is not to have your code work in Python 3, but to ensure that the basic formatting and automatable syntax fixes are in place.  If your code does not successfully compile after this step, you’ll need to find the source of the problem and either add additional fixers to the above step, or manually fix the incompatibilities.  Ensure that any changes you make manually at this stage are syntax only and will not change the behavior of the code in Python 2.  python3 -m compileall .  Run black on the resulting codeThis branch should not change any behavior or functionality, and should not introduce regressions, so it is considered safe to merge at this point.  This helps keep the history easier to read, and means that the Python 3 compatibility branch and master will diverge less during the porting process, making for an easier merge once the work is done.In a new branch, the actual Python 3 port can now begin:  Search for method names that may require some work to deal with list/view/iterator differences between Python 2 and 3.  In Python 3 .values(), .items() and .keys() return an iterator or view instead of a list, so in cases where these methods are called the code should be able to handle both iterator and list returns, otherwise the result will need to be cast to a list.  Similarly, the filter() method returned a list in Python 2, but now returns an iterator.  Change calls from dict.iteritems() and dict.itervalues() to dict.items() and dict.values() if the returned collection won’t be too big.  In these cases, the resulting cleaner code at the cost of a slight performance hit in Python 2 is preferable.  In cases where the collection might contain thousands of items or more, use six.iteritems and six.itervalues instead.  If dict.iterkeys() was used, simply replace the code with something like for key in dictionary:, since this will iterate on keys in both Python versions.  Watch out that returning an iterator in Python 3 doesn’t change the semantics of the code however. If a method used to return dict.values(), you’ll need to wrap the call inside list(dict.values()) to ensure the method always returns a list in all versions on Python.  Search for str, basestring, unicode, open, pickle, encode, decode since these will be areas of the code that likely require some attention to handling of bytes and strings.  We used the coercion helper methods provided by six (e.g. ensure_string) where needed.  See the sections on bytes and pickle below.  Unless generating a super long range, xrange can be changed to range for simplicity, otherwise six.range can be used.  After committing the manual changes from above, run a full python-modernize and go through the diff manually.  Many of the resulting changes will be unwanted, as discussed above, however this is a good way to catch potential problems that were overlooked in the manual porting process.  python-modernize --no-diffs --nobackups -f default . -w &amp;amp;&amp;amp; git diff HEAD  Test the resulting code to find the remaining problems.  There are some incompatibilities that don’t have fixers (this is a good resource to look at to get an idea of what those changes entail), and it’s easy to overlook text/binary problems during the port process.We chose to use this process because we believe it allowed us to maintain a standard of more readable, efficient code than would have been automatically generated by using modernize on its own.GotchasBytes WoesPython 3 introduces a strict separation between binary and textual data.  This is a long-called-for addition that most see as an improvement, but for Python 2 + 3 compatible code it adds some headaches.  Since Python 2 does not enforce this separation, and Python 3 introduces new types to do so, code that deals with data and strings will likely need some attention.  For the most part this just means making sure that strings are encoded / decoded properly, for which the six.ensure_binary and six.ensure_text helper functions are invaluable.  See the examples below for common applications of these methods.  In some cases, however, this can be more complicated.  For an example of this, see the pickle section below.# base64.encodestring expects str in Python 2, and bytes in Python 3.# By using six.ensure_binary() we can ensure that the we always# pass it the correct type.base64.encodestring(six.ensure_binary(some_string))# In this example (from tk-multi-publish2), we get a list of files# from a QDropEvent in Pyside.  The  filenames are unicode, however# they're being passed to code that expects str.# In Python 2, this had looked like:if isinstance(category_type, unicode):                    category_type = category_type.encode(&quot;utf-8&quot;)# Using six, we can get the same behavior in Python 2, and ensure# compatibility with Python 3 with:category_type = six.ensure_str(category_type)The pickle PicklePickle in Python 3 returns a bytes object from dumps(), where previously it had returned a str.  Additionally, the output of pickle.dumps() in Python 3 contains  x00 bytes, which cannot be decoded. This is not a  problem if the data is being stored in a file, but if the pickled data is being stored in, for example, an environment variable, this can become problematic.  As a workaround, we found that by forcing pickle to use protocol 0, no 0 bytes were included, and the output is once again decodable.  This comes at the cost of the slightly less efficient and fewer-featured older protocol.# Dumping data to a pickle string:DUMP_KWARGS = {&quot;protocol&quot;: 0}# Force pickle protocol 0, since this is a non-binary pickle protocol.# See https://docs.python.org/2/library/pickle.html#pickle.HIGHEST_PROTOCOL# Decode the result to a str before returning.pickled_data = six.ensure_str(cPickle.dumps(data, **DUMP_KWARGS))# Loading data from a pickle string:LOAD_KWARGS = {&quot;encoding&quot;: &quot;bytes&quot;} if six.PY3 else {}data = cPickle.loads(six.ensure_binary(data), **LOAD_KWARGS)Regex  W flagIn Python 3, regular expression metacharacters match unicode characters where in Python 2 they do not.  To reproduce the previous behavior, Python 3 introduces a new re.ASCII flag, which does not exist in Python 2.  To maintain consistent behavior across Python 2 and 3, we wrapped re functions to include this flag across the board in Python 3.Dictionary OrderPrior to Python 3.7, dictionary order was not guaranteed.  As of Python 3.7, insertion order is preserved in dictionaries[11].  In practice, on Python 2.7 dictionary order was random but deterministic (though this was not guaranteed), on some versions of Python (including some version of Python 3) dictionary order is non-deterministic[10].  While code prior to Python 3.7 should not rely on dictionary key order being deterministic, there were instances where this assumption was made in our unit tests.  These tests broke in Python 3.7, and needed to be updated to ensure that dictionary key order was not relied upon.sys.platformIn Python 3.3+ sys.platform on Linux returns linux, where previously it had returned “linux” appended with the kernel major version (i.e. linux2).  Of course when testing for Linux it is easy enough to check sys.platform.startswith('linux').  We chose to centralize these tests and platform “normalization”, and introduced functions sgtk.util.is_windows(), sgtk.util.is_linux(), sgtk.util.is_macos(), as well as a sgsix.platform constant that contains a normalized platform string that can be used for consistent mapping to platform names across python versions.Notes            https://www.python.org/doc/sunset-python-2/ &amp;#8617;              https://docs.python.org/3/howto/pyporting.html#drop-support-for-python-2-6-and-older &amp;#8617;              https://portingguide.readthedocs.io/en/latest/syntax.html#tabs-and-spaces &amp;#8617;      ",
    "url": "/5583eab1/",
    "relUrl": "/5583eab1/"
  },
  "72": {
    "id": "72",
    "title": "ShotGrid 데스크톱을 사용하여 툴킷 프로젝트를 다시 설정하는 방법은 무엇입니까?",
    "content": "ShotGrid 데스크톱을 사용하여 툴킷 프로젝트를 다시 설정하는 방법은 무엇입니까?프로젝트에 대한 툴킷 구성을 이미 설정하고 새로 시작해야 하는 경우 ShotGrid 데스크톱의 고급 설정 마법사는 이전의 설정 구성을 제거하기 전에는 프로젝트를 다시 설정할 수 없습니다.수동으로 해당 설정을 제거하는 단계는 다음과 같습니다.  ShotGrid에서 프로젝트에 연결된 모든 PipelineConfiguration 엔티티를 삭제합니다.  ShotGrid의 Project 엔티티에서 Tank Name 필드를 빈 값으로 설정합니다.  디스크에서 해당하는 파이프라인 구성 디렉토리를 모두 제거합니다.  ShotGrid 데스크톱에서 설정할 프로젝트를 선택합니다. 프로젝트를 보고 있던 중이라면 프로젝트 목록 보기로 이동했다가 다시 프로젝트로 돌아옵니다.  이제 프로젝트 설정 프로세스를 다시 실행할 수 있습니다.대체 방법명령줄을 사용하여 tank setup_project 명령으로 프로젝트를 설정한 경우 명령 끝에 --force 인자를 추가할 수 있습니다. 이렇게 하면 위에 나열된 단계를 수동으로 수행하지 않고도 이전에 설정한 프로젝트를 설정할 수 있습니다.tank setup_project --force&quot;",
    "url": "/fb5544b1/",
    "relUrl": "/fb5544b1/"
  },
  "73": {
    "id": "73",
    "title": "Client Responsibilities",
    "content": "Client ResponsibilitiesBelow, we have outlined setup responsibilities between Autodesk and You.Isolation SetupYou are entirely responsible for the validity, security, and execution of the Isolation setup in Your AWS Account. Autodesk should not, under any circumstances, be granted access to Your AWS environment.Autodesk is available during the process for assistance, but the configuration of Isolation features in Your AWS Account is to be executed by You on Your own.Isolation feature set activation requires the ShotGrid Support team’s intervention. Activation delays are to be expected and will depend on demand. You understand that an estimated period of 2-8 weeks is usually required to complete the setup necessary to implement the isolation feature set. The setup time is highly dependent on your cooperation, so please plan to dedicate resources for the setup before beginning the onboarding process.Autodesk does not guarantee any timeline for setup completion.Onboarding            Type      Description / Agreement      Responsibility      Available for Assistance                  AWS Knowledge      Acquiring the AWS-specific knowledge required to set up the isolation features.      You      N/A              S3      Setting up the S3 Bucket that will host Your media Securing access to the S3 Bucket. Additional high-availability measures (versioning, bucket replication, etc.)      You      ShotGrid and *AWS              Closed VPC      Setting up DirectConnect/VPN, etc. to allow closed access to the VPC. Securing the VPC by putting the correct Security Groups in place.      You      *AWS              Media Isolation      Creating the S3 end-points. Deploying the S3 Proxy.      You      ShotGrid and *AWS              Traffic Isolation      Creating VPCs. Creating Subnets.      You      ShotGrid              Private Access Point      Checking that the access point is only available from Your network.      ShotGrid      N/A              Monitoring and Reliability      Maintaining uptime up to Autodesk standards. High availability and redundancy of Cloud Services. Metadata and database resiliency and redundancy. Maintaining Recovery Point Objective (RPO) for metadata and database.      ShotGrid      N/A              Service Level Objective      Maintaining ShotGrid target RPO and RTO (See ShotGrid Security White Paper for more details).      ShotGrid      N/A              Security and Governance      Maintaining the ShotGrid Cloud Services that Isolation clients are interfacing with, so that they are meeting expectations in terms of security, vulnerability patching, scanning, auditing, etc. (See ShotGrid Security White Paper for more details).      ShotGrid      N/A      *You are solely responsible to seek or obtain any support services AWS may provide under any existing relationship between You and AWS. Autodesk teams are not parties to Your relationship with AWS and therefore not responsible or liable for any services or lack thereof provided by AWS to You.",
    "url": "/2f59bc69/",
    "relUrl": "/2f59bc69/"
  },
  "74": {
    "id": "74",
    "title": "Review",
    "content": "ReviewLearn to how to get the most out of RV, the award-winning suite of digital review tools that allows you to play back, compare, and convert digital media with collaboration tools and many deep integrations.Dig into RV’s Reference Manuals for a complete understanding of node graphs, custom shaders, event handling, and networking.Check out the RV-SDI manual to learn about our implementation of the NVIDIA SDI video device as a presentation mode device.Look to our Integration Packages for seamless workflows with Maya, Nuke, and even ShotGrid itself.",
    "url": "/61e62b21/",
    "relUrl": "/61e62b21/"
  },
  "75": {
    "id": "75",
    "title": "S3",
    "content": "S3Amazon S3 is an object storage service offered by AWS. It can be thought of as a highly durable storage space in the cloud. ShotGrid uses S3 to store uploaded media and files.In order to use ShotGrid isolation features, you will bring your own S3 bucket and configure ShotGrid to use it for storage. Please refer to our S3 Bucket Setup article for details on how to do this.",
    "url": "/dfc0cc1b/",
    "relUrl": "/dfc0cc1b/"
  },
  "76": {
    "id": "76",
    "title": "Media Isolation",
    "content": "Media Isolation                    Disclaimer: The security of your S3 bucket is solely a client responsibility, and the integrity of your data will be at risk without it. We very strongly recommend securing your S3 bucket properly.    AWS Account CreationYou can quickly create your AWS Account.You should also contact your AWS contacts to get help with your AWS account setup.AWS CloudFormation templateIt’s possible to start from the Private S3 bucket AWS CloudFormation template and customize it for your needs for a faster deployment.                    Disclaimer: This template is provided as an example only. It is your responsibility to validate that running the template will result in the configuration/policy/security settings your studio requires.      Go the CloudFormation service in AWS Console  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-s3-bucket.yml  Next  Set a stack name like ShotGrid-s3-bucket  Set your S3 bucket name and your ShotGrid site name  Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  NextCORS ConfigurationCORS policy on your S3 bucket will be minimally configured, allowing only the required origin (your site) and methods, amongst other things.IAM RoleThe template will create an AWS Role with the following permissions on your bucket:  Allow ShotGrid to access your S3 bucket.  Allow the ShotGrid account to assume the role by setting the role Trust Relationship.Media Isolation ActivationPlease contact ShotGrid support via the dedicated Slack channel and provide the following information:  S3 bucket name  AWS Region  ShotGrid Role ARNShotGrid will configure your test site to use your own S3 bucket.ValidationAt this stage, you should be able to upload and download media. The ShotGrid Transcoding Service should also be able to read, transcode and write back the thumbnails, filmstrip and web friendly versions of your media back to your S3 Bucket. To validate this:  Log in your Migration Test Site.  From the Navigation Bar, go the the Media app  Once in the Media App, drag and drop or upload an image or a video from your computer. If you didn’t created a Project yet, you may have to create one first.  A version should appear, with a thumbnail, in the Media App.  Validate that you can playback the media by clicking the Play button.  To validate that the media has been stored in your S3 bucket, from the media viewer, click on the cog and then select or hover over ‘view source’. The HTTPS link should contain your bucket name.Next StepsSee Media Traffic Isolation to activate the Media Traffic Isolation feature.See Web Traffic Isolation to activate the Web Traffic Isolation feature.See Media Replication to activate the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/439f0627/",
    "relUrl": "/439f0627/"
  },
  "77": {
    "id": "77",
    "title": "Media Replication",
    "content": "Media ReplicationDescriptionIt’s possible to add S3 replication between two S3 buckets in different regions and configure ShotGrid to leverage it for faster access to media.Features  Support one replica bucket in another region leveraging the AWS S3 replication featureHow it worksWhen S3 bucket replication is activated, users will be able download media files from the replica S3 bucket.For each user, the S3 replication is activated by the Use S3 Replication field.            Value      Behavior                  no      Never use replica S3 bucket (default)              yes      Use replica S3 bucket when delay is over              auto      Use replica S3 bucket when delay is over and the client IP is in IP Adresses for S3 replication range      The IP Adresses for S3 replication preference can be edited in Site Preferences under the Isolation category.Limitations  Only one replica S3 bucket can be configured  Only downloading from the replica bucket is supported  Configurable delay for new media to be replicated before being made available to usersSetup steps  Create the replica S3 bucket in a new AWS region. See Media Isolation  Update your existing ShotGrid role policy to allow ShotGrid to also access the replica bucket  Setup the replication rules on the primary S3 bucket. See How do I add a replication rule to an S3 bucket?  Setup a VPC + Direct Connect + S3 proxy in the new AWS region. See Media Traffic Isolation  Contact ShotGrid Support to configure your site to use the new S3 replica bucket, providing the following information:          Replica Bucket Name      Replica Bucket Region      Replica S3 proxy URL      FAQCopy existing mediaS3 replication only applies to media uploaded after the feature has been enabled. Existing media in the primary bucket must be copied to the replica bucket manually. You can simply use aws-cli sync or use Amazon S3 Batch Operations if you have a lot of media to achieve this.Next StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/44623c83/",
    "relUrl": "/44623c83/"
  },
  "78": {
    "id": "78",
    "title": "소프트웨어를 실행하기 전에 환경 변수는 어떻게 설정합니까?",
    "content": "소프트웨어를 실행하기 전에 환경 변수는 어떻게 설정합니까?ShotGrid 툴킷을 사용하면 실행 프로세스 중에 후크를 사용하여 환경을 구성하고 커스텀 코드를 실행할 수 있습니다.Nuke 또는 Maya와 같은 소프트웨어를 실행할 때 ShotGrid 데스크톱 또는 브라우저 통합을 통해 tk-multi-launchapp이 실행됩니다.이 앱은 소프트웨어 실행을 담당하며 ShotGrid 통합이 예상대로 시작되게 합니다. 이 프로세스 중에 후크를 통해 표시되는 두 지점을 사용하여 커스텀 코드를 실행할 수 있습니다.before_app_launch.pybefore_app_launch.py 후크는 소프트웨어가 실행되기 직전에 호출됩니다.이를 통해 실행된 소프트웨어에 전달될 모든 커스텀 환경 변수를 완벽하게 설정할 수 있습니다.예시:import osimport tankclass BeforeAppLaunch(tank.Hook):    def execute(self, app_path, app_args, version, engine_name, **kwargs):        if engine_name == &quot;tk-maya&quot;:            os.environ[&quot;MY_CUSTOM_MAYA_ENV_VAR&quot;] = &quot;Some Maya specific setting&quot;                    경고: ShotGrid에서 설정된 환경 변수를 완전히 다시 정의하지 않도록 주의해야 합니다.예를 들어 NUKE_PATH(Nuke) 또는 PYTHONPATH(Maya)에 경로를 추가해야 하는 경우 경로를 변경하는 대신 기존 값에 경로를 추가해야 합니다.이 경우 다음과 같이 편리한 방법을 사용할 수 있습니다.tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)    커스텀 래퍼일부 스튜디오에서는 환경 변수 설정 및 소프트웨어 실행을 처리하는 커스텀 래퍼를 사용합니다.이와 같은 커스텀 코드를 사용하여 환경을 설정하려는 경우 Software 엔티티의 경로 필드를 실행 가능한 래퍼로 지정하면 tk-multi-launchapp이 대신 실행합니다.                    경고: 이 경우 ShotGrid에서 설정한 환경 변수를 유지해야 합니다. 그러지 않으면 통합이 시작되지 않습니다.    ",
    "url": "/624f2593/",
    "relUrl": "/624f2593/"
  },
  "79": {
    "id": "79",
    "title": "Setup",
    "content": "ShotGrid Isolation Feature Set - SetupIsolation the isolation features are independent of each other, and can be activated independently of each other. Media replication have as pre-requisite for Media Isolation to be implemented.The setup process will depend on which feature you want to activate for your site.In This Section  Planning your Setup  Migration Test Site  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media Replication  Isolation Fine Tuning  MigrationSetup OverviewUnderstand your responsibilitiesMake sure that you understand the client responsibilities and the implication of activating any of the Isolation feature.Start the onboarding processLeveraging the isolation features requires adopters to become AWS users. The features activation also requires Autodesk Support intervention. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering. Kick-start the onboarding process before going further.Planning your SetupBefore you start working on your setup, put a plan in place. Choose the features you need and get the required security/legal approval from your team to get started with the Isolation feature set.Migration Test SiteTo help you setting up the Isolation features without breaking your production environment and to helping smooting the migration to your isolated environment, ShotGrid propose to use a test site on which to test your setup before applying the result to production.Media IsolationThis feature allow you to use a S3 Bucket owned by your studio to store media.Media Traffic IsolationThis feature allows for private routing of the media through the AWS Backbone and your studio network, isolating the media traffic from the public internet.Web Traffic IsolationThis feature isolate the web traffic on AWS Backbone and your studio network, isolating the traffic from the public internet.Media ReplicationThis feature allows the media to be replicated between AWS Regions, for faster access in your world wide studios. Media Isolation is required.Fine TuningOnce the isolation features you need are activated, make sure that you everything is properly configured for security and cost-efficiency by reviewing this fine tuning guide.MigrationOnce everything is ready, it’s now time to migrate your production site to use the isolation features.",
    "url": "/8128c5fb/",
    "relUrl": "/8128c5fb/"
  },
  "80": {
    "id": "80",
    "title": "ShotGrid 데스크톱이 Ubuntu 같은 Debian 시스템에서도 작동합니까?",
    "content": "ShotGrid 데스크톱이 Ubuntu 같은 Debian 시스템에서도 작동합니까?현재는 ShotGrid 데스크톱용 Debian 기반 배포판을 지원하지 않습니다.과거에 몇몇 고객이 이를 구현하려고 했던 적이 있었는데, cpio를 사용하여 RPM에서 ShotGrid 데스크톱을 추출한 다음 라이브러리 종속성을 충족하려고 했지만 그리 좋은 결과를 내진 못했습니다. 추가 내용은 dev 그룹에서 이 스레드를 확인할 수 있습니다.Python 자체가 많은 시스템 레벨 라이브러리 위에 위치하기 때문에 명시적인 라이브러리 종속성 목록은 없습니다.지금으로서는 Debian 지원에 대한 공식적인 계획이 없습니다. Ubuntu를 위한 빌드에는 문제가 있지만 한편으로는 결코 사소하다고 할 수 없는 변화를 구현하다 보면 추가 운영 체제를 QA 및 지원해야 할 필요도 있습니다.ShotGrid 데스크톱 없이 툴킷을 수동으로 실행 및 활성화하려는 경우(여기 문서에서 설명) - 설명서 페이지에서 activate_shotgun_pipeline_toolkit.py 스크립트를 다운로드하십시오. 이 안내서의 8단계에 있으며, “다운로드하려면 클릭…“(click to download…) 헤더를 클릭하면 됩니다.",
    "url": "/3830df9d/",
    "relUrl": "/3830df9d/"
  },
  "81": {
    "id": "81",
    "title": "Developing apps",
    "content": "Developing your own appIntroductionThis guide outlines what a Toolkit app is, covers how to create one, and explains some basics around app development.ShotGrid Pipeline Toolkit is not only a collection of apps and engines maintained by ShotGrid Software, it is also a development platform that makes it easy to quickly build custom pipeline tools!  What is a Toolkit app?  Creating your own appSteps:  Creating a development sandbox  Forking or downloading the starter app repository  Adding the app to your config  Developing the app          Anatomy of the Template Starter App      Configuration settings      Frameworks      Reloading your changes        Testing  Preparing your first releaseAdditional info:  Modifying an existing app          Contributing      What is a Toolkit app?A Toolkit app can be defined as follows:  A tool that is usually run by an end-user, using the ShotGrid integrations.  Apps usually have a graphical user interface with which the user can guide the app’s operations, but they don’t have to. An app can also be a command registered with the integrations, triggered by the user from the ShotGrid menu in the host software.  They can have an API/public methods in which other processes or apps could interact.  They can be multi-platform, and software agnostic.  They can be set up to be configured differently per environment.  They can be contextually aware. For example, an app can know the task the user is working on, and act accordingly.  They can only be run from a Toolkit engine.Toolkit apps are initialized by Toolkit engines. Engines are designed to run within a specific software environment, where they then provide an interface from which to run Toolkit apps. The engine abstracts away the complexity of needing to handle the various software environments from the app.This means the app only needs to focus on providing the functionality to fulfill its purpose and doesn’t need to, for example, handle window parenting, keeping track of the user’s context, or providing a shortcut for launching itself.Creating your own app.All apps and engines maintained and released by ShotGrid Software are open source and you can find them in GitHub.This section goes through how to create a new app using our starter template. We assume that you are familiar with GitHub and git workflows, but please note that you can do Toolkit development even if you are not using git as your source control solution.Part 1: Creating a development sandboxBefore you do anything else, we recommend that you set up a development sandbox by cloning the project configuration by cloning your project’s configuration.This will result in a separate configuration where you can develop your code and test changes without affecting anyone else on the production.Part 2: Forking or downloading the starter app repositoryWe provide a template starter app that you can use as a starting point for your own app.By using this app you get all the standard Toolkit boilerplate code set up for you, and a basic example GUI.To use it, you can either fork the git repository and then clone it to your local dev area on disk, or if you don’t want to use git source control at this stage, you can just download the files from GitHub as a zip file, and unzip them locally (you can always set up a git repository later).Either way, the goal is to have a local copy of the starter app code so you can start making changes.Part 3: Adding the app to your configWe recommend reading the “Adding an app” guide, as it explains in more detail how to add an app to your configuration.When adding the app to your config, you need to consider where your app will be used, i.e. perhaps only in Nuke or in multiple different software, or standalone from ShotGrid Desktop.You also need to think about the context that your app will depend on.For example, can your app only run when you know the task the user is working on, or can it run with just the project known?Knowing this will dictate which environment YAMLs and engines you need to add your app settings to.If you’re not sure right now, it’s a good idea to start by adding it to the tk-shell engine in the project environment. That way you can run it from your IDE or via the command line with the tank command if you have a centralized config. This will make it quicker to develop with.To start, use a dev descriptor for the location of your app.tk-multi-starterapp:  location:    type: dev    path: /path/to/source_code/tk-multi-starterappThis instructs Toolkit to load the app code directly from disk in the given location, which is great for development, where you want to change the code all the time.Later when you add the app to your production config, you may want to use a different descriptor.Now you’ve added the app to an environment; you should be able to go ahead and launch it. How you launch it will depend on the engine and environment you defined it in.Part 4: Developing the appYou are now all set to start developing your app!Anatomy of the Template Starter AppThe template starter app contains the following basic structure:  app.py - The app entry point and menu registration can be found in the app.py file. This is where you typically set up your classes, get things initialized, and get menu items registered.  info.yml - Also known as the manifest file. It defines all the different settings that this app requires when it is installed, along with their default values if supplied. Settings are often useful if you want reusable apps and you don’t want to hard code any values in the app itself.  python/app/dialog.py - This contains the logic, event callbacks, etc. that produce the main app window.  python/app/ui - This folder contains the automatically generated UI code and resource file. You don’t edit this directly; instead, you edit the Qt UI file in the resources folder.  resources/ - In the resources folder, the dialog.ui file is a Qt Designer file that you can open up and use to rapidly design and define the look and feel of the app. Once you have made changes, you have to execute the build_resources.sh script, which will convert the UI file to python code and store it as /python/app/ui/dialog.py.  style.qss - You can define QSS (Qt style sheets) for your UI in this file.                    Note: An app doesn’t need to have a UI however, and the minimum requirements for a valid app are an app.py containing an Application class and an info.yml.    Configuration settingsInside the manifest file, there should be a configuration section where you can define app settings.Defining a setting in the manifest file allows you to configure different setting values for your app in the environment YAML files.This is useful if your app needs to behave differently depending on the environment it is in.For example, you may wish to have a setting that defines a template to use when saving a file.save_template:    type: template    default_value: &quot;maya_asset_work&quot;    description: The template to use when building the path to save the file into    allows_empty: FalseCreating a setting for this means you don’t have to hard code the template name in your app code, and can instead get the value from the settings defined either by default in the info.yml or overridden in the environment YAML file settings.template = app.get_setting(&quot;save_template&quot;)This means that you could configure your app to use a different template depending on the environment the app is running in.You can read more on configuration settings in the reference documentation.FrameworksIf you know that you will be using frameworks, you can add them to the manifest file.For example, if you plan to use the Qt Widgets and ShotGrid Utils frameworks for your app, add the following to the info.yml:# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;}Minimum required framework versionsIf there is a required minimum version for a framework, the minimum_version setting can be used in the info.yml:# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;, &quot;minimum_version&quot;: &quot;v1.5.0&quot;}The above will ensure that v1.5.0 of tk-framework-qtwidgets is available for the app to use. If it is not, the app will not be loaded at startup time and an error will be printed to the console. When the app is updated using tank updates, any configured frameworks not meeting their required minimum versions will be automatically updated along with the app.For more information about frameworks and how they can be useful, check out the following links:  The Qt Widgets Framework  The ShotGrid utils FrameworkReloading your changesIf you are testing your app within software such as Maya, then as soon as you have one or more dev items in your configuration, Toolkit will automatically add a Reload and Restart option to the ShotGrid menu.Clicking this will reload your configuration and code and then restart your engine. This means that you can iterate quickly: start Maya once, and then each time you make code or configuration changes that you want to try out, simply hit the Reload and Restart button and your changes will be pulled in.                    Note: If you have any UIs active on screen, these will not automatically update, but you have to go in and re-launch the UIs from the menu.    Part 5: TestingWhen you want to test your code, you can easily invite other users to your dev sandbox by adding them to the User Restrictions field on the PipelineConfiguration entity in ShotGrid. As soon as you have added a user, they will see new entries on their menus inside of ShotGrid Create and the browser actions, as well as an option to pick the configuration inside of ShotGrid Desktop.                    Note: Make sure they have access to see your app code as well, otherwise the app will not load.    Part 6: Preparing your first releaseIn part three you set your configuration to point to your app using a dev descriptor.For released software, you will want to ensure that your app can be accessed by all users and that things are versioned so that they can be upgraded safely and easily.All apps provided by ShotGrid use the Toolkit app store to track updates and releases, and they will have a location tag that looks something like this:location:   name: tk-multi-setframerange   type: app_store   version: v0.1.7This allows Toolkit (for example the tank updates command) to check when updates are available, update and maintain configurations in a very safe way. Whenever the updates command is run and a new version is available, Toolkit will download the code and place it in a local “bundle cache” on disk and ensure that users have access to it.There are a few different options for sourcing your app releases.  Git and GitHub  ShotGrid Uploads  Local pathsIn your production config, you add your app and switch to using the descriptor that suits your needs.Git-based descriptorsWe recommend that you start using source control to make sure that changes are tracked, regardless of if you intend to use a git descriptor.Toolkit supports git (http://git-scm.com/) out of the box, and when running tank updates on a configuration, it can check for the latest release in your git repository and update your configuration, just like with the app store descriptor.The requirements for this are:  Your git repo needs to contain just a single app  Your git repo should have the same structure as the starter app repository.  You use Semantic Versioning when creating your tags. Toolkit will use these version numbers to try to determine which version is the most recent, and by following the convention vX.Y.Z.Once you have created your first tag in git (eg. v1.0.0), you could then set up your config to use a git descriptor that points to your tag.Then you can simply run tank updates, and if new tags have been created, you will be prompted if you want to upgrade. The workflow is now identical to the one which happens with official app store apps.                    Caution: The git descriptor works well with centralized configs, where the caching of apps is usually run by an admin and is stored to a central location where all users can access it. However, if you are using a distributed config, then it may not be as suitable. Your app will be downloaded per user, which means each user will need to have git installed and setup to authenticate with your repo and access the code.    Modifying an existing appRather than starting from an empty starter template, it is sometimes necessary to add a minor feature to an existing app, for example, one of ShotGrid Software’s standard apps. When you work with a modified version of an app, you typically want to ‘track’ against the source app and make sure to regularly pull in changes and bug fixes.When you do this type of development, you pick up the parent code, then apply some of your changes, then release this to your pipeline. Your release effectively consists of the base version of the app PLUS your applied local changes. We recommend that you add a version suffix to the existing version number. This will work seamlessly with Toolkit and is relatively straight forward. The following workflow illustrates how to proceed:  You fork the parent app and create your own repository. With the fork, you get all the git tags. Let’s say the latest tag is called v0.2.12 and the master branch basically equals the contents in this tag.  You apply your changes and commit to your master branch. You now have v0.2.12 PLUS your changes. When you release this to production you need to create a tag. Name the tag v0.2.12.1, to indicate that your code is based on v0.2.12 and it is the first release.  Now someone finds a bug in your modifications. Fix the bug and tag up and release v0.2.12.2.  A number of important bug fixes have been released in the parent repository. Pull them down to your repository. The most recent tag is now v0.2.15 due to releases that have happened in the parent repository. Now merge your changes with master and test. You now basically have parent app v0.2.15 merged with your changes. Tag up v0.2.15.1.The tagging scheme outlined above guarantees that the Toolkit updates work correctly and make it easy to quickly see what code each tag in your fork is based on.ContributingWe love pull requests! If you feel you have made a change that can benefit others, don’t hesitate to feed it back to us as a pull request.We may then fold it back into the main version of the app.Alternatively, add a suggestion for a new idea on our roadmap page.If you’ve made an entire app that your willing to share with the community, let us all know on the forums!",
    "url": "/2e5ed7bb/",
    "relUrl": "/2e5ed7bb/"
  },
  "82": {
    "id": "82",
    "title": "Bootstrapping and running an app",
    "content": "Bootstrapping and running an appThis guide walks you through the process of initializing a Toolkit engine so that you can run custom code or launch apps, also known as bootstrapping.Bootstrapping is useful in situations where a Toolkit engine has not already been started and you need to use the API.For example, you might have a processing script that runs on a render farm and needs to utilize the Toolkit API to handle paths and context.Or you may wish to be able to run your Toolkit app from your favorite IDE.                    Note: If you are using a distributed config, a Toolkit engine must be initialized before running Toolkit API methods. It is possible to use the API without bootstrapping an engine if you are using a centralized config, using the factory methods, however, you will need to manually find the path to the correct core API for your project when importing sgtk.    Requirements  An understanding of Python programming fundamentals.  A project with an advanced configuration. If you haven’t set up a configuration before you can follow the “Getting started with configurations” guide.Steps  Importing the Toolkit API for bootstrapping  Logging  Authentication  Bootstrapping an engine  launching an app  Complete scriptPart 1: Importing the Toolkit API for bootstrappingWhere should I import sgtk from?If you’ve followed the “generating a path and publishing it” guide then you’ll have covered the step of importing sgtk.That guide states that you must import the sgtk package from the project configuration you wish to work with.With bootstrapping, this is still true, however, it doesn’t matter which initial sgtk package you import, as any Toolkit API can perform the bootstrap operation into a different project configuration.The bootstrap process will swap out the currently imported sgtk package for the new project config’s Toolkit API.Downloading a standalone Toolkit core APITo start, you need to import an sgtk API package which is found in tk-core.You could import one from an existing project, however, this might be tricky to conveniently locate.A recommended approach would be to download a standalone copy of the latest core API which will be used purely for the purpose of bootstrapping.You should store it in a convenient place where it can be imported. Make sure that the path you add points to the python folder inside the tk-core folder as this is where the sgtk package is located.Code# If your sgtk package is not located in a location where Python will automatically look# then add the path to sys.path.import syssys.path.insert(0, &quot;/path/to/tk-core/python&quot;)import sgtkPart 2: LoggingIf you are running this script via an IDE or shell, then you will most likely want to enable the logging to be output.To do this you need to run LogManager().initialize_custom_handler().You don’t need to provide a custom handler for this purpose, as not providing one will set up a standard stream-based logging handler.Optionally you can also set the LogManager().global_debug = True to give you more verbose output. This means that any logger.debug() calls in our code or yours will now be output.Logging can have an impact on performance, so you should only enable debug logging when developing, and try to limit the amount of logger.info() method calls to those that are important to have visibility over during normal operation.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = TruePart 3: AuthenticationWhen running a script that uses the Toolkit API outside of an environment where ShotGrid Toolkit has already been started, you will always need to authenticate.So before you can perform the bootstrapping, you need to authenticate the Toolkit API with your ShotGrid site.You can authenticate with user credentials or with script credentials.  If the purpose is to bootstrap for a user-facing process like launching an app, or running some code that will require user input,then user authentication is the best way to go, (This is how all our integrations work by default).  If you’re writing a script to automate something and a user is not present to authenticate then you should use script credentials.Authentication is handled via the ShotGridAuthenticator class.Here is an example of both user and script authentication.User Authentication# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Optionally you can clear any previously cached sessions. This will force you to enter credentials each time.authenticator.clear_default_user()# The user will be prompted for their username,# password, and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating an `Sgtk` instance.sgtk.set_authenticated_user(user)Script Authentication# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)Part 4: Bootstrapping an engineNow that you have authenticated the Toolkit API for the session, you can start the bootstrapping process.You can find a lot of information on the bootstrap API in our reference docs.The bootstrapping process at a high level essentially performs the following steps:  Retrieves or locates the Toolkit configuration folder.  Ensures that the configuration dependencies such as the apps and engines are present in the bundle cache. If they are not present, and they are using cloud-based descriptors such as app_store, or ShotGrid then it will download them to the bundle cache.  Swaps out the current loaded sgtk core for the one appropriate to the config.  Initializes the engine, apps, and frameworks.                    Note: Usually bootstrapping should take care of everything that is needed for that engine to run successfully.However, in some situations, the engine may have specific setup requirements that fall outside of the bootstrap process, and must be handled separately.    Bootstrap PreparationTo bootstrap, you must first create a ToolkitManager instance.mgr = sgtk.bootstrap.ToolkitManager()For Toolkit to bootstrap, it needs to know at least the entity, plugin id, and engine.This guide won’t cover all the available parameters and options, as they are covered in the reference documentation.Plugin IDYou can define the plugin id by passing a string to the ToolkitManager.plugin_id parameter before calling the bootstrap method.In this guide, you will be bootstrapping the tk-shell engine so you should provide a suitable plugin id name following the conventions described in the reference docs.mgr.plugin_id = &quot;basic.shell&quot;EngineIf your goal is to launch an app or run Toolkit code in a standalone python environment outside of software such as Maya or Nuke, then tk-shell is the engine you will want to bootstrap into.If you are wanting to run Toolkit apps within supported Software, then you will want to pick the appropriate engine, such as tk-maya or tk-nuke.This parameter is passed directly to the ToolkitManager.bootstrap_engine() method. See the example in the entity section bellow.EntityThe ToolkitManager.bootstrap_engine() methods entity parameter, is used to set the context and therefore environment for the launched engine.The entity can be of any entity type that the configuration is set up to work with. For example, if you provide a Project entity, the engine will start up in a project context, using the project environment settings.Likewise, you could provide a Task entity (where the task is linked to an Asset), and it will start up using the asset_step.yml environment.This is based on the default configuration behavior, the environment that is chosen is controlled via the core hook, pick_environment.py, and so could be changed to pick a different environment based on the context or other parameters.You need to provide the entity in the format of a ShotGrid entity dictionary which must contain at least the type and id:task = {&quot;type&quot;: &quot;Task&quot;, &quot;id&quot;: 17264}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=task)If you bootstrap into an entity type other than Project, you may need to ensure your path cache is in sync, otherwise, it may not be able to load the environment if, for example, it tries to resolve a template.Since you don’t have an Sgtk instance before bootstrapping, you will need to tell the bootstrap process to perform the synchronization after it’s created an Sgtk instance but before it starts the engine.You can do this by setting the ToolkitManager.pre_engine_start_callback property to point to a custom method.In that method you can then run the synchronization:def pre_engine_start_callback(ctx):    '''    Called before the engine is started.    :param :class:&quot;~sgtk.Context&quot; ctx: Context into        which the engine will be launched. This can also be used        to access the Toolkit instance.    '''    ctx.sgtk.synchronize_filesystem_structure()mgr.pre_engine_start_callback = pre_engine_start_callbackChoice of configurationYou have the choice of explicitly defining which configuration to bootstrap, or leaving the bootstrap logic to autodetect an appropriate configuration.You can even set a fallback configuration in case one is not automatically found.In this guide, we assume that your project has a configuration already setup and that it will be found automatically.BootstrappingOnce all the ToolkitManager parameters have been set, and you call the ToolkitManager.bootstrap_engine() method, it will start the engine, and return a pointer to the engine instance.Here is a recap of the code so far:# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap. mgr = sgtk.bootstrap.ToolkitManager()mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)Part 5: Launching an appNow that you have an engine instance, you’re ready to start using the Toolkit API.Before covering how to launch the app, it’s worth pointing out you can get hold of the current context, Sgtk instance, and ShotGrid API instance via the engine.engine.contextengine.sgtkengine.shotgunWhilst the end goal of this guide is to show you how to launch an app, you could from this point make use of the above attributes and test some code snippets or run some automation that makes use of the Toolkit API.Launching the AppWhen the engine starts, it initializes all the apps defined for the environment. The apps in turn register commands with the engine, and the engine usually displays these as actions in a menu, if running in Software like Maya.Finding the commandsTo first see what commands have been registered, you can print out the Engine.commands property:# use pprint to give us a nicely formatted output.import pprintpprint.pprint(engine.commands.keys())&amp;gt;&amp;gt; ['houdini_fx_17.5.360', 'nukestudio_11.2v5', 'nukestudio_11.3v2', 'after_effects_cc_2019', 'maya_2019', 'maya_2018', 'Jump to Screening Room Web Player', 'Publish...',...]With that list, you can see which commands have been registered and can be run.Running the commandHow you run the command will be different depending on the engine, as there is currently no standardized method.For the tk-shell engine, you can use the convenience method: Engine.execute_command().It expects a command string name, which we listed out earlier, and a list of parameters that the app’s command expects to be passed.if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])If you’re not running in the tk-shell engine, then you can fallback to calling the registered callback directly.# now find the command we specifically want to executeapp_command = engine.commands.get(&quot;Publish...&quot;)if app_command:    # now run the command, which in this case will launch the Publish app.    app_command[&quot;callback&quot;]()Your app should now have started, and if you’re running the tk-shell engine then the output should be appearing in the terminal/console.Part 6: The complete script# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminalsgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing)sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap. mgr = sgtk.bootstrap.ToolkitManager()mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)# Optionally print out the list of registered commands:# use pprint to give us a nicely formatted output.# import pprint# pprint.pprint(engine.commands.keys())if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])",
    "url": "/3d8cc69a/",
    "relUrl": "/3d8cc69a/"
  },
  "83": {
    "id": "83",
    "title": "Developing engines",
    "content": "Developing your own engineIntroductionThis document outlines some of the technical details relating to Toolkit engine development.Table of Contents:  What is a Toolkit engine?  Things to know before you start  Approaches to engine integration          Host software includes Qt, PyQt/PySide and Python      Host software includes Qt and Python but not PySide/PyQt      Host software includes Python      Host software does not contain Python but you can write plugins      Host software provides no scriptability at all        Qt window parenting  Startup behavior  Host software wish listWhat is a Toolkit engine?When developing an engine, you effectively establish a bridge between the host software and the various Toolkit apps and frameworks that are loaded into the engine. The engine makes it possible to abstract the differences between software so that apps can be written in more of a software-agnostic manner using Python and Qt.The engine is a collection of files, similar in structure to an app. It has an engine.py file and this must derive from the core Engine base class. Different engines then re-implement various aspects of this base class depending on their internal complexity. An engine typically handles or provides the following services:  Menu management. At engine startup, once the apps have been loaded, the engine needs to create its ShotGrid menu and add the various apps to this menu.  Logging methods are typically overridden to write to the software’s log/console.  Methods for displaying UI dialogs and windows. These methods are usually overridden, if the way the engine handles Qt is different from the default base class behavior, to ensure seamless integration of windows launched by Toolkit apps and the underlying host software window management setup.  Provides a commands dictionary containing all the command objects registered by apps. This is typically accessed when menu entries are created.  The base class exposes various init and destroy methods that are executed at various points in the startup process. These can be overridden to control startup and shutdown execution.  Startup logic that gets called by the tk-multi-launchapp at launch time, as well as automatic software discovery.Engines are launched by the Toolkit platform using the sgtk.platform.start_engine()  or the sgtk.bootstrap.ToolkitManager.bootstrap_engine() methods. This command will read the configuration files, launch the engines, load all apps, etc.The goal with the engine is that once it has launched, it will provide a consistent Python/Qt interface to the apps. Since all engines implement the same base class, apps can call methods on the engines, for example, to create UIs. It is up to each engine to implement these methods so that they work nicely inside the host software.Things to know before you startwe provide integrations for the most commonly used content creation software.There are also engines that Toolkit Community members have built and shared back. But sometimes you’ll need pipeline integrations for software that doesn’t have a Toolkit engine yet.If you have the time and resources, we encourage you to help the Toolkit Community (and yourselves) in writing a missing engine you would like to use!Before embarking on writing code, talk to us! We can’t promise anything, but we will be happy to discuss your plans with you. We may also be able to connect you to other users who are interested in or have done work on the same engine.If you can, open a channel of communication with a technical contact or developer of the software you are looking to integrate Toolkit into. This helps gain insight into what the possibilities and/or roadblocks are for getting something going. Once you establish a contact and talk through the basics of what you are trying to do, you can bring us into the conversation and set up a meeting with all of us to talk through some of the specifics of the engine.Also, you can engage directly with the Toolkit community in the ShotGrid community forum.We love to see new integrations, and are always eternally grateful for people’s generous contributions to the Toolkit Community!                    Tip: The Developing your own app contains a step by step guide to developing an app, which contains principles that apply to developing an engine as well that are not covered in this guide.    Approaches to engine integrationDepending on what the capabilities of the host app are, engine development may be more or less complex. This section outlines a couple of different complexity levels that we have noticed during engine development.Host software includes Qt, PyQt/PySide, and PythonThis is the best setup for Toolkit and implementing an engine on top of a host software that supports Qt, Python, and PySide is very straight forward. The Nuke engine or the Maya engine is a good example of this. Integration is merely a matter of hooking up some log file management and write code to set up the ShotGrid menu.Host software includes Qt and Python but not PySide/PyQtThis class of software includes for example Motionbuilder and is relatively easy to integrate. Since the host software itself was written in Qt and contains a Python interpreter, it is possible to compile a version of PySide or PyQt and distribute it with the engine.This PySide is then added to the Python environment and will allow access to the Qt objects using Python. Commonly, the exact compiler settings that were used when compiling the shot application must be used when compiling PySide, to guarantee it to work.Host software includes PythonThis class of software includes for example, the third party integration Unreal.These host software have a non-Qt UI but contain a Python interpreter. This means that Python code can execute inside of the environment, but there is no existing Qt event loop running. In this case, Qt and PySide will need to be included with the engine and the Qt message pump (event) loop must be hooked up with the main event loop in the UI. Sometimes the host software may contain special methods for doing precisely this. If not, arrangements must be made so that the Qt event loop runs regularly, for example via an on-idle call.Host software does not contain Python but you can write pluginsThis class includes Photoshop and After Effects.There is no Python scripting, but C++ plugins can be created. In this case, the strategy is often to create a plugin that contains an IPC layer and launches Qt and Python in a separate process at startup. Once the secondary process is running, commands are sent back and forth using the IPC layer.  This type of host software usually means significant work to get a working engine solution.                    Tip: With the Photoshop and After Effects engines we actually created a framework that handles the adobe plugin.  Both engine make use of the framework to communicate with the host software, and it makes it easier to build other engines for the rest of the adobe family.    Host software provides no scriptability at allIf the host software cannot be accessed programmatically in any way, it is not possible to create an engine for it.Qt window parentingSpecial attention typically needs to be paid to window parenting. Usually, the PySide windows will not have a natural parent in the widget hierarchy and this needs to be explicitly called out. The window parenting is important to provide a consistent experience and without it implemented, Toolkit app windows may appear behind the main window, which can be quite confusing.Startup behaviorThe engine is also responsible for handling how the software is launched and its integration is started. This logic will be called when the tk-multi-launchapp tries to launch the software with your engine.You can read more about how this is set up in the core documentation.Host software wish listThe following host software traits can be taken advantage of by Toolkit engines. The more of them that are supported, the better the engine experience will be!  Built-in Python interpreter, Qt, and PySide!  Ability to run code at software startup/init.  Ability to access and auto-run code in two places: once when the software is up and running and once when the UI has fully initialized.  API commands that wrap filesystem interaction: Open, Save, Save As, Add reference, etc.      API commands to add UI elements          Add a custom Qt widget as a panel to the app (ideally via a bundled PySide)      Add custom Menu / Context Menu items      Custom nodes in node-based packages (with an easy way to integrate a custom UI for interaction)      Introspection to get at things like selected items/nodes        Flexible event system          “Interesting” events can trigger custom code        Support for running UI asynchronously          For example, pop up a dialog when a custom menu item is triggered that does not lock up the interface      Provide a handle to a top-level window so custom UI windows can be parented correctly      ",
    "url": "/be19bc87/",
    "relUrl": "/be19bc87/"
  },
  "84": {
    "id": "84",
    "title": "Developing frameworks",
    "content": "Developing your own frameworkIntroductionThis document outlines some of the technical details relating to Toolkit framework development.Table of Contents:  What is a Toolkit framework?  Pre-made ShotGrid frameworks  Creating a Framework  Using Frameworks from hooksWhat is a Toolkit framework?Toolkit frameworks are very similar to Toolkit apps. The main difference is that a framework is not something you would run on its own.Instead, you would import a framework into your app or engine. It allows you to keep reusable logic separate so that it can be used in multiple engines and apps.An example of a framework would be a library of reusable UI components, that might contain a playlist picker component.You could then import that framework in your app, and plug in the playlist picker component to your main app UI.Pre-made ShotGrid frameworksShotGrid supplies some premade frameworks that you may find useful when creating your own apps.The Qt Widgets and ShotGrid Utils frameworks are especially useful in app development.Creating a FrameworkWhen it comes to creating your own framework, the setup is pretty much the same as writing an app, and you can get more information on that in the “Developing your own apps” guide.Instead of an app.py file, a framework has a framework.py at the root of the framework package, that contains a class deriving from the Framework base class.Also, your framework won’t register a command with the engine.Instead, you can either store methods directly on the framework instance itself, or store modules inside the python/ folder.For example, the shotgunutils framework stores them in the python folder.To access them, you would import the framework, and then use the import_module() method, to access the submodules.The API docs contain examples on how to import frameworks.Using Frameworks from hooksIt can be useful to create a framework so that you can share some common logic across hooks.A framework can be used in an app, or other framework hooks, even if the app/framework doesn’t explicitly require it in the manifest file, via theHook.load_framework() method. Note frameworks can’t be used in core hooks even with this method.",
    "url": "/312b792f/",
    "relUrl": "/312b792f/"
  },
  "85": {
    "id": "85",
    "title": "Generating a path and publishing it",
    "content": "Generating a path and publishing itThis guide covers getting started with the ShotGrid Toolkit Python API, which is what our pipeline integrations are built with.The purpose of this guide is to walk through a basic example of how you can use the API, and by the end, you will be able to import the Toolkit API and generate a path and publish it.Requirements  An understanding of Python programming fundamentals.  A project with an advanced configuration. If you haven’t set up a configuration before you can follow the “Getting started with configurations” guide.Steps  Importing sgtk  Getting an Sgtk instance  Getting context  Creating folders  Using a template to build a path  Finding existing files and getting the latest version number  Registering a published file  Pulling it all together into a complete scriptPart 1: Importing sgtkThe Toolkit API is contained in a python package called sgtk. Each Toolkit configuration has its own copy of the API, which comes as part of tk-core.To use the API on a project’s configuration, you must import the sgtk package from the configuration you wish to work with; importing it from a different configuration will lead to errors.                    Note: You may sometimes come across references to a tank package. This is the legacy name for the same thing. While both work sgtk is the correct name to use going forward.    To import the API you need to make sure that the path to the core’s python folder exists in the sys.path.However, for this example, we recommend that you run this code in the ShotGrid Desktop’s Python console.This will mean that the correct sgtk package path is already added to your sys.path.Equally, you don’t need to add the path if you are running this code within software where the ShotGrid integration is already running.When running your code in an environment where ShotGrid is already started you can import the API by simply writing:import sgtkIf you want to use the API outside of a ShotGrid integration, for example, if you’re testing it in your favorite IDE, then you will need to set the path to the API first:import syssys.path.append(&quot;/shotgun/configs/my_project_config/install/core/python&quot;)import sgtk                    Note: If you’re using distributed configs and you want to import sgtk in an environment where Toolkit hasn’t already been bootstrapped, you will need to take a different approach. Please see the bootstrapping guide for more details.    Part 2: Getting an Sgtk instanceIn order to start using the Toolkit API, you’ll need to create an instance of the Sgtk class.Sgtk is a class in the sgtk package that acts as the main interface to the API.Once you create an instance of Sgtk, you will be able to do things like get a context, create folders, or access the templates.As the API documentation states, you don’t create an instance of Sgtk directly. Here are some options for getting an Sgtk instance.      You can get an Sgtk instance from the current engine, if you are running the Python code within an environment where the ShotGrid integrations are already running, (such as the Maya Python console, if Maya was launched from ShotGrid.)The Engine.sgtk property holds the engine’s Sgtk instance.So for example, in Maya, you could run the following:     # Get the engine that is currently running. current_engine = sgtk.platform.current_engine()     # Grab the already created Sgtk instance from the current engine. tk = current_engine.sgtk        You can access the Sgtk instance through the Engine.sgtk property.    Note: The Engine.sgtk property should not be confused with or considered the same as the sgtk package that you imported in part 1.        sgtk.sgtk_from_entity() -  If you are running in an environment where an engine hasn’t already been started, you can use this method to get an Sgtk instance based upon an entity id. The entity whose id you are supplying must belong to the project that the sgtk API was imported from. This doesn’t work with distributed configs, please see the bootstrapping guide for more details.        sgtk.sgtk_from_path() - much like the sgtk_from_entity() except this will accept a path to a configuration or a path to or inside the project root folder, for example, a work file or shot folder. This doesn’t work with distributed configs, please see the bootstrapping guide for more details.  Throughout this guide we will assume you are running this code in an environment where an engine has already been started, so we’ll use option 1.Also you will store the Sgtk class instance in a variable called tk.If you’re using the ShotGrid Python Console then the tk variable is already pre-defined as a global variable.You now have an Sgtk instance and you’re ready to start using the API.Your publish script should now look like this:import sgtk# Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtkPart 3: Getting contextWhat is a context and why do I need it?A lot of what happens in Toolkit revolves around context, in other words knowing what you are working on and being able to act accordingly.With the Toolkit API, you will need to be able to store important details about the entities you are working with, and share them with apps or other processes so they can operate in a contextually aware way.For example, when Toolkit knows what task you’re working on, it can automatically link your published files to that task in ShotGrid.The Context class acts as a container for this information.You can store the Task, Step, entity (such as a Shot or Asset), Project, and current HumanUser within an instance of the class, among a few other things.You can create as many different context objects as you like in a given session. However, when there is an engine present, there is a concept of a single current context, which the engine keeps track of.This is the context that the user is currently working in, and that the apps should be working with.In a later step, you will be using the context to help resolve a path that can be used for saving or copying a file.Acquiring a ContextTo create a context you must use one of the following constructor methods Sgtk.context_from_entity(), Sgtk.context_from_entity_dictionary() or Sgtk.context_from_path().You access these methods through the Sgtk instance you created in the previous step, which you stored in the tk variable.                    Note: To get a context from a path, you must have already created folders, which is covered in the next step of this guide.    Instead of creating a new context however, you could grab the current context from the engine, that you gathered in part 2, like this:context = current_engine.contextSince you will be using the context to help resolve a file path for a Task on a Shot in later steps, you need to be certain the context contains the relevant information.If your code was running as part of a Toolkit app, and your app was configured to only run in a shot_step environment then you could safely assume you would get an appropriate current context.However, for the sake of avoiding ambiguity in this guide, you will create a context explicitly from a Task, (that must belong to a Shot), using the Sgtk.context_from_entity().When you create a context you provide the deepest level required for your operations.For example, you could create a context from a Task and Toolkit will work out the rest of the context parameters for you.context = tk.context_from_entity(&quot;Task&quot;, 13155)If you print out a representation of the context instance you will get something like this:print(repr(context))&amp;gt;&amp;gt; &amp;lt;Sgtk Context:   Project: {'type': 'Project', 'name': 'My Project', 'id': 176}  Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}  Step: {'type': 'Step', 'name': 'Comp', 'id': 8}  Task: {'type': 'Task', 'name': 'Comp', 'id': 13155}  User: None  Shotgun URL: https://mysite.shotgunstudio.com/detail/Task/13155  Additional Entities: []  Source Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}&amp;gt;Even though you only provided the task, it should have filled in the other related details.The publish script should now look like this:import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)Part 4: Creating FoldersToolkit can dynamically generate a folder structure on disk based upon your project entities.This fulfills two purposes.  You get an organized structure created on disk where you can place your files.  It allows Toolkit to programmatically understand your structure, derive context from it, and know where to place files.You need to ensure that the folders exist on disk so that you can resolve the path in a later step.You will use the Sgtk.create_filesystem_structure() method to achieve this:tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])You can use the context object to get the task id to generate the folders.Your code should now look like this:import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task, this Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])You’ve now completed all the preparation steps and are ready to move onto generating a path using a template.Part 5: Using a template to build a pathGenerating the pathWhenever you need to know where a file should be placed or found in Toolkit you can use the templates to resolve an absolute path on disk.Templates are essentially tokenized strings that when you apply the context and other data to, can be resolved into filesystem paths.They are customizable via your project’s pipeline configuration, and their purpose is to provide a standardized method for working out where files should be stored.The first thing you need to do is get a template instance for the path you wish to generate.Using the Sgtk instance you created, you can access the desired Template instance via the Sgtk.templates attribute, which is a dictionary where the keys are the template names, and the values are Template instances.template = tk.templates[&quot;maya_shot_publish&quot;]In this example, you will use the maya_shot_publish template. In the Default Configuration the unresolved template path looks like this:'sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{maya_extension}'The template is made up of keys that you will need to resolve into actual values.Since the context contains enough information for the majority of the keys, you can start by using that to extract values:fields = context.as_template_fields(template)&amp;gt;&amp;gt; {'Sequence': 'seq01_chase', 'Shot': 'shot01_running_away', 'Step': 'comp'}The Context.as_template_fields() method gives you a dictionary with the correct values to resolve the template keys. However, it hasn’t provided values for all the keys. The name, version and maya_extension are still missing.The maya_extension key defines a default value in the template keys section so you don’t need to provide a value for that, although you could if you wanted a value other than the default.Which leaves the name and version. Since the name is a matter of choice, you can either hard code a default or provide an opportunity for the user to enter a value, for example, by popping up an interface.For now, you will hard code both, but in the next step, we’ll cover how to find the next available version number.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1Now you have all the fields, you’re ready to resolve the template into an absolute path using Template.apply_fields():publish_path = template.apply_fields(fields)&amp;gt;&amp;gt; /sg_toolkit/mysite.shotgunstudio.com/my_project/sequences/seq01_chase/shot01_running_away/comp/publish/maya/myscene.v001.maEnsuring the folders existAlthough you ran the folder creation method earlier you may need to perform an additional step to ensure that all the folders exist.This can be required if, for example, your template defines folders that are not present in the schema, and so were not created in the original create_filesystem_structure() call.There are a couple of convenience methods you can use to do this.If, your code is running in a Toolkit app or hook you can use the Application.ensure_folder_exists() method.If, there is an engine present you can use Engine.ensure_folder_exists() method.Or if you’re running code outside of an engine, there’s sgtk.util.filesystem.ensure_folder_exists().Make sure to only create the folders for the directory and not the full file path.You can import the os module and run os.path.dirname(publish_path) to extract the folder portion of the full file path.Creating or copying a file using the pathAt this point you have a path, and you could use this, for example, to tell Maya to save a file there, or perhaps copy the file from a different location. It’s not important for the sake of this guide that you implement any behavior that actually creates a file on disk in that location.You can still publish the path even if there is no file there. However, you can use sgtk.util.filesystem.touch_file() to get Toolkit to create an empty file on disk.Bringing it all together so farimport sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Get a template instance by providing a name of a valid template in your config's templates.yml.template = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folders.current_engine.ensure_folder_exists(os.path.dirname(publish_path))# Create an empty file on disk. (optional - should be replaced by actual file save or copy logic)sgtk.util.filesystem.touch_file(publish_path)The next step is to dynamically work out the next version number rather than hard coding it.Part 6: Finding existing files and getting the latest version numberThere two methods you could use here.  Since in this particular example you are resolving a publish file, you could use the ShotGrid API to query for the next available version number on PublishedFile entities.  You can scan the files on disk and work out what versions already exist, and extract the next version number. This is helpful if the files you’re working with aren’t tracked in ShotGrid (such as work files).While the first option would probably be most suitable for the example in this guide, both approaches have their uses so we’ll cover them both.Querying ShotGrid for the next version number.Using the ShotGrid API and the summarize() method you can get the highest version number amongst the PublishedFile entities, that share the same name and task, and then add 1.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1Searching the file system for the next version number.Using the Toolkit API you can gather a list of existing files, extract the template field values from them, and then figure out the next version.In the example below, it’s gathering the latest version from the work file template. Assuming the work file template and publish file template have the same fields, you could call the method below twice with the same fields to work out the highest publish and work file version and decide using a combination of the two.def get_next_version_number(tk, template_name, fields):    template = tk.templates[template_name]    # Get a list of existing file paths on disk that match the template and provided fields    # Skip the version field as we want to find all versions, not a specific version.    skip_fields = [&quot;version&quot;]    file_paths = tk.paths_from_template(                 template,                 fields,                 skip_fields,                 skip_missing_optional_keys=True             )    versions = []    for a_file in file_paths:        # extract the values from the path so we can read the version.        path_fields = template.get_fields(a_file)        versions.append(path_fields[&quot;version&quot;])        # find the highest version in the list and add one.    return max(versions) + 1# Set the version number in the fields dictionary, that will be used to resolve the template into a path. fields[&quot;version&quot;] = get_next_version_number(tk, &quot;maya_shot_work&quot;, fields)The sgtk.paths_from_template() method will gather all the files on disk that match the provided template and fields.This is method is also useful for scenarios where you want to find and display a list of files to the user.You can chose to use either option, but the guide will use the code from option one however to keep it simple.Part 7: Registering a published fileNow that you have a path you’re ready to publish it. To do this you can use the utility method sgtk.util.register_publish().It is possible to use the ShotGrid API’s ShotGrid.create() method to create a PublishedFile entity as well, but we strongly recommend using the Toolkit API for this as it will ensure all the required fields are provided and filled in correctly.# So as to match the Publish app's default behavior, we are adding the extension to the end of the publish name.# This is optional, however.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)At this point, it’s also worth noting that our Publish app also comes with its own API as well.Although that is still essentially using this same sgtk.util.register_publish() method, it builds upon the publishing process by providing a framework to handle collection, validation, and publishing.Part 8: The complete script# Initialization# ==============import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the tasktk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Generating a Path# =================# Get a template instance by providing a name of a valid template in your config's templates.ymltemplate = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;# Get an authenticated Shotgun API instance from the enginesg = current_engine.shotgun# Run a Shotgun API query to summarize the maximum version number on PublishedFiles that# are linked to the task and match the provided name.# Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the# extension in our filter.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folderscurrent_engine.ensure_folder_exists(os.path.dirname(publish_path))# Creating a file# ===============# This is the bit where you would add your own logic to copy or save a file using the path.# In the absence of any file saving in the example, we'll use the following to create an empty file on disk.sgtk.util.filesystem.touch_file(publish_path)# Publishing# ==========# So as to match publishes created by the Publish app's, we are adding the extension to the end of the publish name.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)                    Tip: By this point, the code is getting a bit long, so a recommended next step would be to tidy it up a bit and break things into methods.    Final ThoughtsThis guide has hopefully left you with a foundational understanding of how to get started with the Toolkit API.There are of course many other uses for the API, so we recommend reading through the tk-core API for more information.Also our forums are an excellent place to discuss API questions and get answers, and even leave feedback for us about the this guide.",
    "url": "/836446f3/",
    "relUrl": "/836446f3/"
  },
  "86": {
    "id": "86",
    "title": "Integrations Developer Guide",
    "content": "Integrations Developer GuidePanelsSee https://github.com/shotgunsoftware/tk-multi-shotgunpanel/tree/master/hooks  for examples of panel actions.Configuring what is being displayedThe values in the detail area and the listings are both configurable through the shotgun_fields hook. You can subclass this hook and change the implementation in order to display the exact values you want.Templating SystemThe hook supports a simple templating language, allowing for great flexibility. It also supports the HTML subset supported by Qt, so you can control color, font size, weight, etc. of your displayed values.The template language works in the following way:      ShotGrid values are enclosed in {brackets}, for example &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}. When this template is rendered, the {description} part will be replaced with the description field value.        If you want an optional pre- or post-fix for a value which is only shown if the value is not empty, you can use the syntax {[Prefix]sg_field[suffix]}. The template {[Start: ]start_date} {[End: ]end_date} will render Start: 12 July 2009 End: 14 July 2012 if both values are populated but Start: 12 July 2009 if end date isn’t set.        You can define fallbacks in the case some values are not set. For ShotGrid Versions, the artist fields takes precedence over the created_by field in order to support a workflow where a producer submits versions on behalf of an artist. In this case, the Version will be created by the producer but the artist field will be set to the artist. This, however, is not always the case - in some cases, artist is left blank in pipelines where artists submit their own work. When displaying versions, it is therefore useful to be able to check the artist field first, and in case this isn’t set, fall back on the created_by field. This is done using the {field1|field2} syntax, for example: Created By: {artist|created_by}. You can combine this with optional fields too, e.g. {[Created By: ]artist|created_by}.  This hook contains the following methods:Controlling items appearing in listsThe get_list_item_definition() method returns a dictionary that controls the appearance of items in the various listings, given a ShotGrid entity type. It returns a dictionary with the keys top_left, top_right and body, for example:{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}Controlling the top detail areaThe get_main_view_definition() method returns a dictionary with the keys title and body given a ShotGrid entity type. These values controls the appearance of an object in the detail area, for example:{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}Controlling the fields shown in the Info tabThe get_all_fields() methods returns a list of fields to display for a given entity when this is rendered in the Info tab.Configuring ActionsActions are little snippets of code that operate on a piece of ShotGrid data. Examples include:  An action that launches RV for a given ShotGrid Version  An action that allows a user to assign herself to a given Task  An action that loads a ShotGrid publish into Maya as a Maya reference.The actual payload of an action is defined in an  action hook. Once you have defined the action logic, you can then map that action to ShotGrid objects in the app configuration. These action mappings may for example look like this:action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}In the above example, we use the actions reference, import, texture_node, assign_task and play_in_rv. We then map the actions to various ShotGrid objects and conditions. For example, we are requesting the import action to appear for all publishes of type Maya Scene.When an object is loaded into the Panel, the action configuration above is read in and analyzed. A list of suitable actions for the current object is determined and the generate_actions() hook method will be executed. ShotGrid data for the given entity will be passed to the hook at this point so that the hook code can determine if the action can be run for this particular ShotGrid object. This is a way to allow each hook to run a check prior to being displayed. For example, the play_in_rv hook may only be relevant in the case there is media available locally - the action mappings set up in the configuration tells the panel which actions to enable for a given ShotGrid entity but they may not all be displayed because the generate_actions() method may determine that they are not suitable for the given object.The actions returned from the generate_actions() method will be displayed on the actions menu and when a user clicks on it, the execute_acton() hook method is called to run the action.For each application that the panel supports, there is an actions hook which implements suitable actions. For example, with something like Maya, the default hook will implement reference, import and texture_nodeactions, each carrying out specific Maya commands to bring publishes into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.The panel uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app’s hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/panel/maya_actions.py. This will tell Toolkit to use a hook called hooks/panel/maya_actions.py in your configuration folder.For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks like this:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot; Returns a list of action instances for a particular object. The data returned from this hook will be used to populate the  actions menu. The mapping between ShotGrid objects and actions are kept in a different place (in the configuration) so at the point when this hook is called, the app has already established *which* actions are appropriate for this object. This method needs to return detailed data for those actions, in the form of a list of dictionaries, each with name, params, caption and description keys. Because you are operating on a particular object, you may tailor the output  (caption, tooltip etc) to contain custom information suitable for this publish. The ui_area parameter is a string and indicates where the publish is to be shown.  - If it will be shown in the main browsing area, &quot;main&quot; is passed.  - If it will be shown in the details area, &quot;details&quot; is passed. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :param actions: List of action strings which have been defined in the app configuration. :param ui_area: String denoting the UI Area (see above). :returns List of dictionaries, each with keys name, params, caption and description &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot; Execute a given action. The data sent to this be method will represent one of the actions enumerated by the generate_actions method. :param name: Action name string representing one of the items returned by generate_actions. :param params: Params data, as specified by generate_actions. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :returns: No return value expected. &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}By deriving from the hook as shown above, the custom hook code only need to contain the actual added business logic which makes it easier to maintain and update.PublisherThe Publish app is highly customizable by way of hooks that control how items are presented to artists for publishing and how those items are then processed.The full developer documentation for the publisher app can now be found on the  Toolkit Developer Site.For more information on how to use the Publish app, see the User Guide. If you are looking for more information about the first generation Publisher, please visit the classic Publisher docs.LoaderSee https://github.com/shotgunsoftware/tk-multi-loader2/tree/master/hooks for examples of load actions.Advanced functionalityShotGrid Toolkit makes it easy to develop toolsDid we mention that you can write your own Apps? Each Engine exposes a consistent interface based on Python and PySide, so you can write a single App that works in both Nuke, Photoshop and 3dsmax. With the Core API functionality, there is no need to build a big pipeline stack for the studio - instead focus dev resources on solving production problems. Reusing tools between projects is easy with our Toolkit - if file naming conventions or other requirements are changing, simply reconfigure the app. Roll out tools safely via the Toolkit’s built-in Git and Github support and quickly hot-load your code when doing development. Work in your own Dev Sandbox and invite TDs and early adopters to test your code without having to roll it out to everyone on the project.",
    "url": "/93c6e555/",
    "relUrl": "/93c6e555/"
  },
  "87": {
    "id": "87",
    "title": "How to Submit Integrations Fixes",
    "content": "How to Submit Integrations FixesWe welcome contributions from the Toolkit community! If you have a potential fix for a bug you’ve discovered or have implemented a feature you think we should include, we welcome you to follow the guidelines below in order to sent it through the right channels.Talk to UsWe encourage you to talk to us about what you want to develop or fix. We may have information that will help steer you in the right direction, or prevent you from doing a lot of unnecessary work. Most importantly, we love talking to our users about what they want to build, how they use Toolkit, and how we can make it more awesome.Fork the Repo from GithubMost of the Toolkit engine, app, and framework code is developed in the public on Github. Fork the repo you’re modifying from Github to your local environment.Make Your ChangesDo your development work locally in a branch and test it out in your own environment to the point you feel confident that it’s ready to submit to us. Try and match the style of the existing codebase. Keep your changes focused on your purpose. For example, if you’re fixing a bug in 3 lines of code, don’t try and modify whitespace issues throughout the file. That will make the Toolkit gremlins angry.Comment!Make sure you add detailed comments about what it is you’re doing any why you’re doing it. Keep in mind, there will be other people like you who may fork this repo later and will need to understand what your code does and why. Be clear, but don’t over-comment either. :)TestRemember that other users will have a wide variety of environments and variables in play that may not match what you have at your studio. Toolkit tries to minimize the impact of these types of things for users but there are always things that could be different in other users’ environments. Some examples:  Will your code work the same on OS X, Windows, and Linux?  Will it work in all supported versions of a Software?  Will it work the same whether the user launches from a terminal, SG Desktop, ShotGrid, or perhaps their own custom app?Create a Pull RequestOnce you’re ready, push your changes back to Github and create a pull request. Your pull request should be detailed, explain what your code does, and why the changes are required. When writing this up, think about the user who is coming into this with very little knowledge about this area of code. The public will see your pull request and other users will be happy to understand your well written description!Then What?We will review your pull request when we have time in our sprint. It’s very likely we’ll comment and ask questions about your code or use case. We may kick back the request and ask you to make changes. Don’t be offended! We love contributions but also have deep knowledge about how things will work. We are in this code every day so we don’t expect everyone to submit perfect code.Once we review it, if we accept your pull request, we’ll queue it for QA and then it will be merged into our repo and released at some point. The timeline can vary depending on a lot of factors. Please be patient.We may also politely turn down your pull request. Again, please don’t be offended. We appreciate your efforts and contribution. There can be any number of factors that contribute to this. But if you follow the guidelines above, hopefully this won’t happen.",
    "url": "/924c14e8/",
    "relUrl": "/924c14e8/"
  },
  "88": {
    "id": "88",
    "title": "How do I work with authentication and login credentials in custom scripts?",
    "content": "How do I work with authentication and login credentials in custom scripts?Error MessageIf you’re seeing an error like the one below coming from your script, then it means your script is not authorized to talk to your ShotGrid site.tank.errors.TankError: Missing required script user in config '/path/to/your/project/config/core/shotgun.yml'If user authentication or script authentication is not provided up front, then Toolkit falls back to checking credentials have been defined in the config’s shotgun.yml file.Defining credentials in your shotgun.yml file is the old method of handling authentication.You should avoid defining them in the shotgun.yml file, and instead use one of the approaches detailed below:User-facing scriptsIf the script is user-facing, you can add this at the beginning, before creating a Sgtk instance:# Import the Toolkit API so we can access Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either programmatically or, in this# case, interactively.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Optionally clear the current user if you've already logged in before.authenticator.clear_default_user()# Get an authenticated user. In this scenario, since we've passed in the# CoreDefaultsManager, the code will first look to see if there is a script_user inside# shotgun.yml. If there isn't, the user will be prompted for their username,# password and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating a Sgtk instance.sgtk.set_authenticated_user(user)## Add your app code here...## When you are done, you could optionally clear the current user. Doing so# however, means that the next time the script is run, the user will be prompted# for their credentials again. You should probably avoid doing this in# order to provide a user experience that is as frictionless as possible.authenticator.clear_default_user()If QApplication is available, you’ll get something akin to this:                    Note: If you are importing a Toolkit API (sgtk package) that isn’t associated with a configuration, for example one that you have downloaded to use to bootstrap into a different configuration, then you shouldn’t attempt to create a CoreDefaultsManager. Instead, create a ShotgunAuthenticator() instance without passing a defaults manager.authenticator = ShotgunAuthenticator()    Non-user-facing scriptsIf the script is not user-facing, like on a render farm or in the event handler, you can add this at the beginning, before creating a Sgtk/Tank instance:# Import Toolkit so we can access to Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either interactively or, in this# case, programmatically.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Create a user programmatically using the script's key.user = authenticator.create_script_user(    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;)# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)                    Note: As noted at the end of the user facing scripts section, you shouldn’t create a defaults manager if the sgtk package you imported is standalone/isn’t from a configuration. Also you should provide the host kwarg to the create_script_user() method:user = authenticator.create_script_user(    host=&quot;https://yoursite.shotgunstudio.com&quot;,    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Shotgun site&amp;gt;&quot;)    ",
    "url": "/724152ce/",
    "relUrl": "/724152ce/"
  },
  "89": {
    "id": "89",
    "title": "프로젝트 간에 에셋을 어떻게 공유합니까?",
    "content": "프로젝트 간에 에셋을 어떻게 공유합니까?어느 한 프로젝트가 다른 프로젝트의 샷에 로드할 수 있는 에셋을 포함하고 있는 에셋 라이브러리로 사용되는 경우는 흔히 볼 수 있습니다.프로젝트 간에 에셋을 공유하려면 이 에셋 라이브러리 프로젝트의 에셋을 나열해 주는 탭을 Loader 앱에 추가하면 됩니다. 이렇게 하려면 작업 중인 엔진 및 환경에 대한 로더 설정에서 이를 정의해야 합니다. 아마도 이 설정을 여러 위치에서 업데이트해야 할 것입니다.예를 들어, 샷 단계 환경의 Maya 엔진에 이를 추가하려면 다음 조각을 추가하면 됩니다.caption: Asset Libraryhierarchy: [project, sg_asset_type, code]entity_type: Assetfilters:- [project, is, {'type': 'Project', 'id': 207}]207을 라이브러리 프로젝트의 ID로 바꿉니다.현재 Maya의 샷 단계 환경에서 작업 중인 경우 이렇게 하면 해당 프로젝트에서 사용할 수 있는 모든 게시를 보여 주는 새 탭이 추가됩니다. 이 탭을 다른 엔진(Nuke, 3dsmax 등)의 로더에 추가하려면 해당하는 각 엔진에 대한 tk-multi-loader2 설정도 수정해야 합니다. 다른 환경에서 이를 활성화하려면 에셋 단계 환경, 그리고 해당 탭을 추가할 모든 다른 환경에서도 같은 단계를 수행해야 합니다. 조금 지루하겠지만 이렇게 해야 좀 더 미세하게 조정할 수 있습니다.이렇게 설정하면 Loader 앱이 일반 프로젝트의 게시가 나열되는 탭을 보여 주어야 합니다.",
    "url": "/2088a677/",
    "relUrl": "/2088a677/"
  },
  "90": {
    "id": "90",
    "title": "개요",
    "content": "ShotGrid 개발프로덕션을 관리하려면 시시각각으로 변동되는 모든 요소를 동기화된 상태로 유지하기 위해 많은 노력이 필요합니다.ShotGrid REST API 또는 Python API를 이용해 데이터에 직접 연결하고 이벤트 트리거 프레임워크를 이용해 반복적인 작업을 자동화하고 액션 메뉴 항목을 이용해 ShotGrid의 웹 인터페이스에서 직접 앱을 실행하십시오.귀하 또는 귀하가 권한을 제공한 사용자가 사용하는 서비스에서 작동하거나 해당 서비스와 함께 작동하는 자체 서비스, 응용프로그램, 모듈 및 구성요소를 개발할 때 ShotGrid API를 사용할 수 있습니다.                    인증 키: 사용자가 로그온하지 않고 서비스 또는 해당 기능에 액세스할 수 있는 인증 키 또는 기타 수단을 포함하는 API 정보를 공개하지 마십시오. 또한 귀하가 권한을 제공한 사용자가 공개하는 것도 허용하지 마십시오. 또는 귀하가 직접 API를 사용하여 액세스하거나 사용자들이 로그온하지 않고 서비스 또는 해당 기능에 액세스할 수 있도록 허용하십시오.    ",
    "url": "/6dfa5d53/",
    "relUrl": "/6dfa5d53/"
  },
  "91": {
    "id": "91",
    "title": "Migration Test Site",
    "content": "ShotGrid Migration Test SiteActivating the isolation feature set is an intrusive procedure that can have an impact on the usability of your site. To prevent a production stopping event, we require clients to follow an approach where the configuration is first validated on a test site, before being applied to the production site.The ShotGrid team will create a temporary site to be used as a Proof of Concept for your ShotGrid Isolation deployment. Upon the successful completion of the setup process, your existing ShotGrid site can be migrated to your ShotGrid Isolation environment.If your Migration Test Site has not been created yet, please reach out to our Support team through your Zendesk ticket or your dedicated on-boarding Slack Channel.Next StepsOnce you have your test site, you can the implementation of the feature you need.See Media Isolation for activating the Media Isolation feature.See Web Traffic Isolation for activating the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/0bbe0010/",
    "relUrl": "/0bbe0010/"
  },
  "92": {
    "id": "92",
    "title": "Isolation Features",
    "content": "Isolation Feature SetThe isolation feature set is an hybrid solution that satisfies strict security and legal requirements, while minimizing ShotGrid System Admin specific required knowledge and maintenance. These features enable creative studios to confidently meet their supplier’s and studio’s highly stringent security, privacy, and performance requirements—from the cloud.Continue to About the isolation feature set for more details.Go to Setup if you are ready to activate the Isolation features.In This SectionGetting Started  About Isolation  Client Responsibilities  Onboarding Process  Planning your SetupFeatures Description  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media ReplicationSetup  Setup Overview  Migration Test Site  Media Isolation  Media Traffic Isolation  Web Traffic Isolation  Media Replication  Isolation Fine Tuning  MigrationAWS Knowledge  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/f378a164/",
    "relUrl": "/f378a164/"
  },
  "93": {
    "id": "93",
    "title": "3ds Max",
    "content": "3dsMaxThe ShotGrid engine for 3dsMax contains a standard platform for integrating ShotGrid Toolkit (Sgtk) Apps into 3dsMax. It is light weight, straight forward and adds a ShotGrid menu to the main menu.",
    "url": "/bb1266cb/",
    "relUrl": "/bb1266cb/"
  },
  "94": {
    "id": "94",
    "title": "After Effects",
    "content": "After EffectsThe ShotGrid engine for After Effects provides a platform for integrating ShotGrid into your After Effects workflow. It consists of a standard ShotGrid Toolkit engine and relies on the tk-framework-adobe (CEP).Once enabled, a ShotGrid Adobe Panel panel becomes available in After Effects. It displays information about the current ShotGrid context as well as the commands that are registered for the apps installed in that context.Interface OverviewThe ShotGrid extension panel uses the same color palette and basic layout as native After Effects panels. It is comprised of five components:  Context Header - Thumbnail and fields for the current context.  Favorites Shelf - Designed to show the most commonly-used apps for the current context.  Command List - All non-favorited commands for the current context.  Context Menu - Additional context-related commands and debugging tools.  Logging Console - A console overlay that displays logging output for debugging.InstallationInstallation of the ShotGrid Engine for After Effects follows the same protocol as the other ShotGrid integrations. For information on installing engines and apps, see the Administering Toolkit article. In addition, you can reference the default toolkit config as an example of how to configure the integration.Enabling the extensionOnce the extension is installed, it will need to be launched via the extensions menu in After Effects.This will only need to be done once and the ShotGrid extension panel can remain in the After Effects layout without having to be enabled on subsequent launches.Once enabled, and on future launches, the extension panel will display a loading screen while the ShotGrid integration is bootstrapping.This screen typically displays for a few seconds before the current context is determined and the commands are displayed.Interface componentsThe following sections outline the components of the ShotGrid After Effects integration.Context headerThe context header is a customizable area which can display information about the current ShotGrid context.The context is determined by the currently-active document. Once the context is determined by the engine, the header will update to display the context’s thumbnail field detail. The field information is controlled by a hook. For information on how to customize the field display, see the Context Fields Display Hook section below.It should also be noted that the context switching will only be recognized in if ShotGrid open was used.Favorites shelfThe favorites shelf is similar to the menu favorites available in other ShotGrid DCC integrations such as Maya and Houdini. This section of the interface makes the most commonly used Toolkit apps readily available and easy to find just under the context header.The shelf displays the favorited commands as buttons that, when moused over, transition from grayscale to color and display their name in the label at the top. Tooltips for the buttons will show by hovering the mouse above them.Clicking one of the buttons will trigger the callback for the registered command to execute.For details on how to specify command favorites, see the Shelf Favorites section below.Command listThe command list shows the other “regular” commands that are registered for the current context.Typically, apps installed within a pipeline configuration will register one or more commands that are displayed here. If the commands are not identified as favorites, and are not identified as context-menu commands, they will display here.The command list buttons behave in a manner similar to those in the favorites shelf. The only real difference is that they display as a list with the full name to the right of their icon.Context menuAny commands registered as context menu commands will show in the ShotGrid extension panel’s context menu.Like the other command areas, these commands will change along with the context. Commands such as Jump to ShotGrid and Jump to Filesystem will always be available here.Logging consoleThe logging console shows all of the logging output from both the CEP Javascript interpreter and Toolkit’s Python process.If there are any issues with the extension that require support, the logging console output is extremely useful for helping the ShotGrid support team debug the problem.Configuration and technical detailsThe following sections outline some of the more technical aspects of the integration to help configure the integration to the specific needs of your studio pipeline.PySideThe ShotGrid engine for After Effects relies on PySide. Please see the official instructions for Installing PySide.CEP extensionThe extension itself is bundled with the engine and the engine handles installation automatically on the first launch of After Effects. The extension is installed on the artist’s local machine in the standard, OS-specific CEP extension directories:# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Each time After Effects is launched, the engine bootstrap code will check the version of the extension that is bundled with the engine against the version that is installed on the machine. This means that after an engine update, assuming a new version of the extension came with it, the installed extension will be automatically updated to the newly-bundled version.Configuring favoritesThe Favorites Shelf can be configured to display any of the registered commands for your installed apps. To do this, simply add the shelf_favorites setting to the tk-aftereffects section of your environment configuration. Here’s an example:shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}The value of the setting is a list of dictionaries identifying a registered command provided by one of the installed apps in the configuration. The app_instance key identifies a particular installed app and the name key matches the command’s display name registered by that app. In the example above, you can see four favorited commands: the file open and save dialogs from the tk-multi-workfiles2 app as well as the standard Toolkit publish and snapshot dialogs. These four commands will now show in the favorites shelf.Environment variablesTo aid in debugging, there are a set of environment variables that change some of the engine’s default values:  SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - The Python heartbeat interval in seconds (default is 1 second).  SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - The number of heartbeat errors before quitting (default is 2). The legacy environment variable  SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE is also respected if set.  SHOTGUN_ADOBE_NETWORK_DEBUG - Include additional networking debug messages when logging output. The legacy environment variable  SGTK_PHOTOSHOP_NETWORK_DEBUG is also respected if set.  SHOTGUN_ADOBE_PYTHON - The path to the Python executable to use when launching the engine. If not set, the system Python is used. If Photoshop is launched from a Python process, like ShotGrid Desktop or via the tk-shell engine, the Python used by that process will be used by the Photoshop integration.Note: Additional environment variables exist in the Adobe Framework. For details, please see the developer documentation.Context fields display hookThe engine comes with a hook to control the fields displayed in the Context Header section of the panel. There are two methods in the hook that can be overridden to customize what is displayed.The first method is the get_entity_fields() method. This method accepts an entity type representing the current ShotGrid context. The expected return value is a list of fields for that entity that should be queried for display. The engine itself handles querying the data asynchronously.Once the data has been queried from ShotGrid, the second method in the hook is called. This method, get_context_html(), receives the context entity dictionary populated with the queried fields specified by the get_entity_fields() method. The expected return value is a string containing formatted HTML to display the queried entity fields.The default hook implementation is a good reference as to what is required by these methods.It should be noted that the engine will always display the entity thumbnail if one is available.Import Footage HookThe engine comes with a hook to control the import behaviour of certain file types. One may want that a psd file will be imported as single layer instead of a composition. In this case the this hook may be used to overwrite this behaviour.The default hook implementationAfter Effects APIPlease see the developer documentation for details on the After Effects API.",
    "url": "/1eca509c/",
    "relUrl": "/1eca509c/"
  },
  "95": {
    "id": "95",
    "title": "Alias",
    "content": "AliasThe ShotGrid engine for Alias contains a standard platform for integrating ShotGrid Apps into Alias. It is lightweight and straight forward and adds a ShotGrid menu to the Alias menu.Information for App DevelopersPySideThe ShotGrid engine for Alias uses a PySide installation shipped with the ShotGrid Desktop and will activate this whenever this is necessary.Alias Project ManagementWhenever the ShotGrid engine for Alias starts, it will set the Alias Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the Alias project is set based on a file can be configured in the configuration file, using the template system.Working with tk-aliasThis ShotGrid integration supports the Alias application family (Concept, Surface, and AutoStudio).When Alias opens, a ShotGrid menu (the Alias engine) is added to the menu bar.File Open and SaveUse the My Tasks and Assets tabs to see all your assigned tasks and browse for assets. To the right, use these tabs to view all files, working or published files associated with what is selected to the left.SnapshotOpens the Snapshot dialog to create a quick backup of the current scene.PublishOpens the Publish dialog for publishing the file to ShotGrid, which can then be used by artists downstream. For more information, see Publishing in Alias. LoaderOpens the Content Loader app, allowing you to load data into Alias. For more information see Loading in AliasScene BreakdownOpens the Breakdown dialog, which displays a list of referenced (WREF References) content, along with what in the scene is out-of-date. Select one or more items and click Update Selected to switch and use the latest version of the content. For more information see Scene Breakdown in Alias",
    "url": "/8229b689/",
    "relUrl": "/8229b689/"
  },
  "96": {
    "id": "96",
    "title": "Desktop",
    "content": "DesktopThe tk-desktop engine is an application to let you easily run your Toolkit apps. It is a system tray based window that makes it easy to get started with Toolkit, setup Projects for Toolkit, and access your Projects’ pipeline.Site configuration and Project configurationWhen you launch the desktop application, it will startup the tk-desktop engine for your site configuration.  This configuration is usually automatically managed, although it is possible to disable that behavior and take control over what is in that environment.One of the fundamental principles of Toolkit is that projects can be completely isolated from each other.  This is usually done to make sure that changes made to one project cannot adversely effect another project (possibly nearing delivery). In order to offer this project isolation, the desktop engine makes sure that whenever you are looking at the commands for a particular project, you will run them in a separate python interpreter that has been initialized just for that project.When you click on a project, a python interpreter is launched in the background. This python interpreter is the one the project has been configured to use and on startup will initialize the tk-desktop for that project.  That instance of the engine will communicate back to the GUI what commands it can launch.When you click on a command, that background python process is responsible for launching the command.  This makes it possible (for example) to have one project running python 2.6 while testing python 2.7 on another project.Registering custom panelsToolkit apps which have panel based UI will be automatically docked in tabs inside of Desktop when they execute.If you have a panel based app such as the ShotGrid Panel, and want it to appear as a tab in ShotGrid Desktop, just configure it to run at startup. When Desktop starts up in its site context mode (where it displays all projects), it will launch all items registered to auto start. If any of these items are panels, these will get docked. Items will be processed in the order they are defined in the configuration and this will dictate the tab order.For example, if you wanted the ShotGrid Panel to show as a tab in ShotGrid Desktop, add the following configuration for your site level environment:tk-desktop:  apps:    tk-multi-shotgunpanel:      actions_hook: ...      action_mappings: ...      location: ...  location: ...  run_at_startup:  - {app_instance: '', name: Apps}  - {app_instance: tk-multi-shotgunpanel, name: ''}Please note that the special Apps entry controls where (in the tab order) the default Apps tab should appear.",
    "url": "/75097ed0/",
    "relUrl": "/75097ed0/"
  },
  "97": {
    "id": "97",
    "title": "Flame Export",
    "content": "Flame ExportThe ShotGrid Flame Export App helps kickstart your project!Once you have created an initial conform in Flame, the Shot Exporter can help you quicklygenerate content in ShotGrid, render out plates to disk and send content to review.Once you are up and running, the exporter app will also track all the renders happening in Flare or in Flame batch mode, making it easy to send content to review as part of your workflow.Pushing a conform to ShotGridOnce you have your conform set up in Flame for a sequence, and have allocated shot names to all the segments in your timeline, select the sequence, right click and choose the ShotGrid Shot Export option.This will bring up a ShotGrid UI where you can enter some initial comments for your publish. These comments will be sent to review and also used when adding description to publishes and other content.In addition to the description, you can also select which output data format you want to use for your exported plates. These presets are part of the toolkit app configuration and can be configured to suit the needs of your studio.Once you click the submit button, a number of things will happen straight away:      Shots and Tasks will be created in ShotGrid. The list of tasks to associate with each new Shot that gets created is configurable via a Task template setting to make it quick and painless to create consistent structures. The shots will be parented under a sequence by default, but this is also configurable and if you are working with Scenes or Episodes, it is possible to reconfigure the exporter to work with these instead.        Once ShotGrid contains the right data, folders will be created on disk using the standard folder creation mechanism. This ensures that the project can be kick-started with a set of consistent folders for all shots that are being created.  Once the two steps above have been carried out, you have the basic structure to proceed with further steps. These will happen in the background:      Plates will be exported on disk for each shot according to the presets defined in your configuation. File locations are defined using the Toolkit Template system, meaning that the location of these plates will be well defined and understood by other tools downstream in the pipeline.        Batch files and clip xml files will be exported. These are used by Flame to enable an iterative workflow where you can quickly render out new versions that are later pulled in to the main conform in Flame.        Quicktimes are generated and uploaded to ShotGrid for review.  Sending batch renders to ReviewOnce you have published a Flame batch file for a Shot, you can launch Flare directly from that Shot in order to open up the batch file with render and output settings pre-populated. In order to render out a new version, simply click the Render Range Button.Toolkit will display a dialog at this point where you can choose to send the render to ShotGrid review or not.Files will be published and tracked by ShotGrid and optionally also sent to review.Want to learn more?If you want to learn more, and see this workflow in action, head over tothe Flame engine documentation where we also have some video content that demonstrates the various workflows in action.LINKBOX_ENGINE:ShotGridsoftware/tk-flame:The Flame EngineAs always, if you have question regarding integration or customization, don’t hesitate to visit our support site.Advanced TopicsBelow you’ll find more advanced details relating to configuration and customizationUsing export presetsThe exporter uses a concept of Export Presets in its configuration. When you launch the Export UI inside of Flame you see a dropdown with the available export presets. Each preset is a configuration option which allows you to configure how files are written to disk and uploaded to ShotGrid. High level settings such as file locations on disk are controlled directly in the environment configuration, making it easy to adjust the default configuration options to work with your pipeline.More advanced settings and control over the actual export xml content that is being passed to flame in order to control Flame, is handled by a hook where the behaviour is defined for each preset. In the hook, you have complete control over how media is being generated by the exporter.Bypassing ShotGrid server side transcodingBy default, Quicktimes are uploaded to ShotGrid review by setting the Version.sg_uploaded_movie field. This in turn will trigger ShotGrid server side transcoding; the uploaded quicktime will be further converted to mp4 and webm representations tailored for playback in browsers and mobile. Sometimes, it can be beneficial to bypass this server side transcoding. This is possible by setting the bypass_shotgun_transcoding configuration setting. When this is set to true, the integration will upload directly to the Version.sg_uploaded_movie_mp4 field in ShotGrid, thereby bypassing the server side transcoding. In this case, no webm version is generated, so review playback will not be possible in Firefox.For more information, see https://support.shotgunsoftware.com/entries/26303513-TranscodingCustomizing ffmpegWhen the exporter generates quicktimes, it uses a version of ffmpeg which comes distributed with Flame. By modifying the settings hook in the exporter, you can specify an external version of ffmpeg to use instead of the built-in one. The version of ffmpeg distributed with Flame is tracking the very latest advancements in ffmpeg transcoding and performance, so sometimes using the latest version may result in performance improvements.Please note that the way h264 parameters are passed to ffmpeg has changed between the version that is used by default and the latest versions. By switching to the latest generation of ffmpeg, it is possible to implement exactly the recommended transcoding guidelines that results in optimal upload and performance on the ShotGrid side. You can find these guidelines here:https://support.shotgunsoftware.com/entries/26303513-TranscodingWe only recommend changing the ffmpeg version if you are an advanced user. In that case, follow these steps:Copying the settings hookAll settings that need to be modified can be found in the settings hook that comes shipped with the Flame export app. In order to modify this hook, you first need to copy this hook file from its default location inside the app location into your configuration. Inside your project configuration, you’ll typically find the hook file in a location similar to install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py. Copy this file into the hooks location inside of your configuration, e.g. config/hooks. We recommend renaming it to something a little more verbose than just settings.py in order to make it clear what it is:install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py -&amp;gt; config/hooks/flame_export_settings.pyNow edit your Flame environment configuration file. This is typically config/env/includes/flame.yml. Under the tk-flame-export heading, you’ll find the path to the hook being defined as settings_hook: '{self}/settings.py'. This essentially means that the configuration will look for the hook file inside the app location (e.g. {self}). Changing this to settings_hook: '{config}/flame_export_settings.py' will tell Toolkit to look for the hook file inside the configuration instad. In summary:settings_hook: '{self}/settings.py' -&amp;gt; '{config}/flame_export_settings.py'Modifying the hookNow we are ready to start modifying our config/hooks/flame_export_settings.py hook! Open it up in a text editor. You’ll notice several methods relating to ffmpeg and ffmpeg settings. The first one to modify is the following:def get_external_ffmpeg_location(self):    &quot;&quot;&quot;    Control which version of ffmpeg you want to use when doing transcoding.    By default, this hook returns None, indicating that the app should use    the built-in version of ffmpeg that comes with Flame.    If you want to use a different version of ffmpeg, simply return the path    to the ffmpeg binary here.    :returns: path to ffmpeg as str, or None if the default should be used.    &quot;&quot;&quot;    return NoneBy returning None by default, the exporter will use Flame’s built-in ffmpeg. Change this to return a full path to your ffmpeg. Keep in mind that if you are running a backburner cluster, ffmpeg may be called from any machines in the cluster, so make sure the executable is installed everywhere.Now that once the ffmpeg location is updated, you most likely either need or want to tweak the parameters passed to ffmpeg. This needs to be changed in two different methods:      get_ffmpeg_quicktime_encode_parameters will return the parameters used when generating a quicktime to be uploaded to ShotGrid.        get_local_quicktime_ffmpeg_encode_parameters will return the parameters used when a quicktime is written to disk.  For the ShotGrid upload, we recommend using the default ShotGrid encoding settings as a starting point:def get_ffmpeg_quicktime_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -vf 'scale=trunc((a*oh)/2)*2:720' -g 30 -b:v 2000k -vprofile high -bf 0&quot;For the local ShotGrid transcode, we recommend basing your settings on the ShotGrid transcode settings but removing the resolution constraints and increasing the bit rate:def get_local_quicktime_ffmpeg_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -g 30 -b:v 6000k -vprofile high -bf 0&quot;",
    "url": "/04a6342b/",
    "relUrl": "/04a6342b/"
  },
  "98": {
    "id": "98",
    "title": "Flame Review",
    "content": "Flame ReviewThe ShotGrid Flame Review App makes it easy to push one or more sequences from Flame into ShotGrid review.Simply right click a sequence or a selection of sequences that you want to review:Select the ShotGrid Review Option:A Toolkit UI will appear where you can add some review notes:When you click ok, a background job will be generated and everything will happen behind the scenes.The following steps will be carried out:      The Sequence will be exported to disk as a quicktime. This export is handled as a Flame Quicktime export and you have complete control of the various settings via a configuration hook.        Once the sequence is complete, Toolkit will check if there is a matching Sequence in ShotGrid. If not, a Sequence will be created automatically.        A review version will be generated and associated with the sequence.        Lastly, the quicktime will be uploaded to the review version.  The process supports audio tracks, transitions etc and should be a “what you see is what you get”. Once in ShotGrid, you can review the media in many different ways, including the client review site and the ShotGrid iPhone app.Customization and SettingsThe Flame Review app can be customized in a couple of different ways:      You can control which Entity Type that should be used in ShotGrid to represent a Sequnce in Flame. For example, if you are working on episodic content, it may make more sense to link your review versions to episodes in ShotGrid rather than sequences.        You can customize which tasks the app should automatically add to new items created in ShotGrid. This is done via a task template setting and allows you to standardize the structure that’s created.        Via a hook, you get complete control over the xml preset that the app uses to generate a quicktime out of Flame.  ",
    "url": "/b38dc286/",
    "relUrl": "/b38dc286/"
  },
  "99": {
    "id": "99",
    "title": "Flame",
    "content": "FlameInstallationThe ShotGrid engine for Flame relies on new integration hooks that were added in Flame 2015 Extension 2.  This version of Flame must be used in order for the engine to function.  For more info on Flame 2015 Extension 2 (including how to get it), reach out to Flame Support.The simplest way to get started with the ShotGrid engine for Flame is to set up a new test project with our example pipeline configuration. You can do this by launching the ShotGrid Desktop, running the Project Setup for a new project and choosing the default Flame configuration (in the default configurations section).Flame Project SetupThe ShotGrid engine for Flame also helps associate the ShotGrid project with a Flame project, and creates it if need be.  This is key to the integration, as it ensures data from Flame gets associated with the right things in ShotGrid.  As an added feature, the engine provides functionality for managing the naming conventions of Flame projects as well as the other various settings for the project.When Flame is launched via ShotGrid for the first time, a Flame project creation UI will appear that lets the artist edit the usual settings from the standard Flame project creation screen:But with the ShotGrid integration, the settings can be pre-populated with pipeline-friendly values, helping artists quickly get the right thing without having to think about it.  The defaults can be customized via the project_setup_hook, which supports the following options:use_project_settings_uiIf set to True, the project creation UI will appear.  If False, the Flame project will automatically be created based on the rest of the defaults in the hook.get_server_hostnameBy default this is set to ‘localhost’, but it can be overridden if desired.get_project_nameBy default this is set to the same value as the ShotGrid project, but it can be overridden if desired.get_volumeBy default this is set to the first available storage, but it can be overridden if desired.get_workspaceBy default Flame will create a default workspace according to its standard workspace creation logic, but it can be overridden if desired.get_userThis will try to associate the user logged into the Flame machine with a user in ShotGrid.get_project_settingsThis is where the main Flame settings are configured and the hook helps build the Flame project XML stream.  The following parameters must be supplied:  FrameWidth (e.g. 1280)  FrameHeight (e.g. 1080)  FrameDepth (16-bit fp, 12-bit, 12-bit u, 10-bit, 8-bit)  FieldDominance (PROGRESSIVE, FIELD_1, FIELD_2)  AspectRatio (4:3, 16:9, or floating point value as string)Proxy settings can also be supplied.  For more info, see the Autodesk Wiretap SDK docs!To view the entire codebase for the project_setup hook, please see our Github repo for the engine.",
    "url": "/d5d7b724/",
    "relUrl": "/d5d7b724/"
  },
  "100": {
    "id": "100",
    "title": "Admin UI",
    "content": "Toolkit Admin UI FrameworkThe Admin UI Framework implements a place that holds standard user interfaces that wrap Toolkitadministrative commands.Currently the only interface is for the setup_project command.SetupProjectWizard API ReferenceThis is a QWizard implementation that walks somebody through setting up a Projectfrom their ShotGrid instance for Toolkit.  To use the wizard, simply create aninstance of the class, passing in the project to setup (as a standard ShotGrid APIentity dictionary) and the window to parent to.adminui = sgtk.platform.import_framework(&quot;tk-framework-adminui&quot;, &quot;setup_project&quot;)setup = adminui.SetupProjectWizard(project, parent)dialog_result = setup.exec_()This will run the wizard and return a standard QDialog Accepted or Rejected value.SetupProjectWizard ConstructorInitialize a SetupProjectWizard.  This is a subclass of QtGui.QWizard.SetupProjectWizard()",
    "url": "/02fa2cba/",
    "relUrl": "/02fa2cba/"
  },
  "101": {
    "id": "101",
    "title": "Desktop Server Framework",
    "content": "Toolkit Desktop Server FrameworkThe desktopserver framework provides the functionality behind ShotGrid’s local file linkingand Toolkit integration.  It provides a local websocket server that securely listens forrequests from ShotGrid websites for an action that requires desktop access.For local file linking, these requests allow ShotGrid access to local file paths from the web interface and the ability to open those files directly from ShotGrid pages when requested. For Toolkit, they allow ShotGrid to determine what pipeline actions have been registered for a given entity and to execute them.How to get desktop integration runningFor these ShotGrid features to work, some supported desktop integration must be running.This page covers the various options for howShotGrid can integrate with your desktop.  The Websocket Server section covers the functionality thatthis framework provides.ShotGrid DesktopThis framework is bundled with ShotGrid Desktop, which can be downloaded here. When ShotGrid Desktop is run it will automatically start up the websocket server.  If you are already running ShotGrid Desktop then your setup process is complete.Configuring the serverYou can store the browser integration settings in a configuration file. This configuration file can be specified by setting the environment variable SGTK_BROWSER_INTEGRATION_CONFIG_LOCATION. More details on how you can configure the local server can be found in our sample file.Removing a certificateIf you wish to remove a certificate you have created, you can run the python certificates.py --remove command.Launching via a wrapperBy default, the server will use the operating-system default to launch a command (the equivalent of“xdg-open” on Linux, “open” on OS X, and “run” on Windows). If you wish to provide your own wrapper forlaunching files you can set the SHOTGUN_PLUGIN_LAUNCHER environment variable to point to yourcustom wrapper. If that is set, the wrapper will be called with the path as its only argument.CertificatesThe first time you run the server it will generate the certificate required to establish a secure connection. These certificates are stored local to your machine and are never shared with the public.They allow the encrypted connection that websockets requires, which is necessary despite all traffic remaining local (from your browser to the server); ShotGrid’s websocket traffic is never made available over the Internet.When the certificates are registered with the system you will see dialogs appear like the following.Click “Ok” to allow the registration to proceed.When using the ShotGrid Desktop, the generated certificates will be stored in the following locations:OS X: ~/Library/Caches/Shotgun/desktop/config/certificatesWindows: %AppData% Shotgun desktop config certificatesLinux: ~/.shotgun/desktop/config/certificatesSecurity Setup - Local ShotGrid InstallsBy default, the websocket server is setup to listen to hosted ShotGrid sites on port 9000.If you run a local ShotGrid server, you will need to update the configuration for the ShotGrid server to allow connections from your websocket server.When running ShotGrid Desktop, you will need to setup a config.ini file that lives with theShotGrid binary.  There are detailed instructions for where this file needs to livehere.Within that file there is a section that controls the functionality of the websocket server.A typical configuration would look like this:[BrowserIntegration]low_level_debug=0port=9000enabled=1whitelist=*.shotgunstudio.comTroubleshootingOn Linux the server introduces a dependency on libffi.  If Desktop crashes on startup and you see a message about libffi not found in your logs, then you need to install this package.Visit our support site if you have any issues or questions during setup.  If there is a problemrunning the server, please set debug to 1 in the config.ini file and include Desktop’s logfile.The log file can be found in the following locations:OS X: ~/Library/Logs/Shotgun/tk-desktop.logWindows: ~ %APPDATA% Shotgun tk-desktop.logLinux: ~/.shotgun/tk-desktop.log",
    "url": "/c79f1656/",
    "relUrl": "/c79f1656/"
  },
  "102": {
    "id": "102",
    "title": "Desktop Startup",
    "content": "Toolkit Desktop Startup FrameworkThe Desktop Startup framework implements the startup logic of the ShotGrid Desktop. Its main function is to:  initialize the browser integration  log the user in  download Toolkit  configure the site configuration  auto update itself and the site configuration when necessary  launch the tk-desktop engine.  This is an internal Toolkit framework and therefore the interface it implements is subject to change. We advise that you do not use this framework in your projects.Locking-down the startup logic  Note, this requires the ShotGrid Desktop app version 1.3.4. If you are unsure of your application version, launch the ShotGrid Desktop. Once you are logged in, click on the user icon at the bottom right and click About.... The App Version should be 1.3.4 or greater.By default, ShotGrid Desktop downloads tk-framework-desktopstartup updates locally on the user’s machine and uses it during the launch sequence of the application. When you launch the application, Toolkit automatically checks for updates to the framework. If an update is available, it will also download and install it automatically.Alternately, you can configure the ShotGrid Desktop to use a specific copy of the framework instead of using the local copy. This will disable the auto-update function and you will now be responsible for updating your the startup logic. In order to be kept up to date with updates, we suggest you subscribe to this page.Download a specific release from GitHubYou will need to download updates from GitHub manually. The bundles can easily be downloaded from the Releases page and you can find more information about each official release here.Configure the ShotGrid Desktop to use a specific copyThe only way to lock down the startup logic is to use an environment variable. By setting SGTK_DESKTOP_STARTUP_LOCATION to the root folder of a copy of the framework, you will tell the ShotGrid Desktop to use this copy of the code when starting up. Once the variable is set, you can launch the ShotGrid Desktop and it will use this specific copy of the startup logic.  Note that as of this writing the Startup Version field in the About... box will be Undefined when locking the startup logic due to a technical limitation.Reverting to the old behaviourTo revert back your changes, simply unset the environment variable and launch the ShotGrid Desktop.",
    "url": "/3414fbb3/",
    "relUrl": "/3414fbb3/"
  },
  "103": {
    "id": "103",
    "title": "Hiero/Nuke Studio Export",
    "content": "Hiero/Nuke Studio ExportIntroductionThis app adds ShotGrid awareness to Hiero’s export dialog for sequences.Overview Video &amp;amp; DemoIf you’re new to ShotGrid Toolkit or the Hiero integration, check out the following video which gives a fast-paced overview of what you can do in your pipeline with the ShotGrid Toolkit Hiero integration.If you’re already familiar with Toolkit and Hiero, then feel free to continue on to the docs below.ShotGrid Shot ProcessorWhen this app activates itself it registers a bunch of changes with the Hiero export dialog:The first thing to notice is the new processor that is registered:When you click on this processor, there are some new things to notice.At the top of the dialog, there is extra UI that helps control how shots get created/updated in ShotGrid as a result of exporting the sequence:TagsBy adjusting the dropdowns you can map various Hiero tags into ShotGrid shot statuses and shot task templates.  Thus via Hiero’s tagging workflow you can set a ShotGrid shot to being in progress or setup the tasks for the Shot for a green screen, cg extra, or whatever makes sense for your configuration.  This UI is populated via a hook and is easy to configure for extra functionality.CollatingThere are also options to control collating track items together that mirror Hiero’s built in logic.  If you have multiple items that make up a shot (either overlapping, on different tracks or with the same shot name on multiple tracks) then you should turn these options on. This will cause the ShotGrid Toolkit Shot updater to treat the matching collated items as a single Shot.For example, assume we have two track items representing shots 010 and 020. 010 comes first and 020 overlaps with the end of 010 on a different track. Since 010 comes first, it’s the hero and with collating enabled, ShotGrid treats the two items as a single shot, 010. This means Shot 010 will be created or updated in ShotGrid. The cut in will match the beginning of track item 010 and the cut out will match the end of track item 020. A Screening Room-ready Version will be created for each item, but both will be linked to Shot 010. A plate will be created for each item as a Published File but both will be linked to Shot 010. A single Nuke script will be published linked to Shot 010 containing 2 read nodes, one for each item. Note that in this situation, there is no creation or update to Shot 020 in ShotGrid, since it has been collated into Shot 010.PathsBelow the ShotGrid UI is the standard paths dialog.  There are three items that are added to Shots via Hiero by default… a default Nuke script, a default Nuke write location, and a default location for a plate transcode.  The locations of these items are determined by the app configuration and can make full use of the templating system:This app adds a {tk_version} token to Hiero which will be replaced by the version string, correctly formatted for ShotGrid Toolkit.Custom Template FieldsAny tokens you define in the custom_template_fields setting that are resolved by the resolve_custom_strings hook will automatically be added to Hiero’s list of valid replacement tokens and will be considered valid replacements in your Toolkit template paths.For example, in your Toolkit templates.yml file, say you define a key with the following:    resolution:         type: str         filter_by: alphanumeric  In your project.yml settings for tk-hiero-export you have:  ...  ...  tk-hiero:    apps:      tk-hiero-export:        custom_template_fields:        - {description: Shot Resolution, keyword: resolution}  ...  ...And then you modify the resolve_custom_strings hook with something like the following:# Copyright (c) 2014 ShotGrid Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights# not expressly granted therein are reserved by ShotGrid Software Inc.from tank import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    RESOLUTION_TOKEN_NAME = &quot;{resolution}&quot;    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        &quot;&quot;&quot;        self.parent.log_debug(&quot;attempting to resolve custom keyword: %s&quot; % keyword)        if keyword == self.RESOLUTION_TOKEN_NAME:            translated_value = self._clip_resolution_string(task)        else:            raise RuntimeError(&quot;No translation handler found for custom_template_field: %s&quot; % keyword)        self.parent.log_debug(&quot;Custom resolver: %s -&amp;gt; %s&quot; % (keyword, translated_value))        return translated_value    # Handle the {resolution_fs} token     def _clip_resolution_string(self, task):         &quot;&quot;&quot; returns sequence resolution or task format override&quot;&quot;&quot;         width = &quot;&quot;         height = &quot;&quot;        sequence_format = task._sequence.format()        width = sequence_format.width()         height = sequence_format.height()        if &quot;reformat&quot; in task._preset.properties():             task_reformat_settings = task._preset.properties()[&quot;reformat&quot;]             if task_reformat_settings['to_type'] != &quot;None&quot;:                 width = task_reformat_settings['width']                 height = task_reformat_settings['height']        return &quot;%sx%s&quot; % (width, height)You can now not only use the resolution token in Hiero but it will validate against any template paths you have defined in Toolkit so you can export to a location like:    hiero_plate_path: &quot;sequences/{Sequence}/{Shot}/hiero_plates/{resolution}/v{version}/{project}_{Shot}.mov&quot;ShotGrid TasksThere are two new task types registered.ShotGrid Transcode ImagesThis is a subclass of the standard Hiero transcoding task, which will register the results of the transcode as a Publish in ShotGrid.  Optionally a Version will also be created in ShotGrid.  If a Version is created, then a Quicktime will also be created and uploaded as Screening Room media.ShotGrid Nuke Project FileThis is a subclass of the standard Hiero Nuke script exporter, which registers the resulting Nuke script as a PublishedFile in ShotGrid linked to the Shot. The settings allow you to specify which Toolkit-enabled WriteNodes to include in the file on export.The app settings plate_published_file_type and nuke_script_published_file_type allow you to control what file type the PublishedFiles are registered as. In addition, nuke_script_toolkit_write_nodes allows you to control which WriteNode settings should be available in the export dialog.Export processWhen the export is run, there will be some extra tasks that show up in the export queue:Each shot will run a ShotGridShotUpdater tasks that is responsible for creating the Shot in ShotGrid and creating the full Shot structure specified in the schema configuration:Sequence and Shot updates in ShotGridThe name of the Hiero sequence will be used for the sequence name, and theshots will have their cut info filled in (Cut Order, Head In, Cut In, Cut Out,Tail Out, Cut Duration, and Working Duration).  In addition if poster frameswere selected for the sequence or the items that make up the shot, they will beuploaded as the thumbnails for the shots.If your workflow uses an entity other than Sequence as the shot parent(like Episode), then you can override the get_shot_parent method in thehook_get_shot hook. The default implementation creates (if necessary) andreturns a Sequence.Cut Schema SupportIf your ShotGrid site supports the Cuts schema (v7.0.0 or later), then this appwill automatically generate a Cut with corresponding CutItems inShotGrid.  The Cut entity corresponds to the Hiero sequence and theCutItems correspond to the items in the sequence. The Cut will belinked to the parent entity (Sequence by default) as returned by theget_shot_parent method in the hook_get_shot hook. The CutItems will beassociated with a Shot entity and linked to the reviewable Versioncreated during the export. After exporting, the Cut will be playable in theMedia tab in ShotGrid and in RV.All of the meta data associated with the Cut and CutItem entities isinferred from Hiero except the Cut Type field which can be specified in theexport UI.The value here will show up in the Type field of the Cut.It should be noted that the Cut schema is not supported when either of theCollate options are selected, and creation of Cut and CutItem entrieswill be skipped.In addition, the Cut schema does not handle retimed clips. A debug warning will be logged when exporting retimed clips.Alternate Shot HierarchiesFor studios that don’t work in the standard Sequence &amp;gt; Shot hierarchy, but  perhaps use Episodes and/or Scenes,  there is a hook hiero_get_shot that allows you to configure the app to work with whatever Shot hierarchy is in use at your studio.",
    "url": "/523d3720/",
    "relUrl": "/523d3720/"
  },
  "104": {
    "id": "104",
    "title": "Hiero/Nuke Studio Open in ShotGrid",
    "content": "Hiero/Nuke Studio Open in ShotGridThis app adds a context menu to the Hiero spreadsheet and timeline that allows you to open a given track item in ShotGrid if there is a Shot for that item.You typically configure this app by adding it to the time line and spreadsheet menus in Hiero by adding the following to the ShotGrid Engine for Nuke configuration:    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}",
    "url": "/88ae1c1d/",
    "relUrl": "/88ae1c1d/"
  },
  "105": {
    "id": "105",
    "title": "Houdini Alembic Node",
    "content": "Houdini Alembic NodeThe Houdini Alembic Node App provides a custom ShotGrid Alembic Output node which makes it easy to standardise the location where alembic files are output.  It can be configured for each environment.General UseIn order to use the ShotGrid Alembic Output, save your script as a Toolkit work file first and then create a new node via the TAB menu in Houdini. This will create a node which looks similar to a normal Alembic output node:The node can be configured with multiple output profiles, each using a different template path for where the alembic cache should be written to disk.Rather than entering a path by hand, you just specify which output profile to use and the node will compute the rest of the path automatically. You can see the computed path in the UI.The output alembic files will be versioned and the version number will always follow the current Houdini scene file version which will be incremented automatically when you publish using Multi Publish.ConfigurationThe Toolkit alembic node provides the ability to specify multiple output profiles for an environment configuration. Here’s an example of configuring the node with multiple profiles:  tk-houdini:    apps:      tk-houdini-alembicnode:        location:           name: tk-houdini-alembicnode          type: app_store          version: v0.2.2        work_file_template: houdini_shot_work        default_node_name: tk_alembic_out        output_profiles:          - name: For Publishing            settings: {}            color: [1.0, 0.5, 0.0]            output_cache_template: houdini_shot_work_alembic_cache          - name: Local Testing            settings: {}            color: [0.0, 0.5, 1.0]            output_cache_template: houdini_shot_local_alembic_cacheYou can use the output profiles to alter the look of the node via the color field, and you can adjust individual parms on the underlying Alembic node by supplying key/value pairs matching those parms in the settings field. Finally, the output_cache_template field drives the output path for the alembic cache written to disk.",
    "url": "/55f75584/",
    "relUrl": "/55f75584/"
  },
  "106": {
    "id": "106",
    "title": "Houdini Mantra Node",
    "content": "Houdini Mantra NodeThe Houdini Mantra Node App provides a custom ShotGrid Mantra Output node which makes it easy to standardise the location where render files are output.  It can be configured for each environment.General UseIn order to use the ShotGrid Mantra Node, save your script as a Toolkit work file first and then create a new node via the TAB menu in Houdini. This will create a node which looks similar to a normal Mantra output node:The node can be configured with multiple output profiles, each using a different set of template paths for where the render output (images, ifd, dcm, aov, etc) should be written to disk.Rather than entering a path by hand, you just specify which configuration to use and the node will compute the rest of the path automatically. You can see the computed path in the UI.The rendered files will be versioned and the version number will always follow the current Houdini scene file version which will be incremented automatically when you publish using Multi Publish.ConfigurationThe Toolkit mantra node provides the ability to specify multiple output profiles for an environment configuration. Here’s an example of configuring the node with multiple profiles:  tk-houdini:    apps:      tk-houdini-mantranode:        location:           name: tk-houdini-mantranode          type: dev          version: v0.2.2        default_node_name: tk_mantra_out        work_file_template: houdini_shot_work        output_profiles:          - name: Primary Render            settings: {}            color: [1.0, 0.5, 0.0]            output_render_template: houdini_shot_render            output_ifd_template: houdini_shot_ifd            output_dcm_template: houdini_shot_dcm            output_extra_plane_template: houdini_shot_extra_plane          - name: Local Render            settings: {}            color: [0.0, 0.5, 1.0]            output_render_template: houdini_shot_local_render            output_ifd_template: houdini_shot_local_ifd            output_dcm_template: houdini_shot_local_dcm            output_extra_plane_template: houdini_shot_local_extra_planeYou can use the output profiles to alter the look of the node via the color field, and you can adjust individual parms on the underlying Alembic node by supplying key/value pairs matching those parms in the settings field. Finally, the output_*_template fields drive the output paths for the files written to disk by the mantra renderer.",
    "url": "/2c47f879/",
    "relUrl": "/2c47f879/"
  },
  "107": {
    "id": "107",
    "title": "Houdini",
    "content": "HoudiniThe ShotGrid Engine for Houdini contains a standard platform for integrating ShotGrid Apps into Houdini.Information for App DevelopersSupported platformsThe ShotGrid Engine for Houdini is currently supported on Windows, Linux, and OSXPySideFor older versions of Houdini (13 and older) an external build of PySide is required. On Windows, we have bundled a compatible PySide build that will work with the python that Houdini runs. On Linux, Houdini uses the system python (per http://www.sidefx.com/docs/houdini12.0/hom/) which needs to have PySide or PyQt support.Menu loadingA dynamic menu system was introduced by Side Effects as of Houdini 15, so the engine now supports rebuilding of the ShotGrid menu on context switches.In Houdini 14 and older, the ShotGrid menu in Houdini is generated before Houdini starts and is static throughout the session. Due to this, the toolkit commands registered in the menu will not update on context changes.ShotGrid shelfRelease v0.2.4 introduced a dynamic ShotGrid shelf to the engine. The shelf displays any registered app commands as tool buttons. The buttons will be displayed in roughly the same order as the menu commands.Use the enable_sg_shelf setting to turn on the shelf within an environment. If using a version of Houdini (14 or older) that does not support dynamic menus, you may also want to turn off the ShotGrid menu when using the shelf. This can be done by setting the enable_sg_menu setting to false.To enable context switching via the shelf, you’ll also need to add entity types to the sg_entity_types setting of the tk-multi-workfiles app in your engine configuration.Here’s a look at the settings related to the ShotGrid shelf:tk-houdini:  apps:    # ... other app definitions    tk-multi-workfiles:       # ... other app settings       sg_entity_types: [Shot, Asset] # allow context switching to Shots or Assets       # ... other app settings  enable_sg_shelf: true  enable_sg_menu: false  # ... other engine settingsOnce you’ve enabled the ShotGrid shelf, you need to manually add it to a shelf set inside houdini.Once added to a shelf set the ShotGrid shelf will remain there between houdini sessions and will update dynamically as your ShotGrid context changes.PanelsAs of v0.2.8 the engine adds support for embedded toolkit panels.The panel support currently requires Houdini version 15.0.272 or later for proper embedded panels. Registered panels will show up as panes in the pane  menu for supported versions of Houdini.Older versions of Houdini will display the registered panels as dialogs. SESI may backport some bug fixes to newer builds of Houdini 14. If and when that happens, we will make embedded panels work for those versions as well.Apps with OTLsThe ShotGrid Engine for Houdini makes it easy to load application supplied OTLs. If you are writing an app which uses OTLs, you can just drop them into a folder called otls and the engine will automatically load them into your session:You can then easily access your nodes via the usual Houdini methods.Warning!! Please note that while the use of OTLs may be convenient, it is typically NOT the right solution if you want to create nodes that persist in a scene. The reason for this is because as soon as you have put an OTL in the scene, you have introduced a dependency between that scene and the OTL code. Not only will you need to load the ShotGrid Toolkit every time you load the scene, but you also need to carefully manage your code so that any updates to the code does not break old OTLs being used in scenes.Startup Debugging via Terminal on OSXTurning on debug_logging for the tk-houdini engine on OS X will not send all debug messages to the Terminal. This is because, by default, the tk-multi-launchapp app uses the open command to launch executables. This does not spawn a new subprocess from the Terminal, but rather uses OS X’s Launch Services to create a new process elsewhere. As a result, the log statements are not shown. Even having a python shell saved in the user’s default desktop in houdini does not seem to show debugging statements during startup. After startup, and embedded Python shell will show debug logging statements, but there is a gap in available output during startup. If you need access to debug logging statements during engine startup, you can make 2 changes.First, change your houdini_mac path (temporarily) in your test configuration to point to the executable inside the Houdini app bundle. For example:#houdini_mac: /Applications/Houdini 15.0.272/Houdini Apprentice.apphoudini_mac: /Applications/Houdini  15.0.272/Houdini  Apprentice.app/Contents/MacOS/happrenticeNext, you can make a copy of the tk-multi-launchapp app’s app_launch hook in your test configuration’s config/hooks directory and point to it in your config/env/includes/app_launchers.yml file:launch_houdini:  defer_keyword: ''  engine: tk-houdini  extra: {}  hook_app_launch: app_launch    # &amp;lt;----- use a custom app_launch hook  hook_before_app_launch: default  icon: '{target_engine}/icon_256.png'  linux_args: ''  linux_path: '@houdini_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.6.6}  mac_args: ''  mac_path: '@houdini_mac'  menu_name: Launch Houdini  versions: []  windows_args: ''  windows_path: '@houdini_windows'Then all you have to do is modify the launch logic to launch the executable directly. As an example, you could keep the old behavior for directories (application bundles) and otherwise execute the command directly. Here’s an example:        elif system == &quot;darwin&quot;:            # on the mac, the executable paths are normally pointing            # to the application bundle and not to the binary file            # embedded in the bundle, meaning that we should use the            # built-in mac open command to execute it            if os.path.isdir(app_path):                cmd = &quot;open -n  &quot;%s &quot;&quot; % (app_path)                if app_args:                    cmd += &quot; --args  &quot;%s &quot;&quot; % app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;)            # not a directory, execute directly            else:                cmd = &quot;%s %s&quot; % (app_path, app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;))The next time you run launch_houdini via tank in the Terminal, you should get all the debug output. Once you’re done testing, don’t forget to revert your path and undo your app launch changes. Happy debugging!",
    "url": "/797202da/",
    "relUrl": "/797202da/"
  },
  "108": {
    "id": "108",
    "title": "Mari Project Manager",
    "content": "Mari Project Manager",
    "url": "/82aaf735/",
    "relUrl": "/82aaf735/"
  },
  "109": {
    "id": "109",
    "title": "Mari",
    "content": "MariThe ShotGrid engine for Mari contains a standard platform for integrating ShotGrid Toolkit Apps into Mari. It is light weight and straight forward and adds a ShotGrid menu to the main menu.",
    "url": "/301f5e66/",
    "relUrl": "/301f5e66/"
  },
  "110": {
    "id": "110",
    "title": "Maya",
    "content": "MayaThe ShotGrid engine for Maya contains a standard platform for integrating ShotGrid Apps into Maya. It is lightweight and straight forward and adds a ShotGrid menu to the Maya menu bar.Maya Project ManagementWhenever the ShotGrid engine for Maya starts, it will set the Maya Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the maya project is set based on a file can be configured in the configuration file, using the template system.",
    "url": "/9e62da4a/",
    "relUrl": "/9e62da4a/"
  },
  "111": {
    "id": "111",
    "title": "Motion Builder",
    "content": "Motion BuilderThe ShotGrid engine for Motion Builder contains a standard platform for integrating ShotGrid Toolkit Apps into Motion Builder. It is light weight and straight forward and adds a ShotGrid menu to the main menu.",
    "url": "/54009c12/",
    "relUrl": "/54009c12/"
  },
  "112": {
    "id": "112",
    "title": "About",
    "content": "AboutThis app gives a graphical breakdown of the current work area and all the apps running in the current environment. You can find it on the Context Menu:Reload all appsThere is a handy button this app that reloads the entire environment. This is useful if you are doing development and have made some code changes you want to try out! No need to restart Maya or Nuke, just hit the reload button!In addition to the reload feature, this apps shows a breakdown of your current work area and all the apps that are currently loaded.Three separate views exist:Current Work AreaThis shows the current Shot or Asset, the current Task etc. If you double click any of the items in the list, the system will open the ShotGrid Detail page for that item.Running AppsA view of all the currently running apps, along with their version and description. Double clicking an app will launch the documentation page for that app.Current EnvironmentA view of the currently loaded environment file and engine. This can be useful for debugging purposes 🎀",
    "url": "/c542e4dd/",
    "relUrl": "/c542e4dd/"
  },
  "113": {
    "id": "113",
    "title": "Breakdown",
    "content": "BreakdownThe Scene Breakdown app shows you a list of referenced content and tells you which items are out of date. You access it from the ShotGrid Menu.You can select one more more items and hit update selected. This will switch the items to use the latest version of the content.Scanning the SceneWhen the breakdown app scans the scene for references, it will call a special scanning hook. The scanning hook will return a list of nodes with file corresponding paths. For each reference it finds, it returns the file path, and tank will look at the file path and first check if it recognizes it as a publish, and if it does, see if there is a more recent version available.If the user clicks the update button that is shown for outdated versions, the app will call another hook to do the actual update work. This means that by customizing these hooks it is relatively simple to add new custom nodes to the breakdown.Accessing ShotGrid DataIf you need to access ShotGrid data for the publish you are about to update to in the hook, this is straight forward; a single call to find_publish will retrieve metadata for all the items passed in from the app, like this:class BreakdownHook(Hook):    def update(self, items):        &quot;&quot;&quot;        Perform replacements given a number of scene items passed from the app.        Once a selection has been performed in the main UI and the user clicks        the update button, this method is called.        The items parameter is a list of dictionaries on the same form as was        generated by the scan_scene hook above. The path key now holds        the that each node should be updated *to* rather than the current path.        &quot;&quot;&quot;        engine = self.parent.engine        # resolve ShotGrid data for all paths passed via the items dictionary        sg_data = tank.util.find_publish(engine.sgtk,                                         [i[&quot;path&quot;] for i in items],                                         fields=[&quot;id&quot;, &quot;code&quot;, &quot;version_number&quot;])        for i in items:            node_name = i[&quot;node&quot;]            node_type = i[&quot;type&quot;]            new_path = i[&quot;path&quot;]            # now that each item is processed, it is easy to access the            # ShotGrid data via a dictionary lookup:            sg_data = sg_data.get(i[&quot;path&quot;])            # once we have all our desired info and metadata, we can go ahead            # and apply the update business logic.            # [-business logic here-]API AccessYou can access the breakdown app programatically using its API. The following methods exist:Showing the breakdown UIapp_object.show_breakdown_dialog()If you want to show the breakdown UI, execute the show_breakdown_dialog() method. Assuming the app is included under a tk-multi-breakdown section in your currently running environment, this could for example be done like this:&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; e = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; e.apps[&quot;tk-multi-breakdown&quot;].show_breakdown_dialog()Running the scene analysisitems = app_object.analyze_scene()You can programmatically run the scene analysis logic by executing the analyze_scene() method. This executes exactly the same logic that the breakdown UI uses when it builds the listing of scene items.The method returns a list of breakdown items. Each item is represented by a dictionary with a number of keys to describe the item. Only files whose path corresponds to a template in the Toolkit templates file will be detected. Files do not need to exist as publishes in ShotGrid, however if they do, this method will return basic ShotGrid publish metadata for them.The two keys node_name and node_type are used to return a DCC-centric “address” or representation which makes it possible to identify the path within the DCC. In for example Maya and Nuke, this will return the node name and type. The logic for this is implemented in the hooks and will vary between DCCs. This method will attempt to connect to ShotGrid, but the number of calls made are constant and independent of the scene complexity.Here is an example of what a dictionary in the return data typically looks like:{'fields': {'Sequence': 'aaa',            'Shot': 'aaa_00010',            'Step': 'Comp',            'eye': '%V',            'height': 1556,            'name': 'test',            'output': 'output',            'version': 1,            'width': 2048}, 'template': &amp;lt;Sgtk TemplatePath nuke_shot_render_pub_mono_dpx&amp;gt;,  'node_name': 'Read2', 'node_type': 'Read',  'sg_data': {'code': 'aaa_00010_test_output_v001.%04d.dpx',             'entity': {'id': 1660, 'name': 'aaa_00010', 'type': 'Shot'},             'id': 1424,             'name': 'test',             'published_file_type': {'id': 3,                                     'name': 'Rendered Image',                                     'type': 'PublishedFileType'},             'task': {'id': 4714, 'name': 'Comp', 'type': 'Task'},             'type': 'PublishedFile',             'project': {'id': 234, 'name': 'Climp', 'type': 'Project'},             'version_number': 1}, }Handy Tip!: As you can see above, each item returns a template object and a fields dictionary to represent the path. If you want to see the actual raw path for the item, you can simply run template_obj.apply_fields(fields_dict). In the context of one of the item dictionaries returned by this method, the code would bebreakdown_items = analyze_scene()for item in breakdown_items:   path = item[&quot;template&quot;].apply_fields(item[&quot;fields&quot;])Computing the highest version for an itemhighest_version = app_object.compute_highest_version(template, fields)In order to figure out the highest version for an item, use the compute_highest_version(template, fields) method. The template and fields parameters represent a path that should be analyzed are typically grabbed from the output of the analyze_scene() method. With the breakdown app, the template key containing the version number is always required to be named {version}.This will perform a scan on disk to determine the highest version. The method returns the highest version number found on disk. See the usage example below for more details.Updating a scene itemapp_object.update_item(node_type, node_name, template, fields)In order to update an item, you can use the update_item(node_type, node_name, template, fields) method. The template and fields parameters represent a path that should be updated to. The node_name and node_type parameters are used to identify which node in the scene should be modified. Typically, these  values are grabbed from the output of the analyze_scene() method.This is similar to running the update in the breakdown UI. The actual update call will be dispatched to a hook which handles the DCC specific logic. See the usage example below for more details.Breakdown API exampleBelow is an example showing how to retrieve the scene breakdown and update all items that are not using the latest version.# find the breakdown app instanceimport sgtkengine = sgtk.platform.current_engine()breakdown_app = engine.apps[&quot;tk-multi-breakdown&quot;]# get list of breakdown itemsitems = breakdown_app.analyze_scene()# now loop over all itemsfor item in items:    # get the latest version on disk    latest_version = breakdown_app.compute_highest_version(item[&quot;template&quot;], item[&quot;fields&quot;])        # if our current version is out of date, update it!    current_version = item[&quot;fields&quot;][&quot;version&quot;]    if latest_version &amp;gt; current_version:                # make a fields dictionary representing the latest version        latest_fields = copy.copy(item[&quot;fields&quot;])        latest_fields[&quot;version&quot;] = latest_version                # request that the breakdown updates to the latest version        breakdown_app.update_item(item[&quot;node_type&quot;], item[&quot;node_name&quot;], item[&quot;template&quot;], latest_fields)",
    "url": "/3c0c0ab6/",
    "relUrl": "/3c0c0ab6/"
  },
  "114": {
    "id": "114",
    "title": "Demo",
    "content": "DemoThe Demo App provides live demonstrations of ShotGrid’s native developer platform components including the ShotGrid Utilities framework, the Qt Widgets frameworks and Toolkit core.Each demo displayed in the app includes a working, interactive UI that shows how to use one or more components of the native platform. In addition, the code that is running is readily available to copy and paste into your own app.The app is simple to use. Just select a demo from the list on the left and then interact with the components on the right. Some demos are as simple as displaying a single widget from the Qt Widgets framework. Other demos provide examples of how ShotGrid platform components are commonly wired up for use in production apps.New demos will be added as new components are added to the platform and as time permits. If there is a common pattern of component usage or a demo that you’d like to see, please let us know by submitting a ticket.InstallationTo install the demo app, run the following command:tank install_app project tk-shell tk-multi-demoOnce installed, you can run the following command to launch the app:./tank demos",
    "url": "/42395ae7/",
    "relUrl": "/42395ae7/"
  },
  "115": {
    "id": "115",
    "title": "Launch App",
    "content": "Launch AppThis app provides a shortcut to make it easy to jump from ShotGrid to any supported application. It registers a ShotGrid Action entry called for various entities in ShotGrid according to your configuration choices.How It WorksDepending on your configuration options a menu entry will appear in ShotGrid when right-clicking entities or using the ShotGrid actions menu or gear menu.For example, this screenshot comes from a site who’s configuration uses this app three times to implement menus for Maya, Nuke and Photoshop.Currently supported applications and engines are:  3DSMax  Hiero  Maya  MotionBuilder  Nuke  Photoshop  Mari  Houdini  Softimage  FlameUse Command Line Arguments at LaunchMany applications have command line options that can be called to choose a different edition of the application (ex. Nuke vs. NukeX) or to specify other various usage aspects.  The launcher app has an ‘args’ setting for each OS that can be configured for this purpose.  For example if you put ‘–nukex’ there, it will add that to the command line launch and NukeX will run instead of regular Nuke:—FOLD—Launch NukeX Examplelaunch_nuke:  engine: tk-nuke  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: '--nukex'  linux_path: '@nuke_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.15}  mac_args: '--nukex'  mac_path: '@nuke_mac'  menu_name: Launch Nuke  windows_args: '--nukex'  windows_path: '@nuke_windows'—FOLD—Set Environment Variables and Automate Behavior at LaunchApplications often require certain certain environment variables, plugin paths, etc. to be set in order to properly function in a studio pipeline. The launch app helps cover this case via the ‘before_app_launch’ hook, which allows you to define a snippet of code to run each time an application starts up. By default, the ‘before_app_launch’ hook is a simple pass-through that does nothing, but it can be overridden by following the instructions in this doc.For example, if you use Zync Render, the Zync Maya plugin directory needs to be part of both $PYTHONPATH and $XBMLANGPATH. To have the launch app set these environment variables, update the ‘before_app_launch’ hook with a few lines of code, as follows:—FOLD—Set Environment Variables Exampledef execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # Example to show how to set env vars on Maya launch    # Append the desired path to the existing $PYTHONPATH to ensure    # everything upstream still works    os.environ[&quot;PYTHONPATH&quot;] = os.environ[&quot;PYTHONPATH&quot;] + os.pathsep + &quot;~/Library/zync/zync-maya&quot;    # Set $XBMLANGPATH to the desired path, may need to append it as    # with $PYTHONPATH if already defined in your pipeline    os.environ[&quot;XBMLANGPATH&quot;] = &quot;~/Library/zync/zync-maya&quot;—FOLD—You can also use the ‘before_app_launch’ to automate other behavior, including ShotGrid updates. For example, you can configure the launch app to update the Task status (in this case, to “in progress”) each time it’s run (as long as the launch is from a Task, of course), as follows:—FOLD—Automate Task Status Update Exampledef execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # If there is a Task in the context, set its status to 'ip'    if self.parent.context.task:        task_id = self.parent.context.task['id']        data = {            'sg_status_list':'ip'        }        self.parent.shotgun.update(&quot;Task&quot;, task_id, data)—FOLD—As you can imagine, there are many possibilities here, and the launch app aims to provide the flexibility your pipeline needs.Launching Applications that do not have an Engine YetYou can also use the launch app to start up applications that do not have a Toolkit engine yet. In this case, folders will be created on disk for the shot, task or asset you are launching from and the application will be launched, but no code will run after application startup and no ShotGrid menu will appear inside the application. This means that you can launch applications that are not yet supported by Toolkit from within ShotGrid.In order to do this, configure the app with paths to the application you wish to launch, but leave the engine option as an empty string.Technical Details3DSMaxThis app automatically adds a MaxScript, init_tank.ms, to the 3DSMax command line that 3DSMax will run as part of its boot process.When 3DSMax is booting, the following will happen:  3DSMax will run init_tank.ms upon starting  init_tank.ms makes sure a Python interpreter is available and runs tank_startup.py  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.MayaThis app registers a userSetup.py auto start script with Maya which Maya will call as part of its boot process.When Maya is booting, the following will happen:  Maya starts execution of the userSetup.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.MotionBuilderThis app registers a init_tank.py auto start script with MotionBuilder which MotionBuilder will call as part of its boot process.When MotionBuilder is booting, the following will happen:  MotionBuilder starts execution of the init_tank.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.NukeThis app registers a menu.py auto start script with Nuke which Nuke will call as part of its boot process.When Nuke is booting, the following will happen:  Nuke starts execution of the menu.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.PhotoshopThis app will use the Adobe Extension Manager to install or make sure the Tank plugin is installed.When Photoshop is booting, the following will happen:  Photoshop will start the execution of the Tank Plugin  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.Extra configsIf you intend to use this app to launch Photoshop you will need to supply four config values in the extra section. Here are the configs and sane default values which you would need to adjust for your system and installation locations:mac_python_path: &quot;/usr/bin/python&quot;windows_python_path: &quot;C:  Python27  python.exe&quot;mac_extension_manager_path: &quot;/Applications/Adobe Extension Manager CS6/Adobe Extension Manager CS6.app&quot;windows_extension_manager_path: &quot;C:  Program Files (x86)  Adobe  Adobe Extension Manager CS6  XManCommand.exe&quot;",
    "url": "/1b9c259a/",
    "relUrl": "/1b9c259a/"
  },
  "116": {
    "id": "116",
    "title": "Loader",
    "content": "LoaderThis document describes functionality only available if you have taken control over a Toolkit configuration. Please refer to the ShotGrid Integrations User Guide for details.ConfigurationThe loader is highly configurable and you can set it up in many different ways. There are two main configuration areas:  Setting up what tabs and what content to display in the left hand side tree view.  Controlling which actions to display for different publishes and controlling what the actions actually do.The following sections will give a high level overview how you can configure the loader.For technical minutiae relating to the configuration, please see the separate section further down in the documentation.The tree viewThe tree view is highly configurable and you can control the content of the various tabs using standard ShotGrid filter syntax. Each tab consists of a single ShotGrid API query which is grouped into a hierarchy. You can add arbitrary filters to control which items are being shown, and you can use the special keywords {context.entity}, {context.project}, {context.project.id}, {context.step}, {context.task} and {context.user} to scope a query based on the current context. Each of these keywords will be replaced with the relevant context information, either None, if that part of the context is not populated or a standard ShotGrid link dictionary containing the keys id, type and name.By default, the loader will show assets and shots belonging to the current project. By reconfiguring, this could easily be extended to for example show items from other projects (or a specific asset library project for example). You could also for example use filters to only show items with certain approval status or group items by status or by other ShotGrid fields. Below are some sample configuration settings illustrating how you could set up your tree view tabs:# An asset library tab which shows assets from a specific# ShotGrid projectcaption: Asset Libraryentity_type: Assethierarchy: [sg_asset_type, code]filters:- [project, is, {type: Project, id: 123}]# Approved shots from the current projectcaption: Shotshierarchy: [project, sg_sequence, code]entity_type: Shotfilters:- [project, is, '{context.project}']- [sg_status_list, is, fin]# All assets for which the current user has tasks assignedcaption: Assetsentity_type: Taskhierarchy: [entity.Asset.sg_asset_type, entity, content]filters:- [entity, is_not, null]- [entity, type_is, Asset]- [task_assignees, is, '{context.user}']- [project, is, '{context.project}']Filtering publishesIt is possible to apply a ShotGrid filter to the publish query that the loader carries out when it loads publish data from ShotGrid. This is controlled via the publish_filters parameter and can be used for example to hide publishes that have not been approved or where their associated review version has not been approved.Help, no actions are showing up!The loader comes with a number of different actions for each engine. For example, in the case of Nuke, there are two actions: “import script” and “create read node”. Actions are defined in hooks, meaning that you can modify their behaviour or add additional actions if you wanted to. Then, in the configuration for the loader, you can bind these actions to certain publish types you have. Binding an action to a publish type basically means that the action will appear on the actions menu for all items of that type inside the loader.As an example, by default, the mappings for Nuke are set up like this:action_mappings:  Nuke Script: [script_import]  Rendered Image: [read_node]If you are finding that no action menus are showing up, it may be because you have chosen different names for the publish types that you are using. In that case, go into the config and add those types in order to have them show up inside the loader.Managing actionsFor each application that the loader supports, there is an actions hook which implements the actions that are supported for that application. For example, with something like Maya, the default hook will implement the reference, import and texture_node actions, each carrying out specific Maya commands to bring content into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.Once you have defined a list of actions in your actions hook, you can then bind these actions to Publish File types. For example, if you have a Publish File type in your pipeline named “Maya Scene” you can bind this in the configuration to the reference and import actions that are defined in the hook. By doing this, Toolkit will add a reference and an import action to each Maya Scene publish that is being shown. Separating the Publish Types from the actual hook like this makes it easier to reconfigure the loader for use with a different publish type setup than the one that comes with the default configuration.The loader uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings that are installed for the loader, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/loader/my_hook.py. This will tell Toolkit to use a hook called hooks/loader/my_hook.py in your configuration folder.Another second generation hooks feature that the loader is using is that hooks no longer need to have an execute() method. Instead, a hook is more like a normal class and can contain a collection of methods that all makes sense to group together. In the case of the loader, your actions hook will need to implement the following two methods:def generate_actions(self, sg_publish_data, actions, ui_area)def execute_multiple_actions(self, actions)For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.Note that in versions previous to v1.12.0, the application invoked the execute_action hook to execute an action. Newer versions invoke the execute_multiple_actions hook. In order to provide backward compatibility with existing hooks, the execute_multiple_actions hook actually invokes execute_action for each actions provided. If the application is reporting that the execute_multiple_actions hook is not defined after upgrading to v1.12.0 or later, make sure that the actions_hook setting in your environment correctly inherits from the builtin hook {self}/{engine_name}_actions.py. To learn more about how you can derive custom hooks from the builtin ones, see our Toolkit reference documentation.LINKBOX_DOC:5#The%20hook%20data%20type:Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks likethis:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_publish_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular publish.        This method is called each time a user clicks a publish somewhere in the UI.        The data returned from this hook will be used to populate the actions menu for a publish.        The mapping between Publish types and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the loader app        has already established *which* actions are appropriate for this object.        The hook should return at least one action for each item passed in via the        actions parameter.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular publish, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        - If it will be shown in the history area, &quot;history&quot; is passed.        Please note that it is perfectly possible to create more than one action &quot;instance&quot; for        an action! You can for example do scene introspection - if the action passed in        is &quot;character_attachment&quot; you may for example scan the scene, figure out all the nodes        where this object can be attached and return a list of action instances:        &quot;attach to left hand&quot;, &quot;attach to right hand&quot; etc. In this case, when more than        one object is returned for an action, use the params key to pass additional        data into the run_action hook.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_publish_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_publish_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        # resolve local path to publish via central method        path = self.get_publish_path(sg_publish_data)        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_publish_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  Maya Scene: [import, reference, my_new_action]  Maya Rig: [reference, my_new_action]  Rendered Image: [texture_node]By deriving from the hook as shown above, the custom hook code only need to contain the actual added business logic which makes it easier to maintain and update.ReferenceThe following methods are available on the app instance.open_publish()Presents an ‘Open File’ style version of the Loader that allows the user to select a publish.  The selected publish is then returned.  The normal actions configured for the app are not permitted when run in this mode.app.open_publish( str title, str action, list publish_types )Parameters and Return Value  str title - The title to be displayed in the open publish dialog.  str action - The name of the action to be used for the ‘open’ button.  list publish_types - A list of publish types to use to filter the available list of publishes.  If this is empty/None then all publishes will be shown.  Returns: A list of ShotGrid entity dictionaries that were selected by the user.Example&amp;gt;&amp;gt;&amp;gt; engine = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; loader_app = engine.apps.get[&quot;tk-multi-loader2&quot;]&amp;gt;&amp;gt;&amp;gt; selected = loader_app.open_publish(&quot;Select Geometry Cache&quot;, &quot;Select&quot;, [&quot;Alembic Cache&quot;])&amp;gt;&amp;gt;&amp;gt; print selected",
    "url": "/a4c0a4f1/",
    "relUrl": "/a4c0a4f1/"
  },
  "117": {
    "id": "117",
    "title": "Publish",
    "content": "Publish",
    "url": "/bc718491/",
    "relUrl": "/bc718491/"
  },
  "118": {
    "id": "118",
    "title": "Python Console",
    "content": "Python ConsoleThis is a python console panel for use in DCCs with access to a python interpreter that have limited or no support for interacting with said interpreter.PanelOnce installed, the console is registered as a panel in the DCC and is available in the ShotGrid menu. In apps that support embedded Toolkit panels(maya, nuke, houdini), the console will display in a docked panel. When using with older versions of these DCCs or in a DCC that does not support panels, the console will simply be shown as a regular Toolkit dialog.TabsThe python console displays one or more tabs, each containing an editor and an output window. New tabs can be created by clicking the + button in the bottom right hand corner. Tabs have an x button next to the tab name that allow you to delete the tab. Double clicking the tab itself will prompt you to enter a new name for the tab. Tabs can be rearranged via drag and drop. The state of the tabs is saved when the DCC is closed and restored on the next launch.EditorThe console has an input area for editing python. The editor includes line numbers, highlights the cursor’s current line, and does some basic syntax highlighting. The console attempts to use the palette of the DCC to give it an integrated look and feel.Block indenting and unindenting is supported. Select one or more lines and press tab to indent by four spaces or shift + tab to unindent by four spaces. It tries to keep the indentation in blocks of four so it will indent/unindent to the nearest whole block of four spaces.Block commenting and uncommenting is also supported. Select one or more lines and press cmd + / on Mac, ctrl + / for Windows and Linux. If any of the selected lines don’t have a # at the start it will add one to all selected lines. If all the lines do have a #, then it will remove them.OutputThe output area displays the results of the executed python. Echoing the source python commands is turned on by default and is differentiated in the output by being prefixed with &amp;gt;&amp;gt;&amp;gt;. Each execution is also marked with a timestamp. There is a toggle for turning the echo off. Syntax and Runtime errors are shown in red with a full stack trace for debugging.ButtonsOutput  Clear - Clear the contents of the output browser.  Echo - Toggle echoing the executed commands in the output browser.Editor  Execute - Execute the contents of the editor  Save - Save the current contents of the editor to a file.  Open - Open a file in the editor.  Clear - Clear the contents of the editor.  Lines - Toggle line numbers for the current tabGlobalsSome ShotGrid/Toolkit globals are pre-defined in the console, similar to what is available in the ShotGrid Engine for the shell.  Tk API handle is available via the tk variable  ShotGrid API handle is available via the shotgun variable  The current context is stored in the context variable  The shell engine can be accessed via the engine variableExternal sourcesThe app comes with a hook that can be implemented to load python source from an external location. The hook is called external_sources_hook and requires implementing a method called get_external_source_actions. The method should return a list of QActions that, when triggered, add a new tab (with content)to the console. An example implementation is provided that loads gists from github for a list of predefined users. The actions returned by the hook are shown in the popup menu displayed when the Open button is pressed and held.Hotkeys  Execute selected with Ctrl + Enter  Create a new tab with Ctrl + T  Navigate tabs with Ctrl + Shift + [ or Ctrl + Shift + ]  Resize input/output font via Ctrl + WheelNOTE: These hotkeys may not be available in all DCCs.Other notes  In some older versions of DCCs, leaving the python console open when closing the session may cause a crash. We believe this may be a bug in some older versions of PySide. More recent versions of DCCs, bundled with newer versions of PySide, do not appear to crash on exit. If you encounter this issue with a recent DCC release, please submit a ticket so that we can investigate further.",
    "url": "/770a748a/",
    "relUrl": "/770a748a/"
  },
  "119": {
    "id": "119",
    "title": "Review Submission",
    "content": "Review SubmissionHow do I use this App?As an APIThis app have a mode that is meant to be called from inside other apps like the multi-publish app.This mode creates quicktimes from image sequences and submits them as Versions to ShotGrid in order to facilitate review. The generated quicktimes will have slates and burnins. Things such as font, logo position, movie compression options and burnin / slate information are currently hardcoded in the default hooks and as such you are encouraged to re-implement the hook function to adjust the behaviour.Here are a the current default formats for slate and burnin:Should you want to leverage this app from within your own apps or hooks here is a quick rundown of the simple way to go about it.  Get the tk-multi-reviewsubmission app from the current engine. This can be donefrom inside a hook using the call self.parent.engine.apps.get('tk-multi-reviewsubmission').  If the app is available, call the render_and_submit_version() method.Here’s an example of what this can look like inside your hook code:review_submission_app = self.parent.engine.apps.get(&quot;tk-multi-reviewsubmission&quot;)if review_submission_app:    review_submission_app.render_and_submit_version(        template,        fields,        first_frame,        last_frame,        sg_publishes,        sg_task,        comment,        thumbnail_path,        progress_cb,        color_space    )The arguments that you need to pass to render_and_submit_version are as follows:  template: A template that defines where the files to publish are located  fields: Fields that will be used to fill out the template  first_frame: The first frame of the image sequence to process  last_frame: The last frame of the image sequence to process  sg_publishes: A list of ShotGrid Published File objects to link the version to.  sg_task: A ShotGrid Task link dictionary to link the version to.  comment: Text to add to the Version’s description.  thumbnail_path: The path to a thumbnail to use for the version when the movie isn’t being uploaded to ShotGrid (this is set in the config)  progress_cb: A callback to report progress with.  This should be of the form: callback(percent, message)  color_space: The color space that the input frames are in.  In Nuke, this would be one of the enumeration values on the colorspace knob for the Write node.As a menu itemThis mode adds a menu item to the ShotGrid menu inside the DCC. This mode creates a quick snapshot of the current viewport and sends it to ShotGrid Create as a Version draft. Then, the user can extend the review submission inside of ShotGrid Create by adding annotations, text or comparison notes.In order to add this functionality to your context, you need to:  Set the display_name field to have it in the menu item.  Set the render_media_hook field to a hook that tells how to render media in your DCC (tk-photoshopcc and tk-maya have a default implementation)  Set the submitter_hook field to {self}/submitter_create.pyLike this:tk-multi-reviewsubmission:  display_name: Send for review  render_media_hook: '{self}/render_media.py:{self}/{engine_name}/render_media.py'  submitter_hook: '{self}/submitter_create.py'  location:     type: app_store    name: tk-multi-reviewsubmission    version: v1.0.1",
    "url": "/4badd856/",
    "relUrl": "/4badd856/"
  },
  "120": {
    "id": "120",
    "title": "Screening Room",
    "content": "Screening RoomThis is a small app that hooks up your current Maya session with Screening Room. It will add an item to the ShotGrid menu saying Jump to Screening Room. Clicking this button will launch Screening Room and point it at the current ShotGrid Toolkit Context - for example a Shot, Asset or a Task. You can then use Screening Room to browse all submitted content.",
    "url": "/f3e452a2/",
    "relUrl": "/f3e452a2/"
  },
  "121": {
    "id": "121",
    "title": "Set Frame Range",
    "content": "Set Frame RangeThis app helps managing the frame range in the currently open scene. You can access it from the ShotGrid menu by clicking the Sync Frame Range with ShotGrid menu option.When you click it, the ShotGrid Toolkit will look at the ShotGrid entity associated with the current work area (typically a Shot) and look for in and out fields which contain the in and out frame information. Typically, this is something used in conjunction with Shots and in that case the app uses the standard shot in and out fields defined in ShotGrid’s default config. However, it is perfectly possible to configure the app to pull the frame ranges from other fields too.Once you run the App, it will update the current scene with those ins and outs and finally display a summary message:Multiple ShotGrid field synchronisation optionsYou can define multiple instances of this app in the ShotGrid Menu by setting the menu_name property. This allows the possibility to define a multiple menu actions for synchronization of different ShotGrid fields.To do this, set a different app instance name, menu_name and in and out frame fields for each instance:tk-multi-setframerange_cuts:  menu_name: Sync frame range using cut fields  sg_in_frame_field: sg_cut_in  sg_out_frame_field: sg_cut_out  location: &quot;@apps.tk-multi-setframerange.location&quot;tk-multi-setframerange_handles:  menu_name: Sync frame range using handle fields  sg_in_frame_field: sg_handle_in  sg_out_frame_field: sg_handle_out  location: &quot;@apps.tk-multi-setframerange.location&quot;These should then appear as separate options in the ShotGrid menu:Note: this is new to version v0.4.0 of the app.Operations hookThe software specific logic for getting the current scene frame range or setting the frame range is handled in the frame operations hook. If you are wanting to add support for a new engine or want to change how the behaviour is implemented, you can take over the frame operations hook by setting the hook_frame_operation app property and implementing your own get and set logic.Note: this is new to version v0.4.0 of the app.",
    "url": "/8ac43263/",
    "relUrl": "/8ac43263/"
  },
  "122": {
    "id": "122",
    "title": "ShotGrid Panel",
    "content": "ShotGrid PanelThis document describes functionality only available if you have taken control over a Toolkit configuration. Please refer to the ShotGrid Integrations User Guide for details.Configuring the ShotGrid PanelThere are two main areas that you can configure extensively in the ShotGrid Panel: The appearance of text in the UI and the actions you want to associate with data. The sections below outline how to control the configuration for the two systems.Configuring what is being displayedThe values in the detail area and the listings are both configurable through the ShotGrid_fields hook. You can subclass this hook and change the implementation in order to display the exact values you want:Templating SystemThe hook supports a simple templating language, allowing for great flexibility. It also supports the HTML subset supported by Qt, so you can control color, font size, weight, etc. of your displayed values. The template language works in the following way:      ShotGrid values are enclosed in {brackets}, for example &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}. When this template is rendered, the {description} part will be replaced with the description field value.        If you want an optional pre- or post-fix for a value which is only shown if the value is not empty, you can use the syntax {[Prefix]sg_field[suffix]}. The template {[Start: ]start_date} {[End: ]end_date} will render Start: 12 July 2009 End: 14 July 2012 if both values are populated but Start: 12 July 2009 if end date isn’t set.        You can define fallbacks in the case some values are not set. For ShotGrid Versions, the artist fields takes precedence over the created_by field in order to support a workflow where a producer submits versions on behalf of an artist. In this case, the Version will be created by the producer but the artist field will be set to the artist. This, however, is not always the case - in some cases, artist is left blank in pipelines where artists submit their own work. When displaying versions, it is therefore useful to be able to check the artist field first, and in case this isn’t set, fall back on the created_by field. This is done using the {field1|field2} syntax, for example: Created By: {artist|created_by}. You can combine this with optional fields too, e.g. {[Created By: ]artist|created_by}  This hook contains the following methods:Controlling items appearing in listsThe get_list_item_definition() method returns a dictionary that controls the appearance of items in the various listings, given a ShotGrid entity type. It returns a dictionary with the keys top_left, top_right and body, for example:{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;} Controlling the top detail areaThe get_main_view_definition() method returns a dictionary with the keys title and body given a ShotGrid entity type. These values controls the appearance of an object in the detail area, for example:{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;} Controlling the fields shown in the Info tabThe get_all_fields() methods returns a list of fields to display for a given entity when this is rendered in the Info tab.Configuring ActionsActions are little snippets of code that operate on a piece of ShotGrid data. Examples include:  An action that launches RV for a given ShotGrid Version  An action that allows a user to assign herself to a given Task  An action that loads a ShotGrid publish into Maya as a Maya reference.The actual payload of an action is defined in an action hook. Once you have defined the action logic, you can then map that action to ShotGrid objects in the app configuration. These action mappings may for example look like this:action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}In the above example, we use the actions reference, import, texture_node, assign_task and play_in_rv. We then map the actions to various ShotGrid objects and conditions. For example, we are requesting the import action to appear for all publishes of type Maya Scene.When an object is loaded into the Panel, the action configuration above is read in and analyzed. A list of suitable actions for the current object is determined and the generate_actions() hook method will be executed. ShotGrid data for the given entity will be passed to the hook at this point so that the hook code can determine if the action can be run for this particular ShotGrid object. This is a way to allow each hook to run a check prior to being displayed. For example, the play_in_rv hook may only be relevant in the case there is media available locally - the action mappings set up in the configuration tells the panel which actions to enable for a given ShotGrid entity but they may not all be displayed because the generate_actions() method may determine that they are not suitable for the given object.The actions returned from the generate_actions() method will be displayed on the actions menu and when a user clicks on it, the execute_action() hook method is called to run the action.For each application that the panel supports, there is an actions hook which implements suitable actions. For example, with something like Maya, the default hook will implement reference, import and texture_node actions, each carrying out specific Maya commands to bring publishes into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.The panel uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app’s hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/panel/maya_actions.py. This will tell Toolkit to use a hook called hooks/panel/maya_actions.py in your configuration folder.For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.LINKBOX_DOC:5#The%20hook%20data%20type:Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks like this:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular object.        The data returned from this hook will be used to populate the         actions menu.            The mapping between ShotGrid objects and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the app        has already established *which* actions are appropriate for this object.                This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.                Because you are operating on a particular object, you may tailor the output         (caption, tooltip etc) to contain custom information suitable for this publish.                The ui_area parameter is a string and indicates where the publish is to be shown.                 - If it will be shown in the main browsing area, &quot;main&quot; is passed.         - If it will be shown in the details area, &quot;details&quot; is passed.                        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption, group and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;group&quot;: &quot;Pipeline Utils&quot;,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.                :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}By deriving from the hook as shown above, the custom hook code only need to contain the actual addedbusiness logic which makes it easier to maintain and update.",
    "url": "/c0b0ce05/",
    "relUrl": "/c0b0ce05/"
  },
  "123": {
    "id": "123",
    "title": "Snapshot",
    "content": "Snapshot",
    "url": "/233f8961/",
    "relUrl": "/233f8961/"
  },
  "124": {
    "id": "124",
    "title": "Workfiles",
    "content": "WorkfilesFile Open dialogNavigating your work areasThe main dialog is split in two halves. On the left hand side, there is a series of tabs. The first tab is called “My Tasks” and will display all the tasks that are assigned to the current user. It is very reminiscent of the “My Tasks” page on the ShotGrid website.Alternatively, the user can also browse for a ShotGrid entity using the entities tabs. By default, the workfiles application allows to browse for any tasks associated on shots or assets by looking at the respective tab.The set of tabs is entirely configurable through the entities settings in the environment files.You can disable/enable this dialog by setting the show_file_open: true/false in the app settings.Finding filesOn the right hand-side you will see the working files and publishes associated with the selection from the left hand-side. Working files and publishes can be viewed together or separately using the tabs “All”, “Working” and “Publishes”.Accessing previous versionsThere are two ways to access previous versions. First, the user can click on the “All versions” box at the top of the browser, which will uncollapse the versions and list them all individually in the browser. Another option is to right-click on a file, which will allow you to access the last 10 versions.User sandboxesIf your pipeline configuration uses user sandboxes, only the files for the current user will be seen by default. If the user wants to see the files from other user’s sandboxes, a button at the top will allow to pick which sandboxes to show files from.Narrowing resultsYou can narrow results in the any of the views by typing text. The search will match any item’s name.File Save dialogBy default, the “File Save” dialog allows the user to save a file in the current context. The user will be prompted for a scene name, version number and an optional file extension, if available and the “Save” button will be greyed out. Only once the application has confirmed the next available version number for a scene name will the Save button at the bottom right be enabled.You can disable/enable this dialog by setting the show_file_save: true/false in the app settings.Saving in a different contextIn order to save a file in a different context, a user can click on the expand button at the top-left of the dialog which will expand the “File Save” dialog and allow to pick another context to save into.Adding the file extension dropdownWith the new file save dialog, it is possible to pick the extension of the file being saved. In order to enable this, you need to tweak your pipeline configuration’s templates.yml file. First, a token needs to be defined in the token list inside templates.yml.maya_extension:    type: str    choices:        ma: Maya Ascii (.ma)        mb: Maya Binary (.mb)    default: ma    alias: extensionmaya_extension is the token’s name. choices is a dictionary of file types that will be displayed in the dropdown. The keys (ma and mb) are the possible values that this template token can have. The values (Maya Ascii (.ma) and Maya Binary (.mb)) are UI friendly descriptions that can be used by a Toolkit application. The alias is an hint that is required by the workfiles application. It tells the application that this token is an extension and should be displayed in the dropdown widget.Then, this token can be added to any Maya specific template.maya_shot_work:    definition: '@shot_root/work/maya/{name}.v{version}.{maya_extension}'    root_name: 'primary'Context Change dialogThe context change dialog is similar to the open dialog except that it doesn’t have a the right hand side for file browsing. You can select a task or entity and change your current engine context by pressing press the change context button.You can disable/enable this dialog by setting the show_change_context: true/false in the app settings.Step filteringWhen retrieving Tasks, and if step is included in the hierarchy, the amount of data retrieved from ShotGrid can be reduced with Pipeline Step filtering: only Tasks linked to the selected list of Steps will be retrieved.The list of Steps displayed in a tab is controlled with the step_filter_on setting. If not set, all existing Pipeline Steps are displayed.The example below defines two tabs, respectively displaying Tasks for Assets and Shots:  - caption: Assets Tasks    entity_type: Task    step_filter_on: Asset    filters:    - [entity, type_is, Asset]    hierarchy: [entity.Asset.sg_asset_type, entity, step, content]  - caption: Shots Tasks    entity_type: Task    step_filter_on: Shot    filters:    - [entity, type_is, Shot]    hierarchy: [entity.Shot.sg_sequence, entity, step, content]Deferred queriesFor better performances, building the Entities tree can be broken into two step queries:  A first query is used to retrieve records from ShotGrid and populate the top of the tree.  A second query is used to retrieve children as the user expand the tree.With the following settings, Assets and Shots would be retrieved from ShotGrid when the app is started. And then Tasks linked to a particular Asset or Shot would only be retrieved when this Asset or Shot is selected or expanded in the tree view.  entities:  - caption: Assets    entity_type: Asset    hierarchy: [sg_asset_type, code]    filters:    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]  - caption: Shots    entity_type: Shot    filters:    hierarchy: [sg_sequence, code]    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]",
    "url": "/9a736ee3/",
    "relUrl": "/9a736ee3/"
  },
  "125": {
    "id": "125",
    "title": "Nuke Quickreview",
    "content": "Nuke QuickreviewThe Quickreview app makes it easy to submit Nuke renders for review in ShotGrid. A Version in ShotGrid will be created with each quickreview submission. It appears as a node in Nuke, located on the ShotGrid Node menu. Simply create a new node, attach it to your Nuke network, double click it and click the Upload button.You get presented with the following UI, allowing you control how your Version is created in ShotGrid:The following items can be controlled:  The version name is pre-populated based on the currently loaded nuke script and can be adjusted if needed.  The entity link and task associated with the version is based on the current context and can be adjusted.  The frame range to be submitted can be adjusted.  The created Version can be added to a playlist. A dropdown with recent playlist are being displayed.Once you press the Upload button, a quicktime will be generated in nuke and then uploaded to ShotGrid. Once uploaded, the following screen will be shown, allowing you to either show the Version in the Built-in ShotGrid Panel in Nuke or in the web overlay player.Burnins and slateBy default, the app will generate a Quicktime with a slate and burn-ins:CustomizationMost aspects of the review submission can be adjusted using hooks. Documentation can be found here.",
    "url": "/40da6878/",
    "relUrl": "/40da6878/"
  },
  "126": {
    "id": "126",
    "title": "Nuke Write Node",
    "content": "Nuke Write NodeThe Nuke Write Node App provides a custom ShotGrid Write node which makes it easy to standardise the location where images are rendered to.  It can be configured for each environment.  In addition to the path, the configuration will also determine the render format to be used.General UseIn order to use the ShotGrid Write Node, save your script as a Toolkit work file first and then create a new node via the Nuke menu. This will create a node which looks similar to a normal write node:Rather than entering a path by hand, you just specify an output name and Toolkit will then compute the rest of the path automatically. You can see the computed path in the UI and open up the location on disk by clicking the Show in File System button. The location where the renders are written to depends on the Toolkit configuration.The renders will be versioned and the version number will always follow the current nuke script version which will be incremented automatically when you publish using Multi Publish.Resetting the render pathThe Write Node will cache the current path so that it is still valid if the file is opened outside a Toolkit Work Area.  Occasionally, this can mean that the path becomes out of sync and ‘locked’.  If the render path is locked then renders created with this Write Node cannot be published.To reset a render path, either version-up the scene using the Work-files app’s ‘Version Up Scene’ command or select the Write node individually and in the properties, click Reset Path:Adding Another Write Node ProfileThe ShotGrid Write Node wraps Nuke’s built-in write node, so any format supported by Nuke can be used with the app and additional nodes can be added via configuration.  The simplest way to start is to set up a simple Nuke write node with the parameters you want. For the example, let’s imagine you are doing 16-bit tifs with LZW compression. If you look at your Nuke script in a text editor, the write node will look something like this:Write {    file /Users/ryanmayeda/Desktop/test.%04d.tif    file_type tiff    datatype &quot;16 bit&quot;    compression LZW    checkHashOnRead false    name Write1    xpos -145    ypos -61}The text will tell you what the parameter names and values you need are. In this case it’s datatype and compression. Next, go into your environment configuration (for example: /path/to/pipeline/config/env/shot_step.yml) and find the area where the tk-nuke-writenode app is configured.  Add another Write Node, with these two parameters in the settings:tk-nuke-writenode:  location: {name: tk-nuke-writenode, type: app_store, version: v0.1.6}  template_script_work: nuke_shot_work  ...  write_nodes:  - file_type: exr    ...  - file_type: dpx    ...  - file_type: tiff    name: Mono Tif    publish_template: nuke_shot_render_pub_mono_tif    render_template: nuke_shot_render_mono_tif    proxy_publish_template: null    proxy_render_template: null    settings: {datatype: 16 bit, compression: LZW}    tank_type: Rendered Image    tile_color: []    promote_write_knobs: []The updated configuration will then result in the additional ShotGrid Write Node appearing in Nuke:Note: Be sure to add any new templates (e.g. nuke_shot_render_mono_tif) to your templates.yml file which can be found in your project’s configuration (&amp;lt;configuration root&amp;gt;/config/core/templates.yml).Another example, showing how to add a ShotGrid Write Node that outputs to JPEG with 0.5 compression and a 4:2:2 sub-sampling is shown below. This profile also makes use of the “promote_write_knobs” option to promote the jpeg quality knob to the gizmo’s user interface. This allows the profile to set the default value for quality, but also provide the user the slider to alter that setting themselves:tk-nuke-writenode:  write_nodes:    - file_type: jpeg      name: Compressed JPEG      publish_template: nuke_shot_render_pub_jpeg      render_template: nuke_shot_render_jpeg      proxy_publish_template: null      proxy_render_template: null      settings: {_jpeg_quality: 0.5, _jpeg_sub_sampling: &quot;4:2:2&quot;}      tank_type: Rendered Image      tile_color: []      promote_write_knobs: [_jpeg_quality]Promoting Write KnobsAs shown in the profile example above, knobs from the encapsulated write node can be promoted to become visible in the ShotGrid Write Node’s properties panel. The promoted write knobs are defined as part of a profile and are identified by knob name. Multiple knobs may be promoted.Render Farm IntegrationIt’s common for studios to use a render farm that runs job management tools such as Deadline,  which typically launch Nuke directly when rendering. Because these tools do not launch Nuke in a ShotGrid-aware way (e.g., via Desktop or the tank command), the ShotGrid write node does not have the information it needs to run. We offer a couple options to get around this limitation.Convert ShotGrid write nodes to standard Nuke write nodesA simple solution is to convert the ShotGrid write nodes to regular Nuke write nodes before sending the script to be rendered. There are two options 1. you can enable and use the convert menu options, 2. you can use the API convert methods on the app.Enabling the convert menu optionsThere is a configuration option called show_convert_actions that can be added to the app’s settings in the environment yml files. When you add the setting show_convert_actions: True, the Convert SG Write Nodes to Write Nodes… and Convert Write Nodes back to SG format… menu options become available.However if you have any ShotGrid Write node profiles defined that promote write knobs, then these menu options will be hidden even if the show_convert_actions is set to True. This is because at present the convert back functionality does not support promoted knobs.Using the API to ConvertThere is a convert_to_write_nodes() method that performs this conversion available on the tk-nuke-writenode app.To convert all ShotGrid write nodes in a script to regular Nuke write nodes, run the following code inside Nuke:import sgtkeng = sgtk.platform.current_engine()app = eng.apps[&quot;tk-nuke-writenode&quot;]if app:    app.convert_to_write_nodes() This will remove the ShotGrid write nodes from the scene, so our suggested workflow is that you make a copy of the script to be rendered, perform the conversions on the copy, and submit the copy to the farm. The scene no longer has any Toolkit references and thus Toolkit is not required when the nuke script opened on the render farm.Note: There is a corresponding convert_from_write_nodes() method available, but to ensure data integrity, we recommend that it only be used for debugging and not as part of your pipeline.Bootstrap the ShotGrid Pipeline Toolkit engine using init.pyNuke will run any init.py scripts found in its plugin path. This option consists of adding code to init.py that will perform a minimal bootstrap of the tk-nuke engine, so that ShotGrid write nodes behave as expected on the render farm.There are a few steps to this workflow: First, a “pre-flight” submission script that runs in a ShotGrid-aware Nuke session gets data that will be used to set the environment for your farm job. Next, additional environment variables used to authenticate the ShotGrid session on the render farm are set by render farm administrators. Finally, an init.py with the ShotGrid bootstrap code is placed in a location where the Nuke session on the render farm will detect and run it, bootstrapping the tk-nuke engine within the session, and allowing the ShotGrid write nodes to function properly.1. Pre-flight submission scriptThis approach assumes that artists are submitting farm jobs within a ShotGrid-aware session of Nuke. At submission time, the following code should run. It pulls environment information like Toolkit context, Pipeline Configuration URI, Toolkit Core API location, etc. from the current Nuke session to populate a dictionary that will be passed to the render job, where it will be used to set environment variables.# Populating environment variables from running Nuke:# http://developer.shotgridsoftware.com/tk-core/platform.html#sgtk.platform.create_engine_launchercurrent_engine = sgtk.platform.current_engine()launcher = sgtk.platform.create_engine_launcher(     current_engine.sgtk,     current_engine.context,     current_engine.name)# Get a dictionary with the following keys:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234environment = launcher.get_standard_plugin_environment()# Get the current pipeline config descriptorenvironment[&quot;SHOTGUN_CONFIG_URI&quot;] = os.path.join(current_engine.sgtk.configuration_descriptor.get_uri(),&quot;config&quot;)# Get the current tk-core installation pathenvironment[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;] = sgtk.get_sgtk_module_path()Once you’ve gathered this information, you can pass it to your render submission tool. This process will vary depending on the render farm management system you’re using. Consult your farm management system documentation for more information on how to write render submission scripts.2. ShotGrid authenticationThe bootstrap API’s ToolkitManager requires a script user in order to initialize. In our example, we’re assuming that your site name, script user, and script key exist as environment variables on the farm machine. Typically this is managed by the render farm administrator. Here are the environment variable names our code is expecting, with sample values:SHOTGUN_SITE = “https://mysitename.shotgunstudio.com”SHOTGUN_FARM_SCRIPT_USER = “sg_api_user”SHOTGUN_FARM_SCRIPT_KEY = “xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”For more information on authentication, see our developer documentation.A note on securing your script user: It’s good practice to lock down the script user you use on the farm so that it doesn’t have admin-level permissions. You can learn more about API user permissions here.3. The init.py scriptAt this point, Toolkit environment data is being passed from the render submission tool, and authentication data is in environment variables on the render farm machine. The final piece to bootstrapping Toolkit within your render job is to place the following example init.py code in Nuke’s plugin path, so that Nuke will launch it at startup time. (See the Foundry’s documentation on startup scripts for more details.)# This script shows how a Toolkit as a plugin approach could be used to bootstrap# Toolkit in Nuke on the render farm.# http://developer.shotgridsoftware.com/tk-core/bootstrap.html#bootstrapping-toolkitimport sysimport os# If your render nodes can access the same tk-core install location as# artist workstations, retrieve its path from the environment and ensure# it is in the PYTHONPATHTK_CORE_PATH = os.environ[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;]if TK_CORE_PATH not in sys.path:    sys.path.append(TK_CORE_PATH)# If your render nodes don’t have access to the Toolkit Core API in the same filesystem location as artist workstations, you have to make sure that it is available in the PYTHONPATH, so that render nodes can import it. An easy way # to install tk-core in a centralized location is with pip. You can read more # about it here:# http://developer.shotgridsoftware.com/tk-core/bootstrap.html#installing-the-sgtk-module-using-pipimport sgtk# Authenticate using a pre-defined script user.sa = sgtk.authentication.ShotgunAuthenticator()# Here we retrieve credentials from environment variables, assuming a script user# will be used when rendering. This should be typically be handled by your render# farm administrators.SG_SITE_URL = os.environ[&quot;SHOTGUN_SITE&quot;]SG_SCRIPT_USER = os.environ[&quot;SHOTGUN_FARM_SCRIPT_USER&quot;]SG_SCRIPT_KEY = os.environ[&quot;SHOTGUN_FARM_SCRIPT_KEY&quot;]user = sa.create_script_user(    api_script=SG_SCRIPT_USER,    api_key=SG_SCRIPT_KEY,    host=SG_SITE_URL)# Start up a Toolkit Manager with our script usermgr = sgtk.bootstrap.ToolkitManager(sg_user=user)# Set the base pipeline configuration from the environment variable:mgr.base_configuration = os.environ[&quot;SHOTGUN_CONFIG_URI&quot;]# Disable ShotGrid lookup to ensure that we are getting the Pipeline # Configuration defined in SHOTGUN_CONFIG_URI, and not a dev or override# Pipeline Configuration defined in ShotGrid.mgr.do_shotgun_config_lookup = False# Set a plugin id to indicate to the bootstrap that we are starting# up a standard Nuke integrationmgr.plugin_id = &quot;basic.nuke&quot;# Retrieve the Toolkit context from environment variables:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234sg_entity = mgr.get_entity_from_environment()# Now start up the Nuke engine for a given ShotGrid Entitynuke_engine = mgr.bootstrap_engine(&quot;tk-nuke&quot;, entity=sg_entity)You may need to extend this if your configuration is more complex than this example or if you are passing a Python script to the command line using the -t flag instead of a nuke (.nk) script.Deadline-specific stepsDeadline can copy Nuke scripts to a temporary location when rendering. This will cause problems with Toolkit as the files will no longer be in a disk location that it recognizes. To disable this behavior and load the scripts from their original location:  In Deadline, navigate to Tools &amp;gt; Configure Plugin (In the super user mode)  Disable the ‘Enable Path Mapping’ optionTechnical DetailsThe following API methods are available on the App:get_write_nodes()Return a list of all ShotGrid Write Nodes in the current scene.list app.get_write_nodes()Parameters &amp;amp; Return Value  Returns: list - a list of Toolkit Write nodes found in the sceneExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()get_node_name()Return the name of the specified Write Node.string get_node_name(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the name of the node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_name(nodes[0])get_node_profile_name()Get the name of the configuration profile used by the specified Write node.string get_node_profile_name(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the profile name for this Write Node as defined by the configurationExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_profile_name(nodes[0])get_node_render_path()Get the path that the specified Write node will render images to.string get_node_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the render path for this nodeExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_path(nodes[0]) get_node_render_files()Get a list of all image files that have been rendered for the specified Write Node.list get_node_render_files(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: list - a list of the image files rendered by this Write node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_files(nodes[0])get_node_render_template()Get the template that determines where rendered images will be written to for the specified Write Node as defined in the configuration.template get_node_render_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the render template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_template(nodes[0]) get_node_publish_template()Get the template that determines where rendered images will be published to for the specified Write Node as defined in the configuration.template get_node_publish_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the publish template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_publish_template(nodes[0]) get_node_proxy_render_path()Get the path that the specified Write node will render proxy images to.string get_node_proxy_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the proxy render path for this nodeExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_path(nodes[0]) get_node_proxy_render_files()Get a list of all proxy image files that have been rendered for the specified Write Node.list get_node_proxy_render_files(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: list - a list of the proxy image files rendered by this Write node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_files(nodes[0])get_node_proxy_render_template()Get the template that determines where proxy rendered images will be written to for the specified Write Node as defined in the configuration.If there is no proxy render template configured for the specified node then this will return the regular render template instead.template get_node_proxy_render_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the proxy render template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_template(nodes[0]) get_node_proxy_publish_template()Get the template that determines where proxy rendered images will be published to for the specified Write Node as defined in the configuration.If there is no proxy publish template configured for the specified node then this will return the regular publish template instead.template get_node_proxy_publish_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the proxy publish template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_publish_template(nodes[0]) get_node_published_file_type()Get the Published File Type to be used when Published files are created for images rendered by the specified Write node as defined in the configuration.string get_node_published_file_type(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the Published File Type this node is configured to useExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_published_file_type(nodes[0]) generate_node_thumbnail()Generate a thumbnail for the specified Write Node.  This will render a frame from the middle of the sequence with a maximum size of 800x800px to a temp file (.png).  It is the responsibility of the caller to clean up this file when it is no longer needed.string generate_node_thumbnail(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the path to the rendered thumbnail image on diskExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.generate_node_thumbnail(nodes[0]) reset_node_render_path()Reset the render path for the specified Write Node to match the current script.None reset_node_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: None - no value is returnedExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.reset_node_render_path(nodes[0]) is_node_render_path_locked()Determine if the render path for the specified Write node is locked or not.bool is_node_render_path_locked(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: bool - True if the render path is locked, otherwise FalseExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.is_node_render_path_locked(nodes[0]) convert_to_write_nodes()Convert all ShotGrid write nodes found in the current Script to regular Nuke Write nodes.  Additional toolkit information will be stored on user knobs named ‘tk_*’None convert_to_write_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_to_write_nodes() convert_from_write_nodes()Convert all regular Nuke Write nodes that have previously been converted from ShotGrid Write nodes, back into ShotGrid Write nodes.None convert_from_write_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_from_write_nodes() process_placeholder_nodes()Convert any placeholder nodes into full ShotGrid Write Nodes.  This is primarily used to convert placeholder nodes created by the Hiero Toolkit script exporter when a script is first opened in Nuke.None process_placeholder_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.process_placeholder_nodes() ",
    "url": "/09168e73/",
    "relUrl": "/09168e73/"
  },
  "127": {
    "id": "127",
    "title": "Nuke",
    "content": "NukeThe ShotGrid engine for Nuke contains a standard platform for integrating ShotGrid Apps into Nuke, Nuke Studio, and Hiero. It is light weight and straight forward and adds a bunch of new things to Nuke.It creates a ShotGrid Menu in Nuke on which various items are displayed:It creates a ShotGrid Node Menu in Nuke on which various items are displayed:It adds ShotGrid shortcuts to the file dialogs which makes it easy to jump to various file system locations:You can add your own shortcuts based on template paths in your current environment with the favourite_directories setting. The setting expects a list of dictionaries, with each item in the list representing a new favourite directory. Here is an example of the format you would use: (the icon can also be left unspecified by providing “” as the value.)  favourite_directories:  - display_name: &quot;Shot Publish Path&quot;    template_directory: &quot;shot_publish_area_nuke&quot;    icon: &quot;icons/custom_publish_icon.png&quot;  - display_name: &quot;Shot Work Path&quot;    template_directory: &quot;shot_work_area_nuke&quot;    icon: &quot;icons/custom_work_icon.png&quot;The “ShotGrid Current Project” favourite is added automatically for each root defined. You can customize the name with the project_favourite_name setting, or disable these favourites by setting the value to an empty string ''Note: There is currently a bug in Nuke 8.0 running specifically on CentOS 6.5 that causes Nuke to crash when running Toolkit. Other versions of CentOS are unaffected. The Foundry is aware of this issue (bug 43766). If you are running into this, please contact us so we can try and help you workaround it until it is resolved in a future update of Nuke.Information for App DevelopersContext TrackingThe ShotGrid engine for Nuke will switch context automatically when files are loaded. Whenever a file is loaded, the engine will look at the file, try and resolve a context from it.Apps with custom gizmosThe ShotGrid engine for Nuke makes it easy to handle custom gizmos. If you are writing an app which uses custom gizmos, you can just drop them into a folder called gizmos and the engine will automatically add that location to the nuke path:You can then easily access your gizmo via the create node functionality:  nuke.createNode(&quot;WriteTank&quot;)                    Warning: Please note that while the use of gizmos may be convenient, it is typically NOT the right solution if you want to create nodes that persist in a scene. The reason for this is because as soon as you have put a gizmo in the scene, you have introduced a dependency between that scene and the gizmo code. Not only will you need to load the ShotGrid Toolkit every time you load the scene, but you also need to carefully manage your code so that any updates to the code does not break old gizmos being used in scenes.    Apps Creating NodesApps that create custom nuke nodes need to be carefully crafted. We recommend not using gizmos since these require a dependency between the scene and the gizmo code. Instead, save your custom nodes as a nuke file and import them into the scene:    group_node_script = os.path.join(self.disk_location, &quot;resources&quot;, &quot;my_group_node.nk&quot;)    group_node = nuke.nodePaste(group_node_script)Any code calling the node from within the app can just use the instance returned.Any code needing to call the app from inside the group should do so carefully so that the code is backwards compatible. We recommend the following approach:At app startup, register app handle as part of the nuke namespace:    def init_app(self):        nuke.tk_nuke_nameofmyapp = selfIf you for example have a button on your group node and want to call some ShotGrid app code, try to gracefully fail if the ShotGrid Toolkit cannot be found. The below code is code that is associated with a python button knob that belongs to the group node that the app can create:# have to gracefully support the case when # sgtk is not in the system at all!import nuketry:  app = nuke.tk_nuke_nameofmyapp  app.do_something_v1(nuke.thisNode())except:  nuke.warning(&quot;Could not do XYZ! Most likely Sgtk is not currently active.&quot;)If you make changes to the app behaviour, just keep versioning up the version number on the app callback and that way your app code can support both the new and the old behaviour.Using the ShotGrid Engine for Nuke within HieroThe ShotGrid engine for Nuke is also used for ShotGrid-aware integrations running within Hiero.It allows you to place ShotGrid App actions in several places in the application, both in a specific ShotGrid menu on the main menu bar and in the various right click context menus that you find in the different Hiero panels.How to Configure Hiero MenusBecause Hiero has several different menus, there are more options to configure where menu items go than in Maya or Nuke, for example. The ShotGrid engine for Nuke’s Hiero workflow configuration may look like this:  tk-hiero:    location: {name: tk-nuke, type: app_store, version: v0.6.9}    debug_logging: false    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    bin_context_menu:    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Version up Current Scene...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot History...&quot;, requires_selection: true}    - {app_instance: tk-multi-publish, keep_in_menu: false, name: &quot;Publish Project...&quot;, requires_selection: true}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Shotgun File Manager...}Most engines have a menu_favourites option, a list where you can specify “shortcuts” which are put on the main ShotGrid menu. In addition to this, the Hiero-specific configuration has three special sections:  timeline_context_menu represents the menu you get when you right click on a clip in thetime line editor.  spreadsheet_context_menu represents the menu you get when you right click on a selection ofitems in the spreadsheet editor.  bin_context_menu represents the menu you get when you right click on a selection in of itemsin the bin editor, where you see all the different projects and media.In order to add items to these menus, just make sure that the name field you define in the config matches what the App is displaying on its menus.Apps which require the concept of a current sceneSome Toolkit Apps requires a notion of a default scene or default project. For example, the snapshot app knows how to snapshot the current scene. However, unlike Maya or Nuke, Hiero does not have a concept of a current scene. Several projects can be opened in Hiero at the same time. Therefore, you often need to add special logic in your hooks to help an app (like the snapshot app) to find out which project is being clicked on. We show how this works in the following doc sections.Information for App DevelopersBecause Hiero does not have the notion of a current project, we have added more powerful tools so that Apps can easily find out what is being clicked on inside of Hiero. Therefore, two methods have been added to the ShotGrid engine for Hiero:get_menu_selection()Returns the list of Hiero objects selected in the most recent menu click.This list may contain items of various types. To see exactly what is beingreturned by which methods, turn on debug logging - this will print out detailsof what is going on.Examples of objects that are being returned are:  Selecting a project in the bin view: hiero.core.Bin  Selecting an item in a bin view: hiero.core.BinItem  Selecting a track: hiero.core.TrackItemlist engine_object.get_menu_selection()Parameters &amp;amp; Return Value  Returns: List of Hiero ObjectsExampleGet the objects selected in the most recent click,ensure that a single object was selected and that thisobject is a valid Hiero project. This can be useful for example if you want to triggersave, load or publish operations for a project in Hiero.# get the menu selection from the engineselection = engine_obj.get_menu_selection()if len(selection) != 1:    raise TankError(&quot;Please select a single Project!&quot;)if not isinstance(selection[0] , hiero.core.Bin):    raise TankError(&quot;Please select a Hiero Project!&quot;)project = selection[0].project()if project is None:    # apparently bins can be without projects (child bins I think)    raise TankError(&quot;Please select a Hiero Project!&quot;)HieroEngine.get_menu_category()Returns the UI area where the last menu click took place. This command is lesslikely to be used - you may need it in cases where you have an app command that you wantto behave differently depending on which menu it was called from.area_enum engine_object.get_menu_category()Parameters &amp;amp; Return ValueReturns one of the following constants:  HieroEngine.HIERO_BIN_AREA  HieroEngine.HIERO_SPREADSHEET_AREA  HieroEngine.HIERO_TIMELINE_AREA  None for unknown or undefinedHow to configure your hooks to work with HieroMulti Apps configured for Hiero will typically need to find out which project was being clicked on. For example, the tk-multi-workfiles App needs to do a “ShotGrid Save As” of a project. We therefore add the Tank Save As command to the bin menu in Hiero so that a user can right click a project in the bin view and select the Save As option.The engine configuration would look like this:bin_context_menu:- {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}Now, in the app itself, each engine needs to configure a hook which handles scene events such assave and load. For an application like Maya or Nuke, this is normally just doing a save, a load etc.But for Hiero, we need to start by finding out which project was actually clicked. The hook codein our example above would look like this:class SceneOperation(Hook):    &quot;&quot;&quot;    Hook called to perform an operation with the    current scene    &quot;&quot;&quot;    def execute(self, operation, file_path, context, **kwargs):        &quot;&quot;&quot;        Main hook entry point        :operation: String                    Scene operation to perform        :file_path: String                    File path to use if the operation                    requires it (e.g. open)        :context:   Context                    The context the file operation is being                    performed in.        :returns:   Depends on operation:                    'current_path' - Return the current scene                                     file path as a String                    'reset'        - True if scene was reset to an empty                                     state, otherwise False                    all others     - None        &quot;&quot;&quot;        if operation == &quot;current_path&quot;:            # return the current script path            project = self._get_current_project()            curr_path = project.path().replace(&quot;/&quot;, os.path.sep)            return curr_path        elif operation == &quot;open&quot;:            # open the specified script            hiero.core.openProject(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;save&quot;:            # save the current script:            project = self._get_current_project()            project.save()        elif operation == &quot;save_as&quot;:            project = self._get_current_project()            project.saveAs(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;reset&quot;:            # do nothing and indicate scene was reset to empty            return True        elif operation == &quot;prepare_new&quot;:            # add a new project to hiero            hiero.core.newProject()    def _get_current_project(self):        &quot;&quot;&quot;        Returns the current project based on where in the UI the user clicked        &quot;&quot;&quot;        # get the menu selection from the engine        selection = self.parent.engine.get_menu_selection()        if len(selection) != 1:            raise TankError(&quot;Please select a single Project!&quot;)        if not isinstance(selection[0] , hiero.core.Bin):            raise TankError(&quot;Please select a Hiero Project!&quot;)        project = selection[0].project()        if project is None:            # apparently bins can be without projects (child bins I think)            raise TankError(&quot;Please select a Hiero Project!&quot;)        return projectUsing debug logging to see menu eventsIf you want to see which objects are returned by Hiero when a certain selection is clicked on,just turn on the engine debug mode. In the script editor you get a summary of the objectsthat are selected with each click:",
    "url": "/4dc252e5/",
    "relUrl": "/4dc252e5/"
  },
  "128": {
    "id": "128",
    "title": "Photoshop",
    "content": "PhotoshopThe ShotGrid engine for Photoshop CC provides a platform for integrating ShotGrid into your Photoshop CC workflow. It consists of a standard ShotGrid Pipeline Toolkit engine and relies on the tk-framework-adobe (CEP).Once enabled, a ShotGrid panel becomes available in Photoshop CC. It displays information about the current ShotGrid context as well as the commands that are registered for the apps installed in that context.Interface OverviewThe ShotGrid extension panel uses the same color palette and basic layout as native Photoshop CC panels. It is comprised of five components:  Context Header - Thumbnail and fields for the current context.  Favorites Shelf - Designed to show the most commonly-used apps for the current context.  Command List - All non-favorited commands for the current context.  Context Menu - Additional context-related commands and debugging tools.  Logging Console - A console overlay that displays logging output for debugging.InstallationInstallation of the ShotGrid Engine for Photoshop CC follows the same protocol as the other ShotGrid integrations. For information on installing engines and apps, see the Administering Toolkit article. In addition, you can reference the default toolkit config as an example of how to configure the integration.Enabling the extensionOnce the extension is installed, it will need to be launched via the extensions menu in Photoshop CC.This will only need to be done once and the ShotGrid extension panel can remain in the Photoshop CC layout without having to be enabled on subsequent launches.Once enabled, and on future launches, the extension panel will display a loading screen while the ShotGrid integration is bootstrapping.This screen typically displays for a few seconds before the current context is determined and the commands are displayed.Interface componentsThe following sections outline the components of the ShotGrid Photoshop CC integration.Context headerThe context header is a customizable area which can display information about the current ShotGrid context.The context is determined by the currently-active document. Once the context is determined by the engine, the header will update to display the context’s thumbnail field detail. The field information is controlled by a hook. For information on how to customize the field display, see the Context Fields Display Hook section below.It should also be noted that since Photoshop CC is a multi-document interface, the context, and therefore the ShotGrid extension, will update as you change the active document. It is important that artists understand this behavior, especially when working in multiple ShotGrid contexts simultaneously.Favorites shelfThe favorites shelf is similar to the menu favorites available in other ShotGrid DCC integrations such as Maya and Houdini. This section of the interface makes the most commonly used Toolkit apps readily available and easy to find just under the context header.The shelf displays the favorited commands as buttons that, when moused over, transition from grayscale to color and display their name in the label at the top. Tooltips for the buttons will show by hovering the mouse above them.Clicking one of the buttons will trigger the callback for the registered command to execute.For details on how to specify command favorites, see the Shelf Favorites section below.Command listThe command list shows the other “regular” commands that are registered for the current context.Typically, apps installed within a pipeline configuration will register one or more commands that are displayed here. If the commands are not identified as favorites, and are not identified as context-menu commands, they will display here.The command list buttons behave in a manner similar to those in the favorites shelf. The only real difference is that they display as a list with the full name to the right of their icon.Context menuAny commands registered as context menu commands will show in the ShotGrid extension panel’s context menu.Like the other command areas, these commands will change along with the context. Commands such as Jump to ShotGrid and Jump to Filesystem will always be available here.Logging consoleThe logging console shows all of the logging output from both the CEP Javascript interpreter and Toolkit’s Python process.If there are any issues with the extension that require support, the logging console output is extremely useful for helping the ShotGrid support team debug the problem.Configuration and technical detailsThe following sections outline some of the more technical aspects of the integration to help configure the integration to the specific needs of your studio pipeline.PySideThe ShotGrid engine for Photoshop CC relies on PySide. Please see the official instructions for Installing Pyside.CEP extensionThe extension itself is bundled with the engine and the engine handles installation automatically on the first launch of Photoshop CC. The extension is installed on the artist’s local machine in the standard, OS-specific CEP extension directories:# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Each time Photoshop CC is launched, the engine bootstrap code will check the version of the extension that is bundled with the engine against the version that is installed on the machine. This means that after an engine update, assuming a new version of the extension came with it, the installed extension will be automatically updated to the newly-bundled version.Configuring favoritesThe Favorites Shelf can be configured to display any of the registered commands for your installed apps. To do this, simply add the shelf_favorites setting to the tk-photoshopcc section of your environment configuration. Here’s an example:shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}The value of the setting is a list of dictionaries identifying a registered command provided by one of the installed apps in the configuration. The app_instance key identifies a particular installed app and the name key matches the command’s display name registered by that app. In the example above, you can see four favorited commands: the file open and save dialogs from the tk-multi-workfiles2 app as well as the standard Toolkit publish and snapshot dialogs. These four commands will now show in the favorites shelf.Context fields display hookThe engine comes with a hook to control the fields displayed in the Context Header section of the panel. There are two methods in the hook that can be overridden to customize what is displayed.The first method is the get_entity_fields() method. This method accepts an entity type representing the current ShotGrid context. The expected return value is a list of fields for that entity that should be queried for display. The engine itself handles querying the data asynchronously.Once the data has been queried from ShotGrid, the second method in the hook is called. This method, get_context_html(), receives the context entity dictionary populated with the queried fields specified by the get_entity_fields() method. The expected return value is a string containing formatted HTML to display the queried entity fields.The default hook implementation is a good reference as to what is required by these methods.It should be noted that the engine will always display the entity thumbnail if one is available.Photoshop APIThe engine exposes the Javascript API for Photoshop CC to Python. The full docs for this API can be found here.The Photoshop API object is exposed as engine.adobe. The examples below show how it is possible to directly manipulate the Photoshop DOM from within Toolkit apps and hooks. The standard Toolkit apps also contain working examples of how to interact with Photoshop documents.ExamplesLoad a file:f = adobe.File('/Path/To/File.jpeg')adobe.app.load(f)Set the ruler units to PIXELS:pixels = adobe.Units.PIXELSadobe.app.preferences.rulerUnits = pixelsExport the current doc for the web with default options:temp_thumb_file = adobe.File(out_path)save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()adobe.app.activeDocument.exportDocument(temp_thumb_file, save_for_web, export_options)Export each layer as a separate file:doc = adobe.app.activeDocumentlayers = doc.artLayerslayers = [layers[i] for i in xrange(layers.length)]original_visibility = [layer.visible for layer in layers]save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()for layer in layers:    layer.visible = Falsefor layer in layers:    layer.visible = True    out_file = adobe.File(&quot;c:/layer.%s.jpg&quot; % str(layer.name))    doc.exportDocument(        out_file,        save_for_web,        export_options,    )    layer.visible = Falsefor (i, layer) in enumerate(layers):    layer.visible = original_visibility[i]Environment variablesTo aid in debugging, there are a set of environment variables that change some of the engine’s default values:SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - The Python heartbeat interval in seconds (default is 1 second). The legacy environment variable SGTK_PHOTOSHOP_HEARTBEAT_INTERVAL is also respected if set.SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - The number of heartbeat errors before quitting (default is 2). The legacy environment variable SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE is also respected if set.SHOTGUN_ADOBE_NETWORK_DEBUG - Include additional networking debug messages when logging output. The legacy environment variable SGTK_PHOTOSHOP_NETWORK_DEBUG is also respected if set.SHOTGUN_ADOBE_PYTHON - The path to the Python executable to use when launching the engine. If not set, the system Python is used. If Photoshop is launched from a Python process, like ShotGrid Desktop or via the tk-shell engine, the Python used by that process will be used by the Photoshop integration.Note: Additional environment variables exist in the Adobe Framework. For details, please see thedeveloper documentation.App Developer notes  Because the python process is separate from the Photoshop CC process, there is some work done within the engine to try to make the app windows show above the Photoshop window in as clean a manner as possible. One gotcha with this setup is the default option to use native OS windows for QFileDialog. If you are developing an app for use with this engine, be sureto set the option to not use the native dialog. See an example of this in the tk-multi-pythonconsole app.",
    "url": "/8d461cbe/",
    "relUrl": "/8d461cbe/"
  },
  "129": {
    "id": "129",
    "title": "Shell",
    "content": "ShellThe ShotGrid engine for the shell handles command line interaction and is tightly integrated with the tank command which is distributed as part of the Core API. When you execute the tank command in a terminal, Toolkit launches the engine to handle app execution.",
    "url": "/2ad59ee8/",
    "relUrl": "/2ad59ee8/"
  },
  "130": {
    "id": "130",
    "title": "ShotGrid Folders",
    "content": "ShotGrid FoldersShotGrid Toolkit has a built in system that handles the creation of standardized directory structures based on a configuration. This makes it easy to quickly produce consistent file system layouts for multiple shots.This App hooks up the file system creation API methods in the Sgtk Core API with ShotGrid. This makes folder creation an easy task; just select a collection of Shots or assets and click the Create Folders action.How it worksSimply select one or more Tasks, Shots or other entities (depending on the configuration). Now select create folders from the action menu. Once the process has completed, you will get a report of how many folders were created.",
    "url": "/134adb0e/",
    "relUrl": "/134adb0e/"
  },
  "131": {
    "id": "131",
    "title": "ShotGrid Launch Folder",
    "content": "ShotGrid Launch FolderThe Launch Folder App is a ShotGrid utility which allows you to jump from ShotGrid into the File System.How it worksThe Launch Folder App allows you to jump from ShotGrid into the File System. You can register it for ShotGrid entity types such as Shots, Assets and Sequences. Once activated, it will appear on the Action menu:You can select a single or multiple entries in ShotGrid and when you click the menu action a standard file browser will be launched (Explorer on Windows, Finder on Mac etc.)",
    "url": "/0c3049eb/",
    "relUrl": "/0c3049eb/"
  },
  "132": {
    "id": "132",
    "title": "ShotGrid Launch Publish",
    "content": "ShotGrid Launch PublishThis app adds an “Open in Associated Application” action to the Published File entity in ShotGrid. This makes it easy to open up an already published file: Just navigate to that file, right click on it and select the action.The app makes it easy to configure different app launch sequences for different files – all this is done inside a hook. It also dispatches image sequences to a viewer (such as RV). Files not recognized by the hook will be dispatched to the os-level app.",
    "url": "/a01dbeb7/",
    "relUrl": "/a01dbeb7/"
  },
  "133": {
    "id": "133",
    "title": "ShotGrid",
    "content": "ShotGridThe ShotGrid engine manages apps that can be launched from within ShotGrid. Sometimes we refer to these Toolkit Apps as Actions. They typically appear as items on menus inside of ShotGrid.Using ShotGrid Pipeline Toolkit ActionsActions are visible on the ShotGrid Home page:They can also be found on the standard ShotGrid context menu, which can be shown by right clickingon an object or a selection:When you click on an action, processing will immediately start. Once the app has completed, a message is typically displayed with some status information, or an error message if things didn’t work.Developing Apps for ShotGridDeveloping apps that run inside of ShotGrid is easy! If you are not familiar with how app development works in general, head over to the Platform documentation and read the introductory material over there. In this section we will just cover the ShotGrid specific aspects of the app development process!As of Core v0.13, you can use all the multi apps with the ShotGrid Engine. Technically speaking there is little difference between the ShotGrid engine and other engines. There are, however, some subtle differences:  You will need to manually install PySide or PyQt into your standard python environment if you want to execute QT based apps in the ShotGrid Engine.  It is possible in the ShotGrid engine to make an action visible to a user depending on which permissions group they belong to. This is useful if you want example want to add a command to the ShotGrid Action menu and you only want admins to see it.A hello-world style ShotGrid App, only visible to admins, would look something like this:from tank.platform import Applicationclass LaunchPublish(Application):        def init_app(self):        &quot;&quot;&quot;        Register menu items with ShotGrid        &quot;&quot;&quot;                params = {            &quot;title&quot;: &quot;Hello, World!&quot;,            &quot;deny_permissions&quot;: [&quot;Artist&quot;],        }                self.engine.register_command(&quot;hello_world_cmd&quot;, self.do_stuff, params)            def do_stuff(self, entity_type, entity_ids):        # this message will be displayed to the user        self.engine.log_info(&quot;Hello, World!&quot;)    ",
    "url": "/02c2d8aa/",
    "relUrl": "/02c2d8aa/"
  },
  "134": {
    "id": "134",
    "title": "VRed",
    "content": "VRedThe ShotGrid engine for VRED contains a standard platform for integrating ShotGrid Apps into VRED. It is lightweight and straight forward and adds a ShotGrid menu to the VRED menu.Information for App DevelopersPySideThe ShotGrid engine for VRED contains a PySide installation, and will activate this whenever this is necessary.VRED Project ManagementWhenever the ShotGrid engine for VRED starts, it will set the VRED Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the VRED project is set based on a file can be configured in the configuration file, using the template system.Working with tk-vredThis ShotGrid integration supports the VRED product family (Pro &amp;amp; Design).When VRED opens, a ShotGrid menu (the VRED engine) is added to the menu bar.File Open and SaveUse the My Tasks and Assets tabs to see all your assigned tasks and browse for assets. To the right, use these tabs to view all files, working or published files associated with what is selected to the left.SnapshotSnapshot: Opens the Snapshot dialog to create a quick backup of the current scene. PublishPublish: Opens the Publish dialog for publishing the file to ShotGrid, which can then be used by artists downstream. For more information on VRED Publishing, see hereLoaderLoad: Opens the Content Loader app, along with instructional slides explaining how it works.To see more info about VRED loading see hereScene BreakdownScene Breakdown: Opens the Breakdown dialog, which displays a list of “referenced” files (and their links), along with what in the scene is out-of-date. Select one or more items and click Update Selected to switch and use the latest version of the content.",
    "url": "/9d824e0b/",
    "relUrl": "/9d824e0b/"
  },
  "135": {
    "id": "135",
    "title": "APIs",
    "content": "Toolkit APIsHere you’ll find reference documentation for APIs provided by the Toolkit platform.",
    "url": "/6c5b0b61/",
    "relUrl": "/6c5b0b61/"
  },
  "136": {
    "id": "136",
    "title": "Apps",
    "content": "Toolkit AppsHere you’ll find reference documentation for apps available for the Toolkit platform.",
    "url": "/f8596e35/",
    "relUrl": "/f8596e35/"
  },
  "137": {
    "id": "137",
    "title": "Environment Configuration",
    "content": "Environment Configuration ReferenceIntroductionAt the heart of a Toolkit pipeline is the environment configuration. Within a Toolkit pipeline configuration, the environment configuration files are where you define which Toolkit apps are available within different DCCs and customize the settings for each. This document is a complete reference to the structure and function of the environment configuration files. It covers the Toolkit concept of environments for configuring different workflows within a project, configuration structure, file referencing, and ways to discover what customizations are available.                    Note: While this document acts as a reference to the environment configuration files, you can  see a step-by-step example of editing a configuration setting in the Toolkit Basics Guide on Editing a pipeline configuration.    What is an environment?The ShotGrid Toolkit platform provides a fully customizable set of integrations for commonly used content creation software with which you can build your studio pipeline. Within a project’s configuration, you can specify which software packages have integrations, which specific Toolkit apps are available in each, and your options for each app—building out artists workflows to suit your studio’s needs.But often in studio pipelines, it’s common for different types of artists to have different workflows. As a simple example, for artists working on assets, you might want to make texture painting software such as Mari available, whereas for artists working on shots, you might want to make compositing software such as Nuke available.Beyond just software packages, you might have different settings for the same Toolkit app for different artists. For example, both shot artists and asset artists might use the Workfiles app, but you might want to limit the file navigation to files associated with Shot entities for the former and Asset entities for the latter.To support these different workflows within a project, Toolkit divides its app and engine configurations across environments. An environment contains the integrations and their settings for a set of software packages, all with a certain context in common.In the above example, artists working on assets would be working in an asset step environment, whereas artists working on shots would be working in a shot step environment. Each environment is configured independent of any others, allowing you to have distinct workflows within a project.A note on Toolkit’s Default ConfigurationToolkit gives you a lot of freedom in the way you structure your environment configuration. This document is a reference for all of the options that are available to you, so that you’ll have the necessary knowledge to make choices that best suit the needs of your pipeline.This document will also occasionally cover some of the specific choices we’ve made in the pipeline configuration provided as a starting point, known as the Default Configuration. When you’re ready to customize your pipeline, the first step is to create an editable pipeline configuration for your project.While these choices are only conventions and not hardcoded into the Toolkit workflow, it’s helpful to refer to the Default Configuration as an example for learning what features are available once you start customizing your pipeline and best practices for structuring your own configurations. And, since it’s the suggested starting point for new Toolkit users, it’s helpful to know some of its conventions. We will always distinguish between general features of the Toolkit environment configuration and specific choices in the Default Configuration in this document. For specific details on the Default Configuration’s environment structure, see its README file.File locationsWithin your Pipeline Configuration, the config/ directory contains all the files and folders that are meant to be customized. In config/, you’ll find three sub-directories: cache, core, and env. The env directory holds the environment configuration files, so this document will refer to the files in config/env.In the Default Configuration, you’ll see the following files in config/env/:asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.ymlEach of these files corresponds to an environment; having separate files allows each environment to be configured separately.How Toolkit determines the current environmentToolkit uses a core hook called pick_environment to determine which environment file to use at a given time based on the current context. The pick_environment hook’s return values correspond to environment configuration files. For example, if pick_environment returns shot_step, Toolkit will use config/env/shot_step.yml to configure the Toolkit environment.Custom environmentsThe environment configuration files listed above are the ones provided with the Default Configuration. However, some studios may want to employ different or additional environments. For example, a studio might want different configuration settings for every stage in the pipeline—asset_step_rig, asset_step_model, shot_step_anim, shot_step_light, and so on. Fortunately, you can fully customize the available environments.To do so, add the desired environment config files to the config/env directory. Then, override the pick_environment core hook, adding to it the logic that defines when to use your new environments.Basic structureToolkit’s configuration files are written in YAML. The general configuration structure for any bundle (an app, engine, or framework) is as follows:bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:     type: descriptor_type    descriptor_setting1: value    descriptor_setting2: valueTo demonstrate this structure, here is a very simple example: an environment in which there is a single engine, with a single app defined within it. The following might be the contents of project.yml in this config:engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4The engines blockEvery environment configuration file starts with an engines block. Nested within it are all of the engines defined for that environment.In our example, only a single engine is defined, tk-maya. It has two settings listed, apps and location.location is a special setting that every bundle requires. The apps setting is a list of all the apps defined for the engine, each with its own settings. In this case, only one app is defined for the engine, tk-multi-workfiles2.The location descriptorEvery Toolkit bundle has a location setting, which we refer to as the bundle’s descriptor. The descriptor tells Toolkit where to find the given bundle, and depending on its type, whether to access it directly or cache it locally. Some examples of locations that a Toolkit bundle can come from are the ShotGrid App Store, a git repository, a path on disk, or a zip file uploaded to your ShotGrid site. Each of these has a corresponding descriptor type, with settings specific to that type. Here again is the descriptor for the tk-maya engine from the example above:    location:        type: app_store        name: tk-maya        version: v0.9.4This is a descriptor of type app_store, which tells Toolkit to get the given bundle from the ShotGrid App Store. Descriptors of type app_store have the settings name and version.In contrast, if you are actively developing a custom bundle—say you’re working on writing a Toolkit app for a specific workflow in your studio, you may want to get it directly from a path on disk. In this case you’d use a descriptor of type dev, which might look like this:    location:        type: dev        path: /path/to/appThe dev descriptor has different settings from the app_store descriptor. While it can take other settings, it can be set up simply with a path setting pointing to where the app lives on disk.See the Descriptor section of the Toolkit Core API docs for details on all available descriptor types and their settings.The apps blockApps are Toolkit’s user tools, and each can run independently of any others. You can choose which apps you want to use based on your pipeline needs, and the apps setting within an engine block is where you define which apps are available in a given engine.Here again is the apps setting from our example above:engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8You can see that we have a single app defined, the tk-multi-workfiles2 app. It currently only has a single setting defined:  its descriptor.If you wanted to make other apps available in the tk-maya engine in the project environment, you’d add them here. Let’s add the Panel, tk-multi-shotgunpanel, and the About app, tk-multi-about, to our engine. Our example project.yml file now looks like this:engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4There are a few important things to note at this time:  The Default Config lists bundles in alphabetical order, and this example follows that convention.  The file is beginning to get long, and we haven’t even added any configuration settings yet.  You might imagine that you’ll be using these same apps in other engines and other environments. For example, you’ll probably have all three of these apps—the Panel, the About app, and the Workfiles app—in different engines (say, Houdini, Nuke, or Photoshop), and in different environments (like asset_step or shot_step). Defining common app settings in many places in your config means that when it comes time to make a change, you’ll have to make the modification in many places.To mitigate the last two issues, Toolkit configurations support includes.IncludesIncludes allow you to reference a section of one file in another file in your configuration. Using includes allows you set a configuration setting in one place, but use it in multiple environments.Includes consist of two parts:  The includes list: a YAML dictionary whose key is includes, and whose value is a list of all files we want to include from.  A reference within your configuration settings, prefixed by the @ symbol, and named to point to the name of the section you want to reference from the included file.To flesh out our above example, you might have a single file where you hold the location descriptors for all of your engines. Let’s put that file in an includes subfolder, and call it engine_locations.yml.The contents of engine_locations.yml would look like this:config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...This file can act as a single source for all engine locations, and all of your environment configurations can reference it. Using this include file, our example now looks like this:config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationYou can see here that the value of the location setting for the tk-maya engine is now a reference to a key from the included YAML file.                    Note: Having all engine locations in a config/env/includes/engine_locations.yml file, as we do in this example, follows the convention of the Default Configuration.    You can add a second include file for app locations, and in fact, the Default Configuration does just that. Let’s expand our example:config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationWe’re now getting the tk-maya engine’s descriptor from the included engine_locations.yml file, and the descriptor for each app defined for the tk-maya engine from the included app_locations.yml file.                    Note: The Default Configuration employs a second level of nesting that’s not demonstrated here. Every app or engine that has settings beyond just a descriptor has a settings file in includes/settings (e.g., includes/settings/tk-maya.yml, includes/settings/tk-multi-workfiles2.yml). The engine settings files include app settings from the app settings files, and the environment configuration files include from the engine settings files. For details on the Default Configuration’s structure, see its README file. For a detailed walkthrough of modifying a configuration setting, see the Toolkit Basics Guide on Editing a Configuration Setting.    Sparse configurationsEvery Toolkit bundle has a set of available configuration settings, with a default value for each. Toolkit allows sparse configurations: if a configuration setting is not explicitly specified in the environment config files (and/or the files they include), then the default value from the bundle will be used.In our example, we haven’t specified any settings for our apps aside from location. So, in our configuration’s current state, our three apps will use the default values for all of their settings. So, how do we know what configuration settings are available?                    Note: While it’s not a requirement that Toolkit configurations be sparse, the Default Configuration is a sparse configuration.    Discovering available configuration settingsWith sparse configurations, it’s not immediately evident what configuration settings are available for an app simply by looking at your configuration files. To find out what configuration settings an app has available, you have two choices:  App documentation: Each of our apps has its own documentation page, and each of these pages has a “Configuration Options” section. This section lists all of the available configuration settings for the app, with description and default values for each. You can see the Workfiles documentation page as an example. The Apps and Engines page lists the documentation pages for all apps and engines.  The manifest: Every Toolkit bundle includes a file called info.yml in its root directory. We refer to this file as the bundle’s manifest, and it defines all of the available configuration settings for the bundle, with a description and default value for each. You can find the manifest in your own cache of the bundle (e.g., install/app_store/tk-multi-workfiles2/v0.11.8/info.yml within your pipeline configuration), or in Github (here it is for Workfiles as an example).Modifying configuration settingsTo modify a configuration from the default value, simply add it to the proper block, in the proper environment in your Pipeline Configuration, and set its value.Going back to our example, let’s say that we want to configure tk-multi-workfiles2 so that it launches automatically when Maya is launched in the project environment. We can see in the app’s manifest that there is a launch_at_startup setting that controls whether to launch the Workfiles UI at application startup time, and that its default value is False. So, we’ll just add the launch_at_startup option, and set it to True. Our project.yml file now looks like this:config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationNote that if the settings for tk-multi-workfiles2 were coming from an included file, we’d make this change in that file.Additional resources  Toolkit Basics Guide: Editing a pipeline configuration  Toolkit Basics Guide: Adding an app  Animation pipeline tutorial  Descriptor reference documentation  Webinar: Toolkit administration  File system configuration reference  Default Configuration environment structure README",
    "url": "/c73fcb84/",
    "relUrl": "/c73fcb84/"
  },
  "138": {
    "id": "138",
    "title": "Configuration",
    "content": "Toolkit ConfigurationHere you’ll find reference documentation for configuring the Toolkit platform",
    "url": "/10e8ee51/",
    "relUrl": "/10e8ee51/"
  },
  "139": {
    "id": "139",
    "title": "어떻게 하면 ShotGrid 이벤트 데몬을 사용하여 다른 Toolkit Core 모듈을 로드할 수 있습니까?",
    "content": "어떻게 하면 shotgunEvents 데몬을 사용하여 다른 Toolkit Core 모듈을 로드할 수 있습니까?이 정보를 공유해 준 Benoit Leveau @ Milk VFX에게 깊이 감사드립니다.문제툴킷의 sgtk API는 프로젝트 중심입니다. 즉, 사용할 프로젝트에서 특별히 가져와야 합니다. 이는 단일 Python 세션에서 다중 프로젝트에 대해 sgtk API 작업을 사용하는 경우 Python은 이름이 동일한 모듈을 한 번만 가져올 수 있기 때문에 문제가 발생할 수 있음을 의미합니다.ShotGrid 이벤트 데몬을 사용 중인 경우 특정 이벤트에 대해서는 플러그인 내에서 툴킷 액션을 수행하고 싶을 수 있습니다. 하지만 Python은 모듈을 한 번만 가져오기 때문에 이렇게 하는 것은 위험할 수 있습니다. 따라서 프로젝트 A용 Toolkit Core API를 플러그인을 처음 실행할 때 가져오면 그 버전이 데몬의 사용 기간 동안 가져온 채로 유지되는 버전이 됩니다. 즉, 플러그인으로 발송된 다음 이벤트가 프로젝트 B의 이벤트인 경우 프로젝트 A용 Core API를 사용하여 프로젝트 B를 위한 새 툴킷 객체의 인스턴스화를 시도하면 툴킷에서 오류가 발생할 수 있습니다.중앙 집중식 구성을 사용하는 경우의 문제 예시:  이벤트 123은 프로젝트 A의 이벤트입니다.  프로젝트 A에 대한 Core API는 /mnt/toolkit/projectA/install/core/python에 있습니다.  이 디렉토리를 sys.path에 접두사로 붙입니다.  import sgtk가 이 위치에서 이 API를 가져옵니다.  이 Core API로 툴킷 인스턴스를 인스턴스화하고 일부 액션을 수행합니다.  Core API 디렉토리를 sys.path에서 분리합니다.  이벤트 234는 프로젝트 B의 이벤트입니다.  프로젝트 B에 대한 Core API는 /mnt/toolkit/projectB/install/core/python에 있습니다.  이 디렉토리를 sys.path에 접두사로 붙입니다.  Python은 이를 이미 가져온 sgtk로 인식하기 때문에 import sgtk는 아무 동작도 하지 않습니다.  이 Core API로 툴킷 인스턴스를 인스턴스화하고 일부 액션을 수행합니다.  툴킷 코어가 작업을 수행하려는 프로젝트 (B)가 아닌 프로젝트 (A)를 위한 것이기 때문에 오류가 발생합니다.솔루션아래 예는 다른 버전의 모듈을 이미 가져왔을 수도 있는 경우에 스크립트 또는 플러그인에서 올바른 버전의 sgtk 코어를 가져올 수 있는 방법을 보여 줍니다. 원래 가져온 항목은 언로드되어 Python 메모리에서 제거되기 때문에 새로운 모듈 인스턴스를 성공적으로 가져와 사용할 수 있습니다.&quot;&quot;&quot;Example of how to import the correct sgtk core code in a script wherea different instance of the module may have already been imported. Theoriginal import is unloaded and removed from memory in Python so the newinstance of the module can be imported and used successfully.Thanks to Benoit Leveau @ Milk VFX for sharing this.&quot;&quot;&quot;import osimport sysdef import_sgtk(project):    &quot;&quot;&quot;    Import and return the sgtk module related to a Project.    This will check where the Core API is located on disk (in case it's localized or shared).    It shouldn't be used to get several instances of the sgtk module at different places.    This should be seen as a kind of 'reload(sgtk)' command.    :param project: (str) project name on disk for to import the Toolkit Core API for.    &quot;&quot;&quot;    # where all our pipeline configurations are located    shotgun_base = os.getenv(&quot;SHOTGUN_BASE&quot;, &quot;/mnt/sgtk/configs&quot;)    # delete existing core modules in the environment    for mod in filter(lambda mod: mod.startswith(&quot;tank&quot;) or mod.startswith(&quot;sgtk&quot;), sys.modules):        sys.modules.pop(mod)        del mod    # check which location to use to import the core    python_subfolder = os.path.join(&quot;install&quot;, &quot;core&quot;, &quot;python&quot;)    is_core_localized = os.path.exists(os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;_core_upgrader.py&quot;))    if is_core_localized:        # the core API is located inside the configuration        core_python_path = os.path.join(shotgun_base, project, python_subfolder)    else:        # the core API can still be localized through the share_core/attach_to_core commands        # so look in the core_Linux.cfg file which will give us the proper location (modify this        # to match your primary platform)        core_cfg = os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;core_Linux.cfg&quot;)        if os.path.exists(core_cfg):            core_python_path = os.path.join(open(core_cfg).read(), python_subfolder)        else:            # use the studio default one            # this assumes you have a shared studio core installed.            # See https://support.shotgunsoftware.com/entries/96141707            core_python_path = os.path.join(shotgun_base, &quot;studio&quot;, python_subfolder)    # tweak sys.path to add the core API to the beginning so it will be picked up    if sys.path[0] != &quot;&quot;:        sys.path.pop(0)    sys.path = [core_python_path] + sys.path    # Remove the TANK_CURRENT_PC env variable so that it can be populated by the new import    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    # now import the sgtk module, it should be found at the 'core_python_path' location above    import sgtk    return sgtk분산 구성위 예에서는 중앙 집중식 구성을 사용한다고 가정하고 있지만 분산 구성을 사용할 경우에는 상황이 약간 다릅니다. 분산 구성의 경우 sgtk API를 가져오려면 부트스트랩 API를 사용해야 합니다. 부트스트랩 API를 사용하는 경우 일반적으로 비 프로젝트 중심 sgtk API를 가져온 다음 이를 사용하여 지정된 프로젝트에 대한 엔진을 부트스트랩합니다.이 부트스트랩 프로세스는 sgtk 모듈 교환을 처리하여 부트스트랩 프로세스 마지막에 엔진 오브젝트를 사용할 수 있도록 합니다. 부트스트랩 후 sgtk를 가져오면 프로젝트에 적합한 관련 sgtk 모듈을 가져옵니다. 위의 예에서 다중 프로젝트에 대해 sgtk를 로드해야 하는 대신 다중 프로젝트에 대해 부트스트랩해야 합니다. 여기 작은 캐시는 한 번에 하나의 엔진만 실행할 수 있으므로 다른 엔진을 로드하기 전에 먼저 삭제해야 합니다.                    경고: 구성을 부트스트랩하면 프로세스가 구성을 로컬로 캐시하고 모든 종속성을 다운로드해야 하므로 속도가 느려질 수 있습니다. 이벤트 데몬 플러그인에서 부트스트랩하면 성능에 심각한 영향을 미칠 수 있습니다. 한 가지 가능한 접근 방식은 각 프로젝트 부트스트랩에 대해 별도의 Python 인스턴스를 생성하여 플러그인에서 명령을 전달하는 것입니다. 이렇게 하면 필요할 때마다 프로젝트를 다시 부트스트랩하지 않아도 됩니다.    예는 다음과 같습니다.# insert the path to the non project centric sgtk APIsys.path.insert(0,&quot;/path/to/non/project/centric/sgtk&quot;)import sgtksa = sgtk.authentication.ShotgunAuthenticator()# Use the authenticator to create a user object.user = sa.create_script_user(api_script=&quot;SCRIPTNAME&quot;,                            api_key=&quot;SCRIPTKEY&quot;,                            host=&quot;https://SITENAME.shotgunstudio.com&quot;)sgtk.set_authenticated_user(user)mgr = sgtk.bootstrap.ToolkitManager(sg_user=user)mgr.plugin_id = &quot;basic.&quot;engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity={&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176})# import sgtk again for the newly bootstrapped project, (we don't need to handle setting sys paths)import sgtk# perform any required operations on Project 176 ...# Destroy the engine to allow us to bootstrap into another project/engine.engine.destroy()# now repeat the process for the next project, although we don't need to do the initial non-project centric sgtk import this time.# We can reuse the already import sgtk API to bootstrap the next...                    참고: 중앙 집중식 구성도 부트스트랩할 수 있으므로 혼합하여 사용할 경우 다른 메서드가 필요하지 않습니다.    ",
    "url": "/3520ad2e/",
    "relUrl": "/3520ad2e/"
  },
  "140": {
    "id": "140",
    "title": "Engines",
    "content": "Toolkit EnginesHere you’ll find reference documentation for engines available for the Toolkit platform.",
    "url": "/3a69db47/",
    "relUrl": "/3a69db47/"
  },
  "141": {
    "id": "141",
    "title": "Frameworks",
    "content": "Toolkit FrameworksHere you’ll find reference documentation for frameworks available for the Toolkit platform.",
    "url": "/c6db88dd/",
    "relUrl": "/c6db88dd/"
  },
  "142": {
    "id": "142",
    "title": "An Overview of Toolkit",
    "content": "An Overview of ToolkitAn overview of the different concepts in the ShotGrid Pipeline Toolkit.Here, we cover the main concepts in detail: How apps and Engines work, how Toolkit is launched and manages the current context (work area), how folders are created on disk, etc. We recommend that anyone involved in configuration or development start here.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For details, see the  ShotGrid Integrations Admin Guide.IntroductionThis document explains some of the key features in more depth. With explanations, examples and small demos, we show what Toolkit is all about. This document is a good starting point if you want to familiarize yourself with Toolkit or if you want to understand how Toolkit could add value to your studio. After you have read it, you’ll have a good grasp of some of the key concepts and how they work in practice.Below is a brief description of Toolkit (SGTK):  Toolkit is a  Pipeline Toolkit  based on the ShotGrid platform - it makes it easier to write and install tools for a studio.  Toolkit is filesystem based - it helps you organize where things are stored on disk so that what you have on disk is nicely structured.  Toolkit is an assistant - it does not try to take over or abstract the data in your pipeline, but rather is there to provide artists with compelling tools to make finding information easier and avoid making mistakes.  Toolkit is helping you to share work by storing all of its publishes in ShotGrid. Toolkit makes it easy to share updates and work that is going on across a production.In the following sections, we will be looking in depth at the Toolkit and how it works.Projects and ConfigurationsIn Toolkit, everything is project centric. A project typically starts its lifecycle inside of ShotGrid, goes through a bidding and a pre-production phase, and then once it is ready for the content-creation phase Toolkit can be set up for that project.When you set up a new project, you use a template configuration. This is a predefined config containing engines and apps, filesystem configuration, and other settings. If you are just starting with Toolkit, you can use our example configuration as a starting point for your exploration. If you have already been using Toolkit on another project, we suggest that you take that configuration and use that as the starting point for your new project. That way, you will be evolving a studio configuration and it will be refined with each new project. Of course, you can also maintain a studio configuration separately and use this as a template for all new projects.Each configuration defines a number of storage points. For the standard sample configuration, tk-config-default, we define a single storage point called  primary. This means that all your production data will be under a single filesystem project root. You can also set up configs with more than a single file system root. We call these multi-root configurations. Examples of when you might need multi-root configurations include having a separate storage for renders, a separate storage for editorial, etc. Each of these storage points need to exist as a Local File Storage in ShotGrid, which can be set up in the Site Preferences, under the File Management tab.Toolkit will install the actual project configuration in any location you like. Typically this will go into a  software install area on disk and not into the project data area itself.Let your studio configuration evolveWhen you set up a new project, you can base it off of an existing project. Toolkit will then copy the configuration folder from that project to your new project. This means that your new project will get exactly the same versions of apps and engines, the same settings and the same customizations as the project you are basing it on. This can be useful if you want to evolve your pipeline and take advantage of improvements and tweaks that have happened as part of an existing production.Alternatively, you can just take the configuration folder from a project when you are happy with that project’s setup and save it in a central location somewhere. This config can then be used as a studio template and each time you create a new project you can base it off this config. If you want, you can even source control this studio template config using a revision control system, such as git or something similar, and tracking how the pipeline configuration template evolves over time becomes simple and transparent. Whenever you want to update it, just copy the config from one of your projects and commit the changes.For detailed information about configuration management, check out our detailed docs:Managing your project configuration.Each Project has a Pipeline ConfigurationWhenever you set up Toolkit for a project, a pipeline configuration is created. This configuration contains all the settings and files needed for the project. The configuration has a dedicated tank command which you can run in a shell if you want to address the project directly (there is also a global tank command that works with all projects). In ShotGrid, the Pipeline Configuration has been registered as a special Pipeline Configuration Entity to make it easy to keep track of where your project configurations reside on disk.In addition to the master config that is created when the project is set up, you can create additional configurations for a project. This is often useful if you want to make changes to the configuration without affecting everyone on the project. If you want to do this, you can navigate to a pipeline configuration in ShotGrid, right click it and choose to clone it. This will create a new pipeline configuration for a project, based on another one, and using the new configuration you can safely test out a new app without affecting other users.Please note that the main configuration for a project needs to be named Primary. If you rename, modify or delete it, things may not work as expected. The Pipeline Configurations stored in ShotGrid are not intended to be manipulated by hand, but rather through various specific tank administration commands.Example:How to clone a configurationChecking for updatesSimilar to other App stores out there, the Toolkit app store constantly gets new versions for apps and engines. These new versions may contain important bug fixes or interesting new features. Upgrading your apps and engines is completely optional. It is normally a quick process and the upgrade scripts will always prompt you before making any changes. Likewise, it is straightforward to roll back should you have accidentally installed an unsatisfactory version.A single command handles the upgrade process. Simply run the  tank  command located in your project configuration folder and add an  updates  parameter:/software/shotgun/bug_buck_bunny/tank updatesRunning this command with no parameters will check all environments, engines and app. This may take a long time, but you can also run the updater on a subset of your installed apps and engines.General syntax:tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:  Check everything:  tank updates  Check the Shot environment:  tank updates Shot  Check all maya apps in all environments:  tank updates ALL tk-maya  Check all maya apps in the Shot environment:  tank updates Shot tk-maya  Make sure the loader app is up to date everywhere:  tank updates ALL ALL tk-multi-loader  Make sure the loader app is up to date in maya:  tank updates ALL tk-maya tk-multi-loaderIn addition to checking the app store, this script checks all other registered locations too, so it may query your local git, a GitHub repository, a file on disk and the app store, depending on where you have deployed your apps.Please note that a new version of an app may introduce changes to the app configuration. For example, there may be a new feature which requires a new configuration parameter. In that case, the tank upgrade script will prompt you to type in values for these parameters.Checking for updates to the Core APISometimes we release new versions of the Toolkit Core API. A separate command is used to update the Core API. In this case, the command is tank core.Creating folders on diskOnce Toolkit has been set up for your project, you can use it to help you create a consistent folder structure. This folder structure is configured by creating a filesystem template as part of the pipeline configuration on disk. In this folder structure, some of the paths will be dynamic - for example, you may have a folder called asset that represents a ShotGrid Asset entity. These dynamic folders can be connected to ShotGrid queries and many other things.Toolkit provides a number of different dynamic folder types that handle different setups and scenarios. You can use the standard ShotGrid API query syntax when you set up your folder creation, so you could organize your filesystem so that assets with different types end up in different folders on the filesystem.For a detailed walkthrough of how this works, see the admin guide:Administering the ShotGrid Pipeline ToolkitToolkit’s folder creation happens in two passes: a direct pass, which can be run by anyone at any time, and a deferred pass, which is typically run by the artist just before application launch. This deferred pass is completely automatic and can be used to set up application-specific folders and user sandboxes.The Current ContextOnce the filesystem structure has been created, Toolkit knows the relationship between a folder on disk and the ShotGrid object that the folder came from. This is important, because it allows Toolkit to easily associate an object in ShotGrid with a folder or disk, or file, when publishing, loading or resolving paths. It also relates to what we call the context or sometimes the current work area. The context object is part of the Toolkit Core and tracks the current thing that is being worked on. It is a central mechanism when Toolkit resolves filesystem paths.The context can be created either from a ShotGrid object, such as a Task, Asset or Shot, or from a path on disk. When apps are running, they can always access the context, and this makes it easy to construct apps that have no knowledge of the filesystem naming conventions or whether the app is used in an Asset or Shot pipeline. This is all handled by the Toolkit Core API and the context.Filesystem TemplatesThe Toolkit Core contains a system for handling file paths. It is called the Templates System. Since Toolkit is filesystem based, apps will need to resolve file paths whenever they need to read or write data from disk. Apps are filesystem-structure agnostic, meaning that they don’t know how the filesystem is organized. The template system handles all this for them.At the heart of the template system, there is a Templates Configuration File. This file contains all the important filesystem locations for a project. A  Template looks something like this:maya_shot_publish: 'shots/{Shot}/{Step}/pub/{name}.v{version}.ma'It defines a path which contains certain dynamic fields. Each field can be configured with validation and typing, so that, for example, you can define that the {version} field in the template above is an integer padded with three zeros (e.g. 001, 012, 132). Whenever and app needs to write or read something from disk, a template is added to the templates file to describe that location. Since apps often are set up to form a pipeline, the output template of one app (e.g. a publishing app) is often the input template of another app (e.g. a loading app). This is why all of the filesystem locations are kept in a single file.The template API lets you jump between a list of field values and paths:# get a template object from the API&amp;gt;&amp;gt;&amp;gt; template_obj = sgtk.templates[&quot;maya_shot_publish&quot;]&amp;lt;SGTK Template maya_asset_project: shots/{Shot}/{Step}/pub/{name}.v{version}.ma&amp;gt;# we can use the template object to turn a path into a set of fields...&amp;gt;&amp;gt;&amp;gt; path = '/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'&amp;gt;&amp;gt;&amp;gt; fields = template_obj.get_fields(path){'Shot': '001_002', 'Step': 'comp', 'name': 'main_scene', 'version': 3}# alternatively, we can take a fields dictionary and make a path&amp;gt;&amp;gt;&amp;gt; template_obj.apply_fields(fields)'/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'Note how the above path and template has two different types of fields. The Shot and Step fields are high-level fields with equivalent objects in ShotGrid (a Shot and a Pipeline Step) where the name and the version fields are very specific to this particular type of template. If we wanted to describe a publish path for an Asset rather than a Shot, we would still have a name and a version field, since this is needed for all publishes, regardless of what type of data it is. However, we would not have a Shot and a Step field. Instead, we may have an Asset and a Step field, where the asset field would be associated with an asset in ShotGrid.When we develop an app that does publishing, we obviously don’t want to have a separate app that does Shot publishing and one that does Asset publishing. Instead, we want a single publishing app that can handle any publish scenario, regardless of whether it is a Sequence, Shot, Asset or whatever.This is where the Toolkit Context comes into play. The Toolkit Context allows us to split the template fields into two distinct groups: the Context fields (Shot, Step, Asset, etc) are fields that we want to ensure are resolved outside of the app in such a way that the app’s logic will not have to have code that specifically handles concepts such as Shots and Assets. Instead, the app should only populate the fields that are directly associated with the particular  business logic of the app. In our example of a publish app, the business logic consists of the name and the version fields. As the figure above illustrates, Toolkit therefore splits the field resolution into two distinct phases: some fields are populated by the context and some fields are populated by the business logic inside the app. This way, apps can be designed that are not tied to a particular filesystem layout. We believe this is an important aspect of building good pipeline tools.The App Code that would deal with the path resolve would typically look something like this:# start with an empty fields dictionaryfields = {}# first let the context populate all its fieldsfields.update( self.context.as_template_fields( publish_template_obj ) )# fields is now {'Shot': '001_002', 'Step': 'comp' }# now the app can add its business logicfields[&quot;name&quot;] = &quot;main_scene&quot;fields[&quot;version&quot;] = 234# and finally the app can produce the path it needs in# order to save out the filepath = publish_template_obj.apply_fields(fields)For more details of how you can configure and use the Templates API, see the following:File System Configuration ReferenceCore API ReferenceChoosing which Engines and Apps to runAnother important role that the Toolkit Core plays is in deciding which Apps should be presented to a user. If you are working on character rigging and start up Maya, you probably want a different collection of apps than if you are doing lighting on a shot. Furthermore, the apps can be configured differently depending on how you want them to operate, so a review app for rigging may be generating a turntable, whereas the same review app is doing a playblast using the shot camera when an animator runs it.In order to allow for this flexibility, a Toolkit project configuration contains a collection of environments. An environment is a configuration file that defines a collection of apps and engines and all their configuration parameters.When Toolkit starts up, it needs to decide which environment to initialize. This is done via a piece of Python code called a hook, where you can add your own business logic. The context object is passed into this piece of code and this is often what is used to determine which environment to use.This makes it possible to configure separate collections of apps for different parts of the pipeline. Furthermore, you can also update them independently and even have different supervisors managing them separately.Environments in the Default ConfigurationTo give you a practical example of how environments work and can be structured, let’s take a look at the environments that come with the default configuration:  project.yml - Apps and Engines to run when the context only contains a project.  shot_and_asset.yml - Apps and Engines to run when the context contains a shot or an asset.  shot_step.yml - Apps ane Engines when the context contains a Shot and a Pipeline Step.  asset_step.yml - Apps and Engines when the context contains an Asset and a Pipeline Step.The default config has organized its filesystem based on pipeline steps. This means that under a Shot location, you can find folders for modeling, rigging, etc. Essentially, there is one folder for each pipeline step you work on. Each of these folders have its own work and publish areas on disk. This means that a publish template may look like this:maya_shot_publish: 'sequences/{Sequence}/{Shot}/{Step}/pub/{name}.v{version}.ma'In order to use this template, the context needs to contain both an entity and a Pipeline Step. For Shot 1122, parented under Sequence ABC and pipeline step Modeling, the above template would resolve to  sequences/ABC/1122/Modeling/.... This means that a context that contains a Shot but not a Pipeline Step is not enough to populate the above template. You cannot launch Maya for a Shot-only context and use the above template. In order for it to be functional, a Step is required.This leads us to the environment breakdown shown above. Because the filesystem structure defined in the default configuration is centered around steps, all the main apps need to run in a context which has a step defined. We define two such environments in the default config: the asset_step.yml file and the shot_step.yml file. Each of these files contain engines for a number of DCCs, such as Maya, Nuke, 3dsmax, Motionbuilder, and Photoshop to mention a few. When you launch Maya from a Task inside of ShotGrid, the pick environment hook will choose the shot_step environment, start Maya and load up the Maya app configuration.It can also be useful to launch Maya directly from a Shot object inside of ShotGrid. More importantly, it can be really useful to be able to type in a console tank Shot 1122 launch_maya. This is where the shot and asset environments come in. When you load Maya with a context which contains a Shot or Asset but no Pipeline Step, it will load one of these environments. Since the filesystem structure is all organized per Pipeline Step, it is not really possible to do any loading or publishing if we are missing that information in our context. Maya instead launches with a bare configuration, only containing the Workfiles app. This app lets you choose a Task to work on. Once you have picked a Task, Toolkit switches the context and restarts the engine for you and will load up the shot_step environment with the full range of apps.Similarly, the project environment is a catch-all fallback, also just containing the Workfiles app. This makes it possible to launch Maya from pretty much anywhere inside the project and it will initialize Toolkit in a minimal state, allowing you to jump to a valid work area using the Workfiles app.Configuring AppsEach app has number of configuration parameters that need to be specified. When you install or upgrade an app, Toolkit makes sure that you have specified all the required settings.Simple setting values such as strings or integers are specified directly in the environment config. Templates are different, and since Toolkit wants to keep all templates in a single place, the environment file merely points to templates defined in the templates file. Each app will require different fields to be present in the templates that it uses in its configuration. In our previous example, the publish app was using a template with the fields name and version when creating its output files on disk. The app would therefore have a configuration setting which requires a template containing the fields name and version.If you try to configure the app using a template that has more than the context fields (name and version), the app would not know how to populate these additional fields and would not be able to generate a path from that template. Similarly, if you provided a template that was missing one of the fields it would lead to confusing results; in our case, version numbers would not be written out of the app. Therefore, Toolkit will validate the configuration at startup to make sure that the necessary fields are provided for all templates. Toolkit also supports several ways of using default values and optional fields.For a complete reference, check the following links:Apps and Engines Configuration ReferenceFile System Configuration ReferenceHooksIn addition to app settings using templates, Toolkit also supports a concept called hooks. Hooks are small snippets of Python code, allowing you to customize parts of the app as part of your configuration.Here’s how it works and why it is useful:Apps are powerful because they can be reused across multiple engines and projects. But apps tend to need some small snippets of engine-specific logic. For example, if we are building a loader app which should work both in Nuke and Maya, there will need to be code that handles the actual file load and this code will have to be different in Nuke and Maya. Furthermore, it would be great if it would be possible to use this app with any engine! Different studios may also have different ways to load items into a scene, and someone may need to support a custom Maya reference node where other studios may just do an import.This situation is handled in Toolkit using a hook. The hook is a customizable piece of code. The App comes with a default hook which contains a base level implementation, meaning that the app will work fine right out of the box. However, if you want to customize the behaviour you can copy that hook file into your configuration and Toolkit will use that code instead.Read more about how to work with hooks in the Admin guide.Running from ShotGrid and the ShellOnce Toolkit is installed, you can access it from several primary entry points:  ShotGrid Actions will appear on the right-click menus inside of ShotGrid  Launch icons will appear for the project in the ShotGrid Desktop app  You can use the tank command in a console.  The Toolkit Python API is available both inside applications and in the shell.Running the Toolkit from within ShotGrid is a common way of starting applications and carrying out tasks. ShotGrid will use ShotGrid Desktop to communicate with the Toolkit install that is local on your machine and use a local Python to execute a Toolkit command. This means that you can run local operations such as folder creation right from inside of ShotGrid.You can also access Toolkit from a shell. Each project configuration comes with its own tank command. Simply navigate to your project configuration root and execute the ./tank command from there.Lastly, you can simply add the Toolkit API to the PYTHONPATH environment variable and import it. Using the API is straightforward and if you want to start up Toolkit inside of Maya manually or as part of an existing studio launch system instead of using ShotGrid Desktop, all you need to execute is a couple of simple commands.PublishingWhen you want to share files that you are working on with others, you can publish them. What this means is that a PublishedFile entity is created in ShotGrid which other users can import using Toolkit’s loader app.The details of exactly what this means in terms of the data management (where on disk things are saved, what the file contains, etc) is left to the app doing the actual work. The Toolkit API provides developers with methods to easily create publishes inside of ShotGrid and link these up to the right objects to ensure that ShotGrid can go ahead and push notifications to all the right people. We also provide a default publish app that is meant to be versatile and highly configurable, but this is by no means the only way to implement version control using Toolkit. Because Toolkit is extensible, you could build your own custom version control and publishing system using Toolkit if this is desirable.As a starting point, however, we recommend our Publish App:The Default Multi Publish App.Building Reusable AppsToolkit is not just a collection of apps and engines. It is also a framework that you can use to develop your own tools and technologies! We have included a lot of features to make Toolkit a rich studio development platform. With Toolkit as a foundation, you can focus on the problems at hand rather than building the underlying platform yourself. We have tried to make it easy for developers to build, evaluate and release software without accidentally breaking the pipeline for artists.  The engines ensure that apps can be written in Python and Qt (PySide/PySide2) regardless of the underlying foundation. This means that some engines are very simple, while some engines are more complex depending on their provided APIs. This means that there is a straightforward, consistent way to develop tools for the studio. In our experience, Python and Qt is often found being the development environment studios use and many TDs are familiar with it.  The engine layer also means that apps can be written once and then be deployed in multiple environments. We have developed the standard app suite as Multi Apps, meaning that the same app is used in all engines. There will inevitably be specific code that needs to be tailored to work with the specific API that each DCC application exposes, but this is typically contained in one or more hooks, making it easy to reuse an app. Another consequence of being able to create multi apps like this is that when a new engine is being developed, all the standard apps can be easily configured to work with that new engine.  Via Pipeline Configurations and Cloning, it is easy to create a development sandbox, allowing developers to do work on a production without interfering with the day-to-day production activity. Once the tools are ready to be deployed, the main project configuration can be easily updated and the tool is rolled out to all artists.  Since apps run inside an engine, it is easy to reload them. Instead of having to restart Nuke or Maya every time you want to test a new code change, simply hit the reload button in Toolkit and the latest code is loaded in.For an more extensive introduction to App Development, see the following documents:An Introduction to the Toolkit App Development.The Toolkit API ReferenceApps and Engines Configuration Reference",
    "url": "/e95205a8/",
    "relUrl": "/e95205a8/"
  },
  "143": {
    "id": "143",
    "title": "개요",
    "content": "툴킷 플랫폼툴킷은 아티스트 응용프로그램과 파이프라인 도구를 ShotGrid과 통합할 수 있게 해 주는 확장 가능한 플랫폼입니다.Toolkit Core API는 모든 통합이 구축되는 플랫폼입니다. Core API는 앱, 엔진 및 플랫폼 기반뿐 아니라 파일 시스템 구성과 도구 배포까지 처리합니다.",
    "url": "/3d1cd26d/",
    "relUrl": "/3d1cd26d/"
  },
  "144": {
    "id": "144",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationThe goal is to set up an AWS PrivateLink to privately access your ShotGrid site.Set up PrivateLink to ShotGrid      Ask ShotGrid support to provide you with the ShotGrid PrivateLink service name for your AWS region.        Update the private VPC CloudFormation stack you created earlier and set ShotGridPrivateServiceName parameter.  Manual steps if needed      Add a new VPC Endpoint in your VPC        For the security group, ShotGrid service only requires the inbound port tcp/443 to be open.  DNS ConfigurationProvide your PrivateLink DNS name to ShotGrid support. We will setup a new private URL for your site that will look like mystudio-staging.priv.shotgunstudio.com.ValidationVerify that your site private URL resolves to IPs in your AWS VPC block.nslookup mystudio-staging.priv.shotgunstudio.comTry to access your test site from inside your office ie https://mystudio-staging.priv.shotgunstudio.comNext StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/d9ef03ce/",
    "relUrl": "/d9ef03ce/"
  },
  "145": {
    "id": "145",
    "title": "문제 해결",
    "content": "문제 해결문제 해결을 위한 빠른 답변 모음입니다.일반적인 문제 해결 도움말  성능 문제 해결  디버그 로깅을 어떻게 켭니까?  로그 파일은 어디에 있습니까?  내 컨텍스트에 태스크/단계가 누락되어 있는데 파일 이름의 일부로 존재하는 이유는 무엇입니까?  Python API에서 SSL: CERTIFICATE_VERIFY_FAILED 문제 수정소프트웨어 통합.  Houdini ShotGrid 통합이 시작되지 않는 이유는 무엇일까요?  SG 데스크톱에서 Nuke/Maya 등을 실행했는데 ShotGrid 메뉴에 해당 항목이 없습니다  NUKE_PATH 환경 변수를 설정하면 Nuke 통합이 시작되지 않는 이유가 무엇입니까?  두 개의 익스텐션이 설치된 경우 Photoshop 통합 문제 해결  ShotGrid 툴킷 사용 시 3ds Max를 시작하면 충돌 오류가 발생하는 이유는 무엇입니까?브라우저 통합  Chrome에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다  Firefox에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다.  ShotGrid 데스크톱/브라우저 통합을 Linux에서 실행할 수 없습니다",
    "url": "/7ef5be1d/",
    "relUrl": "/7ef5be1d/"
  },
  "146": {
    "id": "146",
    "title": "Fine Tuning",
    "content": "Fine TuningCost Management RecommendationsS3 Infrequent AccessWe recommend enabling S3 Infrequent Access to easily reduce costs without impacting performance. For the ShotGrid Cloud hosted offering, we apply a policy for all objects older than one month.With Infrequent Access, objects are stored at a lower cost. However, if they are accessed, it will involve an additional cost. ShotGrid has observed that one month was the right policy to use globally, but you may want to adapt that policy to your studio workflows as needed.Read more about S3 Infrequent Access and other storage classes here.S3 Bucket policyWe recommend you restrict access to your S3 bucket to only your VPC and ShotGrid transcoding services IPs. There is an example policy, replace your_vpc_id and your_s3_bucket by your values.We strongly recommend you test media access and media transcoding in your migration test site right after applying the bucket policy changes to be sure your S3 bucket is still accessible from your VPC and from ShotGrid transcoders.{    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Id&quot;: &quot;Policy1415115909152&quot;,    &quot;Statement&quot;: [        {            &quot;Sid&quot;: &quot;AllowSSLRequestsOnly&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: [                &quot;arn:aws:s3:::your_s3_bucket&quot;,                &quot;arn:aws:s3:::your_s3_bucket/*&quot;            ],            &quot;Condition&quot;: {                &quot;Bool&quot;: {                    &quot;aws:SecureTransport&quot;: &quot;false&quot;                }            }        },        {            &quot;Sid&quot;: &quot;Access-to-specific-VPC-only and Shotgun transcoder&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: &quot;arn:aws:s3:::your_s3_bucket/*&quot;,            &quot;Condition&quot;: {                &quot;NotIpAddress&quot;: {                    &quot;aws:SourceIp&quot;: [                        &quot;34.200.155.69/32&quot;,                        &quot;34.224.232.103/32&quot;,                        &quot;34.202.127.170/32&quot;                    ]                },                &quot;StringNotEquals&quot;: {                    &quot;aws:sourceVpc&quot;: [                        &quot;vpc-2fd62a56&quot;,                        &quot;your_vpc_id&quot;                    ]                }            }        }    ]}S3 endpoint policyWe recommend setting a VPC endpoint policy on your S3 endpoint to allow access to your S3 bucket only. See here for an example.Application Load Balancer  We recommend you enable deletion protection on the S3 proxy load balancer to prevent accidental deletion.  We recommend you enable access logging on the S3 proxy load balancer to aid in traffic analysis and identification of security issues.Next StepsSee Migration to migrate your production site to use the isolation features.Go to Setup for an overview of the possible next steps.",
    "url": "/26190270/",
    "relUrl": "/26190270/"
  },
  "147": {
    "id": "147",
    "title": "디버그 로깅을 어떻게 켭니까?",
    "content": "디버그 로깅을 어떻게 켭니까?ShotGrid 데스크톱을 통해 디버깅 활성화디버깅을 활성화하는 가장 쉬운 방법은 ShotGrid 데스크톱 앱을 통해 켜는 것입니다. ShotGrid 데스크톱에 로그인하고 나면 설정할 수 있습니다. 앱 오른쪽 아래에 있는 프로파일 사진을 클릭하고 고급(Advanced) -&amp;gt; 디버그 로깅 토글(Toggle Debug Logging)을 선택합니다. 이 설정은 세션 간에 영속적이기 때문에 작업을 마치면 끄는 것을 잊지 마십시오.이 기능을 켜면 ShotGrid 데스크톱에서 실행한 앱 또는 브라우저 통합을 통한 툴킷 명령도 이 디버그 상태를 상속한다는 점에도 유의하십시오.환경 변수 설정디버그 로깅 영구적으로 켜기먼저 새 환경 변수 TK_DEBUG=1을 설정해야 합니다.                    참고: 플랫폼에 따라 지침이 다르므로 스튜디오의 기술 전문가와 환경 변수를 설정하는 방법을 논의하는 것이 좋습니다. 어쨌든 아래 예에는 Windows 7 컴퓨터에서 환경 변수를 설정하는 방법이 나와 있습니다.    Windows 7 사용 예시  Windows 아이콘 &amp;gt; 제어판 &amp;gt; 시스템 &amp;gt; 고급 시스템 설정 &amp;gt; 환경 변수… &amp;gt; 새로 만들기…로 이동하여 디버그 로깅을 영구적으로 켤 수 있습니다.  변수 이름: TK_DEBUG  변수 값: 1  확인을 선택합니다.이제 환경 변수가 올바로 설정되고, 디버그 로깅이 켜졌습니다.                    참고: 로깅이 진행되도록 하려면 데스크톱을 다시 시작하십시오.    디버그 로깅을 끄고 싶으면 다음을 수행합니다.a. TK_DEBUG 환경 변수 값을 0으로 설정합니다.b. TK_DEBUG 환경 변수를 삭제합니다.이 환경 변수가 이미 설정되어 있는지 확인이 환경 변수가 이미 설정되어 있는지 확인하려면 터미널을 열고 set 명령을 실행합니다.그런 다음, TK_DEBUG=1을 검색합니다.그러면 데스크톱을 실행하고 나면 디버그 로깅이 켜집니다.디버그 로깅 일시적으로 켜기대신 세션 동안에만 일시적으로 디버그 로깅을 사용하고 싶다면 터미널을 열고 set TK_DEBUG=1 명령을 통해 디버그 로깅을 설정하면 됩니다.그런 다음, 터미널을 통해 데스크톱을 실행합니다.                    참고: ShotGrid 데스크톱과 터미널을 닫으면 디버그 로깅이 더 이상 켜진 상태로 유지되지 않습니다.    로그 파일에서 디버그 출력 검사로그 파일을 찾으려면 로그 파일은 어디에 있습니까? 문서를 참조하십시오.고급 구성 디버그 로깅 옵션고급 설정을 사용 중인 경우 몇 가지 옵션을 더 사용할 수 있습니다. 이 기능은 툴킷 구성에 대한 제어 권한이 있는 경우에만 사용할 수 있습니다.모든 엔진은 환경 파일에 debug_logging 설정이 있습니다. 이 설정을 켜면 추가 디버그 레벨 로그 메시지가 소프트웨어(예: Nuke 또는 Maya의 스크립트 편집기)의 기본 출력으로 전송됩니다. 엔진에서 실행 중인 모든 앱이 이 디버그 레벨 메시지를 전송하기 때문에 엔진에 대해 이 설정을 켜면 결국 모든 앱에 대해서도 켜는 셈입니다.이렇게 해도 파일로 어떤 로그 메시지를 출력하지는 않습니다. 이를 가능하게 할 추가 표준 로깅 프레임워크를 구현하기 위해 작업 중입니다. 예외는 SG 데스크톱 및 Photoshop 엔진이며 GUI 콘솔과 파일 모두에 출력을 로깅합니다.소프트웨어의 엔진에 대해 디버그 로깅 켜기예를 들어, 샷 단계 환경의 Nuke 엔진에 대해 디버깅 출력을 켜려면 환경 파일에서 Nuke 엔진(tk-nuke) 섹션을 찾아 설정을 debug_logging: true로 업데이트합니다.config/env/shot_step.yml을 편집합니다.engines:  ...  ...  tk-nuke:    apps:      ...      ...    compatibility_dialog_min_version: 9    debug_logging: true    favourite_directories: []    location: {name: tk-nuke, type: app_store, version: v0.2.23}    ...   ...파일을 저장하고 샷 단계 환경에서 Nuke를 다시 실행합니다. 이제 스크립트 편집기 창에서 디버그 출력을 볼 수 있을 것입니다.tank 명령에 대해 디버그 로깅 켜기tank 명령을 실행 중인데 터미널에서 디버그 출력을 보고 싶다면 실행 중인 명령과 함께 --debug 옵션을 사용하면 됩니다. 그러면 해당 명령에 대해 디버그 로깅이 켜집니다../tank --debug coreDEBUG [10:11:38 617.835998535]:DEBUG [10:11:38 618.768930435]: 디버그 출력을 활성화한 상태에서 실행합니다.DEBUG [10:11:38 618.921995163]:DEBUG [10:11:38 619.092941284]: Core API는 현지화된 파이프라인 구성 내부에 있습니다.DEBUG [10:11:38 619.235992432]: 전체 명령줄이 전달됨:['/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.py','/sgtk/software/shotgun/scarlet', '--debug', 'core']DEBUG [10:11:38 619.364023209]:DEBUG [10:11:38 619.463920593]:DEBUG [10:11:38 619.575977325]: 코드 설치 루트:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.678020477]: 파이프라인 구성 루트:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.756937027]:DEBUG [10:11:38 619.826078415]:DEBUG [10:11:38 619.905948639]:DEBUG [10:11:38 619.978904724]: 컨텍스트 항목:['/sgtk/software/shotgun/scarlet']DEBUG [10:11:38 620.06688118]: 명령: coreDEBUG [10:11:38 620.129108429]: 명령 인수: []DEBUG [10:11:38 620.193004608]: Sgtk 파이프라인 구성 위치:/sgtk/software/shotgun/scarletDEBUG [10:11:38 620.270967484]: 이 스크립트의 위치(__file__):/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.pyShotgun Pipeline Toolkit을 시작합니다.설명서는 https://toolkit.shotgunsoftware.com을 참조하십시오.현재 경로 '/sgtk/software/shotgun/scarlet'에 대해 툴킷 시작- 경로가 Shotgun 객체와 연결되어 있지 않음- 기본 프로젝트 설정으로 폴백DEBUG [10:11:39 125.463962555]: Sgtk API 및 컨텍스트가 완전히 해석합니다.DEBUG [10:11:39 126.449108124]: Sgtk API: Sgtk Core v0.15.18, 구성/sgtk/software/shotgun/scarletDEBUG [10:11:39 126.588106155]: 컨텍스트: scarlet- '기본' 구성 및 Core v0.15.18 사용- 컨텍스트를 scarlet으로 설정DEBUG [10:11:39 129.276990891]: 이 명령의 경우 엔진을 로드할 필요가 없습니다.- 명령 코어 실행...----------------------------------------------------------------------명령: Core----------------------------------------------------------------------Shotgun Pipeline Toolkit 업데이트 검사 프로그램을 시작합니다.이 스크립트는 /sgtk/software/shotgun/scarlet에 설치된Toolkit Core API가 최신인지확인합니다.Core API 업그레이드 시 일반적으로 둘 이상의 프로젝트에 영향을미칩니다. 여러 프로젝트에 롤아웃하기 전에 별개로 Core API 업그레이드를테스트하려면 *현지화된* 특수 파이프라인 구성을 생성하는 것이좋습니다. 자세한 내용은 툴킷 문서를참조하십시오.현재 Shotgun Pipeline Toolkit v0.15.18 버전을 실행 중입니다.지금은 Toolkit Core API를 업데이트할 필요가 없습니다.DEBUG [10:11:39 981.74405098]: 종료 코드를 사용한 종료가 없음",
    "url": "/143e0a94/",
    "relUrl": "/143e0a94/"
  },
  "148": {
    "id": "148",
    "title": "두 개의 익스텐션이 설치된 경우 Photoshop 통합 문제 해결",
    "content": "두 개의 익스텐션이 설치된 경우 Photoshop 통합 문제 해결어떤 문제가 있습니까?After Effects 통합 릴리즈에는 ShotGrid과 통합되는 모든 Adobe 앱에서 사용할 수 있는 공통 플러그인이 있습니다. 이를 구현하는 과정에서, 이전 Photoshop 통합과의 호환성을 유지하고 스튜디오에서 확실하게 해당 업데이트로 전환할 수 있도록 하기 위해 익스텐션의 이름을 변경해야 했습니다.하지만 이로 인해 업그레이드할 때 두 개의 ShotGrid 익스텐션이 설치될 수 있습니다.ShotGrid Adobe 패널은 새로운 익스텐션으로, v1.7.0 이상의 Photoshop 통합을 사용하는 경우에 사용해야 합니다.문제를 어떻게 해결할 수 있습니까?이전 익스텐션을 제거하려면 홈 디렉토리의 Adobe 설치 위치에서 제거할 수 있습니다. 해당 폴더는 Photoshop 시작 시 디버그 출력에서 볼 수 있으며 다음과 같습니다.  OSX: ~/Library/Application Support/Adobe/CEP/extensions/com.sg.basic.ps  Windows: %AppData% Adobe CEP extensions com.sg.basic.psPhotoshop을 종료하고 해당 디렉토리를 제거하고 난 후 다시 시작하면 하나의 익스텐션만 확인됩니다.                    참고: 여러 환경 또는 여러 구성에 Photoshop 통합이 있고 이전 플러그인과 새 플러그인이 혼합된 경우 사용자가 이전 통합을 사용하여 Photoshop을 시작하면 이전 플러그인이 반환됩니다. 한 번에 정리할 수 있도록 전체적으로 Photoshop을 업데이트하는 것이 좋습니다.    ",
    "url": "/3fd1f835/",
    "relUrl": "/3fd1f835/"
  },
  "149": {
    "id": "149",
    "title": "앱 또는 엔진을 어떻게 제거합니까?",
    "content": "앱 또는 엔진을 어떻게 제거합니까?앱 또는 엔진이 더 이상 존재하지 않도록 구성의 환경 YAML 파일을 편집하여 앱 또는 엔진을 제거할 수 있습니다.환경 파일을 사용하면 앱을 완전히 제거하는 대신 특정 컨텍스트 또는 엔진에서만 사용할 수 있도록 앱을 구성할 수 있습니다.일반적인 환경 파일 편집에 대한 자세한 내용은 이 안내서를 참조하십시오.예시다음은 기본 구성에서 Publish 앱을 완전히 제거하는 방법을 보여 주는 예입니다.앱은 환경 설정 내부의 엔진에 추가되므로 앱이 추가된 모든 엔진에서 Publish 앱을 제거해야 합니다.엔진에서 앱 제거각 엔진에는 .../env/includes/settings 내에 자체 YAML 파일이 있습니다. Publish 앱은 모든 엔진에 포함되어 있으므로 각 엔진 YAML 파일을 수정해야 합니다. 예를 들어 Maya 엔진을 사용하는 경우 tk-maya.yml을 열고 Publish 앱에 대한 모든 참조를 제거합니다.우선 includes 섹션에 앱에 대한 참조가 있습니다..../env/includes/settings/tk-maya.yml L18에셋 단계 컨텍스트에 있는 경우 Maya 엔진에도 앱이 포함됩니다..../env/includes/settings/tk-maya.yml L47메뉴 즐겨찾기에 이를 추가하는 줄도 있습니다..../env/includes/settings/tk-maya.yml L56다음으로 샷 단계 설정에 다음 줄을 반복합니다..../env/includes/settings/tk-maya.yml L106.../env/includes/settings/tk-maya.yml L115그런 다음 다른 모든 엔진 환경 yml 파일(예: tk-nuke, tk-3dsmaxplus, tk-desktop 등)에서 이 단계를 반복합니다.                    중요: 이제 통합에서 사용자에게 앱이 표시되지 않으므로 이것으로 충분합니다. 그러나 깨끗하게 유지하기 위해 구성에서 앱에 대한 참조를 완전히 제거하려면 나머지 단계를 완료합니다.    앱 설정 제거이러한 모든 엔진 YAML 파일은 tk-multi-publish2.yml 설정 파일을 포함하고 있었습니다. 이제 엔진 YAML 파일에서 해당 참조가 제거되어 이 파일을 완전히 제거할 수 있습니다.                    중요: tk-multi-publish2.yml을 제거해도 이를 가리키는 엔진 파일이 남아 있는 경우 다음과 같은 내용의 오류가 발생합니다.ErrorInclude resolve error in '/configs/my_project/env/./includes/settings/tk-desktop2.yml': './tk-multi-publish2.yml' resolved to '/configs/my_project/env/./includes/settings/./tk-multi-publish2.yml' which does not exist!     앱 위치 제거기본 구성에서 모든 앱은 …/env/includes/app_locations.yml 파일에 해당 위치 설명자를 저장합니다. tk-multi-publish2.yml은 이를 참조하므로 설명자 줄을 제거해야 합니다.",
    "url": "/86ab39ef/",
    "relUrl": "/86ab39ef/"
  },
  "150": {
    "id": "150",
    "title": "API를 사용하여 툴킷 구성을 프로그래밍 방식으로 업데이트하려면 어떻게 해야 합니까?",
    "content": "API를 사용하여 툴킷 구성을 프로그래밍 방식으로 업데이트하려면 어떻게 해야 합니까?앱, 엔진 및 프레임워크 업데이트프로그래밍 방식으로 엔진, 앱 및 프레임워크를 모두 최신 버전으로 업데이트하려면 다음 코드를 사용하면 됩니다.import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;updates&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):     from tank_vendor.shotgun_authentication import ShotgunAuthenticator     user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()     sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    주의: 이렇게 하면 추가적인 상호 작용 또는 확인 없이 파이프라인 구성에서 모든 엔진, 앱 및 프레임워크가 최신 버전으로 업데이트됩니다. 계속 진행하기 전에 유념하시기 바랍니다.    코어 업데이트프로젝트의 코어를 상호 작용하지 않는 방식으로 실행하기 위해 스크립트에서 프로젝트 코어 버전을 업데이트하려면 다음 코드를 사용하면 됩니다.import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;core&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):    from tank_vendor.shotgun_authentication import ShotgunAuthenticator    user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()    sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    주의: 이렇게 하면 추가적인 상호 작용 또는 확인 없이 Toolkit Core가 최신 버전으로 업데이트됩니다. 이 양식을 실행 중인 코어가 공유 코어인 경우 이렇게 하면 이 코어 버전을 공유 중인 모든 프로젝트가 사용하는 코어 버전이 업데이트됩니다! 계속 진행하기 전에 유념하시기 바랍니다.    참고:  커스텀 스크립트의 인증 및 로그인 자격 증명",
    "url": "/4de9c1d6/",
    "relUrl": "/4de9c1d6/"
  },
  "151": {
    "id": "151",
    "title": "파이프라인 구성 코어 위치를 업데이트하려면 어떻게 해야 합니까?",
    "content": "파이프라인 구성 코어 위치를 업데이트하려면 어떻게 해야 합니까?파이프라인 구성이 로컬 코어를 사용하도록 업데이트하려면 어떻게 해야 합니까?파이프라인 구성이 공유 Toolkit Core를 사용하도록 설정되어 있는 경우에는 해당 프로세스를 실행 취소하거나 tank localize 명령을 사용하여 파이프라인 구성 내부에 Toolkit Core API의 사본을 설치함으로써 코어의 “공유를 해제”할 수 있습니다. 이를 가리켜 코어를 “지역화”한다고 합니다.       터미널을 열고 Toolkit Core를 설치하려는 파이프라인 구성으로 이동합니다.     $ cd /sgtk/software/shotgun/scarlet            다음 tank 명령을 실행합니다.     $ ./tank localize ... ... ---------------------------------------------------------------------- Command: Localize ---------------------------------------------------------------------- This will copy the Core API in /sgtk/software/shotgun/studio into the Pipeline configuration /sgtk/software/shotgun/scarlet. Do you want to proceed [yn]        계속 진행하기 전에 툴킷이 모든 사항을 확인합니다. 파이프라인 구성이 현재 가리키고 있는 Toolkit Core 사본이 파이프라인 구성에 로컬로 복사됩니다.        이제 툴킷이 파이프라인 구성에서 사용 중인 모든 앱, 엔진 및 프레임워크를 install 폴더에 로컬로 복사합니다. 그런 후 Toolkit Core를 복사하고 새로 설치된 로컬 Toolkit Core를 사용하도록 파이프라인 구성의 구성 파일을 업데이트합니다.     Copying 59 apps, engines and frameworks... 1/59: Copying tk-multi-workfiles v0.6.15... 2/59: Copying tk-maya v0.4.7... 3/59: Copying tk-nuke-breakdown v0.3.0... 4/59: Copying tk-framework-widget v0.2.2... 5/59: Copying tk-shell v0.4.1... 6/59: Copying tk-multi-launchapp Undefined... 7/59: Copying tk-motionbuilder v0.3.0... 8/59: Copying tk-hiero-openinshotgun v0.1.0... 9/59: Copying tk-multi-workfiles2 v0.7.9... ... ... 59/59: Copying tk-framework-qtwidgets v2.0.1... Localizing Core: /sgtk/software/shotgun/studio/install/core -&amp;gt; /sgtk/software/shotgun/scarlet/install/core Copying Core Configuration Files... The Core API was successfully localized. Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.                          참고: 설치한 앱, 엔진 및 프레임워크 버전에 따라 출력이 달라집니다.    파이프라인 구성이 기존 공유 코어를 사용하도록 업데이트하려면 어떻게 해야 합니까?기존 공유 Toolkit Core가 있는 경우 tank 명령을 사용하여 공유 코어를 사용하도록 기존의 “지역화된” 파이프라인 구성을 업데이트할 수 있습니다.      터미널을 열고 업데이트하려는 파이프라인 구성으로 이동합니다.     $ cd /sgtk/software/shotgun/scarlet            그리고 tank attach_to_core 명령을 실행하고, 현재 플랫폼에 있는 유효한 공유 코어 경로를 제공합니다.     $ ./tank attach_to_core /sgtk/software/shotgun/studio ... ... ---------------------------------------------------------------------- Command: Attach to core ---------------------------------------------------------------------- After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/hgfs/sgtk/software/shotgun/studio' - Windows: 'z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]        계속 진행하기 전에 툴킷이 모든 사항을 확인합니다. 이 공유 코어는 이미 여러 플랫폼에 맞게 설정되었기 때문에 각 플랫폼의 위치가 표시됩니다.    새 플랫폼의 위치를 추가해야 한다면 공유 코어 구성에서 config/core/install_location.yml 파일을 업데이트하고 필요한 경로를 추가합니다.        이제 툴킷이 파이프라인 구성에 로컬 Core API를 백업하고, 지역화된 코어를 제거한 후에 공유 코어에 있는 파이프라인 구성을 가리키도록 필요한 구성을 추가합니다.     Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.        나중에 파이프라인 구성에서 Toolkit Core를 지역화하기로 결정할 경우(예: 공유 코어에서 파이프라인 구성을 분리하고 로컬로 설치된 버전을 사용) tank localize 명령을 사용하여 그렇게 할 수 있습니다.                      참고: 공유 스튜디오 코어는 현재 파이프라인 구성의 코어 버전 이상이어야 합니다.    프로젝트 간에 Toolkit Core를 어떻게 공유합니까?현재는 SG 데스크톱을 사용하여 프로젝트를 설정하는 경우 Toolkit Core API가 “지역화됩니다”. 즉, 파이프라인 구성 내부에 설치됩니다. 모든 파이프라인 구성이 툴킷 설치를 완벽하게 포함하게 됩니다. 원한다면 Toolkit Core API 버전이 프로젝트 간에 공유되도록 하여 유지 관리 부담을 최소화하고, 모든 프로젝트가 같은 코어 코드를 사용하도록 할 수도 있습니다. 이를 대개 “공유 스튜디오 코어”라고 합니다.여기서는 여러 프로젝트 파이프라인 구성 간에 공유할 수 있는 새 Toolkit Core API 구성을 생성하는 방법을 소개합니다.      터미널을 열고, 공유하려는 Toolkit Core 버전이 포함된 기존의 파이프라인 구성으로 이동합니다. 프로젝트가 완료되면 이 파이프라인 구성은 더 이상 지역화된 상태로 유지되지 않고 새로 생성된 공유 코어를 사용하게 됩니다.     $ cd /sgtk/software/shotgun/pied_piper            다음 tank 명령을 실행하여 Toolkit Core를 디스크의 외부 위치로 복사합니다. 이 경로를 모든 플랫폼에서 찾을 수 있도록 해당 위치를 제공해야 합니다(linux_path, windows_path, mac_path). 각 경로마다 따옴표를 사용하는 것이 좋습니다. 특정 플랫폼에서는 툴킷을 사용하지 않는다면 그냥 빈 문자열(&quot;&quot;)을 지정하면 됩니다.      $ ./tank share_core &quot;/mnt/sgtk/software/shotgun/studio&quot; &quot;Z: sgtk software shotgun studio&quot;   &quot;/sgtk/software/shotgun/studio&quot;            툴킷이 작업을 진행하기 전에 변경될 사항을 요약하여 보여 줍니다.     ---------------------------------------------------------------------- Command: Share core ---------------------------------------------------------------------- This will move the embedded core API in the configuration '/sgtk/software/shotgun/pied_piper'. After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/sgtk/software/shotgun/studio' - Windows: 'Z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]            툴킷이 새 공유 위치로 코어 설치를 복사하고, 새 공유 위치를 가리키도록 기존 파이프라인 구성을 업데이트합니다.     Setting up base structure... Copying configuration files... Copying core installation... Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.      이제 다른 파이프라인 구성에서 이 새로운 공유 코어를 사용할 수 있습니다. (방금 생성한 것과 같은) 기존 공유 코어를 사용하도록 파이프라인 구성을 업데이트하려면 tank attach_to_core 명령을 사용하면 됩니다.",
    "url": "/b12f2510/",
    "relUrl": "/b12f2510/"
  },
  "152": {
    "id": "152",
    "title": "버전과 게시된 파일 간의 차이점은 무엇입니까?",
    "content": "버전과 게시된 파일 간의 차이점은 무엇입니까?“게시”는 디스크에 저장되어 응용프로그램 내에서 사용할 수 있는 파일(또는 이미지 시퀀스)이나 데이터를 의미합니다. exr 시퀀스, abc, Maya 파일 등이 여기에 포함될 수 있습니다. 게시는 ShotGrid 내에서 PublishedFile 엔티티로 표현됩니다.“버전”(ShotGrid 내 Version 엔티티)은 게시의 시각적 표현이며 리뷰 및 노트 작성에 사용됩니다. Version 엔티티에는 게시된 파일이라고 하는 필드가 있습니다. 이 필드에는 서로 연결할 게시 레코드의 수를 입력할 수 있습니다. 이를 통해 어떠한 리뷰 Version이 게시 그룹과 연결되는지 트래킹할 수 있습니다. 게시할 때 이 관계를 입력하는 것이 좋습니다. 버전은 ShotGrid 내에서 Version 엔티티로 표현됩니다.궁극적인 아이디어는 게시할 때 파일 모음, 그러니까 대개 파일 형식은 다르지만 실질적으로 같은 내용을 가진 파일(Maya 파일, obj, alembic 등)을 생성할 수 있도록 하는 것입니다. 그리고 결국 이 파일들은 모두 같은 것을 서로 다르게 표현한 것입니다. 그런 후 이 파일들은 게시 데이터 미리보기 및 노트 작성을 위해 단일 리뷰 Version과 연결됩니다.게시된 데이터가 이미지 시퀀스인 경우에는 이 아이디어가 조금 쓸모없어질 수 있습니다. 사실 이미지 시퀀스는 리뷰하려는 것이기도 하면서 파이프를 따라 전송될 것이기도 합니다. 이 경우 게시와 Version 모두를 “더블 업”하고 생성해야 할 수 있습니다. 그러면 Loader 앱 등을 통해 Version을 표현하는 게시된 데이터를 로드할 수 있습니다.",
    "url": "/b867b4b0/",
    "relUrl": "/b867b4b0/"
  },
  "153": {
    "id": "153",
    "title": "VPC / IAM / Security Group",
    "content": "VPC / IAM / Security GroupAmazon Virtual Private Cloud permits users to logically separate virtual networks that host their AWS resources and provides you complete control over access to your AWS network.Within a VPC, security groups act as a basic firewall and control what inbound and outbound connections are permitted to each given resource. For example, a security group can allow inbound HTTPS traffic to a proxy server but block all other inbound traffic.With AWS Identity and Access Management (IAM), access to AWS resources and services can be controlled at a more fine-grained level. For example, IAM can be leveraged to control who or which resources can access S3 buckets used by ShotGrid.All three of the above features are used in the ShotGrid isolation features implementation to ensure that you securely connect your closed VPC to ShotGrid and allow access to the media S3 buckets.",
    "url": "/28430132/",
    "relUrl": "/28430132/"
  },
  "154": {
    "id": "154",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationCommunication between your client systems and your ShotGrid site will traverse the open Internet by default. Web Traffic Isolation allows you to restrict access to your ShotGrid site from the public Internet entirely and ensure that all traffic transits directly between your AWS VPC and Autodesk’s AWS VPC.ConfigurationA unique VPC endpoint is provided by Autodesk. Access to the endpoint must be configured from your VPC, and the relevant DNS configuration must be completed to allow your client systems to reach the new endpoint.How it worksBy using the provided VPC endpoint, web traffic is isolated from the public Internet completely. All web traffic transits between your AWS VPC and Autodesk’s AWS VPC, rather than the public Internet.CostsThe only cost associated with Web Traffic Isolation are those related to web traffic transiting to/from your AWS VPC. See AWS VPC Pricing for more details.Next StepsSee Web Traffic Isolation for setup instructions.",
    "url": "/57122ae9/",
    "relUrl": "/57122ae9/"
  },
  "155": {
    "id": "155",
    "title": "웹후크(곧 제공 예정)",
    "content": "웹후크                    베타: 웹후크는 현재 베타 테스트 중입니다. 베타 테스트에 참여하려면 다음 주소로 이메일을 보내 주십시오. webhooks-beta@shotgunsoftware.com    웹후크를 사용하면 사용자가 제어하는 서비스는 ShotGrid에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다. 웹후크를 만들 때 관심 있는 이벤트 유형을 지정하고 이벤트가 트리거될 때 데이터를 보낼 URL을 ShotGrid에 알려 주십시오. ShotGrid에서 관련 이벤트가 발생하면 이벤트를 정의하는 데이터 페이로드가 웹후크의 URL로 전송됩니다. 이런 방법으로 ShotGrid과의 긴밀한 통합을 구축하고 워크플로우의 일부를 자동화할 수 있습니다.웹후크 사용 방법에는 어떤 것이 있습니까?다양한 웹후크 사용 사례가 있습니다. 설득력 있는 몇 가지 사례가 이 문서에 개략적으로 설명되어 있지만 이러한 몇 가지 예에 국한되지는 않습니다.엔티티 생성 시 디스크에 디렉토리 구조 만들기우리가 여러 번 확인한 워크플로우 중에는 ShotGrid에서 새 엔티티가 생성될 때 디스크에 디렉토리 구조를 생성하는 것이 있습니다. ShotGrid에서 엔티티가 생성되면 자동으로 아티스트 작업을 위한 새 샷이 준비되도록 할 수 있습니다.상태 관리 자동화애니메이션 팀이 작업을 완료하면, 후속 작업을 시작할 준비가 되었음을 나타내도록 동일한 샷의 다운스트림 태스크 상태를 변경할 수 있습니다. 이 방법을 통해 여러 분야에서 할당된 아티스트에게 작업을 시작할 수 있음을 자동으로 통지할 수 있습니다.상태 관리 자동화의 또 다른 좋은 예는 새 노트가 작성될 때 태스크의 상태 변경을 트리거하는 것입니다. 아티스트 및 프로덕션 팀에게 감독이 리뷰 세션 후에 현재 작업에 대한 변경 또는 수정을 요청했음을 알려 주기에 좋은 방법입니다.언제 ShotGrid 이벤트 데몬 대신 웹후크를 사용해야 합니까?웹후크와 ShotGrid 이벤트 데몬은 비슷한 기능을 제공하지만 몇 가지 중요한 차이점이 있습니다. 이벤트 데몬을 사용하려면 사용자 고유의 서비스를 실행, 모니터링 및 유지 관리해야 합니다. 모든 사용자 코드는 Python으로 작성해야 하며 그래야 ShotGrid에 대한 사용자 고유의 연결을 시작할 수 있습니다. 웹후크는 이와 달리 연결에 응답하며 모든 프로그래밍 언어로 작성할 수 있습니다. 웹후크는 AWS Lambda와 같은 서버리스 환경에서 호스트되거나 Zapier 및 IFTTT와 같이 온라인으로 사용 가능한 모든 자동화 플랫폼을 트리거할 수 있습니다. 웹후크를 사용한 경우에는 이 솔루션을 사용하는 것이 좋습니다.웹후크 생성웹후크 생성을 시작하려면 웹후크 페이지로 이동한 다음 웹후크 목록 위에 있는 버튼으로 이동합니다.다음으로 새 웹후크를 생성하는 데 필요한 정보를 입력합니다.비밀 토큰웹후크에 비밀 토큰을 할당하는 것은 선택 사항입니다. 비밀 토큰을 제공한 경우, 해당 웹후크 URL에 전송된 모든 요청은 해당 토큰을 사용하여 서명됩니다. 토큰 값은 요청과 함께 X-SG-SIGNATURE라는 이름의 헤더로 전송됩니다. 서명은 SHA1과 함께 HMAC를 사용하여 계산되고 서명된 메시지는 요청의 JSON 본문입니다.헤더 형식&amp;lt;algorithm&amp;gt;=&amp;lt;signature&amp;gt;비밀 토큰을 사용하는 이유는 무엇입니까?꼭 필요한 것은 아니지만 비밀 토큰을 제공하면 웹후크 URL로 전송된 페이로드가 서명됩니다. 이를 통해 사용자 서비스는 예상한 소스에서 데이터가 생성되었으며 전송 중에 페이로드가 변경되지 않았음을 확인할 수 있습니다.서명 확인Python을 사용한 페이로드 서명 확인 방법의 예가 아래에 나와 있습니다.&amp;gt;&amp;gt;&amp;gt; import hmac&amp;gt;&amp;gt;&amp;gt; import hashlib&amp;gt;&amp;gt;&amp;gt; body | `&amp;lt;json body&amp;gt;'&amp;gt;&amp;gt;&amp;gt; token | `mytoken'&amp;gt;&amp;gt;&amp;gt; 'sha1=' + hmac.new(token, body, hashlib.sha1).hexdigest()  == 'sha1=32824e0ea4b3f1ae37ba8d67ec40042f3ff02f6c'TrueSSL 인증서 유효성 확인SSL 인증서 유효성 확인은 웹후크의 사용자 URL에 대한 모든 연결의 보안을 유지하는 데 도움이 되는 선택적 기능입니다. 이 옵션이 설정된 경우 웹후크의 URL로 전달이 이루어지면 ShotGrid은 OpenSSL 인증서 유효성 확인 루틴을 사용하여 인증서를 확인합니다.웹후크 상태웹후크의 상태는 여러 가지 중 하나이며 계속해서 전달을 받을 수 있는 기능 및 상태를 나타냅니다.            상태      예시      설명                  활성(Active)            웹후크가 안정적인 방식으로 작동합니다. 지난 24시간 동안 이 웹후크에 전달이 없으면 해당 대상에 도달하지 못한 것입니다.              불안정(Unstable)            웹후크가 불안정한 방식으로 작동합니다. 지난 24시간 동안 일부 전달이 대상에 도달하지 못했지만 ShotGrid에서 웹후크가 작동하지 않는 것으로 간주할 정도는 아닙니다.              실패(Failed)            웹후크가 작동하지 않는 것으로 간주되고 더 이상 전달을 시도하지 않습니다. 이는 짧은 기간 동안 너무 많은 전달 실패에 따른 결과이며 시스템은 웹후크가 더 이상 실행 가능하지 않은 것으로 판단합니다. 지난 24시간 동안 10번의 전달에 실패한 경우 웹후크가 실패로 간주됩니다.              비활성화됨(Disabled)            웹후크가 비활성화된 상태이며 다시 활성 상태가 될 때까지 전달이 더 이상 시도되지 않습니다.      전달웹후크 목록에서 웹후크를 선택하면 5일 전까지 수행된 해당 웹후크의 모든 전달이 표시됩니다.                    참고: 5일보다 오래된 전달 로그는 제거되며 복구할 수 없습니다.    전달 상태전달 상태는 웹후크의 URL로 성공적으로 전달되었는지 여부를 나타냅니다.전달 상세 정보전달을 확장하여 웹후크 URL로 전송한 요청과 해당 요청에 대한 응답의 상세 정보를 표시할 수 있습니다.페이로드웹후크 URL로 전송한 페이로드에는 ShotGrid에서 발생한 이벤트 및 이벤트를 트리거한 사용자에 대한 정보가 포함됩니다. JSON 형식으로 제공됩니다.                    페이로드 크기: 전달 페이로드의 최대 크기는 1MB입니다. ShotGrid에서 트리거된 이벤트의 페이로드 크기가 1MB보다 크면 new_value 및 old_value 키가 제거되고 발생 이벤트, 원인 및 ShotGrid에서 전체 이벤트 로그 항목을 검색하는 방법을 설명하는 메시지가 포함된 warning 키가 추가됩니다.    페이로드 예시{  &quot;data&quot;: {    &quot;id&quot;: &quot;95.0&quot;,    &quot;meta&quot;: {      &quot;type&quot;: &quot;attribute_change&quot;,      &quot;entity_id&quot;: 758,      &quot;new_value&quot;: &quot;This is the newest description ever!!&quot;,      &quot;old_value&quot;: &quot;This is the old description!&quot;,      &quot;entity_type&quot;: &quot;Asset&quot;,      &quot;attribute_name&quot;: &quot;description&quot;,      &quot;field_data_type&quot;: &quot;text&quot;    },    &quot;user&quot;: {      &quot;id&quot;: 113,      &quot;type&quot;: &quot;HumanUser&quot;    },    &quot;entity&quot;: {      &quot;id&quot;: 758,      &quot;type&quot;: &quot;Asset&quot;    },    &quot;project&quot;: {      &quot;id&quot;: 65,      &quot;type&quot;: &quot;Project&quot;    },    &quot;operation&quot;: &quot;update&quot;,    &quot;created_at&quot;: &quot;2019-07-12 21:14:36.598835&quot;,    &quot;event_type&quot;: &quot;Shotgun_Asset_Change&quot;,    &quot;session_uuid&quot;: &quot;07473c00-a4ea-11e9-b3b8-0242ac110006&quot;,    &quot;attribute_name&quot;: &quot;description&quot;,    &quot;event_log_entry_id&quot;: 248249  }}세션 UUIDShotGrid에서 이벤트를 트리거한 session_uuid가 이벤트 페이로드의 일부로 제공됩니다. 이 값은 ShotGrid의 Python API에 제공될 수 있으며, 그러면 이 session_uuid를 사용하여 열려 있는 모든 브라우저 세션에 API에서 생성한 이벤트에 대한 업데이트가 표시됩니다.확인 응답확인 응답을 포함하도록 전달을 업데이트할 수 있습니다. 전달이 만들어지면 요청의 일부로 헤더가 제공됩니다. 이러한 헤더에는 x-sg-delivery-id 키에 저장된 전달 레코드의 ID가 포함됩니다. 이 ID는 ShotGrid REST API를 사용하여 확인 응답이 포함되도록 전달 레코드를 업데이트하는 데 사용할 수 있습니다.                    확인 응답 크기: 확인 응답에 허용되는 최대 크기는 4KB입니다.    헤더 예시{  &quot;accept&quot;: &quot;application/json&quot;,  &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;,  &quot;x-sg-webhook-id&quot;: &quot;30f279a0-42a6-4cf2-bb5e-6fc550d187c8&quot;,  &quot;x-sg-delivery-id&quot;: &quot;dea7a71d-4896-482f-b238-b61820df8b65&quot;,  &quot;x-sg-event-batch-id&quot;: &quot;1&quot;,  &quot;x-sg-event-batch-size&quot;: &quot;4&quot;,  &quot;x-sg-webhook-site-url&quot;: &quot;http://yoursite.shotgunstudio.com/&quot;,  &quot;x-sg-event-batch-index&quot;: &quot;3&quot;}확인 응답의 역할은 무엇입니까?확인 응답은 웹후크의 URL에서 성공적으로 수신한 전달 처리의 성공 또는 실패에 대한 대역 외 상세 보고를 허용합니다. 이를 통해 ShotGrid에서 전달 수신 상태를, 해당 전달과 관련된 이벤트 처리의 성공 또는 실패와 구분할 수 있습니다. 이런 방법으로, 성공적으로 전달된 이벤트에서 디버깅을 위해 유용한 추가 정보를 포함할 수 있습니다. 에셋 생성 시 트리거되는 웹후크가 좋은 예입니다. 이 웹후크의 역할이 새로운 각 에셋에 대해 디스크에 디렉토리 구조를 만드는 것인 경우 웹후크의 URL은 성공적으로 전달받을 수 있지만 디스크 또는 네트워크 문제로 인해 관련 디렉토리는 만들 수 없을 수 있습니다. 이 경우 디렉토리 구조가 생성되지 않은 사실과 그 원인을 나타내는 자세한 오류 메시지와 함께 전달 레코드가 업데이트됩니다.웹후크 테스트자유롭게 사용할 수 있는 온라인 웹후크 URL 생성기 중 하나를 테스트용으로 사용할 수 있습니다. 이러한 서비스는 특별히 웹후크 및 기타 유형의 HTTP 요청 테스트에 사용해야 합니다. 이 방법은 고유의 네트워크에 인프라를 설정할 필요 없이 웹후크를 배우기 시작할 때 좋습니다.webhook.site 사용webhook.site를 사용하는 것이 권장됩니다. 이는 웹후크에 복사하여 붙여넣을 수 있는 고유한 URL로, 해당 주소에 대한 전달을 실시간으로 보여 줍니다. 전달에 응답할 때 특정 상태 코드 및 본문을 사용하도록 이 페이지를 사용자 지정하여, 전달 성공 및 실패를 테스트할 수 있습니다.webhook.site의 서비스는 매우 속도에 제한적입니다. 즉, 일부 전달이 거부되거나 불안정해지거나 실패한 웹후크 상황에서 쉽게 종료될 수 있습니다. 테스트할 때는 프로덕션의 라이브 데이터 대신, 알려져 있으며 제어 가능한 프로젝트 환경을 사용하는 것이 좋습니다.                    프로덕션 데이터: 공개적으로 사용할 수 있는 타사 웹 서비스에는 프로덕션 이벤트 데이터를 보내지 않는 것이 좋습니다. webhook.site와 같은 서비스를 사용하여 웹후크를 테스트하는 경우 테스트 데이터만 사용하는 것이 좋습니다.    전달에 대한 응답시스템에서 성공적인 전달로 간주하려면 사용자 서비스가 전달에 응답해야 합니다.                    응답 시간 초과: 웹후크의 URL로 전달이 전송된 후 6초 내에 응답을 받아야 합니다. 이후에는 연결이 종료됩니다. 시간 내에 응답하지 못하면 전달에 실패하게 됩니다.    상태 코드            상태      코드      설명                  성공      &amp;lt; 400      전달이 수신되고 성공적으로 처리되었습니다.              오류      &amp;gt;= 400      전달이 수신되었지만 성공적으로 처리되지 않았습니다.              리디렉션      3xx      전달이 수신되었지만 다른 URL로 리디렉션해야 합니다.      ",
    "url": "/3d448f5e/",
    "relUrl": "/3d448f5e/"
  },
  "156": {
    "id": "156",
    "title": "경로 캐시가 무엇입니까? 파일 시스템 위치가 무엇입니까?",
    "content": "경로 캐시가 무엇입니까? 파일 시스템 위치가 무엇입니까?경로 캐시는 툴킷이 디스크의 폴더와 ShotGrid의 엔티티 간 연결을 트래킹하는 데 사용합니다.마스터 캐시는 FilesystemLocation 엔티티 유형을 사용하여 ShotGrid에 저장됩니다. 그러면 각 사용자는 디스크의 툴킷 캐시 디렉토리에 로컬로 저장되는 각자의 경로 캐시 버전을 갖게 되고, 이 경로 캐시는 응용프로그램이 시작되거나 폴더가 생성될 때마다 백그라운드에서 동기화됩니다.보통 경로 캐시는 수동으로 수정하지 않는 것이 좋습니다. 저희의 내부 프로세스를 통해 여러분의 로컬 캐시가 ShotGrid의 파일 시스템 위치 엔티티와 동기화될 뿐 아니라, 모든 사용자의 컴퓨터가 ShotGrid과 동기화 상태를 유지할 수 있도록 이벤트 로그 항목도 생성됩니다.경로 캐시를 수정하는 데 사용할 수 있는 몇 가지 tank 명령이 있습니다.  tank unregister_folders 명령은 경로 캐시 연결을 제거합니다.  tank synchronize_folders 명령은 로컬 경로 캐시와 ShotGrid의 동기화를 실행합니다.보통은 이 명령을 실행할 필요가 없지만 상황에 따라서는 실행하는 것이 유용할 수 있습니다.예를 들어, unregister_folders 명령은 프로젝트 내 엔티티의 이름을 바꾸거나 엔티티를 다시 생성하기 전에 실행해야 합니다.",
    "url": "/cbbf99a4/",
    "relUrl": "/cbbf99a4/"
  },
  "157": {
    "id": "157",
    "title": "로그 파일은 어디에 있습니까?",
    "content": "로그 파일은 어디에 있습니까?기본적으로 ShotGrid 데스크톱 및 통합은 로그 파일을 다음 디렉토리에 저장합니다.Mac~/Library/Logs/Shotgun/Windows%APPDATA% Shotgun logs Linux~/.shotgun/logs/로그 파일 이름의 형식은 tk-&amp;lt;ENGINE&amp;gt;.log입니다. 예를 들면 tk-desktop.log 또는 tk-maya.log입니다.ShotGrid_HOME 환경 변수를 설정하여 사용자의 캐시 위치를 재정의한 경우 로그 파일이 $SHOTGUN_HOME/logs에 위치하게 됩니다.                    참고: ShotGrid 데스크톱에서도 이 디렉토리에 액세스할 수 있습니다. 프로젝트를 선택하고, 프로젝트 이름 오른쪽에 있는 아래쪽 화살표 버튼을 클릭하고, 로그 폴더 열기(Open Log Folder)를 선택하면 됩니다.    ",
    "url": "/38c5c024/",
    "relUrl": "/38c5c024/"
  },
  "158": {
    "id": "158",
    "title": "내 캐시는 어디에 있습니까?",
    "content": "내 캐시는 어디에 있습니까?루트 캐시 위치툴킷은 일부 데이터를 로컬 캐시에 저장하여 ShotGrid 서버에 대한 불필요한 호출을 방지합니다. 여기에는 경로 캐시, 번들 캐시 및 썸네일이 포함됩니다. 대부분의 사용자는 기본 위치로도 문제 없지만 이를 변경해야 한다면 cache_location 코어 후크를 사용하여 구성할 수 있습니다.기본 캐시 루트 위치는 다음과 같습니다.Mac OS X~/Library/Caches/ShotgunWindows%APPDATA% ShotgunLinux~/.shotgun경로 캐시경로 캐시 위치는 다음과 같습니다.&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/path_cache.db번들 캐시분산 구성번들 캐시는 ShotGrid 사이트의 프로젝트 전반에 사용되는 전체 응용프로그램, 엔진, 프레임워크의 캐시 모음입니다. 분산 구성의 번들 캐시는 다음 위치에 저장됩니다.Mac: ~/Library/Caches/Shotgun/bundle_cacheWindows:%APPDATA% Shotgun bundle_cacheLinux:~/.shotgun/bundle_cache                    참고: SHOTGUN_BUNDLE_CACHE_PATH 환경 변수를 사용하여 이러한 위치를 재정의할 수 있으므로 실제 구현은 다를 수 있습니다.    중앙 집중식 구성중앙 집중식 구성의 번들 캐시는 중앙 집중식 구성 내부에 저장됩니다....{project configuration}/install/구성에서 공유 코어를 사용하는 경우 번들 캐시는 공유 코어의 설치 폴더 내부에 저장됩니다.썸네일툴킷 앱(예: Loader)에서 사용하는 썸네일은 로컬 툴킷 캐시에 저장됩니다. 썸네일은 프로젝트, 파이프라인 구성, 앱(필요 시)별로 저장됩니다. 루트 캐시 디렉토리 아래의 구조는 다음과 같습니다.&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/&amp;lt;app_or_framework_name&amp;gt;/thumbs/",
    "url": "/7c9867c0/",
    "relUrl": "/7c9867c0/"
  },
  "159": {
    "id": "159",
    "title": "워크플로우",
    "content": "워크플로우툴킷 워크플로우와 관련된 질문과 대답이 간략하게 정리되어 있습니다.  버전과 게시된 파일 간의 차이점은 무엇입니까?",
    "url": "/8396394b/",
    "relUrl": "/8396394b/"
  },
  "160": {
    "id": "160",
    "title": "Workflows",
    "content": "Workflows",
    "url": "/f5a4341f/",
    "relUrl": "/f5a4341f/"
  }
}
